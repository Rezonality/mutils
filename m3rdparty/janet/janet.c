/* Amalgamated build - DO NOT EDIT */
/* Generated from janet version 1.10.1-dev-local */
#define JANET_BUILD "local"
#define JANET_AMALG

/* src/core/features.h */
#line 0 "src/core/features.h"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

/* Feature test macros */

#ifndef JANET_FEATURES_H_defined
#define JANET_FEATURES_H_defined

#ifndef _POSIX_C_SOURCE
#define _POSIX_C_SOURCE 200809L
#endif

#if defined(WIN32) || defined(_WIN32)
#define WIN32_LEAN_AND_MEAN
#endif

/* Needed for realpath on linux */
#if !defined(_XOPEN_SOURCE) && (defined(__linux__) || defined(__EMSCRIPTEN__))
#define _XOPEN_SOURCE 500
#endif

#endif

#include "janet.h"

/* src/core/util.h */
#line 0 "src/core/util.h"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_UTIL_H_defined
#define JANET_UTIL_H_defined

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#endif

#include <stdio.h>
#include <errno.h>

/* Handle runtime errors */
#ifndef JANET_EXIT
#include <stdio.h>
#define JANET_EXIT(m) do { \
    fprintf(stderr, "C runtime error at line %d in file %s: %s\n",\
        __LINE__,\
        __FILE__,\
        (m));\
    exit(1);\
} while (0)
#endif

#define janet_assert(c, m) do { \
    if (!(c)) JANET_EXIT((m)); \
} while (0)

/* What to do when out of memory */
#ifndef JANET_OUT_OF_MEMORY
#include <stdio.h>
#define JANET_OUT_OF_MEMORY do { fprintf(stderr, "janet out of memory\n"); exit(1); } while (0)
#endif

/* Omit docstrings in some builds */
#ifndef JANET_BOOTSTRAP
#define JDOC(x) NULL
#define JANET_NO_BOOTSTRAP
#else
#define JDOC(x) x
#endif

/* Utils */
#define janet_maphash(cap, hash) ((uint32_t)(hash) & (cap - 1))
extern const char janet_base64[65];
int32_t janet_array_calchash(const Janet *array, int32_t len);
int32_t janet_kv_calchash(const JanetKV *kvs, int32_t len);
int32_t janet_string_calchash(const uint8_t *str, int32_t len);
int32_t janet_tablen(int32_t n);
void safe_memcpy(void *dest, const void *src, size_t len);
void janet_buffer_push_types(JanetBuffer *buffer, int types);
const JanetKV *janet_dict_find(const JanetKV *buckets, int32_t cap, Janet key);
Janet janet_dict_get(const JanetKV *buckets, int32_t cap, Janet key);
void janet_memempty(JanetKV *mem, int32_t count);
void *janet_memalloc_empty(int32_t count);
JanetTable *janet_get_core_table(const char *name);
const void *janet_strbinsearch(
    const void *tab,
    size_t tabcount,
    size_t itemsize,
    const uint8_t *key);
void janet_buffer_format(
    JanetBuffer *b,
    const char *strfrmt,
    int32_t argstart,
    int32_t argc,
    Janet *argv);

/* Inside the janet core, defining globals is different
 * at bootstrap time and normal runtime */
#ifdef JANET_BOOTSTRAP
#define janet_core_def janet_def
#define janet_core_cfuns janet_cfuns
#else
void janet_core_def(JanetTable *env, const char *name, Janet x, const void *p);
void janet_core_cfuns(JanetTable *env, const char *regprefix, const JanetReg *cfuns);
#endif

/* Initialize builtin libraries */
void janet_lib_io(JanetTable *env);
void janet_lib_math(JanetTable *env);
void janet_lib_array(JanetTable *env);
void janet_lib_tuple(JanetTable *env);
void janet_lib_buffer(JanetTable *env);
void janet_lib_table(JanetTable *env);
void janet_lib_fiber(JanetTable *env);
void janet_lib_os(JanetTable *env);
void janet_lib_string(JanetTable *env);
void janet_lib_marsh(JanetTable *env);
void janet_lib_parse(JanetTable *env);
#ifdef JANET_ASSEMBLER
void janet_lib_asm(JanetTable *env);
#endif
void janet_lib_compile(JanetTable *env);
void janet_lib_debug(JanetTable *env);
#ifdef JANET_PEG
void janet_lib_peg(JanetTable *env);
#endif
#ifdef JANET_TYPED_ARRAY
void janet_lib_typed_array(JanetTable *env);
#endif
#ifdef JANET_INT_TYPES
void janet_lib_inttypes(JanetTable *env);
#endif
#ifdef JANET_THREADS
void janet_lib_thread(JanetTable *env);
#endif
#ifdef JANET_NET
void janet_lib_net(JanetTable *env);
void janet_net_deinit(void);
void janet_net_markloop(void);
#endif

#endif


/* src/core/state.h */
#line 0 "src/core/state.h"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_STATE_H_defined
#define JANET_STATE_H_defined

#include <stdint.h>

/* The VM state. Rather than a struct that is passed
 * around, the vm state is global for simplicity. If
 * at some point a global state object, or context,
 * is required to be passed around, this is what would
 * be in it. However, thread local global variables for interpreter
 * state should allow easy multi-threading. */

typedef struct JanetScratch JanetScratch;

/* Cache the core environment */
extern JANET_THREAD_LOCAL JanetTable *janet_vm_core_env;

/* How many VM stacks have been entered */
extern JANET_THREAD_LOCAL int janet_vm_stackn;

/* The current running fiber on the current thread.
 * Set and unset by janet_run. */
extern JANET_THREAD_LOCAL JanetFiber *janet_vm_fiber;
extern JANET_THREAD_LOCAL JanetFiber *janet_vm_root_fiber;

/* The current pointer to the inner most jmp_buf. The current
 * return point for panics. */
extern JANET_THREAD_LOCAL jmp_buf *janet_vm_jmp_buf;
extern JANET_THREAD_LOCAL Janet *janet_vm_return_reg;

/* The global registry for c functions. Used to store meta-data
 * along with otherwise bare c function pointers. */
extern JANET_THREAD_LOCAL JanetTable *janet_vm_registry;

/* Registry for abstract abstract types that can be marshalled.
 * We need this to look up the constructors when unmarshalling. */
extern JANET_THREAD_LOCAL JanetTable *janet_vm_abstract_registry;

/* Immutable value cache */
extern JANET_THREAD_LOCAL const uint8_t **janet_vm_cache;
extern JANET_THREAD_LOCAL uint32_t janet_vm_cache_capacity;
extern JANET_THREAD_LOCAL uint32_t janet_vm_cache_count;
extern JANET_THREAD_LOCAL uint32_t janet_vm_cache_deleted;

/* Garbage collection */
extern JANET_THREAD_LOCAL void *janet_vm_blocks;
extern JANET_THREAD_LOCAL size_t janet_vm_gc_interval;
extern JANET_THREAD_LOCAL size_t janet_vm_next_collection;
extern JANET_THREAD_LOCAL int janet_vm_gc_suspend;

/* GC roots */
extern JANET_THREAD_LOCAL Janet *janet_vm_roots;
extern JANET_THREAD_LOCAL size_t janet_vm_root_count;
extern JANET_THREAD_LOCAL size_t janet_vm_root_capacity;

/* Scratch memory */
extern JANET_THREAD_LOCAL JanetScratch **janet_scratch_mem;
extern JANET_THREAD_LOCAL size_t janet_scratch_cap;
extern JANET_THREAD_LOCAL size_t janet_scratch_len;

/* Recursionless traversal of data structures */
typedef struct {
    JanetGCObject *self;
    JanetGCObject *other;
    int32_t index;
    int32_t index2;
} JanetTraversalNode;
extern JANET_THREAD_LOCAL JanetTraversalNode *janet_vm_traversal;
extern JANET_THREAD_LOCAL JanetTraversalNode *janet_vm_traversal_top;
extern JANET_THREAD_LOCAL JanetTraversalNode *janet_vm_traversal_base;

/* Setup / teardown */
#ifdef JANET_THREADS
void janet_threads_init(void);
void janet_threads_deinit(void);
#endif

#endif /* JANET_STATE_H_defined */


/* src/core/gc.h */
#line 0 "src/core/gc.h"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_GC_H
#define JANET_GC_H

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#endif

/* The metadata header associated with an allocated block of memory */
#define janet_gc_header(mem) ((JanetGCObject *)(mem))

#define JANET_MEM_TYPEBITS 0xFF
#define JANET_MEM_REACHABLE 0x100
#define JANET_MEM_DISABLED 0x200

#define janet_gc_settype(m, t) ((janet_gc_header(m)->flags |= (0xFF & (t))))
#define janet_gc_type(m) (janet_gc_header(m)->flags & 0xFF)

#define janet_gc_mark(m) (janet_gc_header(m)->flags |= JANET_MEM_REACHABLE)
#define janet_gc_reachable(m) (janet_gc_header(m)->flags & JANET_MEM_REACHABLE)

/* Memory types for the GC. Different from JanetType to include funcenv and funcdef. */
enum JanetMemoryType {
    JANET_MEMORY_NONE,
    JANET_MEMORY_STRING,
    JANET_MEMORY_SYMBOL,
    JANET_MEMORY_ARRAY,
    JANET_MEMORY_TUPLE,
    JANET_MEMORY_TABLE,
    JANET_MEMORY_STRUCT,
    JANET_MEMORY_FIBER,
    JANET_MEMORY_BUFFER,
    JANET_MEMORY_FUNCTION,
    JANET_MEMORY_ABSTRACT,
    JANET_MEMORY_FUNCENV,
    JANET_MEMORY_FUNCDEF
};

/* To allocate collectable memory, one must calk janet_alloc, initialize the memory,
 * and then call when janet_enablegc when it is initailize and reachable by the gc (on the JANET stack) */
void *janet_gcalloc(enum JanetMemoryType type, size_t size);

#endif


/* src/core/vector.h */
#line 0 "src/core/vector.h"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_VECTOR_H_defined
#define JANET_VECTOR_H_defined

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#endif

/*
 * vector code modified from
 * https://github.com/nothings/stb/blob/master/stretchy_buffer.h
*/

/* This is mainly used code such as the assembler or compiler, which
 * need vector like data structures that are only garbage collected in case
 * of an error, and normally rely on malloc/free. */

#define janet_v_free(v)         (((v) != NULL) ? (janet_sfree(janet_v__raw(v)), 0) : 0)
#define janet_v_push(v, x)      (janet_v__maybegrow(v, 1), (v)[janet_v__cnt(v)++] = (x))
#define janet_v_pop(v)          (janet_v_count(v) ? janet_v__cnt(v)-- : 0)
#define janet_v_count(v)        (((v) != NULL) ? janet_v__cnt(v) : 0)
#define janet_v_last(v)         ((v)[janet_v__cnt(v) - 1])
#define janet_v_empty(v)        (((v) != NULL) ? (janet_v__cnt(v) = 0) : 0)
#define janet_v_flatten(v)      (janet_v_flattenmem((v), sizeof(*(v))))

#define janet_v__raw(v) ((int32_t *)(v) - 2)
#define janet_v__cap(v) janet_v__raw(v)[0]
#define janet_v__cnt(v) janet_v__raw(v)[1]

#define janet_v__needgrow(v, n)  ((v) == NULL || janet_v__cnt(v) + (n) >= janet_v__cap(v))
#define janet_v__maybegrow(v, n) (janet_v__needgrow((v), (n)) ? janet_v__grow((v), (n)) : 0)
#define janet_v__grow(v, n)      ((v) = janet_v_grow((v), (n), sizeof(*(v))))

/* Actual functions defined in vector.c */
void *janet_v_grow(void *v, int32_t increment, int32_t itemsize);
void *janet_v_flattenmem(void *v, int32_t itemsize);

#endif


/* src/core/fiber.h */
#line 0 "src/core/fiber.h"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_FIBER_H_defined
#define JANET_FIBER_H_defined

#ifndef JANET_AMALG
#include <janet.h>
#endif

/* Fiber signal masks. */
#define JANET_FIBER_MASK_ERROR 2
#define JANET_FIBER_MASK_DEBUG 4
#define JANET_FIBER_MASK_YIELD 8

#define JANET_FIBER_MASK_USER0 (16 << 0)
#define JANET_FIBER_MASK_USER1 (16 << 1)
#define JANET_FIBER_MASK_USER2 (16 << 2)
#define JANET_FIBER_MASK_USER3 (16 << 3)
#define JANET_FIBER_MASK_USER4 (16 << 4)
#define JANET_FIBER_MASK_USER5 (16 << 5)
#define JANET_FIBER_MASK_USER6 (16 << 6)
#define JANET_FIBER_MASK_USER7 (16 << 7)
#define JANET_FIBER_MASK_USER8 (16 << 8)
#define JANET_FIBER_MASK_USER9 (16 << 9)

#define JANET_FIBER_MASK_USERN(N) (16 << (N))
#define JANET_FIBER_MASK_USER 0x3FF0

#define JANET_FIBER_STATUS_MASK 0xFF0000
#define JANET_FIBER_STATUS_OFFSET 16

#define JANET_FIBER_BREAKPOINT       0x1000000
#define JANET_FIBER_RESUME_NO_USEVAL 0x2000000
#define JANET_FIBER_RESUME_NO_SKIP   0x4000000
#define JANET_FIBER_DID_LONGJUMP     0x8000000
#define JANET_FIBER_FLAG_MASK        0xF000000

extern JANET_THREAD_LOCAL JanetFiber *janet_vm_fiber;

#define janet_fiber_set_status(f, s) do {\
    (f)->flags &= ~JANET_FIBER_STATUS_MASK;\
    (f)->flags |= (s) << JANET_FIBER_STATUS_OFFSET;\
} while (0)

#define janet_stack_frame(s) ((JanetStackFrame *)((s) - JANET_FRAME_SIZE))
#define janet_fiber_frame(f) janet_stack_frame((f)->data + (f)->frame)
void janet_fiber_setcapacity(JanetFiber *fiber, int32_t n);
void janet_fiber_push(JanetFiber *fiber, Janet x);
void janet_fiber_push2(JanetFiber *fiber, Janet x, Janet y);
void janet_fiber_push3(JanetFiber *fiber, Janet x, Janet y, Janet z);
void janet_fiber_pushn(JanetFiber *fiber, const Janet *arr, int32_t n);
int janet_fiber_funcframe(JanetFiber *fiber, JanetFunction *func);
int janet_fiber_funcframe_tail(JanetFiber *fiber, JanetFunction *func);
void janet_fiber_cframe(JanetFiber *fiber, JanetCFunction cfun);
void janet_fiber_popframe(JanetFiber *fiber);
void janet_env_maybe_detach(JanetFuncEnv *env);
int janet_env_valid(JanetFuncEnv *env);

#endif


/* src/core/regalloc.h */
#line 0 "src/core/regalloc.h"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

/* Implements a simple first fit register allocator for the compiler. */

#ifndef JANET_REGALLOC_H
#define JANET_REGALLOC_H

#include <stdint.h>

/* Placeholder for allocating temporary registers */
typedef enum {
    JANETC_REGTEMP_0,
    JANETC_REGTEMP_1,
    JANETC_REGTEMP_2,
    JANETC_REGTEMP_3,
    JANETC_REGTEMP_4,
    JANETC_REGTEMP_5,
    JANETC_REGTEMP_6,
    JANETC_REGTEMP_7
} JanetcRegisterTemp;

typedef struct {
    uint32_t *chunks;
    int32_t count; /* number of chunks in chunks */
    int32_t capacity; /* amount allocated for chunks */
    int32_t max; /* The maximum allocated register so far */
    int32_t regtemps; /* Hold which temp. registers are allocated. */
} JanetcRegisterAllocator;

void janetc_regalloc_init(JanetcRegisterAllocator *ra);
void janetc_regalloc_deinit(JanetcRegisterAllocator *ra);

int32_t janetc_regalloc_1(JanetcRegisterAllocator *ra);
void janetc_regalloc_free(JanetcRegisterAllocator *ra, int32_t reg);
int32_t janetc_regalloc_temp(JanetcRegisterAllocator *ra, JanetcRegisterTemp nth);
void janetc_regalloc_freetemp(JanetcRegisterAllocator *ra, int32_t reg, JanetcRegisterTemp nth);
void janetc_regalloc_clone(JanetcRegisterAllocator *dest, JanetcRegisterAllocator *src);
void janetc_regalloc_touch(JanetcRegisterAllocator *ra, int32_t reg);

#endif


/* src/core/compile.h */
#line 0 "src/core/compile.h"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_COMPILE_H
#define JANET_COMPILE_H

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "regalloc.h"
#endif

/* Tags for some functions for the prepared inliner */
#define JANET_FUN_DEBUG 1
#define JANET_FUN_ERROR 2
#define JANET_FUN_APPLY 3
#define JANET_FUN_YIELD 4
#define JANET_FUN_RESUME 5
#define JANET_FUN_IN 6
#define JANET_FUN_PUT 7
#define JANET_FUN_LENGTH 8
#define JANET_FUN_ADD 9
#define JANET_FUN_SUBTRACT 10
#define JANET_FUN_MULTIPLY 11
#define JANET_FUN_DIVIDE 12
#define JANET_FUN_BAND 13
#define JANET_FUN_BOR 14
#define JANET_FUN_BXOR 15
#define JANET_FUN_LSHIFT 16
#define JANET_FUN_RSHIFT 17
#define JANET_FUN_RSHIFTU 18
#define JANET_FUN_BNOT 19
#define JANET_FUN_GT 20
#define JANET_FUN_LT 21
#define JANET_FUN_GTE 22
#define JANET_FUN_LTE 23
#define JANET_FUN_EQ 24
#define JANET_FUN_NEQ 25
#define JANET_FUN_PROP 26
#define JANET_FUN_GET 27
#define JANET_FUN_NEXT 28
#define JANET_FUN_MODULO 29
#define JANET_FUN_REMAINDER 30

/* Compiler typedefs */
typedef struct JanetCompiler JanetCompiler;
typedef struct FormOptions FormOptions;
typedef struct SlotTracker SlotTracker;
typedef struct JanetScope JanetScope;
typedef struct JanetSlot JanetSlot;
typedef struct JanetFopts JanetFopts;
typedef struct JanetFunOptimizer JanetFunOptimizer;
typedef struct JanetSpecial JanetSpecial;

#define JANET_SLOT_CONSTANT 0x10000
#define JANET_SLOT_NAMED 0x20000
#define JANET_SLOT_MUTABLE 0x40000
#define JANET_SLOT_REF 0x80000
#define JANET_SLOT_RETURNED 0x100000
/* Needed for handling single element arrays as global vars. */

/* Used for unquote-splicing */
#define JANET_SLOT_SPLICED 0x200000

#define JANET_SLOTTYPE_ANY 0xFFFF

/* A stack slot */
struct JanetSlot {
    Janet constant; /* If the slot has a constant value */
    int32_t index;
    int32_t envindex; /* 0 is local, positive number is an upvalue */
    uint32_t flags;
};

#define JANET_SCOPE_FUNCTION 1
#define JANET_SCOPE_ENV 2
#define JANET_SCOPE_TOP 4
#define JANET_SCOPE_UNUSED 8
#define JANET_SCOPE_CLOSURE 16
#define JANET_SCOPE_WHILE 32

/* A symbol and slot pair */
typedef struct SymPair {
    JanetSlot slot;
    const uint8_t *sym;
    int keep;
} SymPair;

/* A lexical scope during compilation */
struct JanetScope {

    /* For debugging */
    const char *name;

    /* Scopes are doubly linked list */
    JanetScope *parent;
    JanetScope *child;

    /* Constants for this funcdef */
    Janet *consts;

    /* Map of symbols to slots. Use a simple linear scan for symbols. */
    SymPair *syms;

    /* FuncDefs */
    JanetFuncDef **defs;

    /* Regsiter allocator */
    JanetcRegisterAllocator ra;

    /* Upvalue allocator */
    JanetcRegisterAllocator ua;

    /* Referenced closure environments. The values at each index correspond
     * to which index to get the environment from in the parent. The environment
     * that corresponds to the direct parent's stack will always have value 0. */
    int32_t *envs;

    int32_t bytecode_start;
    int flags;
};

/* Compilation state */
struct JanetCompiler {

    /* Pointer to current scope */
    JanetScope *scope;

    uint32_t *buffer;
    JanetSourceMapping *mapbuffer;

    /* Hold the environment */
    JanetTable *env;

    /* Name of source to attach to generated functions */
    const uint8_t *source;

    /* The result of compilation */
    JanetCompileResult result;

    /* Keep track of where we are in the source */
    JanetSourceMapping current_mapping;

    /* Prevent unbounded recursion */
    int recursion_guard;
};

#define JANET_FOPTS_TAIL 0x10000
#define JANET_FOPTS_HINT 0x20000
#define JANET_FOPTS_DROP 0x40000

/* Options for compiling a single form */
struct JanetFopts {
    JanetCompiler *compiler;
    JanetSlot hint;
    uint32_t flags; /* bit set of accepted primitive types */
};

/* Get the default form options */
JanetFopts janetc_fopts_default(JanetCompiler *c);

/* For optimizing builtin normal functions. */
struct JanetFunOptimizer {
    int (*can_optimize)(JanetFopts opts, JanetSlot *args);
    JanetSlot(*optimize)(JanetFopts opts, JanetSlot *args);
};

/* A grouping of a named special and the corresponding compiler fragment */
struct JanetSpecial {
    const char *name;
    JanetSlot(*compile)(JanetFopts opts, int32_t argn, const Janet *argv);
};

/****************************************************/

/* Get an optimizer if it exists, otherwise NULL */
const JanetFunOptimizer *janetc_funopt(uint32_t flags);

/* Get a special. Return NULL if none exists */
const JanetSpecial *janetc_special(const uint8_t *name);

void janetc_freeslot(JanetCompiler *c, JanetSlot s);
void janetc_nameslot(JanetCompiler *c, const uint8_t *sym, JanetSlot s);
JanetSlot janetc_farslot(JanetCompiler *c);

/* Throw away some code after checking that it is well formed. */
void janetc_throwaway(JanetFopts opts, Janet x);

/* Get a target slot for emitting an instruction. Will always return
 * a local slot. */
JanetSlot janetc_gettarget(JanetFopts opts);

/* Get a bunch of slots for function arguments */
JanetSlot *janetc_toslots(JanetCompiler *c, const Janet *vals, int32_t len);

/* Get a bunch of slots for function arguments */
JanetSlot *janetc_toslotskv(JanetCompiler *c, Janet ds);

/* Push slots load via janetc_toslots. */
int32_t janetc_pushslots(JanetCompiler *c, JanetSlot *slots);

/* Free slots loaded via janetc_toslots */
void janetc_freeslots(JanetCompiler *c, JanetSlot *slots);

/* Generate the return instruction for a slot. */
JanetSlot janetc_return(JanetCompiler *c, JanetSlot s);

/* Store an error */
void janetc_error(JanetCompiler *c, const uint8_t *m);
void janetc_cerror(JanetCompiler *c, const char *m);

/* Dispatch to correct form compiler */
JanetSlot janetc_value(JanetFopts opts, Janet x);

/* Push and pop from the scope stack */
void janetc_scope(JanetScope *s, JanetCompiler *c, int flags, const char *name);
void janetc_popscope(JanetCompiler *c);
void janetc_popscope_keepslot(JanetCompiler *c, JanetSlot retslot);
JanetFuncDef *janetc_pop_funcdef(JanetCompiler *c);

/* Create a destory slots */
JanetSlot janetc_cslot(Janet x);

/* Search for a symbol */
JanetSlot janetc_resolve(JanetCompiler *c, const uint8_t *sym);

#endif


/* src/core/emit.h */
#line 0 "src/core/emit.h"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_EMIT_H
#define JANET_EMIT_H

#ifndef JANET_AMALG
#include "compile.h"
#endif

void janetc_emit(JanetCompiler *c, uint32_t instr);

int32_t janetc_allocfar(JanetCompiler *c);
int32_t janetc_allocnear(JanetCompiler *c, JanetcRegisterTemp);

int32_t janetc_emit_s(JanetCompiler *c, uint8_t op, JanetSlot s, int wr);
int32_t janetc_emit_sl(JanetCompiler *c, uint8_t op, JanetSlot s, int32_t label);
int32_t janetc_emit_st(JanetCompiler *c, uint8_t op, JanetSlot s, int32_t tflags);
int32_t janetc_emit_si(JanetCompiler *c, uint8_t op, JanetSlot s, int16_t immediate, int wr);
int32_t janetc_emit_su(JanetCompiler *c, uint8_t op, JanetSlot s, uint16_t immediate, int wr);
int32_t janetc_emit_ss(JanetCompiler *c, uint8_t op, JanetSlot s1, JanetSlot s2, int wr);
int32_t janetc_emit_ssi(JanetCompiler *c, uint8_t op, JanetSlot s1, JanetSlot s2, int8_t immediate, int wr);
int32_t janetc_emit_ssu(JanetCompiler *c, uint8_t op, JanetSlot s1, JanetSlot s2, uint8_t immediate, int wr);
int32_t janetc_emit_sss(JanetCompiler *c, uint8_t op, JanetSlot s1, JanetSlot s2, JanetSlot s3, int wr);

/* Move value from one slot to another. Cannot copy to constant slots. */
void janetc_copy(JanetCompiler *c, JanetSlot dest, JanetSlot src);

#endif


/* src/core/symcache.h */
#line 0 "src/core/symcache.h"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_SYMCACHE_H_defined
#define JANET_SYMCACHE_H_defined

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#endif

/* Initialize the cache (allocate cache memory) */
void janet_symcache_init(void);
void janet_symcache_deinit(void);
void janet_symbol_deinit(const uint8_t *sym);

#endif


/* Windows work around - winsock2 must be included before windows.h, especially in amalgamated build */
#if defined(JANET_WINDOWS) && defined(JANET_NET)
#include <winsock2.h>
#endif


/* src/core/abstract.c */
#line 0 "src/core/abstract.c"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "gc.h"
#endif

/* Create new userdata */
void *janet_abstract_begin(const JanetAbstractType *atype, size_t size) {
    JanetAbstractHead *header = janet_gcalloc(JANET_MEMORY_NONE,
                                sizeof(JanetAbstractHead) + size);
    header->size = size;
    header->type = atype;
    return (void *) & (header->data);
}

void *janet_abstract_end(void *x) {
    janet_gc_settype((void *)(janet_abstract_head(x)), JANET_MEMORY_ABSTRACT);
    return x;
}

void *janet_abstract(const JanetAbstractType *atype, size_t size) {
    return janet_abstract_end(janet_abstract_begin(atype, size));
}


/* src/core/array.c */
#line 0 "src/core/array.c"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "gc.h"
#include "util.h"
#include "state.h"
#endif

#include <string.h>

/* Creates a new array */
JanetArray *janet_array(int32_t capacity) {
    JanetArray *array = janet_gcalloc(JANET_MEMORY_ARRAY, sizeof(JanetArray));
    Janet *data = NULL;
    if (capacity > 0) {
        janet_vm_next_collection += capacity * sizeof(Janet);
        data = (Janet *) malloc(sizeof(Janet) * (size_t) capacity);
        if (NULL == data) {
            JANET_OUT_OF_MEMORY;
        }
    }
    array->count = 0;
    array->capacity = capacity;
    array->data = data;
    return array;
}

/* Creates a new array from n elements. */
JanetArray *janet_array_n(const Janet *elements, int32_t n) {
    JanetArray *array = janet_gcalloc(JANET_MEMORY_ARRAY, sizeof(JanetArray));
    array->capacity = n;
    array->count = n;
    array->data = malloc(sizeof(Janet) * (size_t) n);
    if (!array->data) {
        JANET_OUT_OF_MEMORY;
    }
    safe_memcpy(array->data, elements, sizeof(Janet) * n);
    return array;
}

/* Ensure the array has enough capacity for elements */
void janet_array_ensure(JanetArray *array, int32_t capacity, int32_t growth) {
    Janet *newData;
    Janet *old = array->data;
    if (capacity <= array->capacity) return;
    int64_t new_capacity = ((int64_t) capacity) * growth;
    if (new_capacity > INT32_MAX) new_capacity = INT32_MAX;
    capacity = (int32_t) new_capacity;
    newData = realloc(old, capacity * sizeof(Janet));
    if (NULL == newData) {
        JANET_OUT_OF_MEMORY;
    }
    janet_vm_next_collection += (capacity - array->capacity) * sizeof(Janet);
    array->data = newData;
    array->capacity = capacity;
}

/* Set the count of an array. Extend with nil if needed. */
void janet_array_setcount(JanetArray *array, int32_t count) {
    if (count < 0)
        return;
    if (count > array->count) {
        int32_t i;
        janet_array_ensure(array, count, 1);
        for (i = array->count; i < count; i++) {
            array->data[i] = janet_wrap_nil();
        }
    }
    array->count = count;
}

/* Push a value to the top of the array */
void janet_array_push(JanetArray *array, Janet x) {
    if (array->count == INT32_MAX) {
        janet_panic("array overflow");
    }
    int32_t newcount = array->count + 1;
    janet_array_ensure(array, newcount, 2);
    array->data[array->count] = x;
    array->count = newcount;
}

/* Pop a value from the top of the array */
Janet janet_array_pop(JanetArray *array) {
    if (array->count) {
        return array->data[--array->count];
    } else {
        return janet_wrap_nil();
    }
}

/* Look at the last value in the array */
Janet janet_array_peek(JanetArray *array) {
    if (array->count) {
        return array->data[array->count - 1];
    } else {
        return janet_wrap_nil();
    }
}

/* C Functions */

static Janet cfun_array_new(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    int32_t cap = janet_getinteger(argv, 0);
    JanetArray *array = janet_array(cap);
    return janet_wrap_array(array);
}

static Janet cfun_array_new_filled(int32_t argc, Janet *argv) {
    janet_arity(argc, 1, 2);
    int32_t count = janet_getinteger(argv, 0);
    Janet x = (argc == 2) ? argv[1] : janet_wrap_nil();
    JanetArray *array = janet_array(count);
    for (int32_t i = 0; i < count; i++) {
        array->data[i] = x;
    }
    array->count = count;
    return janet_wrap_array(array);
}

static Janet cfun_array_fill(int32_t argc, Janet *argv) {
    janet_arity(argc, 1, 2);
    JanetArray *array = janet_getarray(argv, 0);
    Janet x = (argc == 2) ? argv[1] : janet_wrap_nil();
    for (int32_t i = 0; i < array->count; i++) {
        array->data[i] = x;
    }
    return argv[0];
}

static Janet cfun_array_pop(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    JanetArray *array = janet_getarray(argv, 0);
    return janet_array_pop(array);
}

static Janet cfun_array_peek(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    JanetArray *array = janet_getarray(argv, 0);
    return janet_array_peek(array);
}

static Janet cfun_array_push(int32_t argc, Janet *argv) {
    janet_arity(argc, 1, -1);
    JanetArray *array = janet_getarray(argv, 0);
    if (INT32_MAX - argc + 1 <= array->count) {
        janet_panic("array overflow");
    }
    int32_t newcount = array->count - 1 + argc;
    janet_array_ensure(array, newcount, 2);
    if (argc > 1) memcpy(array->data + array->count, argv + 1, (size_t)(argc - 1) * sizeof(Janet));
    array->count = newcount;
    return argv[0];
}

static Janet cfun_array_ensure(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 3);
    JanetArray *array = janet_getarray(argv, 0);
    int32_t newcount = janet_getinteger(argv, 1);
    int32_t growth = janet_getinteger(argv, 2);
    if (newcount < 1) janet_panic("expected positive integer");
    janet_array_ensure(array, newcount, growth);
    return argv[0];
}

static Janet cfun_array_slice(int32_t argc, Janet *argv) {
    JanetView view = janet_getindexed(argv, 0);
    JanetRange range = janet_getslice(argc, argv);
    JanetArray *array = janet_array(range.end - range.start);
    if (array->data)
        memcpy(array->data, view.items + range.start, sizeof(Janet) * (range.end - range.start));
    array->count = range.end - range.start;
    return janet_wrap_array(array);
}

static Janet cfun_array_concat(int32_t argc, Janet *argv) {
    int32_t i;
    janet_arity(argc, 1, -1);
    JanetArray *array = janet_getarray(argv, 0);
    for (i = 1; i < argc; i++) {
        switch (janet_type(argv[i])) {
            default:
                janet_array_push(array, argv[i]);
                break;
            case JANET_ARRAY:
            case JANET_TUPLE: {
                int32_t j, len = 0;
                const Janet *vals = NULL;
                janet_indexed_view(argv[i], &vals, &len);
                for (j = 0; j < len; j++)
                    janet_array_push(array, vals[j]);
            }
            break;
        }
    }
    return janet_wrap_array(array);
}

static Janet cfun_array_insert(int32_t argc, Janet *argv) {
    size_t chunksize, restsize;
    janet_arity(argc, 2, -1);
    JanetArray *array = janet_getarray(argv, 0);
    int32_t at = janet_getinteger(argv, 1);
    if (at < 0) {
        at = array->count + at + 1;
    }
    if (at < 0 || at > array->count)
        janet_panicf("insertion index %d out of range [0,%d]", at, array->count);
    chunksize = (argc - 2) * sizeof(Janet);
    restsize = (array->count - at) * sizeof(Janet);
    if (INT32_MAX - (argc - 2) < array->count) {
        janet_panic("array overflow");
    }
    janet_array_ensure(array, array->count + argc - 2, 2);
    if (restsize) {
        memmove(array->data + at + argc - 2,
                array->data + at,
                restsize);
    }
    safe_memcpy(array->data + at, argv + 2, chunksize);
    array->count += (argc - 2);
    return argv[0];
}

static Janet cfun_array_remove(int32_t argc, Janet *argv) {
    janet_arity(argc, 2, 3);
    JanetArray *array = janet_getarray(argv, 0);
    int32_t at = janet_getinteger(argv, 1);
    int32_t n = 1;
    if (at < 0) {
        at = array->count + at + 1;
    }
    if (at < 0 || at > array->count)
        janet_panicf("removal index %d out of range [0,%d]", at, array->count);
    if (argc == 3) {
        n = janet_getinteger(argv, 2);
        if (n < 0)
            janet_panicf("expected non-negative integer for argument n, got %v", argv[2]);
    }
    if (at + n > array->count) {
        n = array->count - at;
    }
    memmove(array->data + at,
            array->data + at + n,
            (array->count - at - n) * sizeof(Janet));
    array->count -= n;
    return argv[0];
}

static Janet cfun_array_trim(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    JanetArray *array = janet_getarray(argv, 0);
    if (array->count) {
        if (array->count < array->capacity) {
            Janet *newData = realloc(array->data, array->count * sizeof(Janet));
            if (NULL == newData) {
                JANET_OUT_OF_MEMORY;
            }
            array->data = newData;
            array->capacity = array->count;
        }
    } else {
        array->capacity = 0;
        free(array->data);
        array->data = NULL;
    }
    return argv[0];
}

static const JanetReg array_cfuns[] = {
    {
        "array/new", cfun_array_new,
        JDOC("(array/new capacity)\n\n"
             "Creates a new empty array with a pre-allocated capacity. The same as "
             "(array) but can be more efficient if the maximum size of an array is known.")
    },
    {
        "array/new-filled", cfun_array_new_filled,
        JDOC("(array/new-filled count &opt value)\n\n"
             "Creates a new array of count elements, all set to value, which defaults to nil. Returns the new array.")
    },
    {
        "array/fill", cfun_array_fill,
        JDOC("(array/fill arr &opt value)\n\n"
             "Replace all elements of an array with value (defaulting to nil) without changing the length of the array. "
             "Returns the modified array.")
    },
    {
        "array/pop", cfun_array_pop,
        JDOC("(array/pop arr)\n\n"
             "Remove the last element of the array and return it. If the array is empty, will return nil. Modifies "
             "the input array.")
    },
    {
        "array/peek", cfun_array_peek,
        JDOC("(array/peek arr)\n\n"
             "Returns the last element of the array. Does not modify the array.")
    },
    {
        "array/push", cfun_array_push,
        JDOC("(array/push arr x)\n\n"
             "Insert an element in the end of an array. Modifies the input array and returns it.")
    },
    {
        "array/ensure", cfun_array_ensure,
        JDOC("(array/ensure arr capacity growth)\n\n"
             "Ensures that the memory backing the array is large enough for capacity "
             "items at the given rate of growth. Capacity and growth must be integers. "
             "If the backing capacity is already enough, then this function does nothing. "
             "Otherwise, the backing memory will be reallocated so that there is enough space.")
    },
    {
        "array/slice", cfun_array_slice,
        JDOC("(array/slice arrtup &opt start end)\n\n"
             "Takes a slice of array or tuple from start to end. The range is half open, "
             "[start, end). Indexes can also be negative, indicating indexing from the end of the "
             "end of the array. By default, start is 0 and end is the length of the array. "
             "Note that index -1 is synonymous with index (length arrtup) to allow a full "
             "negative slice range. Returns a new array.")
    },
    {
        "array/concat", cfun_array_concat,
        JDOC("(array/concat arr & parts)\n\n"
             "Concatenates a variadic number of arrays (and tuples) into the first argument "
             "which must an array. If any of the parts are arrays or tuples, their elements will "
             "be inserted into the array. Otherwise, each part in parts will be appended to arr in order. "
             "Return the modified array arr.")
    },
    {
        "array/insert", cfun_array_insert,
        JDOC("(array/insert arr at & xs)\n\n"
             "Insert all of xs into array arr at index at. at should be an integer "
             "0 and the length of the array. A negative value for at will index from "
             "the end of the array, such that inserting at -1 appends to the array. "
             "Returns the array.")
    },
    {
        "array/remove", cfun_array_remove,
        JDOC("(array/remove arr at &opt n)\n\n"
             "Remove up to n elements starting at index at in array arr. at can index from "
             "the end of the array with a negative index, and n must be a non-negative integer. "
             "By default, n is 1. "
             "Returns the array.")
    },
    {
        "array/trim", cfun_array_trim,
        JDOC("(array/trim arr)\n\n"
             "Set the backing capacity of an array to its current length. Returns the modified array.")
    },
    {NULL, NULL, NULL}
};

/* Load the array module */
void janet_lib_array(JanetTable *env) {
    janet_core_cfuns(env, NULL, array_cfuns);
}


/* src/core/asm.c */
#line 0 "src/core/asm.c"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "util.h"
#endif

#include <setjmp.h>

/* Conditionally compile this file */
#ifdef JANET_ASSEMBLER

/* Definition for an instruction in the assembler */
typedef struct JanetInstructionDef JanetInstructionDef;
struct JanetInstructionDef {
    const char *name;
    enum JanetOpCode opcode;
};

/* Hold all state needed during assembly */
typedef struct JanetAssembler JanetAssembler;
struct JanetAssembler {
    JanetAssembler *parent;
    JanetFuncDef *def;
    jmp_buf on_error;
    const uint8_t *errmessage;
    int32_t errindex;

    int32_t environments_capacity;
    int32_t defs_capacity;
    int32_t bytecode_count; /* Used for calculating labels */

    Janet name;
    JanetTable labels; /* keyword -> bytecode index */
    JanetTable slots; /* symbol -> slot index */
    JanetTable envs; /* symbol -> environment index */
    JanetTable defs; /* symbol -> funcdefs index */
};

/* Janet opcode descriptions in lexicographic order. This
 * allows a binary search over the elements to find the
 * correct opcode given a name. This works in reasonable
 * time and is easier to setup statically than a hash table or
 * prefix tree. */
static const JanetInstructionDef janet_ops[] = {
    {"add", JOP_ADD},
    {"addim", JOP_ADD_IMMEDIATE},
    {"band", JOP_BAND},
    {"bnot", JOP_BNOT},
    {"bor", JOP_BOR},
    {"bxor", JOP_BXOR},
    {"call", JOP_CALL},
    {"clo", JOP_CLOSURE},
    {"cmp", JOP_COMPARE},
    {"div", JOP_DIVIDE},
    {"divim", JOP_DIVIDE_IMMEDIATE},
    {"eq", JOP_EQUALS},
    {"eqim", JOP_EQUALS_IMMEDIATE},
    {"err", JOP_ERROR},
    {"get", JOP_GET},
    {"geti", JOP_GET_INDEX},
    {"gt", JOP_GREATER_THAN},
    {"gte", JOP_GREATER_THAN_EQUAL},
    {"gtim", JOP_GREATER_THAN_IMMEDIATE},
    {"in", JOP_IN},
    {"jmp", JOP_JUMP},
    {"jmpif", JOP_JUMP_IF},
    {"jmpni", JOP_JUMP_IF_NIL},
    {"jmpnn", JOP_JUMP_IF_NOT_NIL},
    {"jmpno", JOP_JUMP_IF_NOT},
    {"ldc", JOP_LOAD_CONSTANT},
    {"ldf", JOP_LOAD_FALSE},
    {"ldi", JOP_LOAD_INTEGER},
    {"ldn", JOP_LOAD_NIL},
    {"lds", JOP_LOAD_SELF},
    {"ldt", JOP_LOAD_TRUE},
    {"ldu", JOP_LOAD_UPVALUE},
    {"len", JOP_LENGTH},
    {"lt", JOP_LESS_THAN},
    {"lte", JOP_LESS_THAN_EQUAL},
    {"ltim", JOP_LESS_THAN_IMMEDIATE},
    {"mkarr", JOP_MAKE_ARRAY},
    {"mkbtp", JOP_MAKE_BRACKET_TUPLE},
    {"mkbuf", JOP_MAKE_BUFFER},
    {"mkstr", JOP_MAKE_STRING},
    {"mkstu", JOP_MAKE_STRUCT},
    {"mktab", JOP_MAKE_TABLE},
    {"mktup", JOP_MAKE_TUPLE},
    {"mod", JOP_MODULO},
    {"movf", JOP_MOVE_FAR},
    {"movn", JOP_MOVE_NEAR},
    {"mul", JOP_MULTIPLY},
    {"mulim", JOP_MULTIPLY_IMMEDIATE},
    {"next", JOP_NEXT},
    {"noop", JOP_NOOP},
    {"prop", JOP_PROPAGATE},
    {"push", JOP_PUSH},
    {"push2", JOP_PUSH_2},
    {"push3", JOP_PUSH_3},
    {"pusha", JOP_PUSH_ARRAY},
    {"put", JOP_PUT},
    {"puti", JOP_PUT_INDEX},
    {"rem", JOP_REMAINDER},
    {"res", JOP_RESUME},
    {"ret", JOP_RETURN},
    {"retn", JOP_RETURN_NIL},
    {"setu", JOP_SET_UPVALUE},
    {"sig", JOP_SIGNAL},
    {"sl", JOP_SHIFT_LEFT},
    {"slim", JOP_SHIFT_LEFT_IMMEDIATE},
    {"sr", JOP_SHIFT_RIGHT},
    {"srim", JOP_SHIFT_RIGHT_IMMEDIATE},
    {"sru", JOP_SHIFT_RIGHT_UNSIGNED},
    {"sruim", JOP_SHIFT_RIGHT_UNSIGNED_IMMEDIATE},
    {"sub", JOP_SUBTRACT},
    {"tcall", JOP_TAILCALL},
    {"tchck", JOP_TYPECHECK}
};

/* Typename aliases for tchck instruction */
typedef struct TypeAlias {
    const char *name;
    int32_t mask;
} TypeAlias;

static const TypeAlias type_aliases[] = {
    {"abstract", JANET_TFLAG_ABSTRACT},
    {"array", JANET_TFLAG_ARRAY},
    {"boolean", JANET_TFLAG_BOOLEAN},
    {"buffer", JANET_TFLAG_BUFFER},
    {"callable", JANET_TFLAG_CALLABLE},
    {"cfunction", JANET_TFLAG_CFUNCTION},
    {"dictionary", JANET_TFLAG_DICTIONARY},
    {"fiber", JANET_TFLAG_FIBER},
    {"function", JANET_TFLAG_FUNCTION},
    {"indexed", JANET_TFLAG_INDEXED},
    {"keyword", JANET_TFLAG_KEYWORD},
    {"nil", JANET_TFLAG_NIL},
    {"number", JANET_TFLAG_NUMBER},
    {"pointer", JANET_TFLAG_POINTER},
    {"string", JANET_TFLAG_STRING},
    {"struct", JANET_TFLAG_STRUCT},
    {"symbol", JANET_TFLAG_SYMBOL},
    {"table", JANET_TFLAG_TABLE},
    {"tuple", JANET_TFLAG_TUPLE}
};

/* Deinitialize an Assembler. Does not deinitialize the parents. */
static void janet_asm_deinit(JanetAssembler *a) {
    janet_table_deinit(&a->slots);
    janet_table_deinit(&a->labels);
    janet_table_deinit(&a->envs);
    janet_table_deinit(&a->defs);
}

static void janet_asm_longjmp(JanetAssembler *a) {
#if defined(JANET_BSD) || defined(JANET_APPLE)
    _longjmp(a->on_error, 1);
#else
    longjmp(a->on_error, 1);
#endif
}

/* Throw some kind of assembly error */
static void janet_asm_error(JanetAssembler *a, const char *message) {
    a->errmessage = janet_formatc("%s, instruction %d", message, a->errindex);
    janet_asm_longjmp(a);
}
#define janet_asm_assert(a, c, m) do { if (!(c)) janet_asm_error((a), (m)); } while (0)

/* Throw some kind of assembly error */
static void janet_asm_errorv(JanetAssembler *a, const uint8_t *m) {
    a->errmessage = m;
    janet_asm_longjmp(a);
}

/* Add a closure environment to the assembler. Sub funcdefs may need
 * to reference outer function environments, and may change the outer environment.
 * Returns the index of the environment in the assembler's environments, or -1
 * if not found. */
static int32_t janet_asm_addenv(JanetAssembler *a, Janet envname) {
    Janet check;
    JanetFuncDef *def = a->def;
    int32_t envindex;
    int32_t res;
    if (janet_equals(a->name, envname)) {
        return -1;
    }
    /* Check for memoized value */
    check = janet_table_get(&a->envs, envname);
    if (janet_checktype(check, JANET_NUMBER)) {
        return (int32_t) janet_unwrap_number(check);
    }
    if (NULL == a->parent) return -2;
    res = janet_asm_addenv(a->parent, envname);
    if (res < -1) {
        return res;
    }
    envindex = def->environments_length;
    janet_table_put(&a->envs, envname, janet_wrap_number(envindex));
    if (envindex >= a->environments_capacity) {
        int32_t newcap = 2 * envindex;
        def->environments = realloc(def->environments, newcap * sizeof(int32_t));
        if (NULL == def->environments) {
            JANET_OUT_OF_MEMORY;
        }
        a->environments_capacity = newcap;
    }
    def->environments[envindex] = (int32_t) res;
    def->environments_length = envindex + 1;
    return envindex;
}

/* Parse an argument to an assembly instruction, and return the result as an
 * integer. This integer will need to be bounds checked. */
static int32_t doarg_1(
    JanetAssembler *a,
    enum JanetOpArgType argtype,
    Janet x) {
    int32_t ret = -1;
    JanetTable *c;
    switch (argtype) {
        default:
            c = NULL;
            break;
        case JANET_OAT_SLOT:
            c = &a->slots;
            break;
        case JANET_OAT_ENVIRONMENT:
            c = &a->envs;
            break;
        case JANET_OAT_LABEL:
            c = &a->labels;
            break;
        case JANET_OAT_FUNCDEF:
            c = &a->defs;
            break;
    }
    switch (janet_type(x)) {
        default:
            goto error;
            break;
        case JANET_NUMBER: {
            double y = janet_unwrap_number(x);
            if (janet_checkintrange(y)) {
                ret = (int32_t) y;
            } else {
                goto error;
            }
            break;
        }
        case JANET_TUPLE: {
            const Janet *t = janet_unwrap_tuple(x);
            if (argtype == JANET_OAT_TYPE) {
                int32_t i = 0;
                ret = 0;
                for (i = 0; i < janet_tuple_length(t); i++) {
                    ret |= doarg_1(a, JANET_OAT_SIMPLETYPE, t[i]);
                }
            } else {
                goto error;
            }
            break;
        }
        case JANET_KEYWORD: {
            if (NULL != c && argtype == JANET_OAT_LABEL) {
                Janet result = janet_table_get(c, x);
                if (janet_checktype(result, JANET_NUMBER)) {
                    ret = janet_unwrap_integer(result) - a->bytecode_count;
                } else {
                    goto error;
                }
            } else if (argtype == JANET_OAT_TYPE || argtype == JANET_OAT_SIMPLETYPE) {
                const TypeAlias *alias = janet_strbinsearch(
                                             &type_aliases,
                                             sizeof(type_aliases) / sizeof(TypeAlias),
                                             sizeof(TypeAlias),
                                             janet_unwrap_keyword(x));
                if (alias) {
                    ret = alias->mask;
                } else {
                    janet_asm_errorv(a, janet_formatc("unknown type %v", x));
                }
            } else {
                goto error;
            }
            break;
        }
        case JANET_SYMBOL: {
            if (NULL != c) {
                Janet result = janet_table_get(c, x);
                if (janet_checktype(result, JANET_NUMBER)) {
                    ret = (int32_t) janet_unwrap_number(result);
                } else {
                    janet_asm_errorv(a, janet_formatc("unknown name %v", x));
                }
            } else {
                goto error;
            }
            if (argtype == JANET_OAT_ENVIRONMENT && ret == -1) {
                /* Add a new env */
                ret = janet_asm_addenv(a, x);
                if (ret < -1) {
                    janet_asm_errorv(a, janet_formatc("unknown environment %v", x));
                }
            }
            break;
        }
    }
    if (argtype == JANET_OAT_SLOT && ret >= a->def->slotcount)
        a->def->slotcount = (int32_t) ret + 1;
    return ret;

error:
    janet_asm_errorv(a, janet_formatc("error parsing instruction argument %v", x));
    return 0;
}

/* Parse a single argument to an instruction. Trims it as well as
 * try to convert arguments to bit patterns */
static uint32_t doarg(
    JanetAssembler *a,
    enum JanetOpArgType argtype,
    int nth,
    int nbytes,
    int hassign,
    Janet x) {
    int32_t arg = doarg_1(a, argtype, x);
    /* Calculate the min and max values that can be stored given
     * nbytes, and whether or not the storage is signed */
    int32_t max = (1 << ((nbytes << 3) - hassign)) - 1;
    int32_t min = hassign ? -max - 1 : 0;
    if (arg < min)
        janet_asm_errorv(a, janet_formatc("instruction argument %v is too small, must be %d byte%s",
                                          x, nbytes, nbytes > 1 ? "s" : ""));
    if (arg > max)
        janet_asm_errorv(a, janet_formatc("instruction argument %v is too large, must be %d byte%s",
                                          x, nbytes, nbytes > 1 ? "s" : ""));
    return ((uint32_t) arg) << (nth << 3);
}

/* Provide parsing methods for the different kinds of arguments */
static uint32_t read_instruction(
    JanetAssembler *a,
    const JanetInstructionDef *idef,
    const Janet *argt) {
    uint32_t instr = idef->opcode;
    enum JanetInstructionType type = janet_instructions[idef->opcode];
    switch (type) {
        case JINT_0: {
            if (janet_tuple_length(argt) != 1)
                janet_asm_error(a, "expected 0 arguments: (op)");
            break;
        }
        case JINT_S: {
            if (janet_tuple_length(argt) != 2)
                janet_asm_error(a, "expected 1 argument: (op, slot)");
            instr |= doarg(a, JANET_OAT_SLOT, 1, 2, 0, argt[1]);
            break;
        }
        case JINT_L: {
            if (janet_tuple_length(argt) != 2)
                janet_asm_error(a, "expected 1 argument: (op, label)");
            instr |= doarg(a, JANET_OAT_LABEL, 1, 3, 1, argt[1]);
            break;
        }
        case JINT_SS: {
            if (janet_tuple_length(argt) != 3)
                janet_asm_error(a, "expected 2 arguments: (op, slot, slot)");
            instr |= doarg(a, JANET_OAT_SLOT, 1, 1, 0, argt[1]);
            instr |= doarg(a, JANET_OAT_SLOT, 2, 2, 0, argt[2]);
            break;
        }
        case JINT_SL: {
            if (janet_tuple_length(argt) != 3)
                janet_asm_error(a, "expected 2 arguments: (op, slot, label)");
            instr |= doarg(a, JANET_OAT_SLOT, 1, 1, 0, argt[1]);
            instr |= doarg(a, JANET_OAT_LABEL, 2, 2, 1, argt[2]);
            break;
        }
        case JINT_ST: {
            if (janet_tuple_length(argt) != 3)
                janet_asm_error(a, "expected 2 arguments: (op, slot, type)");
            instr |= doarg(a, JANET_OAT_SLOT, 1, 1, 0, argt[1]);
            instr |= doarg(a, JANET_OAT_TYPE, 2, 2, 0, argt[2]);
            break;
        }
        case JINT_SI:
        case JINT_SU: {
            if (janet_tuple_length(argt) != 3)
                janet_asm_error(a, "expected 2 arguments: (op, slot, integer)");
            instr |= doarg(a, JANET_OAT_SLOT, 1, 1, 0, argt[1]);
            instr |= doarg(a, JANET_OAT_INTEGER, 2, 2, type == JINT_SI, argt[2]);
            break;
        }
        case JINT_SD: {
            if (janet_tuple_length(argt) != 3)
                janet_asm_error(a, "expected 2 arguments: (op, slot, funcdef)");
            instr |= doarg(a, JANET_OAT_SLOT, 1, 1, 0, argt[1]);
            instr |= doarg(a, JANET_OAT_FUNCDEF, 2, 2, 0, argt[2]);
            break;
        }
        case JINT_SSS: {
            if (janet_tuple_length(argt) != 4)
                janet_asm_error(a, "expected 3 arguments: (op, slot, slot, slot)");
            instr |= doarg(a, JANET_OAT_SLOT, 1, 1, 0, argt[1]);
            instr |= doarg(a, JANET_OAT_SLOT, 2, 1, 0, argt[2]);
            instr |= doarg(a, JANET_OAT_SLOT, 3, 1, 0, argt[3]);
            break;
        }
        case JINT_SSI:
        case JINT_SSU: {
            if (janet_tuple_length(argt) != 4)
                janet_asm_error(a, "expected 3 arguments: (op, slot, slot, integer)");
            instr |= doarg(a, JANET_OAT_SLOT, 1, 1, 0, argt[1]);
            instr |= doarg(a, JANET_OAT_SLOT, 2, 1, 0, argt[2]);
            instr |= doarg(a, JANET_OAT_INTEGER, 3, 1, type == JINT_SSI, argt[3]);
            break;
        }
        case JINT_SES: {
            JanetAssembler *b = a;
            uint32_t env;
            if (janet_tuple_length(argt) != 4)
                janet_asm_error(a, "expected 3 arguments: (op, slot, environment, envslot)");
            instr |= doarg(a, JANET_OAT_SLOT, 1, 1, 0, argt[1]);
            env = doarg(a, JANET_OAT_ENVIRONMENT, 0, 1, 0, argt[2]);
            instr |= env << 16;
            for (env += 1; env > 0; env--) {
                b = b->parent;
                if (NULL == b)
                    janet_asm_error(a, "invalid environment index");
            }
            instr |= doarg(b, JANET_OAT_SLOT, 3, 1, 0, argt[3]);
            break;
        }
        case JINT_SC: {
            if (janet_tuple_length(argt) != 3)
                janet_asm_error(a, "expected 2 arguments: (op, slot, constant)");
            instr |= doarg(a, JANET_OAT_SLOT, 1, 1, 0, argt[1]);
            instr |= doarg(a, JANET_OAT_CONSTANT, 2, 2, 0, argt[2]);
            break;
        }
    }
    return instr;
}

/* Helper to get from a structure */
static Janet janet_get1(Janet ds, Janet key) {
    switch (janet_type(ds)) {
        default:
            return janet_wrap_nil();
        case JANET_TABLE:
            return janet_table_get(janet_unwrap_table(ds), key);
        case JANET_STRUCT:
            return janet_struct_get(janet_unwrap_struct(ds), key);
    }
}

/* Helper to assembly. Return the assembly result */
static JanetAssembleResult janet_asm1(JanetAssembler *parent, Janet source, int flags) {
    JanetAssembleResult result;
    JanetAssembler a;
    Janet s = source;
    JanetFuncDef *def;
    int32_t count, i;
    const Janet *arr;
    Janet x;
    (void) flags;

    /* Initialize funcdef */
    def = janet_funcdef_alloc();

    /* Initialize Assembler */
    a.def = def;
    a.parent = parent;
    a.errmessage = NULL;
    a.errindex = 0;
    a.environments_capacity = 0;
    a.bytecode_count = 0;
    a.defs_capacity = 0;
    a.name = janet_wrap_nil();
    janet_table_init(&a.labels, 0);
    janet_table_init(&a.slots, 0);
    janet_table_init(&a.envs, 0);
    janet_table_init(&a.defs, 0);

    /* Set error jump */
#if defined(JANET_BSD) || defined(JANET_APPLE)
    if (_setjmp(a.on_error)) {
#else
    if (setjmp(a.on_error)) {
#endif
        if (NULL != a.parent) {
            janet_asm_deinit(&a);
            janet_asm_longjmp(a.parent);
        }
        result.funcdef = NULL;
        result.error = a.errmessage;
        result.status = JANET_ASSEMBLE_ERROR;
        janet_asm_deinit(&a);
        return result;
    }

    janet_asm_assert(&a,
                     janet_checktype(s, JANET_STRUCT) ||
                     janet_checktype(s, JANET_TABLE),
                     "expected struct or table for assembly source");

    /* Check for function name */
    a.name = janet_get1(s, janet_ckeywordv("name"));
    if (!janet_checktype(a.name, JANET_NIL)) {
        def->name = janet_to_string(a.name);
    }

    /* Set function arity */
    x = janet_get1(s, janet_ckeywordv("arity"));
    def->arity = janet_checkint(x) ? janet_unwrap_integer(x) : 0;
    janet_asm_assert(&a, def->arity >= 0, "arity must be non-negative");

    x = janet_get1(s, janet_ckeywordv("max-arity"));
    def->max_arity = janet_checkint(x) ? janet_unwrap_integer(x) : def->arity;
    janet_asm_assert(&a, def->max_arity >= def->arity, "max-arity must be greater than or equal to arity");

    x = janet_get1(s, janet_ckeywordv("min-arity"));
    def->min_arity = janet_checkint(x) ? janet_unwrap_integer(x) : def->arity;
    janet_asm_assert(&a, def->min_arity <= def->arity, "min-arity must be less than or equal to arity");

    /* Check vararg */
    x = janet_get1(s, janet_ckeywordv("vararg"));
    if (janet_truthy(x)) def->flags |= JANET_FUNCDEF_FLAG_VARARG;

    /* Check source */
    x = janet_get1(s, janet_ckeywordv("source"));
    if (janet_checktype(x, JANET_STRING)) def->source = janet_unwrap_string(x);

    /* Create slot aliases */
    x = janet_get1(s, janet_ckeywordv("slots"));
    if (janet_indexed_view(x, &arr, &count)) {
        for (i = 0; i < count; i++) {
            Janet v = arr[i];
            if (janet_checktype(v, JANET_TUPLE)) {
                const Janet *t = janet_unwrap_tuple(v);
                int32_t j;
                for (j = 0; j < janet_tuple_length(t); j++) {
                    if (!janet_checktype(t[j], JANET_SYMBOL))
                        janet_asm_error(&a, "slot names must be symbols");
                    janet_table_put(&a.slots, t[j], janet_wrap_integer(i));
                }
            } else if (janet_checktype(v, JANET_SYMBOL)) {
                janet_table_put(&a.slots, v, janet_wrap_integer(i));
            } else {
                janet_asm_error(&a, "slot names must be symbols or tuple of symbols");
            }
        }
    }

    /* Parse constants */
    x = janet_get1(s, janet_ckeywordv("constants"));
    if (janet_indexed_view(x, &arr, &count)) {
        def->constants_length = count;
        def->constants = malloc(sizeof(Janet) * (size_t) count);
        if (NULL == def->constants) {
            JANET_OUT_OF_MEMORY;
        }
        for (i = 0; i < count; i++) {
            Janet ct = arr[i];
            def->constants[i] = ct;
        }
    } else {
        def->constants = NULL;
        def->constants_length = 0;
    }

    /* Parse sub funcdefs */
    x = janet_get1(s, janet_ckeywordv("closures"));
    if (janet_indexed_view(x, &arr, &count)) {
        int32_t i;
        for (i = 0; i < count; i++) {
            JanetAssembleResult subres;
            Janet subname;
            int32_t newlen;
            subres = janet_asm1(&a, arr[i], flags);
            if (subres.status != JANET_ASSEMBLE_OK) {
                janet_asm_errorv(&a, subres.error);
            }
            subname = janet_get1(arr[i], janet_ckeywordv("name"));
            if (!janet_checktype(subname, JANET_NIL)) {
                janet_table_put(&a.defs, subname, janet_wrap_integer(def->defs_length));
            }
            newlen = def->defs_length + 1;
            if (a.defs_capacity < newlen) {
                int32_t newcap = newlen;
                def->defs = realloc(def->defs, newcap * sizeof(JanetFuncDef *));
                if (NULL == def->defs) {
                    JANET_OUT_OF_MEMORY;
                }
                a.defs_capacity = newcap;
            }
            def->defs[def->defs_length] = subres.funcdef;
            def->defs_length = newlen;
        }
    }

    /* Parse bytecode and labels */
    x = janet_get1(s, janet_ckeywordv("bytecode"));
    if (janet_indexed_view(x, &arr, &count)) {
        /* Do labels and find length */
        int32_t blength = 0;
        for (i = 0; i < count; ++i) {
            Janet instr = arr[i];
            if (janet_checktype(instr, JANET_KEYWORD)) {
                janet_table_put(&a.labels, instr, janet_wrap_integer(blength));
            } else if (janet_checktype(instr, JANET_TUPLE)) {
                blength++;
            } else {
                a.errindex = i;
                janet_asm_error(&a, "expected assembly instruction");
            }
        }
        /* Allocate bytecode array */
        def->bytecode_length = blength;
        def->bytecode = malloc(sizeof(uint32_t) * (size_t) blength);
        if (NULL == def->bytecode) {
            JANET_OUT_OF_MEMORY;
        }
        /* Do bytecode */
        for (i = 0; i < count; ++i) {
            Janet instr = arr[i];
            if (janet_checktype(instr, JANET_KEYWORD)) {
                continue;
            } else {
                uint32_t op;
                const JanetInstructionDef *idef;
                const Janet *t;
                a.errindex = i;
                janet_asm_assert(&a, janet_checktype(instr, JANET_TUPLE), "expected tuple");
                t = janet_unwrap_tuple(instr);
                if (janet_tuple_length(t) == 0) {
                    op = 0;
                } else {
                    janet_asm_assert(&a, janet_checktype(t[0], JANET_SYMBOL),
                                     "expected symbol in assembly instruction");
                    idef = janet_strbinsearch(
                               &janet_ops,
                               sizeof(janet_ops) / sizeof(JanetInstructionDef),
                               sizeof(JanetInstructionDef),
                               janet_unwrap_symbol(t[0]));
                    if (NULL == idef)
                        janet_asm_errorv(&a, janet_formatc("unknown instruction %v", t[0]));
                    op = read_instruction(&a, idef, t);
                }
                def->bytecode[a.bytecode_count++] = op;
            }
        }
    } else {
        janet_asm_error(&a, "bytecode expected");
    }
    a.errindex = -1;

    /* Check for source mapping */
    x = janet_get1(s, janet_ckeywordv("sourcemap"));
    if (janet_indexed_view(x, &arr, &count)) {
        janet_asm_assert(&a, count == def->bytecode_length, "sourcemap must have the same length as the bytecode");
        def->sourcemap = malloc(sizeof(JanetSourceMapping) * (size_t) count);
        if (NULL == def->sourcemap) {
            JANET_OUT_OF_MEMORY;
        }
        for (i = 0; i < count; i++) {
            const Janet *tup;
            Janet entry = arr[i];
            JanetSourceMapping mapping;
            if (!janet_checktype(entry, JANET_TUPLE)) {
                janet_asm_error(&a, "expected tuple");
            }
            tup = janet_unwrap_tuple(entry);
            if (!janet_checkint(tup[0])) {
                janet_asm_error(&a, "expected integer");
            }
            if (!janet_checkint(tup[1])) {
                janet_asm_error(&a, "expected integer");
            }
            mapping.line = janet_unwrap_integer(tup[0]);
            mapping.column = janet_unwrap_integer(tup[1]);
            def->sourcemap[i] = mapping;
        }
    }

    /* Set environments */
    def->environments =
        realloc(def->environments, def->environments_length * sizeof(int32_t));
    if (NULL == def->environments) {
        JANET_OUT_OF_MEMORY;
    }

    /* Verify the func def */
    if (janet_verify(def)) {
        janet_asm_error(&a, "invalid assembly");
    }

    /* Finish everything and return funcdef */
    janet_asm_deinit(&a);
    result.error = NULL;
    result.funcdef = def;
    result.status = JANET_ASSEMBLE_OK;
    return result;
}

/* Assemble a function */
JanetAssembleResult janet_asm(Janet source, int flags) {
    return janet_asm1(NULL, source, flags);
}

/* Disassembly */

/* Find the definition of an instruction given the instruction word. Return
 * NULL if not found. */
static const JanetInstructionDef *janet_asm_reverse_lookup(uint32_t instr) {
    size_t i;
    uint32_t opcode = instr & 0x7F;
    for (i = 0; i < sizeof(janet_ops) / sizeof(JanetInstructionDef); i++) {
        const JanetInstructionDef *def = janet_ops + i;
        if (def->opcode == opcode)
            return def;
    }
    return NULL;
}

/* Create some constant sized tuples */
static const Janet *tup1(Janet x) {
    Janet *tup = janet_tuple_begin(1);
    tup[0] = x;
    return janet_tuple_end(tup);
}
static const Janet *tup2(Janet x, Janet y) {
    Janet *tup = janet_tuple_begin(2);
    tup[0] = x;
    tup[1] = y;
    return janet_tuple_end(tup);
}
static const Janet *tup3(Janet x, Janet y, Janet z) {
    Janet *tup = janet_tuple_begin(3);
    tup[0] = x;
    tup[1] = y;
    tup[2] = z;
    return janet_tuple_end(tup);
}
static const Janet *tup4(Janet w, Janet x, Janet y, Janet z) {
    Janet *tup = janet_tuple_begin(4);
    tup[0] = w;
    tup[1] = x;
    tup[2] = y;
    tup[3] = z;
    return janet_tuple_end(tup);
}

/* Given an argument, convert it to the appropriate integer or symbol */
Janet janet_asm_decode_instruction(uint32_t instr) {
    const JanetInstructionDef *def = janet_asm_reverse_lookup(instr);
    Janet name;
    if (NULL == def) {
        return janet_wrap_integer((int32_t)instr);
    }
    name = janet_csymbolv(def->name);
    const Janet *ret = NULL;
#define oparg(shift, mask) ((instr >> ((shift) << 3)) & (mask))
    switch (janet_instructions[def->opcode]) {
        case JINT_0:
            ret = tup1(name);
            break;
        case JINT_S:
            ret = tup2(name, janet_wrap_integer(oparg(1, 0xFFFFFF)));
            break;
        case JINT_L:
            ret = tup2(name, janet_wrap_integer((int32_t)instr >> 8));
            break;
        case JINT_SS:
        case JINT_ST:
        case JINT_SC:
        case JINT_SU:
        case JINT_SD:
            ret = tup3(name,
                       janet_wrap_integer(oparg(1, 0xFF)),
                       janet_wrap_integer(oparg(2, 0xFFFF)));
            break;
        case JINT_SI:
        case JINT_SL:
            ret =  tup3(name,
                        janet_wrap_integer(oparg(1, 0xFF)),
                        janet_wrap_integer((int32_t)instr >> 16));
            break;
        case JINT_SSS:
        case JINT_SES:
        case JINT_SSU:
            ret = tup4(name,
                       janet_wrap_integer(oparg(1, 0xFF)),
                       janet_wrap_integer(oparg(2, 0xFF)),
                       janet_wrap_integer(oparg(3, 0xFF)));
            break;
        case JINT_SSI:
            ret = tup4(name,
                       janet_wrap_integer(oparg(1, 0xFF)),
                       janet_wrap_integer(oparg(2, 0xFF)),
                       janet_wrap_integer((int32_t)instr >> 24));
            break;
    }
#undef oparg
    if (ret) {
        /* Check if break point set */
        if (instr & 0x80) {
            janet_tuple_flag(ret) |= JANET_TUPLE_FLAG_BRACKETCTOR;
        }
        return janet_wrap_tuple(ret);
    }
    return janet_wrap_nil();
}

Janet janet_disasm(JanetFuncDef *def) {
    int32_t i;
    JanetArray *bcode = janet_array(def->bytecode_length);
    JanetArray *constants;
    JanetTable *ret = janet_table(10);
    janet_table_put(ret, janet_ckeywordv("arity"), janet_wrap_integer(def->arity));
    janet_table_put(ret, janet_ckeywordv("min-arity"), janet_wrap_integer(def->min_arity));
    janet_table_put(ret, janet_ckeywordv("max-arity"), janet_wrap_integer(def->max_arity));
    janet_table_put(ret, janet_ckeywordv("bytecode"), janet_wrap_array(bcode));
    if (NULL != def->source) {
        janet_table_put(ret, janet_ckeywordv("source"), janet_wrap_string(def->source));
    }
    if (def->flags & JANET_FUNCDEF_FLAG_VARARG) {
        janet_table_put(ret, janet_ckeywordv("vararg"), janet_wrap_true());
    }
    if (NULL != def->name) {
        janet_table_put(ret, janet_ckeywordv("name"), janet_wrap_string(def->name));
    }

    /* Add constants */
    if (def->constants_length > 0) {
        constants = janet_array(def->constants_length);
        janet_table_put(ret, janet_ckeywordv("constants"), janet_wrap_array(constants));
        for (i = 0; i < def->constants_length; i++) {
            constants->data[i] = def->constants[i];
        }
        constants->count = def->constants_length;
    }

    /* Add bytecode */
    for (i = 0; i < def->bytecode_length; i++) {
        bcode->data[i] = janet_asm_decode_instruction(def->bytecode[i]);
    }
    bcode->count = def->bytecode_length;

    /* Add source map */
    if (NULL != def->sourcemap) {
        JanetArray *sourcemap = janet_array(def->bytecode_length);
        for (i = 0; i < def->bytecode_length; i++) {
            Janet *t = janet_tuple_begin(2);
            JanetSourceMapping mapping = def->sourcemap[i];
            t[0] = janet_wrap_integer(mapping.line);
            t[1] = janet_wrap_integer(mapping.column);
            sourcemap->data[i] = janet_wrap_tuple(janet_tuple_end(t));
        }
        sourcemap->count = def->bytecode_length;
        janet_table_put(ret, janet_ckeywordv("sourcemap"), janet_wrap_array(sourcemap));
    }

    /* Add environments */
    if (NULL != def->environments) {
        JanetArray *envs = janet_array(def->environments_length);
        for (i = 0; i < def->environments_length; i++) {
            envs->data[i] = janet_wrap_integer(def->environments[i]);
        }
        envs->count = def->environments_length;
        janet_table_put(ret, janet_ckeywordv("environments"), janet_wrap_array(envs));
    }

    /* Add closures */
    /* Funcdefs cannot be recursive */
    if (NULL != def->defs) {
        JanetArray *defs = janet_array(def->defs_length);
        for (i = 0; i < def->defs_length; i++) {
            defs->data[i] = janet_disasm(def->defs[i]);
        }
        defs->count = def->defs_length;
        janet_table_put(ret, janet_ckeywordv("defs"), janet_wrap_array(defs));
    }

    /* Add slotcount */
    janet_table_put(ret, janet_ckeywordv("slotcount"), janet_wrap_integer(def->slotcount));

    return janet_wrap_struct(janet_table_to_struct(ret));
}

/* C Function for assembly */
static Janet cfun_asm(int32_t argc, Janet *argv) {
    janet_arity(argc, 1, 1);
    JanetAssembleResult res;
    res = janet_asm(argv[0], 0);
    if (res.status != JANET_ASSEMBLE_OK) {
        janet_panics(res.error);
    }
    return janet_wrap_function(janet_thunk(res.funcdef));
}

static Janet cfun_disasm(int32_t argc, Janet *argv) {
    janet_arity(argc, 1, 1);
    JanetFunction *f = janet_getfunction(argv, 0);
    return janet_disasm(f->def);
}

static const JanetReg asm_cfuns[] = {
    {
        "asm", cfun_asm,
        JDOC("(asm assembly)\n\n"
             "Returns a new function that is the compiled result of the assembly.\n"
             "The syntax for the assembly can be found on the Janet website. Will throw an\n"
             "error on invalid assembly.")
    },
    {
        "disasm", cfun_disasm,
        JDOC("(disasm func)\n\n"
             "Returns assembly that could be used be compile the given function.\n"
             "func must be a function, not a c function. Will throw on error on a badly\n"
             "typed argument.")
    },
    {NULL, NULL, NULL}
};

/* Load the library */
void janet_lib_asm(JanetTable *env) {
    janet_core_cfuns(env, NULL, asm_cfuns);
}

#endif


/* src/core/buffer.c */
#line 0 "src/core/buffer.c"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "gc.h"
#include "util.h"
#include "state.h"
#endif

/* Initialize a buffer */
JanetBuffer *janet_buffer_init(JanetBuffer *buffer, int32_t capacity) {
    uint8_t *data = NULL;
    if (capacity > 0) {
        janet_gcpressure(capacity);
        data = malloc(sizeof(uint8_t) * (size_t) capacity);
        if (NULL == data) {
            JANET_OUT_OF_MEMORY;
        }
    }
    buffer->count = 0;
    buffer->capacity = capacity;
    buffer->data = data;
    return buffer;
}

/* Deinitialize a buffer (free data memory) */
void janet_buffer_deinit(JanetBuffer *buffer) {
    free(buffer->data);
}

/* Initialize a buffer */
JanetBuffer *janet_buffer(int32_t capacity) {
    JanetBuffer *buffer = janet_gcalloc(JANET_MEMORY_BUFFER, sizeof(JanetBuffer));
    return janet_buffer_init(buffer, capacity);
}

/* Ensure that the buffer has enough internal capacity */
void janet_buffer_ensure(JanetBuffer *buffer, int32_t capacity, int32_t growth) {
    uint8_t *new_data;
    uint8_t *old = buffer->data;
    if (capacity <= buffer->capacity) return;
    int64_t big_capacity = ((int64_t) capacity) * growth;
    capacity = big_capacity > INT32_MAX ? INT32_MAX : (int32_t) big_capacity;
    janet_gcpressure(capacity - buffer->capacity);
    new_data = realloc(old, (size_t) capacity * sizeof(uint8_t));
    if (NULL == new_data) {
        JANET_OUT_OF_MEMORY;
    }
    buffer->data = new_data;
    buffer->capacity = capacity;
}

/* Ensure that the buffer has enough internal capacity */
void janet_buffer_setcount(JanetBuffer *buffer, int32_t count) {
    if (count < 0)
        return;
    if (count > buffer->count) {
        int32_t oldcount = buffer->count;
        janet_buffer_ensure(buffer, count, 1);
        memset(buffer->data + oldcount, 0, count - oldcount);
    }
    buffer->count = count;
}

/* Adds capacity for enough extra bytes to the buffer. Ensures that the
 * next n bytes pushed to the buffer will not cause a reallocation */
void janet_buffer_extra(JanetBuffer *buffer, int32_t n) {
    /* Check for buffer overflow */
    if ((int64_t)n + buffer->count > INT32_MAX) {
        janet_panic("buffer overflow");
    }
    int32_t new_size = buffer->count + n;
    if (new_size > buffer->capacity) {
        int32_t new_capacity = new_size * 2;
        uint8_t *new_data = realloc(buffer->data, new_capacity * sizeof(uint8_t));
        janet_gcpressure(new_capacity - buffer->capacity);
        if (NULL == new_data) {
            JANET_OUT_OF_MEMORY;
        }
        buffer->data = new_data;
        buffer->capacity = new_capacity;
    }
}

/* Push a cstring to buffer */
void janet_buffer_push_cstring(JanetBuffer *buffer, const char *cstring) {
    int32_t len = 0;
    while (cstring[len]) ++len;
    janet_buffer_push_bytes(buffer, (const uint8_t *) cstring, len);
}

/* Push multiple bytes into the buffer */
void janet_buffer_push_bytes(JanetBuffer *buffer, const uint8_t *string, int32_t length) {
    if (0 == length) return;
    janet_buffer_extra(buffer, length);
    memcpy(buffer->data + buffer->count, string, length);
    buffer->count += length;
}

void janet_buffer_push_string(JanetBuffer *buffer, const uint8_t *string) {
    janet_buffer_push_bytes(buffer, string, janet_string_length(string));
}

/* Push a single byte to the buffer */
void janet_buffer_push_u8(JanetBuffer *buffer, uint8_t byte) {
    janet_buffer_extra(buffer, 1);
    buffer->data[buffer->count] = byte;
    buffer->count++;
}

/* Push a 16 bit unsigned integer to the buffer */
void janet_buffer_push_u16(JanetBuffer *buffer, uint16_t x) {
    janet_buffer_extra(buffer, 2);
    buffer->data[buffer->count] = x & 0xFF;
    buffer->data[buffer->count + 1] = (x >> 8) & 0xFF;
    buffer->count += 2;
}

/* Push a 32 bit unsigned integer to the buffer */
void janet_buffer_push_u32(JanetBuffer *buffer, uint32_t x) {
    janet_buffer_extra(buffer, 4);
    buffer->data[buffer->count] = x & 0xFF;
    buffer->data[buffer->count + 1] = (x >> 8) & 0xFF;
    buffer->data[buffer->count + 2] = (x >> 16) & 0xFF;
    buffer->data[buffer->count + 3] = (x >> 24) & 0xFF;
    buffer->count += 4;
}

/* Push a 64 bit unsigned integer to the buffer */
void janet_buffer_push_u64(JanetBuffer *buffer, uint64_t x) {
    janet_buffer_extra(buffer, 8);
    buffer->data[buffer->count] = x & 0xFF;
    buffer->data[buffer->count + 1] = (x >> 8) & 0xFF;
    buffer->data[buffer->count + 2] = (x >> 16) & 0xFF;
    buffer->data[buffer->count + 3] = (x >> 24) & 0xFF;
    buffer->data[buffer->count + 4] = (x >> 32) & 0xFF;
    buffer->data[buffer->count + 5] = (x >> 40) & 0xFF;
    buffer->data[buffer->count + 6] = (x >> 48) & 0xFF;
    buffer->data[buffer->count + 7] = (x >> 56) & 0xFF;
    buffer->count += 8;
}

/* C functions */

static Janet cfun_buffer_new(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    int32_t cap = janet_getinteger(argv, 0);
    JanetBuffer *buffer = janet_buffer(cap);
    return janet_wrap_buffer(buffer);
}

static Janet cfun_buffer_new_filled(int32_t argc, Janet *argv) {
    janet_arity(argc, 1, 2);
    int32_t count = janet_getinteger(argv, 0);
    int32_t byte = 0;
    if (argc == 2) {
        byte = janet_getinteger(argv, 1) & 0xFF;
    }
    JanetBuffer *buffer = janet_buffer(count);
    if (buffer->data)
        memset(buffer->data, byte, count);
    buffer->count = count;
    return janet_wrap_buffer(buffer);
}

static Janet cfun_buffer_fill(int32_t argc, Janet *argv) {
    janet_arity(argc, 1, 2);
    JanetBuffer *buffer = janet_getbuffer(argv, 0);
    int32_t byte = 0;
    if (argc == 2) {
        byte = janet_getinteger(argv, 1) & 0xFF;
    }
    if (buffer->count) {
        memset(buffer->data, byte, buffer->count);
    }
    return argv[0];
}

static Janet cfun_buffer_trim(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    JanetBuffer *buffer = janet_getbuffer(argv, 0);
    if (buffer->count) {
        if (buffer->count < buffer->capacity) {
            uint8_t *newData = realloc(buffer->data, buffer->count);
            if (NULL == newData) {
                JANET_OUT_OF_MEMORY;
            }
            buffer->data = newData;
            buffer->capacity = buffer->count;
        }
    } else {
        buffer->capacity = 0;
        free(buffer->data);
        buffer->data = NULL;
    }
    return argv[0];
}

static Janet cfun_buffer_u8(int32_t argc, Janet *argv) {
    int32_t i;
    janet_arity(argc, 1, -1);
    JanetBuffer *buffer = janet_getbuffer(argv, 0);
    for (i = 1; i < argc; i++) {
        janet_buffer_push_u8(buffer, (uint8_t)(janet_getinteger(argv, i) & 0xFF));
    }
    return argv[0];
}

static Janet cfun_buffer_word(int32_t argc, Janet *argv) {
    int32_t i;
    janet_arity(argc, 1, -1);
    JanetBuffer *buffer = janet_getbuffer(argv, 0);
    for (i = 1; i < argc; i++) {
        double number = janet_getnumber(argv, i);
        uint32_t word = (uint32_t) number;
        if (word != number)
            janet_panicf("cannot convert %v to machine word", argv[i]);
        janet_buffer_push_u32(buffer, word);
    }
    return argv[0];
}

static Janet cfun_buffer_chars(int32_t argc, Janet *argv) {
    int32_t i;
    janet_arity(argc, 1, -1);
    JanetBuffer *buffer = janet_getbuffer(argv, 0);
    for (i = 1; i < argc; i++) {
        JanetByteView view = janet_getbytes(argv, i);
        if (view.bytes == buffer->data) {
            janet_buffer_ensure(buffer, buffer->count + view.len, 2);
            view.bytes = buffer->data;
        }
        janet_buffer_push_bytes(buffer, view.bytes, view.len);
    }
    return argv[0];
}

static Janet cfun_buffer_clear(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    JanetBuffer *buffer = janet_getbuffer(argv, 0);
    buffer->count = 0;
    return argv[0];
}

static Janet cfun_buffer_popn(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 2);
    JanetBuffer *buffer = janet_getbuffer(argv, 0);
    int32_t n = janet_getinteger(argv, 1);
    if (n < 0) janet_panic("n must be non-negative");
    if (buffer->count < n) {
        buffer->count = 0;
    } else {
        buffer->count -= n;
    }
    return argv[0];
}

static Janet cfun_buffer_slice(int32_t argc, Janet *argv) {
    JanetByteView view = janet_getbytes(argv, 0);
    JanetRange range = janet_getslice(argc, argv);
    JanetBuffer *buffer = janet_buffer(range.end - range.start);
    if (buffer->data)
        memcpy(buffer->data, view.bytes + range.start, range.end - range.start);
    buffer->count = range.end - range.start;
    return janet_wrap_buffer(buffer);
}

static void bitloc(int32_t argc, Janet *argv, JanetBuffer **b, int32_t *index, int *bit) {
    janet_fixarity(argc, 2);
    JanetBuffer *buffer = janet_getbuffer(argv, 0);
    double x = janet_getnumber(argv, 1);
    int64_t bitindex = (int64_t) x;
    int64_t byteindex = bitindex >> 3;
    int which_bit = bitindex & 7;
    if (bitindex != x || bitindex < 0 || byteindex >= buffer->count)
        janet_panicf("invalid bit index %v", argv[1]);
    *b = buffer;
    *index = (int32_t) byteindex;
    *bit = which_bit;
}

static Janet cfun_buffer_bitset(int32_t argc, Janet *argv) {
    int bit;
    int32_t index;
    JanetBuffer *buffer;
    bitloc(argc, argv, &buffer, &index, &bit);
    buffer->data[index] |= 1 << bit;
    return argv[0];
}

static Janet cfun_buffer_bitclear(int32_t argc, Janet *argv) {
    int bit;
    int32_t index;
    JanetBuffer *buffer;
    bitloc(argc, argv, &buffer, &index, &bit);
    buffer->data[index] &= ~(1 << bit);
    return argv[0];
}

static Janet cfun_buffer_bitget(int32_t argc, Janet *argv) {
    int bit;
    int32_t index;
    JanetBuffer *buffer;
    bitloc(argc, argv, &buffer, &index, &bit);
    return janet_wrap_boolean(buffer->data[index] & (1 << bit));
}

static Janet cfun_buffer_bittoggle(int32_t argc, Janet *argv) {
    int bit;
    int32_t index;
    JanetBuffer *buffer;
    bitloc(argc, argv, &buffer, &index, &bit);
    buffer->data[index] ^= (1 << bit);
    return argv[0];
}

static Janet cfun_buffer_blit(int32_t argc, Janet *argv) {
    janet_arity(argc, 2, 5);
    JanetBuffer *dest = janet_getbuffer(argv, 0);
    JanetByteView src = janet_getbytes(argv, 1);
    int same_buf = src.bytes == dest->data;
    int32_t offset_dest = 0;
    int32_t offset_src = 0;
    if (argc > 2)
        offset_dest = janet_gethalfrange(argv, 2, dest->count, "dest-start");
    if (argc > 3)
        offset_src = janet_gethalfrange(argv, 3, src.len, "src-start");
    int32_t length_src;
    if (argc > 4) {
        int32_t src_end = janet_gethalfrange(argv, 4, src.len, "src-end");
        length_src = src_end - offset_src;
        if (length_src < 0) length_src = 0;
    } else {
        length_src = src.len - offset_src;
    }
    int64_t last = (int64_t) offset_dest + length_src;
    if (last > INT32_MAX)
        janet_panic("buffer blit out of range");
    int32_t last32 = (int32_t) last;
    janet_buffer_ensure(dest, last32, 2);
    if (last32 > dest->count) dest->count = last32;
    if (length_src) {
        if (same_buf) {
            /* janet_buffer_ensure may have invalidated src */
            src.bytes = dest->data;
            memmove(dest->data + offset_dest, src.bytes + offset_src, length_src);
        } else {
            memcpy(dest->data + offset_dest, src.bytes + offset_src, length_src);
        }
    }
    return argv[0];
}

static Janet cfun_buffer_format(int32_t argc, Janet *argv) {
    janet_arity(argc, 2, -1);
    JanetBuffer *buffer = janet_getbuffer(argv, 0);
    const char *strfrmt = (const char *) janet_getstring(argv, 1);
    janet_buffer_format(buffer, strfrmt, 1, argc, argv);
    return argv[0];
}

static const JanetReg buffer_cfuns[] = {
    {
        "buffer/new", cfun_buffer_new,
        JDOC("(buffer/new capacity)\n\n"
             "Creates a new, empty buffer with enough backing memory for capacity bytes. "
             "Returns a new buffer of length 0.")
    },
    {
        "buffer/new-filled", cfun_buffer_new_filled,
        JDOC("(buffer/new-filled count &opt byte)\n\n"
             "Creates a new buffer of length count filled with byte. By default, byte is 0. "
             "Returns the new buffer.")
    },
    {
        "buffer/fill", cfun_buffer_fill,
        JDOC("(buffer/fill buffer &opt byte)\n\n"
             "Fill up a buffer with bytes, defaulting to 0s. Does not change the buffer's length. "
             "Returns the modified buffer.")
    },
    {
        "buffer/trim", cfun_buffer_trim,
        JDOC("(buffer/trim buffer)\n\n"
             "Set the backing capacity of the buffer to the current length of the buffer. Returns the "
             "modified buffer.")
    },
    {
        "buffer/push-byte", cfun_buffer_u8,
        JDOC("(buffer/push-byte buffer x)\n\n"
             "Append a byte to a buffer. Will expand the buffer as necessary. "
             "Returns the modified buffer. Will throw an error if the buffer overflows.")
    },
    {
        "buffer/push-word", cfun_buffer_word,
        JDOC("(buffer/push-word buffer x)\n\n"
             "Append a machine word to a buffer. The 4 bytes of the integer are appended "
             "in twos complement, little endian order, unsigned. Returns the modified buffer. Will "
             "throw an error if the buffer overflows.")
    },
    {
        "buffer/push-string", cfun_buffer_chars,
        JDOC("(buffer/push-string buffer str)\n\n"
             "Push a string onto the end of a buffer. Non string values will be converted "
             "to strings before being pushed. Returns the modified buffer. "
             "Will throw an error if the buffer overflows.")
    },
    {
        "buffer/popn", cfun_buffer_popn,
        JDOC("(buffer/popn buffer n)\n\n"
             "Removes the last n bytes from the buffer. Returns the modified buffer.")
    },
    {
        "buffer/clear", cfun_buffer_clear,
        JDOC("(buffer/clear buffer)\n\n"
             "Sets the size of a buffer to 0 and empties it. The buffer retains "
             "its memory so it can be efficiently refilled. Returns the modified buffer.")
    },
    {
        "buffer/slice", cfun_buffer_slice,
        JDOC("(buffer/slice bytes &opt start end)\n\n"
             "Takes a slice of a byte sequence from start to end. The range is half open, "
             "[start, end). Indexes can also be negative, indicating indexing from the end of the "
             "end of the array. By default, start is 0 and end is the length of the buffer. "
             "Returns a new buffer.")
    },
    {
        "buffer/bit-set", cfun_buffer_bitset,
        JDOC("(buffer/bit-set buffer index)\n\n"
             "Sets the bit at the given bit-index. Returns the buffer.")
    },
    {
        "buffer/bit-clear", cfun_buffer_bitclear,
        JDOC("(buffer/bit-clear buffer index)\n\n"
             "Clears the bit at the given bit-index. Returns the buffer.")
    },
    {
        "buffer/bit", cfun_buffer_bitget,
        JDOC("(buffer/bit buffer index)\n\n"
             "Gets the bit at the given bit-index. Returns true if the bit is set, false if not.")
    },
    {
        "buffer/bit-toggle", cfun_buffer_bittoggle,
        JDOC("(buffer/bit-toggle buffer index)\n\n"
             "Toggles the bit at the given bit index in buffer. Returns the buffer.")
    },
    {
        "buffer/blit", cfun_buffer_blit,
        JDOC("(buffer/blit dest src &opt dest-start src-start src-end)\n\n"
             "Insert the contents of src into dest. Can optionally take indices that "
             "indicate which part of src to copy into which part of dest. Indices can be "
             "negative to index from the end of src or dest. Returns dest.")
    },
    {
        "buffer/format", cfun_buffer_format,
        JDOC("(buffer/format buffer format & args)\n\n"
             "Snprintf like functionality for printing values into a buffer. Returns "
             " the modified buffer.")
    },
    {NULL, NULL, NULL}
};

void janet_lib_buffer(JanetTable *env) {
    janet_core_cfuns(env, NULL, buffer_cfuns);
}


/* src/core/bytecode.c */
#line 0 "src/core/bytecode.c"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "gc.h"
#include "util.h"
#endif

/* Look up table for instructions */
enum JanetInstructionType janet_instructions[JOP_INSTRUCTION_COUNT] = {
    JINT_0, /* JOP_NOOP, */
    JINT_S, /* JOP_ERROR, */
    JINT_ST, /* JOP_TYPECHECK, */
    JINT_S, /* JOP_RETURN, */
    JINT_0, /* JOP_RETURN_NIL, */
    JINT_SSI, /* JOP_ADD_IMMEDIATE, */
    JINT_SSS, /* JOP_ADD, */
    JINT_SSS, /* JOP_SUBTRACT, */
    JINT_SSI, /* JOP_MULTIPLY_IMMEDIATE, */
    JINT_SSS, /* JOP_MULTIPLY, */
    JINT_SSI, /* JOP_DIVIDE_IMMEDIATE, */
    JINT_SSS, /* JOP_DIVIDE, */
    JINT_SSS, /* JOP_MODULO, */
    JINT_SSS, /* JOP_REMAINDER, */
    JINT_SSS, /* JOP_BAND, */
    JINT_SSS, /* JOP_BOR, */
    JINT_SSS, /* JOP_BXOR, */
    JINT_SS, /* JOP_BNOT, */
    JINT_SSS, /* JOP_SHIFT_LEFT, */
    JINT_SSI, /* JOP_SHIFT_LEFT_IMMEDIATE, */
    JINT_SSS, /* JOP_SHIFT_RIGHT, */
    JINT_SSI, /* JOP_SHIFT_RIGHT_IMMEDIATE, */
    JINT_SSS, /* JOP_SHIFT_RIGHT_UNSIGNED, */
    JINT_SSU, /* JOP_SHIFT_RIGHT_UNSIGNED_IMMEDIATE, */
    JINT_SS, /* JOP_MOVE_FAR, */
    JINT_SS, /* JOP_MOVE_NEAR, */
    JINT_L, /* JOP_JUMP, */
    JINT_SL, /* JOP_JUMP_IF, */
    JINT_SL, /* JOP_JUMP_IF_NOT, */
    JINT_SL, /* JOP_JUMP_IF_NIL, */
    JINT_SL, /* JOP_JUMP_IF_NOT_NIL, */
    JINT_SSS, /* JOP_GREATER_THAN, */
    JINT_SSI, /* JOP_GREATER_THAN_IMMEDIATE, */
    JINT_SSS, /* JOP_LESS_THAN, */
    JINT_SSI, /* JOP_LESS_THAN_IMMEDIATE, */
    JINT_SSS, /* JOP_EQUALS, */
    JINT_SSI, /* JOP_EQUALS_IMMEDIATE, */
    JINT_SSS, /* JOP_COMPARE, */
    JINT_S, /* JOP_LOAD_NIL, */
    JINT_S, /* JOP_LOAD_TRUE, */
    JINT_S, /* JOP_LOAD_FALSE, */
    JINT_SI, /* JOP_LOAD_INTEGER, */
    JINT_SC, /* JOP_LOAD_CONSTANT, */
    JINT_SES, /* JOP_LOAD_UPVALUE, */
    JINT_S, /* JOP_LOAD_SELF, */
    JINT_SES, /* JOP_SET_UPVALUE, */
    JINT_SD, /* JOP_CLOSURE, */
    JINT_S, /* JOP_PUSH, */
    JINT_SS, /* JOP_PUSH_2, */
    JINT_SSS, /* JOP_PUSH_3, */
    JINT_S, /* JOP_PUSH_ARRAY, */
    JINT_SS, /* JOP_CALL, */
    JINT_S, /* JOP_TAILCALL, */
    JINT_SSS, /* JOP_RESUME, */
    JINT_SSU, /* JOP_SIGNAL, */
    JINT_SSS, /* JOP_PROPAGATE */
    JINT_SSS, /* JOP_IN, */
    JINT_SSS, /* JOP_GET, */
    JINT_SSS, /* JOP_PUT, */
    JINT_SSU, /* JOP_GET_INDEX, */
    JINT_SSU, /* JOP_PUT_INDEX, */
    JINT_SS, /* JOP_LENGTH */
    JINT_S, /* JOP_MAKE_ARRAY */
    JINT_S, /* JOP_MAKE_BUFFER */
    JINT_S, /* JOP_MAKE_STRING */
    JINT_S, /* JOP_MAKE_STRUCT */
    JINT_S, /* JOP_MAKE_TABLE */
    JINT_S, /* JOP_MAKE_TUPLE */
    JINT_S, /* JOP_MAKE_BRACKET_TUPLE */
    JINT_SSS, /* JOP_GREATER_THAN_EQUAL */
    JINT_SSS, /* JOP_LESS_THAN_EQUAL */
    JINT_SSS, /* JOP_NEXT */
};

/* Verify some bytecode */
int32_t janet_verify(JanetFuncDef *def) {
    int vargs = !!(def->flags & JANET_FUNCDEF_FLAG_VARARG);
    int32_t i;
    int32_t maxslot = def->arity + vargs;
    int32_t sc = def->slotcount;

    if (def->bytecode_length == 0) return 1;

    if (maxslot > sc) return 2;

    /* Verify each instruction */
    for (i = 0; i < def->bytecode_length; i++) {
        uint32_t instr = def->bytecode[i];
        /* Check for invalid instructions */
        if ((instr & 0x7F) >= JOP_INSTRUCTION_COUNT) {
            return 3;
        }
        enum JanetInstructionType type = janet_instructions[instr & 0x7F];
        switch (type) {
            case JINT_0:
                continue;
            case JINT_S: {
                if ((int32_t)(instr >> 8) >= sc) return 4;
                continue;
            }
            case JINT_SI:
            case JINT_SU:
            case JINT_ST: {
                if ((int32_t)((instr >> 8) & 0xFF) >= sc) return 4;
                continue;
            }
            case JINT_L: {
                int32_t jumpdest = i + (((int32_t)instr) >> 8);
                if (jumpdest < 0 || jumpdest >= def->bytecode_length) return 5;
                continue;
            }
            case JINT_SS: {
                if ((int32_t)((instr >> 8) & 0xFF) >= sc ||
                        (int32_t)(instr >> 16) >= sc) return 4;
                continue;
            }
            case JINT_SSI:
            case JINT_SSU: {
                if ((int32_t)((instr >> 8) & 0xFF) >= sc ||
                        (int32_t)((instr >> 16) & 0xFF) >= sc) return 4;
                continue;
            }
            case JINT_SL: {
                int32_t jumpdest = i + (((int32_t)instr) >> 16);
                if ((int32_t)((instr >> 8) & 0xFF) >= sc) return 4;
                if (jumpdest < 0 || jumpdest >= def->bytecode_length) return 5;
                continue;
            }
            case JINT_SSS: {
                if (((int32_t)(instr >> 8) & 0xFF) >= sc ||
                        ((int32_t)(instr >> 16) & 0xFF) >= sc ||
                        ((int32_t)(instr >> 24) & 0xFF) >= sc) return 4;
                continue;
            }
            case JINT_SD: {
                if ((int32_t)((instr >> 8) & 0xFF) >= sc) return 4;
                if ((int32_t)(instr >> 16) >= def->defs_length) return 6;
                continue;
            }
            case JINT_SC: {
                if ((int32_t)((instr >> 8) & 0xFF) >= sc) return 4;
                if ((int32_t)(instr >> 16) >= def->constants_length) return 7;
                continue;
            }
            case JINT_SES: {
                /* How can we check the last slot index? We need info parent funcdefs. Resort
                 * to runtime checks for now. Maybe invalid upvalue references could be defaulted
                 * to nil? (don't commit to this in the long term, though) */
                if ((int32_t)((instr >> 8) & 0xFF) >= sc) return 4;
                if ((int32_t)((instr >> 16) & 0xFF) >= def->environments_length) return 8;
                continue;
            }
        }
    }

    /* Verify last instruction is either a jump, return, return-nil, or tailcall. Eventually,
     * some real flow analysis would be ideal, but this should be very effective. Will completely
     * prevent running over the end of bytecode. However, valid functions with dead code will
     * be rejected. */
    {
        uint32_t lastop = def->bytecode[def->bytecode_length - 1] & 0xFF;
        switch (lastop) {
            default:
                return 9;
            case JOP_RETURN:
            case JOP_RETURN_NIL:
            case JOP_JUMP:
            case JOP_ERROR:
            case JOP_TAILCALL:
                break;
        }
    }

    return 0;
}

/* Allocate an empty funcdef. This function may have added functionality
 * as commonalities between asm and compile arise. */
JanetFuncDef *janet_funcdef_alloc(void) {
    JanetFuncDef *def = janet_gcalloc(JANET_MEMORY_FUNCDEF, sizeof(JanetFuncDef));
    def->environments = NULL;
    def->constants = NULL;
    def->bytecode = NULL;
    def->closure_bitset = NULL;
    def->flags = 0;
    def->slotcount = 0;
    def->arity = 0;
    def->min_arity = 0;
    def->max_arity = INT32_MAX;
    def->source = NULL;
    def->sourcemap = NULL;
    def->name = NULL;
    def->defs = NULL;
    def->defs_length = 0;
    def->constants_length = 0;
    def->bytecode_length = 0;
    def->environments_length = 0;
    return def;
}

/* Create a simple closure from a funcdef */
JanetFunction *janet_thunk(JanetFuncDef *def) {
    JanetFunction *func = janet_gcalloc(JANET_MEMORY_FUNCTION, sizeof(JanetFunction));
    func->def = def;
    janet_assert(def->environments_length == 0, "tried to create thunk that needs upvalues");
    return func;
}


/* src/core/capi.c */
#line 0 "src/core/capi.c"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "state.h"
#include "fiber.h"
#endif

JANET_NO_RETURN static void janet_top_level_signal(const char *msg) {
#ifdef JANET_TOP_LEVEL_SIGNAL
    JANET_TOP_LEVEL_SIGNAL(msg);
#else
    fputs(msg, stdout);
    exit(1);
#endif
}

void janet_signalv(JanetSignal sig, Janet message) {
    if (janet_vm_return_reg != NULL) {
        *janet_vm_return_reg = message;
        janet_vm_fiber->flags |= JANET_FIBER_DID_LONGJUMP;
#if defined(JANET_BSD) || defined(JANET_APPLE)
        _longjmp(*janet_vm_jmp_buf, sig);
#else
        longjmp(*janet_vm_jmp_buf, sig);
#endif
    } else {
        const char *str = (const char *)janet_formatc("janet top level signal - %v\n", message);
        janet_top_level_signal(str);
    }
}

void janet_panicv(Janet message) {
    janet_signalv(JANET_SIGNAL_ERROR, message);
}

void janet_panicf(const char *format, ...) {
    va_list args;
    const uint8_t *ret;
    JanetBuffer buffer;
    int32_t len = 0;
    while (format[len]) len++;
    janet_buffer_init(&buffer, len);
    va_start(args, format);
    janet_formatbv(&buffer, format, args);
    va_end(args);
    ret = janet_string(buffer.data, buffer.count);
    janet_buffer_deinit(&buffer);
    janet_panics(ret);
}

void janet_panic(const char *message) {
    janet_panicv(janet_cstringv(message));
}

void janet_panics(const uint8_t *message) {
    janet_panicv(janet_wrap_string(message));
}

void janet_panic_type(Janet x, int32_t n, int expected) {
    janet_panicf("bad slot #%d, expected %T, got %v", n, expected, x);
}

void janet_panic_abstract(Janet x, int32_t n, const JanetAbstractType *at) {
    janet_panicf("bad slot #%d, expected %s, got %v", n, at->name, x);
}

void janet_fixarity(int32_t arity, int32_t fix) {
    if (arity != fix)
        janet_panicf("arity mismatch, expected %d, got %d", fix, arity);
}

void janet_arity(int32_t arity, int32_t min, int32_t max) {
    if (min >= 0 && arity < min)
        janet_panicf("arity mismatch, expected at least %d, got %d", min, arity);
    if (max >= 0 && arity > max)
        janet_panicf("arity mismatch, expected at most %d, got %d", max, arity);
}

#define DEFINE_GETTER(name, NAME, type) \
type janet_get##name(const Janet *argv, int32_t n) { \
    Janet x = argv[n]; \
    if (!janet_checktype(x, JANET_##NAME)) { \
        janet_panic_type(x, n, JANET_TFLAG_##NAME); \
    } \
    return janet_unwrap_##name(x); \
}

#define DEFINE_OPT(name, NAME, type) \
type janet_opt##name(const Janet *argv, int32_t argc, int32_t n, type dflt) { \
    if (n >= argc) return dflt; \
    if (janet_checktype(argv[n], JANET_NIL)) return dflt; \
    return janet_get##name(argv, n); \
}

#define DEFINE_OPTLEN(name, NAME, type) \
type janet_opt##name(const Janet *argv, int32_t argc, int32_t n, int32_t dflt_len) { \
    if (n >= argc || janet_checktype(argv[n], JANET_NIL)) {\
        return janet_##name(dflt_len); \
    }\
    return janet_get##name(argv, n); \
}

int janet_getmethod(const uint8_t *method, const JanetMethod *methods, Janet *out) {
    while (methods->name) {
        if (!janet_cstrcmp(method, methods->name)) {
            *out = janet_wrap_cfunction(methods->cfun);
            return 1;
        }
        methods++;
    }
    return 0;
}

DEFINE_GETTER(number, NUMBER, double)
DEFINE_GETTER(array, ARRAY, JanetArray *)
DEFINE_GETTER(tuple, TUPLE, const Janet *)
DEFINE_GETTER(table, TABLE, JanetTable *)
DEFINE_GETTER(struct, STRUCT, const JanetKV *)
DEFINE_GETTER(string, STRING, const uint8_t *)
DEFINE_GETTER(keyword, KEYWORD, const uint8_t *)
DEFINE_GETTER(symbol, SYMBOL, const uint8_t *)
DEFINE_GETTER(buffer, BUFFER, JanetBuffer *)
DEFINE_GETTER(fiber, FIBER, JanetFiber *)
DEFINE_GETTER(function, FUNCTION, JanetFunction *)
DEFINE_GETTER(cfunction, CFUNCTION, JanetCFunction)
DEFINE_GETTER(boolean, BOOLEAN, int)
DEFINE_GETTER(pointer, POINTER, void *)

DEFINE_OPT(number, NUMBER, double)
DEFINE_OPT(tuple, TUPLE, const Janet *)
DEFINE_OPT(struct, STRUCT, const JanetKV *)
DEFINE_OPT(string, STRING, const uint8_t *)
DEFINE_OPT(keyword, KEYWORD, const uint8_t *)
DEFINE_OPT(symbol, SYMBOL, const uint8_t *)
DEFINE_OPT(fiber, FIBER, JanetFiber *)
DEFINE_OPT(function, FUNCTION, JanetFunction *)
DEFINE_OPT(cfunction, CFUNCTION, JanetCFunction)
DEFINE_OPT(boolean, BOOLEAN, int)
DEFINE_OPT(pointer, POINTER, void *)

DEFINE_OPTLEN(buffer, BUFFER, JanetBuffer *)
DEFINE_OPTLEN(table, TABLE, JanetTable *)
DEFINE_OPTLEN(array, ARRAY, JanetArray *)

const char *janet_optcstring(const Janet *argv, int32_t argc, int32_t n, const char *dflt) {
    if (n >= argc || janet_checktype(argv[n], JANET_NIL)) {
        return dflt;
    }
    return janet_getcstring(argv, n);
}

#undef DEFINE_GETTER
#undef DEFINE_OPT
#undef DEFINE_OPTLEN

const char *janet_getcstring(const Janet *argv, int32_t n) {
    const uint8_t *jstr = janet_getstring(argv, n);
    const char *cstr = (const char *)jstr;
    if (strlen(cstr) != (size_t) janet_string_length(jstr)) {
        janet_panicf("string %v contains embedded 0s");
    }
    return cstr;
}

int32_t janet_getnat(const Janet *argv, int32_t n) {
    Janet x = argv[n];
    if (!janet_checkint(x)) goto bad;
    int32_t ret = janet_unwrap_integer(x);
    if (ret < 0) goto bad;
    return ret;
bad:
    janet_panicf("bad slot #%d, expected non-negative 32 bit signed integer, got %v", n, x);
}

JanetAbstract janet_checkabstract(Janet x, const JanetAbstractType *at) {
    if (!janet_checktype(x, JANET_ABSTRACT)) return NULL;
    JanetAbstract a = janet_unwrap_abstract(x);
    if (janet_abstract_type(a) != at) return NULL;
    return a;
}

static int janet_strlike_cmp(JanetType type, Janet x, const char *cstring) {
    if (janet_type(x) != type) return 0;
    return !janet_cstrcmp(janet_unwrap_string(x), cstring);
}

int janet_keyeq(Janet x, const char *cstring) {
    return janet_strlike_cmp(JANET_KEYWORD, x, cstring);
}

int janet_streq(Janet x, const char *cstring) {
    return janet_strlike_cmp(JANET_STRING, x, cstring);
}

int janet_symeq(Janet x, const char *cstring) {
    return janet_strlike_cmp(JANET_SYMBOL, x, cstring);
}

int32_t janet_getinteger(const Janet *argv, int32_t n) {
    Janet x = argv[n];
    if (!janet_checkint(x)) {
        janet_panicf("bad slot #%d, expected 32 bit signed integer, got %v", n, x);
    }
    return janet_unwrap_integer(x);
}

int64_t janet_getinteger64(const Janet *argv, int32_t n) {
    Janet x = argv[n];
    if (!janet_checkint64(x)) {
        janet_panicf("bad slot #%d, expected 64 bit signed integer, got %v", n, x);
    }
    return (int64_t) janet_unwrap_number(x);
}

size_t janet_getsize(const Janet *argv, int32_t n) {
    Janet x = argv[n];
    if (!janet_checksize(x)) {
        janet_panicf("bad slot #%d, expected size, got %v", n, x);
    }
    return (size_t) janet_unwrap_number(x);
}

int32_t janet_gethalfrange(const Janet *argv, int32_t n, int32_t length, const char *which) {
    int32_t raw = janet_getinteger(argv, n);
    int32_t not_raw = raw;
    if (not_raw < 0) not_raw += length + 1;
    if (not_raw < 0 || not_raw > length)
        janet_panicf("%s index %d out of range [%d,%d]", which, raw, -length - 1, length);
    return not_raw;
}

int32_t janet_getargindex(const Janet *argv, int32_t n, int32_t length, const char *which) {
    int32_t raw = janet_getinteger(argv, n);
    int32_t not_raw = raw;
    if (not_raw < 0) not_raw += length;
    if (not_raw < 0 || not_raw > length)
        janet_panicf("%s index %d out of range [%d,%d)", which, raw, -length, length);
    return not_raw;
}

JanetView janet_getindexed(const Janet *argv, int32_t n) {
    Janet x = argv[n];
    JanetView view;
    if (!janet_indexed_view(x, &view.items, &view.len)) {
        janet_panic_type(x, n, JANET_TFLAG_INDEXED);
    }
    return view;
}

JanetByteView janet_getbytes(const Janet *argv, int32_t n) {
    Janet x = argv[n];
    JanetByteView view;
    if (!janet_bytes_view(x, &view.bytes, &view.len)) {
        janet_panic_type(x, n, JANET_TFLAG_BYTES);
    }
    return view;
}

JanetDictView janet_getdictionary(const Janet *argv, int32_t n) {
    Janet x = argv[n];
    JanetDictView view;
    if (!janet_dictionary_view(x, &view.kvs, &view.len, &view.cap)) {
        janet_panic_type(x, n, JANET_TFLAG_DICTIONARY);
    }
    return view;
}

void *janet_getabstract(const Janet *argv, int32_t n, const JanetAbstractType *at) {
    Janet x = argv[n];
    if (!janet_checktype(x, JANET_ABSTRACT)) {
        janet_panic_abstract(x, n, at);
    }
    void *abstractx = janet_unwrap_abstract(x);
    if (janet_abstract_type(abstractx) != at) {
        janet_panic_abstract(x, n, at);
    }
    return abstractx;
}

JanetRange janet_getslice(int32_t argc, const Janet *argv) {
    janet_arity(argc, 1, 3);
    JanetRange range;
    int32_t length = janet_length(argv[0]);
    if (argc == 1) {
        range.start = 0;
        range.end = length;
    } else if (argc == 2) {
        range.start = janet_checktype(argv[1], JANET_NIL)
                      ? 0
                      : janet_gethalfrange(argv, 1, length, "start");
        range.end = length;
    } else {
        range.start = janet_checktype(argv[1], JANET_NIL)
                      ? 0
                      : janet_gethalfrange(argv, 1, length, "start");
        range.end = janet_checktype(argv[2], JANET_NIL)
                    ? length
                    : janet_gethalfrange(argv, 2, length, "end");
        if (range.end < range.start)
            range.end = range.start;
    }
    return range;
}

Janet janet_dyn(const char *name) {
    if (!janet_vm_fiber) return janet_wrap_nil();
    if (janet_vm_fiber->env) {
        return janet_table_get(janet_vm_fiber->env, janet_ckeywordv(name));
    } else {
        return janet_wrap_nil();
    }
}

void janet_setdyn(const char *name, Janet value) {
    if (!janet_vm_fiber) return;
    if (!janet_vm_fiber->env) {
        janet_vm_fiber->env = janet_table(1);
    }
    janet_table_put(janet_vm_fiber->env, janet_ckeywordv(name), value);
}

uint64_t janet_getflags(const Janet *argv, int32_t n, const char *flags) {
    uint64_t ret = 0;
    const uint8_t *keyw = janet_getkeyword(argv, n);
    int32_t klen = janet_string_length(keyw);
    int32_t flen = (int32_t) strlen(flags);
    if (flen > 64) {
        flen = 64;
    }
    for (int32_t j = 0; j < klen; j++) {
        for (int32_t i = 0; i < flen; i++) {
            if (((uint8_t) flags[i]) == keyw[j]) {
                ret |= 1ULL << i;
                goto found;
            }
        }
        janet_panicf("unexpected flag %c, expected one of \"%s\"", (char) keyw[j], flags);
    found:
        ;
    }
    return ret;
}

int32_t janet_optnat(const Janet *argv, int32_t argc, int32_t n, int32_t dflt) {
    if (argc <= n) return dflt;
    if (janet_checktype(argv[n], JANET_NIL)) return dflt;
    return janet_getnat(argv, n);
}

int32_t janet_optinteger(const Janet *argv, int32_t argc, int32_t n, int32_t dflt) {
    if (argc <= n) return dflt;
    if (janet_checktype(argv[n], JANET_NIL)) return dflt;
    return janet_getinteger(argv, n);
}

int64_t janet_optinteger64(const Janet *argv, int32_t argc, int32_t n, int64_t dflt) {
    if (argc <= n) return dflt;
    if (janet_checktype(argv[n], JANET_NIL)) return dflt;
    return janet_getinteger64(argv, n);
}

size_t janet_optsize(const Janet *argv, int32_t argc, int32_t n, size_t dflt) {
    if (argc <= n) return dflt;
    if (janet_checktype(argv[n], JANET_NIL)) return dflt;
    return janet_getsize(argv, n);
}

void *janet_optabstract(const Janet *argv, int32_t argc, int32_t n, const JanetAbstractType *at, void *dflt) {
    if (argc <= n) return dflt;
    if (janet_checktype(argv[n], JANET_NIL)) return dflt;
    return janet_getabstract(argv, n, at);
}

/* Some definitions for function-like macros */

JANET_API JanetStructHead *(janet_struct_head)(const JanetKV *st) {
    return janet_struct_head(st);
}

JANET_API JanetAbstractHead *(janet_abstract_head)(const void *abstract) {
    return janet_abstract_head(abstract);
}

JANET_API JanetStringHead *(janet_string_head)(const uint8_t *s) {
    return janet_string_head(s);
}

JANET_API JanetTupleHead *(janet_tuple_head)(const Janet *tuple) {
    return janet_tuple_head(tuple);
}


/* src/core/cfuns.c */
#line 0 "src/core/cfuns.c"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "compile.h"
#include "emit.h"
#include "vector.h"
#endif

static int arity1or2(JanetFopts opts, JanetSlot *args) {
    (void) opts;
    int32_t arity = janet_v_count(args);
    return arity == 1 || arity == 2;
}
static int fixarity1(JanetFopts opts, JanetSlot *args) {
    (void) opts;
    return janet_v_count(args) == 1;
}
static int maxarity1(JanetFopts opts, JanetSlot *args) {
    (void) opts;
    return janet_v_count(args) <= 1;
}
static int minarity2(JanetFopts opts, JanetSlot *args) {
    (void) opts;
    return janet_v_count(args) >= 2;
}
static int fixarity2(JanetFopts opts, JanetSlot *args) {
    (void) opts;
    return janet_v_count(args) == 2;
}
static int fixarity3(JanetFopts opts, JanetSlot *args) {
    (void) opts;
    return janet_v_count(args) == 3;
}

/* Generic handling for $A = op $B */
static JanetSlot genericSS(JanetFopts opts, int op, JanetSlot s) {
    JanetSlot target = janetc_gettarget(opts);
    janetc_emit_ss(opts.compiler, op, target, s, 1);
    return target;
}

/* Generic handling for $A = $B op I */
static JanetSlot genericSSI(JanetFopts opts, int op, JanetSlot s, int32_t imm) {
    JanetSlot target = janetc_gettarget(opts);
    janetc_emit_ssi(opts.compiler, op, target, s, imm, 1);
    return target;
}

/* Emit an insruction that implements a form by itself. */
static JanetSlot opfunction(
    JanetFopts opts,
    JanetSlot *args,
    int op,
    Janet defaultArg2) {
    JanetCompiler *c = opts.compiler;
    int32_t len;
    len = janet_v_count(args);
    JanetSlot t;
    if (len == 1) {
        t = janetc_gettarget(opts);
        janetc_emit_sss(c, op, t, args[0], janetc_cslot(defaultArg2), 1);
        return t;
    } else {
        /* len == 2 */
        t = janetc_gettarget(opts);
        janetc_emit_sss(c, op, t, args[0], args[1], 1);
    }
    return t;
}

/* Emit a series of instructions instead of a function call to a math op */
static JanetSlot opreduce(
    JanetFopts opts,
    JanetSlot *args,
    int op,
    Janet nullary) {
    JanetCompiler *c = opts.compiler;
    int32_t i, len;
    len = janet_v_count(args);
    JanetSlot t;
    if (len == 0) {
        return janetc_cslot(nullary);
    } else if (len == 1) {
        t = janetc_gettarget(opts);
        janetc_emit_sss(c, op, t, janetc_cslot(nullary), args[0], 1);
        return t;
    }
    t = janetc_gettarget(opts);
    janetc_emit_sss(c, op, t, args[0], args[1], 1);
    for (i = 2; i < len; i++)
        janetc_emit_sss(c, op, t, t, args[i], 1);
    return t;
}

/* Function optimizers */

static JanetSlot do_propagate(JanetFopts opts, JanetSlot *args) {
    return opreduce(opts, args, JOP_PROPAGATE, janet_wrap_nil());
}
static JanetSlot do_error(JanetFopts opts, JanetSlot *args) {
    janetc_emit_s(opts.compiler, JOP_ERROR, args[0], 0);
    return janetc_cslot(janet_wrap_nil());
}
static JanetSlot do_debug(JanetFopts opts, JanetSlot *args) {
    (void)args;
    int32_t len = janet_v_count(args);
    JanetSlot t = janetc_gettarget(opts);
    janetc_emit_ssu(opts.compiler, JOP_SIGNAL, t,
                    (len == 1) ? args[0] : janetc_cslot(janet_wrap_nil()),
                    JANET_SIGNAL_DEBUG,
                    1);
    return t;
}
static JanetSlot do_in(JanetFopts opts, JanetSlot *args) {
    return opreduce(opts, args, JOP_IN, janet_wrap_nil());
}
static JanetSlot do_get(JanetFopts opts, JanetSlot *args) {
    return opreduce(opts, args, JOP_GET, janet_wrap_nil());
}
static JanetSlot do_next(JanetFopts opts, JanetSlot *args) {
    return opfunction(opts, args, JOP_NEXT, janet_wrap_nil());
}
static JanetSlot do_modulo(JanetFopts opts, JanetSlot *args) {
    return opreduce(opts, args, JOP_MODULO, janet_wrap_nil());
}
static JanetSlot do_remainder(JanetFopts opts, JanetSlot *args) {
    return opreduce(opts, args, JOP_REMAINDER, janet_wrap_nil());
}
static JanetSlot do_put(JanetFopts opts, JanetSlot *args) {
    if (opts.flags & JANET_FOPTS_DROP) {
        janetc_emit_sss(opts.compiler, JOP_PUT, args[0], args[1], args[2], 0);
        return janetc_cslot(janet_wrap_nil());
    } else {
        JanetSlot t = janetc_gettarget(opts);
        janetc_copy(opts.compiler, t, args[0]);
        janetc_emit_sss(opts.compiler, JOP_PUT, t, args[1], args[2], 0);
        return t;
    }
}
static JanetSlot do_length(JanetFopts opts, JanetSlot *args) {
    return genericSS(opts, JOP_LENGTH, args[0]);
}
static JanetSlot do_yield(JanetFopts opts, JanetSlot *args) {
    if (janet_v_count(args) == 0) {
        return genericSSI(opts, JOP_SIGNAL, janetc_cslot(janet_wrap_nil()), 3);
    } else {
        return genericSSI(opts, JOP_SIGNAL, args[0], 3);
    }
}
static JanetSlot do_resume(JanetFopts opts, JanetSlot *args) {
    return opfunction(opts, args, JOP_RESUME, janet_wrap_nil());
}
static JanetSlot do_apply(JanetFopts opts, JanetSlot *args) {
    /* Push phase */
    JanetCompiler *c = opts.compiler;
    int32_t i;
    for (i = 1; i < janet_v_count(args) - 3; i += 3)
        janetc_emit_sss(c, JOP_PUSH_3, args[i], args[i + 1], args[i + 2], 0);
    if (i == janet_v_count(args) - 3)
        janetc_emit_ss(c, JOP_PUSH_2, args[i], args[i + 1], 0);
    else if (i == janet_v_count(args) - 2)
        janetc_emit_s(c, JOP_PUSH, args[i], 0);
    /* Push array phase */
    janetc_emit_s(c, JOP_PUSH_ARRAY, janet_v_last(args), 0);
    /* Call phase */
    JanetSlot target;
    if (opts.flags & JANET_FOPTS_TAIL) {
        janetc_emit_s(c, JOP_TAILCALL, args[0], 0);
        target = janetc_cslot(janet_wrap_nil());
        target.flags |= JANET_SLOT_RETURNED;
    } else {
        target = janetc_gettarget(opts);
        janetc_emit_ss(c, JOP_CALL, target, args[0], 1);
    }
    return target;
}

/* Variadic operators specialization */

static JanetSlot do_add(JanetFopts opts, JanetSlot *args) {
    return opreduce(opts, args, JOP_ADD, janet_wrap_integer(0));
}
static JanetSlot do_sub(JanetFopts opts, JanetSlot *args) {
    return opreduce(opts, args, JOP_SUBTRACT, janet_wrap_integer(0));
}
static JanetSlot do_mul(JanetFopts opts, JanetSlot *args) {
    return opreduce(opts, args, JOP_MULTIPLY, janet_wrap_integer(1));
}
static JanetSlot do_div(JanetFopts opts, JanetSlot *args) {
    return opreduce(opts, args, JOP_DIVIDE, janet_wrap_integer(1));
}
static JanetSlot do_band(JanetFopts opts, JanetSlot *args) {
    return opreduce(opts, args, JOP_BAND, janet_wrap_integer(-1));
}
static JanetSlot do_bor(JanetFopts opts, JanetSlot *args) {
    return opreduce(opts, args, JOP_BOR, janet_wrap_integer(0));
}
static JanetSlot do_bxor(JanetFopts opts, JanetSlot *args) {
    return opreduce(opts, args, JOP_BXOR, janet_wrap_integer(0));
}
static JanetSlot do_lshift(JanetFopts opts, JanetSlot *args) {
    return opreduce(opts, args, JOP_SHIFT_LEFT, janet_wrap_integer(1));
}
static JanetSlot do_rshift(JanetFopts opts, JanetSlot *args) {
    return opreduce(opts, args, JOP_SHIFT_RIGHT, janet_wrap_integer(1));
}
static JanetSlot do_rshiftu(JanetFopts opts, JanetSlot *args) {
    return opreduce(opts, args, JOP_SHIFT_RIGHT, janet_wrap_integer(1));
}
static JanetSlot do_bnot(JanetFopts opts, JanetSlot *args) {
    return genericSS(opts, JOP_BNOT, args[0]);
}

/* Specialization for comparators */
static JanetSlot compreduce(
    JanetFopts opts,
    JanetSlot *args,
    int op,
    int invert) {
    JanetCompiler *c = opts.compiler;
    int32_t i, len;
    len = janet_v_count(args);
    int32_t *labels = NULL;
    JanetSlot t;
    if (len < 2) {
        return invert
               ? janetc_cslot(janet_wrap_false())
               : janetc_cslot(janet_wrap_true());
    }
    t = janetc_gettarget(opts);
    for (i = 1; i < len; i++) {
        janetc_emit_sss(c, op, t, args[i - 1], args[i], 1);
        if (i != (len - 1)) {
            int32_t label = janetc_emit_si(c, JOP_JUMP_IF_NOT, t, 0, 1);
            janet_v_push(labels, label);
        }
    }
    int32_t end = janet_v_count(c->buffer);
    if (invert) {
        janetc_emit_si(c, JOP_JUMP_IF, t, 3, 0);
        janetc_emit_s(c, JOP_LOAD_TRUE, t, 1);
        janetc_emit(c, JOP_JUMP | (2 << 8));
        janetc_emit_s(c, JOP_LOAD_FALSE, t, 1);
    }
    for (i = 0; i < janet_v_count(labels); i++) {
        int32_t label = labels[i];
        c->buffer[label] |= ((end - label) << 16);
    }
    janet_v_free(labels);
    return t;
}

static JanetSlot do_gt(JanetFopts opts, JanetSlot *args) {
    return compreduce(opts, args, JOP_GREATER_THAN, 0);
}
static JanetSlot do_lt(JanetFopts opts, JanetSlot *args) {
    return compreduce(opts, args, JOP_LESS_THAN, 0);
}
static JanetSlot do_gte(JanetFopts opts, JanetSlot *args) {
    return compreduce(opts, args, JOP_GREATER_THAN_EQUAL, 0);
}
static JanetSlot do_lte(JanetFopts opts, JanetSlot *args) {
    return compreduce(opts, args, JOP_LESS_THAN_EQUAL, 0);
}
static JanetSlot do_eq(JanetFopts opts, JanetSlot *args) {
    return compreduce(opts, args, JOP_EQUALS, 0);
}
static JanetSlot do_neq(JanetFopts opts, JanetSlot *args) {
    return compreduce(opts, args, JOP_EQUALS, 1);
}

/* Arranged by tag */
static const JanetFunOptimizer optimizers[] = {
    {maxarity1, do_debug},
    {fixarity1, do_error},
    {minarity2, do_apply},
    {maxarity1, do_yield},
    {arity1or2, do_resume},
    {fixarity2, do_in},
    {fixarity3, do_put},
    {fixarity1, do_length},
    {NULL, do_add},
    {NULL, do_sub},
    {NULL, do_mul},
    {NULL, do_div},
    {NULL, do_band},
    {NULL, do_bor},
    {NULL, do_bxor},
    {NULL, do_lshift},
    {NULL, do_rshift},
    {NULL, do_rshiftu},
    {fixarity1, do_bnot},
    {NULL, do_gt},
    {NULL, do_lt},
    {NULL, do_gte},
    {NULL, do_lte},
    {NULL, do_eq},
    {NULL, do_neq},
    {fixarity2, do_propagate},
    {fixarity2, do_get},
    {arity1or2, do_next},
    {fixarity2, do_modulo},
    {fixarity2, do_remainder},
};

const JanetFunOptimizer *janetc_funopt(uint32_t flags) {
    uint32_t tag = flags & JANET_FUNCDEF_FLAG_TAG;
    if (tag == 0)
        return NULL;
    uint32_t index = tag - 1;
    if (index >= (sizeof(optimizers) / sizeof(optimizers[0])))
        return NULL;
    return optimizers + index;
}



/* src/core/compile.c */
#line 0 "src/core/compile.c"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "compile.h"
#include "emit.h"
#include "vector.h"
#include "util.h"
#include "state.h"
#endif

JanetFopts janetc_fopts_default(JanetCompiler *c) {
    JanetFopts ret;
    ret.compiler = c;
    ret.flags = 0;
    ret.hint = janetc_cslot(janet_wrap_nil());
    return ret;
}

/* Throw an error with a janet string. */
void janetc_error(JanetCompiler *c, const uint8_t *m) {
    /* Don't override first error */
    if (c->result.status == JANET_COMPILE_ERROR) {
        return;
    }
    c->result.status = JANET_COMPILE_ERROR;
    c->result.error = m;
}

/* Throw an error with a message in a cstring */
void janetc_cerror(JanetCompiler *c, const char *m) {
    janetc_error(c, janet_cstring(m));
}

/* Free a slot */
void janetc_freeslot(JanetCompiler *c, JanetSlot s) {
    if (s.flags & (JANET_SLOT_CONSTANT | JANET_SLOT_REF | JANET_SLOT_NAMED)) return;
    if (s.envindex >= 0) return;
    janetc_regalloc_free(&c->scope->ra, s.index);
}

/* Add a slot to a scope with a symbol associated with it (def or var). */
void janetc_nameslot(JanetCompiler *c, const uint8_t *sym, JanetSlot s) {
    SymPair sp;
    sp.sym = sym;
    sp.slot = s;
    sp.keep = 0;
    sp.slot.flags |= JANET_SLOT_NAMED;
    janet_v_push(c->scope->syms, sp);
}

/* Create a slot with a constant */
JanetSlot janetc_cslot(Janet x) {
    JanetSlot ret;
    ret.flags = (1 << janet_type(x)) | JANET_SLOT_CONSTANT;
    ret.index = -1;
    ret.constant = x;
    ret.envindex = -1;
    return ret;
}

/* Get a local slot */
JanetSlot janetc_farslot(JanetCompiler *c) {
    JanetSlot ret;
    ret.flags = JANET_SLOTTYPE_ANY;
    ret.index = janetc_allocfar(c);
    ret.constant = janet_wrap_nil();
    ret.envindex = -1;
    return ret;
}

/* Enter a new scope */
void janetc_scope(JanetScope *s, JanetCompiler *c, int flags, const char *name) {
    JanetScope scope;
    scope.name = name;
    scope.child = NULL;
    scope.consts = NULL;
    scope.syms = NULL;
    scope.envs = NULL;
    scope.defs = NULL;
    scope.bytecode_start = janet_v_count(c->buffer);
    scope.flags = flags;
    scope.parent = c->scope;
    janetc_regalloc_init(&scope.ua);
    /* Inherit slots */
    if ((!(flags & JANET_SCOPE_FUNCTION)) && c->scope) {
        janetc_regalloc_clone(&scope.ra, &(c->scope->ra));
    } else {
        janetc_regalloc_init(&scope.ra);
    }
    /* Link parent and child and update pointer */
    if (c->scope)
        c->scope->child = s;
    c->scope = s;
    *s = scope;
}

/* Leave a scope. */
void janetc_popscope(JanetCompiler *c) {
    JanetScope *oldscope = c->scope;
    JanetScope *newscope = oldscope->parent;
    /* Move free slots to parent scope if not a new function.
     * We need to know the total number of slots used when compiling the function. */
    if (!(oldscope->flags & (JANET_SCOPE_FUNCTION | JANET_SCOPE_UNUSED)) && newscope) {
        /* Parent scopes inherit child's closure flag. Needed
         * for while loops. (if a while loop creates a closure, it
         * is compiled to a tail recursive iife) */
        if (oldscope->flags & JANET_SCOPE_CLOSURE) {
            newscope->flags |= JANET_SCOPE_CLOSURE;
        }
        if (newscope->ra.max < oldscope->ra.max)
            newscope->ra.max = oldscope->ra.max;

        /* Keep upvalue slots */
        for (int32_t i = 0; i < janet_v_count(oldscope->syms); i++) {
            SymPair pair = oldscope->syms[i];
            if (pair.keep) {
                /* The variable should not be lexically accessible */
                pair.sym = NULL;
                janet_v_push(newscope->syms, pair);
                janetc_regalloc_touch(&newscope->ra, pair.slot.index);
            }
        }

    }
    /* Free the old scope */
    janet_v_free(oldscope->consts);
    janet_v_free(oldscope->syms);
    janet_v_free(oldscope->envs);
    janet_v_free(oldscope->defs);
    janetc_regalloc_deinit(&oldscope->ra);
    janetc_regalloc_deinit(&oldscope->ua);
    /* Update pointer */
    if (newscope)
        newscope->child = NULL;
    c->scope = newscope;
}

/* Leave a scope but keep a slot allocated. */
void janetc_popscope_keepslot(JanetCompiler *c, JanetSlot retslot) {
    JanetScope *scope;
    janetc_popscope(c);
    scope = c->scope;
    if (scope && retslot.envindex < 0 && retslot.index >= 0) {
        janetc_regalloc_touch(&scope->ra, retslot.index);
    }
}

/* Allow searching for symbols. Return information about the symbol */
JanetSlot janetc_resolve(
    JanetCompiler *c,
    const uint8_t *sym) {

    JanetSlot ret = janetc_cslot(janet_wrap_nil());
    JanetScope *scope = c->scope;
    SymPair *pair;
    int foundlocal = 1;
    int unused = 0;

    /* Search scopes for symbol, starting from top */
    while (scope) {
        int32_t i, len;
        if (scope->flags & JANET_SCOPE_UNUSED)
            unused = 1;
        len = janet_v_count(scope->syms);
        /* Search in reverse order */
        for (i = len - 1; i >= 0; i--) {
            pair = scope->syms + i;
            if (pair->sym == sym) {
                ret = pair->slot;
                goto found;
            }
        }
        if (scope->flags & JANET_SCOPE_FUNCTION)
            foundlocal = 0;
        scope = scope->parent;
    }

    /* Symbol not found - check for global */
    {
        Janet check;
        JanetBindingType btype = janet_resolve(c->env, sym, &check);
        switch (btype) {
            default:
            case JANET_BINDING_NONE:
                janetc_error(c, janet_formatc("unknown symbol %q", janet_wrap_symbol(sym)));
                return janetc_cslot(janet_wrap_nil());
            case JANET_BINDING_DEF:
            case JANET_BINDING_MACRO: /* Macro should function like defs when not in calling pos */
                return janetc_cslot(check);
            case JANET_BINDING_VAR: {
                JanetSlot ret = janetc_cslot(check);
                /* TODO save type info */
                ret.flags |= JANET_SLOT_REF | JANET_SLOT_NAMED | JANET_SLOT_MUTABLE | JANET_SLOTTYPE_ANY;
                ret.flags &= ~JANET_SLOT_CONSTANT;
                return ret;
            }
        }
    }

    /* Symbol was found */
found:

    /* Constants can be returned immediately (they are stateless) */
    if (ret.flags & (JANET_SLOT_CONSTANT | JANET_SLOT_REF))
        return ret;

    /* Unused references and locals shouldn't add captured envs. */
    if (unused || foundlocal) {
        ret.envindex = -1;
        return ret;
    }

    /* non-local scope needs to expose its environment */
    pair->keep = 1;
    while (scope && !(scope->flags & JANET_SCOPE_FUNCTION))
        scope = scope->parent;
    janet_assert(scope, "invalid scopes");
    scope->flags |= JANET_SCOPE_ENV;

    /* In the function scope, allocate the slot as an upvalue */
    janetc_regalloc_touch(&scope->ua, ret.index);

    /* Iterate through child scopes and make sure environment is propagated */
    scope = scope->child;

    /* Propagate env up to current scope */
    int32_t envindex = -1;
    while (scope) {
        if (scope->flags & JANET_SCOPE_FUNCTION) {
            int32_t j, len;
            int scopefound = 0;
            /* Check if scope already has env. If so, break */
            len = janet_v_count(scope->envs);
            for (j = 0; j < len; j++) {
                if (scope->envs[j] == envindex) {
                    scopefound = 1;
                    envindex = j;
                    break;
                }
            }
            /* Add the environment if it is not already referenced */
            if (!scopefound) {
                len = janet_v_count(scope->envs);
                janet_v_push(scope->envs, envindex);
                envindex = len;
            }
        }
        scope = scope->child;
    }

    ret.envindex = envindex;
    return ret;
}

/* Generate the return instruction for a slot. */
JanetSlot janetc_return(JanetCompiler *c, JanetSlot s) {
    if (!(s.flags & JANET_SLOT_RETURNED)) {
        if (s.flags & JANET_SLOT_CONSTANT && janet_checktype(s.constant, JANET_NIL))
            janetc_emit(c, JOP_RETURN_NIL);
        else
            janetc_emit_s(c, JOP_RETURN, s, 0);
        s.flags |= JANET_SLOT_RETURNED;
    }
    return s;
}

/* Get a target slot for emitting an instruction. */
JanetSlot janetc_gettarget(JanetFopts opts) {
    JanetSlot slot;
    if ((opts.flags & JANET_FOPTS_HINT) &&
            (opts.hint.envindex < 0) &&
            (opts.hint.index >= 0 && opts.hint.index <= 0xFF)) {
        slot = opts.hint;
    } else {
        slot.envindex = -1;
        slot.constant = janet_wrap_nil();
        slot.flags = 0;
        slot.index = janetc_allocfar(opts.compiler);
    }
    return slot;
}

/* Get a bunch of slots for function arguments */
JanetSlot *janetc_toslots(JanetCompiler *c, const Janet *vals, int32_t len) {
    int32_t i;
    JanetSlot *ret = NULL;
    JanetFopts subopts = janetc_fopts_default(c);
    for (i = 0; i < len; i++) {
        janet_v_push(ret, janetc_value(subopts, vals[i]));
    }
    return ret;
}

/* Get a bunch of slots for function arguments */
JanetSlot *janetc_toslotskv(JanetCompiler *c, Janet ds) {
    JanetSlot *ret = NULL;
    JanetFopts subopts = janetc_fopts_default(c);
    const JanetKV *kvs = NULL;
    int32_t cap = 0, len = 0;
    janet_dictionary_view(ds, &kvs, &len, &cap);
    for (int32_t i = 0; i < cap; i++) {
        if (janet_checktype(kvs[i].key, JANET_NIL)) continue;
        janet_v_push(ret, janetc_value(subopts, kvs[i].key));
        janet_v_push(ret, janetc_value(subopts, kvs[i].value));
    }
    return ret;
}

/* Push slots loaded via janetc_toslots. Return the minimum number of slots pushed,
 * or -1 - min_arity if there is a splice. (if there is no splice, min_arity is also
 * the maximum possible arity). */
int32_t janetc_pushslots(JanetCompiler *c, JanetSlot *slots) {
    int32_t i;
    int32_t count = janet_v_count(slots);
    int32_t min_arity = 0;
    int has_splice = 0;
    for (i = 0; i < count;) {
        if (slots[i].flags & JANET_SLOT_SPLICED) {
            janetc_emit_s(c, JOP_PUSH_ARRAY, slots[i], 0);
            i++;
            has_splice = 1;
        } else if (i + 1 == count) {
            janetc_emit_s(c, JOP_PUSH, slots[i], 0);
            i++;
            min_arity++;
        } else if (slots[i + 1].flags & JANET_SLOT_SPLICED) {
            janetc_emit_s(c, JOP_PUSH, slots[i], 0);
            janetc_emit_s(c, JOP_PUSH_ARRAY, slots[i + 1], 0);
            i += 2;
            min_arity++;
            has_splice = 1;
        } else if (i + 2 == count) {
            janetc_emit_ss(c, JOP_PUSH_2, slots[i], slots[i + 1], 0);
            i += 2;
            min_arity += 2;
        } else if (slots[i + 2].flags & JANET_SLOT_SPLICED) {
            janetc_emit_ss(c, JOP_PUSH_2, slots[i], slots[i + 1], 0);
            janetc_emit_s(c, JOP_PUSH_ARRAY, slots[i + 2], 0);
            i += 3;
            min_arity += 2;
            has_splice = 1;
        } else {
            janetc_emit_sss(c, JOP_PUSH_3, slots[i], slots[i + 1], slots[i + 2], 0);
            i += 3;
            min_arity += 3;
        }
    }
    return has_splice ? (-1 - min_arity) : min_arity;
}

/* Check if a list of slots has any spliced slots */
static int has_spliced(JanetSlot *slots) {
    int32_t i;
    for (i = 0; i < janet_v_count(slots); i++) {
        if (slots[i].flags & JANET_SLOT_SPLICED)
            return 1;
    }
    return 0;
}

/* Free slots loaded via janetc_toslots */
void janetc_freeslots(JanetCompiler *c, JanetSlot *slots) {
    int32_t i;
    for (i = 0; i < janet_v_count(slots); i++) {
        janetc_freeslot(c, slots[i]);
    }
    janet_v_free(slots);
}

/* Compile some code that will be thrown away. Used to ensure
 * that dead code is well formed without including it in the final
 * bytecode. */
void janetc_throwaway(JanetFopts opts, Janet x) {
    JanetCompiler *c = opts.compiler;
    JanetScope unusedScope;
    int32_t bufstart = janet_v_count(c->buffer);
    int32_t mapbufstart = janet_v_count(c->mapbuffer);
    janetc_scope(&unusedScope, c, JANET_SCOPE_UNUSED, "unusued");
    janetc_value(opts, x);
    janetc_popscope(c);
    if (c->buffer) {
        janet_v__cnt(c->buffer) = bufstart;
        if (c->mapbuffer)
            janet_v__cnt(c->mapbuffer) = mapbufstart;
    }
}

/* Compile a call or tailcall instruction */
static JanetSlot janetc_call(JanetFopts opts, JanetSlot *slots, JanetSlot fun) {
    JanetSlot retslot;
    JanetCompiler *c = opts.compiler;
    int specialized = 0;
    if (fun.flags & JANET_SLOT_CONSTANT && !has_spliced(slots)) {
        if (janet_checktype(fun.constant, JANET_FUNCTION)) {
            JanetFunction *f = janet_unwrap_function(fun.constant);
            const JanetFunOptimizer *o = janetc_funopt(f->def->flags);
            if (o && (!o->can_optimize || o->can_optimize(opts, slots))) {
                specialized = 1;
                retslot = o->optimize(opts, slots);
            }
        }
        /* TODO janet function inlining (no c functions)*/
    }
    if (!specialized) {
        int32_t min_arity = janetc_pushslots(c, slots);
        /* Check for provably incorrect function calls */
        if (fun.flags & JANET_SLOT_CONSTANT) {

            /* Check for bad arity type if fun is a constant */
            switch (janet_type(fun.constant)) {
                case JANET_FUNCTION: {
                    JanetFunction *f = janet_unwrap_function(fun.constant);
                    int32_t min = f->def->min_arity;
                    int32_t max = f->def->max_arity;
                    if (min_arity < 0) {
                        /* Call has splices */
                        min_arity = -1 - min_arity;
                        if (min_arity > max && max >= 0) {
                            const uint8_t *es = janet_formatc(
                                                    "%v expects at most %d argument, got at least %d",
                                                    fun.constant, max, min_arity);
                            janetc_error(c, es);
                        }
                    } else {
                        /* Call has no splices */
                        if (min_arity > max && max >= 0) {
                            const uint8_t *es = janet_formatc(
                                                    "%v expects at most %d argument, got %d",
                                                    fun.constant, max, min_arity);
                            janetc_error(c, es);
                        }
                        if (min_arity < min) {
                            const uint8_t *es = janet_formatc(
                                                    "%v expects at least %d argument, got %d",
                                                    fun.constant, min, min_arity);
                            janetc_error(c, es);
                        }
                    }
                }
                break;
                case JANET_CFUNCTION:
                case JANET_ABSTRACT:
                case JANET_NIL:
                    break;
                case JANET_KEYWORD:
                    if (min_arity == 0) {
                        const uint8_t *es = janet_formatc("%v expects at least 1 argument, got 0",
                                                          fun.constant);
                        janetc_error(c, es);
                    }
                    break;
                default:
                    if (min_arity > 1 || min_arity == 0) {
                        const uint8_t *es = janet_formatc("%v expects 1 argument, got %d",
                                                          fun.constant, min_arity);
                        janetc_error(c, es);
                    }
                    if (min_arity < -2) {
                        const uint8_t *es = janet_formatc("%v expects 1 argument, got at least %d",
                                                          fun.constant, -1 - min_arity);
                        janetc_error(c, es);
                    }
                    break;
            }
        }

        if ((opts.flags & JANET_FOPTS_TAIL) &&
                /* Prevent top level tail calls for better errors */
                !(c->scope->flags & JANET_SCOPE_TOP)) {
            janetc_emit_s(c, JOP_TAILCALL, fun, 0);
            retslot = janetc_cslot(janet_wrap_nil());
            retslot.flags = JANET_SLOT_RETURNED;
        } else {
            retslot = janetc_gettarget(opts);
            janetc_emit_ss(c, JOP_CALL, retslot, fun, 1);
        }
    }
    janetc_freeslots(c, slots);
    return retslot;
}

static JanetSlot janetc_maker(JanetFopts opts, JanetSlot *slots, int op) {
    JanetCompiler *c = opts.compiler;
    JanetSlot retslot;
    janetc_pushslots(c, slots);
    janetc_freeslots(c, slots);
    retslot = janetc_gettarget(opts);
    janetc_emit_s(c, op, retslot, 1);
    return retslot;
}

static JanetSlot janetc_array(JanetFopts opts, Janet x) {
    JanetCompiler *c = opts.compiler;
    JanetArray *a = janet_unwrap_array(x);
    return janetc_maker(opts,
                        janetc_toslots(c, a->data, a->count),
                        JOP_MAKE_ARRAY);
}

static JanetSlot janetc_tuple(JanetFopts opts, Janet x) {
    JanetCompiler *c = opts.compiler;
    const Janet *t = janet_unwrap_tuple(x);
    return janetc_maker(opts,
                        janetc_toslots(c, t, janet_tuple_length(t)),
                        JOP_MAKE_TUPLE);
}

static JanetSlot janetc_tablector(JanetFopts opts, Janet x, int op) {
    JanetCompiler *c = opts.compiler;
    return janetc_maker(opts,
                        janetc_toslotskv(c, x),
                        op);
}

static JanetSlot janetc_bufferctor(JanetFopts opts, Janet x) {
    JanetCompiler *c = opts.compiler;
    JanetBuffer *b = janet_unwrap_buffer(x);
    Janet onearg = janet_stringv(b->data, b->count);
    return janetc_maker(opts,
                        janetc_toslots(c, &onearg, 1),
                        JOP_MAKE_BUFFER);
}

/* Expand a macro one time. Also get the special form compiler if we
 * find that instead. */
static int macroexpand1(
    JanetCompiler *c,
    Janet x,
    Janet *out,
    const JanetSpecial **spec) {
    if (!janet_checktype(x, JANET_TUPLE))
        return 0;
    const Janet *form = janet_unwrap_tuple(x);
    if (janet_tuple_length(form) == 0)
        return 0;
    /* Source map - only set when we get a tuple */
    if (janet_tuple_sm_line(form) >= 0) {
        c->current_mapping.line = janet_tuple_sm_line(form);
        c->current_mapping.column = janet_tuple_sm_column(form);
    }
    /* Bracketed tuples are not specials or macros! */
    if (janet_tuple_flag(form) & JANET_TUPLE_FLAG_BRACKETCTOR)
        return 0;
    if (!janet_checktype(form[0], JANET_SYMBOL))
        return 0;
    const uint8_t *name = janet_unwrap_symbol(form[0]);
    const JanetSpecial *s = janetc_special(name);
    if (s) {
        *spec = s;
        return 0;
    }
    Janet macroval;
    JanetBindingType btype = janet_resolve(c->env, name, &macroval);
    if (btype != JANET_BINDING_MACRO ||
            !janet_checktype(macroval, JANET_FUNCTION))
        return 0;

    /* Evaluate macro */
    JanetFunction *macro = janet_unwrap_function(macroval);
    int32_t arity = janet_tuple_length(form) - 1;
    JanetFiber *fiberp = janet_fiber(macro, 64, arity, form + 1);
    if (NULL == fiberp) {
        int32_t minar = macro->def->min_arity;
        int32_t maxar = macro->def->max_arity;
        const uint8_t *es = NULL;
        if (minar >= 0 && arity < minar)
            es = janet_formatc("macro arity mismatch, expected at least %d, got %d", minar, arity);
        if (maxar >= 0 && arity > maxar)
            es = janet_formatc("macro arity mismatch, expected at most %d, got %d", maxar, arity);
        c->result.macrofiber = NULL;
        janetc_error(c, es);
        return 0;
    }
    /* Set env */
    fiberp->env = c->env;
    int lock = janet_gclock();
    Janet mf_kw = janet_ckeywordv("macro-form");
    janet_table_put(c->env, mf_kw, x);
    Janet tempOut;
    JanetSignal status = janet_continue(fiberp, janet_wrap_nil(), &tempOut);
    janet_table_put(c->env, mf_kw, janet_wrap_nil());
    janet_gcunlock(lock);
    if (status != JANET_SIGNAL_OK) {
        const uint8_t *es = janet_formatc("(macro) %V", tempOut);
        c->result.macrofiber = fiberp;
        janetc_error(c, es);
        return 0;
    } else {
        *out = tempOut;
    }

    return 1;
}

/* Compile a single value */
JanetSlot janetc_value(JanetFopts opts, Janet x) {
    JanetSlot ret;
    JanetCompiler *c = opts.compiler;
    JanetSourceMapping last_mapping = c->current_mapping;
    c->recursion_guard--;

    /* Guard against previous errors and unbounded recursion */
    if (c->result.status == JANET_COMPILE_ERROR) return janetc_cslot(janet_wrap_nil());
    if (c->recursion_guard <= 0) {
        janetc_cerror(c, "recursed too deeply");
        return janetc_cslot(janet_wrap_nil());
    }

    /* Macro expand. Also gets possible special form and
     * refines source mapping cursor if possible. */
    const JanetSpecial *spec = NULL;
    int macroi = JANET_MAX_MACRO_EXPAND;
    while (macroi &&
            c->result.status != JANET_COMPILE_ERROR &&
            macroexpand1(c, x, &x, &spec))
        macroi--;
    if (macroi == 0) {
        janetc_cerror(c, "recursed too deeply in macro expansion");
        return janetc_cslot(janet_wrap_nil());
    }

    /* Special forms */
    if (spec) {
        const Janet *tup = janet_unwrap_tuple(x);
        ret = spec->compile(opts, janet_tuple_length(tup) - 1, tup + 1);
    } else {
        switch (janet_type(x)) {
            case JANET_TUPLE: {
                JanetFopts subopts = janetc_fopts_default(c);
                const Janet *tup = janet_unwrap_tuple(x);
                /* Empty tuple is tuple literal */
                if (janet_tuple_length(tup) == 0) {
                    ret = janetc_cslot(janet_wrap_tuple(janet_tuple_n(NULL, 0)));
                } else if (janet_tuple_flag(tup) & JANET_TUPLE_FLAG_BRACKETCTOR) { /* [] tuples are not function call */
                    ret = janetc_tuple(opts, x);
                } else {
                    JanetSlot head = janetc_value(subopts, tup[0]);
                    subopts.flags = JANET_FUNCTION | JANET_CFUNCTION;
                    ret = janetc_call(opts, janetc_toslots(c, tup + 1, janet_tuple_length(tup) - 1), head);
                    janetc_freeslot(c, head);
                }
                ret.flags &= ~JANET_SLOT_SPLICED;
            }
            break;
            case JANET_SYMBOL:
                ret = janetc_resolve(c, janet_unwrap_symbol(x));
                break;
            case JANET_ARRAY:
                ret = janetc_array(opts, x);
                break;
            case JANET_STRUCT:
                ret = janetc_tablector(opts, x, JOP_MAKE_STRUCT);
                break;
            case JANET_TABLE:
                ret = janetc_tablector(opts, x, JOP_MAKE_TABLE);
                break;
            case JANET_BUFFER:
                ret = janetc_bufferctor(opts, x);
                break;
            default:
                ret = janetc_cslot(x);
                break;
        }
    }

    if (c->result.status == JANET_COMPILE_ERROR)
        return janetc_cslot(janet_wrap_nil());
    if (opts.flags & JANET_FOPTS_TAIL)
        ret = janetc_return(c, ret);
    if (opts.flags & JANET_FOPTS_HINT) {
        janetc_copy(c, opts.hint, ret);
        ret = opts.hint;
    }
    c->current_mapping = last_mapping;
    c->recursion_guard++;
    return ret;
}

/* Compile a funcdef */
JanetFuncDef *janetc_pop_funcdef(JanetCompiler *c) {
    JanetScope *scope = c->scope;
    JanetFuncDef *def = janet_funcdef_alloc();
    def->slotcount = scope->ra.max + 1;

    janet_assert(scope->flags & JANET_SCOPE_FUNCTION, "expected function scope");

    /* Copy envs */
    def->environments_length = janet_v_count(scope->envs);
    def->environments = janet_v_flatten(scope->envs);

    def->constants_length = janet_v_count(scope->consts);
    def->constants = janet_v_flatten(scope->consts);

    def->defs_length = janet_v_count(scope->defs);
    def->defs = janet_v_flatten(scope->defs);

    /* Copy bytecode (only last chunk) */
    def->bytecode_length = janet_v_count(c->buffer) - scope->bytecode_start;
    if (def->bytecode_length) {
        size_t s = sizeof(int32_t) * (size_t) def->bytecode_length;
        def->bytecode = malloc(s);
        if (NULL == def->bytecode) {
            JANET_OUT_OF_MEMORY;
        }
        safe_memcpy(def->bytecode, c->buffer + scope->bytecode_start, s);
        janet_v__cnt(c->buffer) = scope->bytecode_start;
        if (NULL != c->mapbuffer && c->source) {
            size_t s = sizeof(JanetSourceMapping) * (size_t) def->bytecode_length;
            def->sourcemap = malloc(s);
            if (NULL == def->sourcemap) {
                JANET_OUT_OF_MEMORY;
            }
            safe_memcpy(def->sourcemap, c->mapbuffer + scope->bytecode_start, s);
            janet_v__cnt(c->mapbuffer) = scope->bytecode_start;
        }
    }

    /* Get source from parser */
    def->source = c->source;

    def->arity = 0;
    def->min_arity = 0;
    def->flags = 0;
    if (scope->flags & JANET_SCOPE_ENV) {
        def->flags |= JANET_FUNCDEF_FLAG_NEEDSENV;
    }

    /* Copy upvalue bitset */
    if (scope->ua.count) {
        /* Number of u32s we need to create a bitmask for all slots */
        int32_t slotchunks = (def->slotcount + 31) >> 5;
        /* numchunks is min of slotchunks and scope->ua.count */
        int32_t numchunks = slotchunks > scope->ua.count ? scope->ua.count : slotchunks;
        uint32_t *chunks = calloc(sizeof(uint32_t), slotchunks);
        if (NULL == chunks) {
            JANET_OUT_OF_MEMORY;
        }
        memcpy(chunks, scope->ua.chunks, sizeof(uint32_t) * numchunks);
        /* Register allocator preallocates some registers [240-255, high 16 bits of chunk index 7], we can ignore those. */
        if (scope->ua.count > 7) chunks[7] &= 0xFFFFU;
        def->closure_bitset = chunks;
        def->flags |= JANET_FUNCDEF_FLAG_HASCLOBITSET;
    }

    /* Pop the scope */
    janetc_popscope(c);

    return def;
}

/* Initialize a compiler */
static void janetc_init(JanetCompiler *c, JanetTable *env, const uint8_t *where) {
    c->scope = NULL;
    c->buffer = NULL;
    c->mapbuffer = NULL;
    c->recursion_guard = JANET_RECURSION_GUARD;
    c->env = env;
    c->source = where;
    c->current_mapping.line = -1;
    c->current_mapping.column = -1;
    /* Init result */
    c->result.error = NULL;
    c->result.status = JANET_COMPILE_OK;
    c->result.funcdef = NULL;
    c->result.macrofiber = NULL;
    c->result.error_mapping.line = -1;
    c->result.error_mapping.column = -1;
}

/* Deinitialize a compiler struct */
static void janetc_deinit(JanetCompiler *c) {
    janet_v_free(c->buffer);
    janet_v_free(c->mapbuffer);
    c->env = NULL;
}

/* Compile a form. */
JanetCompileResult janet_compile(Janet source, JanetTable *env, const uint8_t *where) {
    JanetCompiler c;
    JanetScope rootscope;
    JanetFopts fopts;

    janetc_init(&c, env, where);

    /* Push a function scope */
    janetc_scope(&rootscope, &c, JANET_SCOPE_FUNCTION | JANET_SCOPE_TOP, "root");

    /* Set initial form options */
    fopts.compiler = &c;
    fopts.flags = JANET_FOPTS_TAIL | JANET_SLOTTYPE_ANY;
    fopts.hint = janetc_cslot(janet_wrap_nil());

    /* Compile the value */
    janetc_value(fopts, source);

    if (c.result.status == JANET_COMPILE_OK) {
        JanetFuncDef *def = janetc_pop_funcdef(&c);
        def->name = janet_cstring("_thunk");
        c.result.funcdef = def;
    } else {
        c.result.error_mapping = c.current_mapping;
        janetc_popscope(&c);
    }

    janetc_deinit(&c);

    return c.result;
}

/* C Function for compiling */
static Janet cfun(int32_t argc, Janet *argv) {
    janet_arity(argc, 1, 3);
    JanetTable *env = argc > 1 ? janet_gettable(argv, 1) : janet_vm_fiber->env;
    if (NULL == env) {
        env = janet_table(0);
        janet_vm_fiber->env = env;
    }
    const uint8_t *source = NULL;
    if (argc == 3) {
        source = janet_getstring(argv, 2);
    }
    JanetCompileResult res = janet_compile(argv[0], env, source);
    if (res.status == JANET_COMPILE_OK) {
        return janet_wrap_function(janet_thunk(res.funcdef));
    } else {
        JanetTable *t = janet_table(4);
        janet_table_put(t, janet_ckeywordv("error"), janet_wrap_string(res.error));
        janet_table_put(t, janet_ckeywordv("line"), janet_wrap_integer(res.error_mapping.line));
        janet_table_put(t, janet_ckeywordv("column"), janet_wrap_integer(res.error_mapping.column));
        if (res.macrofiber) {
            janet_table_put(t, janet_ckeywordv("fiber"), janet_wrap_fiber(res.macrofiber));
        }
        return janet_wrap_table(t);
    }
}

static const JanetReg compile_cfuns[] = {
    {
        "compile", cfun,
        JDOC("(compile ast &opt env source)\n\n"
             "Compiles an Abstract Syntax Tree (ast) into a function. "
             "Pair the compile function with parsing functionality to implement "
             "eval. Returns a new function and does not modify ast. Returns an error "
             "struct with keys :line, :column, and :error if compilation fails.")
    },
    {NULL, NULL, NULL}
};

void janet_lib_compile(JanetTable *env) {
    janet_core_cfuns(env, NULL, compile_cfuns);
}


/* src/core/corelib.c */
#line 0 "src/core/corelib.c"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include <math.h>
#include "compile.h"
#include "state.h"
#include "util.h"
#endif

/* Generated bytes */
#ifndef JANET_BOOTSTRAP
extern const unsigned char *janet_core_image;
extern size_t janet_core_image_size;
#endif

/* Use LoadLibrary on windows or dlopen on posix to load dynamic libaries
 * with native code. */
#if defined(JANET_NO_DYNAMIC_MODULES)
typedef int Clib;
#define load_clib(name) ((void) name, 0)
#define symbol_clib(lib, sym) ((void) lib, (void) sym, NULL)
#define error_clib() "dynamic libraries not supported"
#elif defined(JANET_WINDOWS)
#include <windows.h>
typedef HINSTANCE Clib;
#define load_clib(name) LoadLibrary((name))
#define symbol_clib(lib, sym) GetProcAddress((lib), (sym))
static char error_clib_buf[256];
static char *error_clib(void) {
    FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                   NULL, GetLastError(), MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                   error_clib_buf, sizeof(error_clib_buf), NULL);
    error_clib_buf[strlen(error_clib_buf) - 1] = '\0';
    return error_clib_buf;
}
#else
#include <dlfcn.h>
typedef void *Clib;
#define load_clib(name) dlopen((name), RTLD_NOW)
#define symbol_clib(lib, sym) dlsym((lib), (sym))
#define error_clib() dlerror()
#endif

JanetModule janet_native(const char *name, const uint8_t **error) {
    Clib lib = load_clib(name);
    JanetModule init;
    JanetModconf getter;
    if (!lib) {
        *error = janet_cstring(error_clib());
        return NULL;
    }
    init = (JanetModule) symbol_clib(lib, "_janet_init");
    if (!init) {
        *error = janet_cstring("could not find the _janet_init symbol");
        return NULL;
    }
    getter = (JanetModconf) symbol_clib(lib, "_janet_mod_config");
    if (!getter) {
        *error = janet_cstring("could not find the _janet_mod_config symbol");
        return NULL;
    }
    JanetBuildConfig modconf = getter();
    JanetBuildConfig host = janet_config_current();
    if (host.major != modconf.major ||
            host.minor < modconf.minor ||
            host.bits != modconf.bits) {
        char errbuf[128];
        sprintf(errbuf, "config mismatch - host %d.%.d.%d(%.4x) vs. module %d.%d.%d(%.4x)",
                host.major,
                host.minor,
                host.patch,
                host.bits,
                modconf.major,
                modconf.minor,
                modconf.patch,
                modconf.bits);
        *error = janet_cstring(errbuf);
        return NULL;
    }
    return init;
}

static const char *janet_dyncstring(const char *name, const char *dflt) {
    Janet x = janet_dyn(name);
    if (janet_checktype(x, JANET_NIL)) return dflt;
    if (!janet_checktype(x, JANET_STRING)) {
        janet_panicf("expected string, got %v", x);
    }
    const uint8_t *jstr = janet_unwrap_string(x);
    const char *cstr = (const char *)jstr;
    if (strlen(cstr) != (size_t) janet_string_length(jstr)) {
        janet_panicf("string %v contains embedded 0s");
    }
    return cstr;
}

static int is_path_sep(char c) {
#ifdef JANET_WINDOWS
    if (c == '\\') return 1;
#endif
    return c == '/';
}

/* Used for module system. */
static Janet janet_core_expand_path(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 2);
    const char *input = janet_getcstring(argv, 0);
    const char *template = janet_getcstring(argv, 1);
    const char *curfile = janet_dyncstring("current-file", "");
    const char *syspath = janet_dyncstring("syspath", "");
    JanetBuffer *out = janet_buffer(0);
    size_t tlen = strlen(template);

    /* Calculate name */
    const char *name = input + strlen(input);
    while (name > input) {
        if (is_path_sep(*(name - 1))) break;
        name--;
    }

    /* Calculate dirpath from current file */
    const char *curname = curfile + strlen(curfile);
    while (curname > curfile) {
        if (is_path_sep(*curname)) break;
        curname--;
    }
    const char *curdir;
    int32_t curlen;
    if (curname == curfile) {
        /* Current file has one or zero path segments, so
         * we are in the . directory. */
        curdir = ".";
        curlen = 1;
    } else {
        /* Current file has 2 or more segments, so we
         * can cut off the last segment. */
        curdir = curfile;
        curlen = (int32_t)(curname - curfile);
    }

    for (size_t i = 0; i < tlen; i++) {
        if (template[i] == ':') {
            if (strncmp(template + i, ":all:", 5) == 0) {
                janet_buffer_push_cstring(out, input);
                i += 4;
            } else if (strncmp(template + i, ":cur:", 5) == 0) {
                janet_buffer_push_bytes(out, (const uint8_t *)curdir, curlen);
                i += 4;
            } else if (strncmp(template + i, ":dir:", 5) == 0) {
                janet_buffer_push_bytes(out, (const uint8_t *)input,
                                        (int32_t)(name - input));
                i += 4;
            } else if (strncmp(template + i, ":sys:", 5) == 0) {
                janet_buffer_push_cstring(out, syspath);
                i += 4;
            } else if (strncmp(template + i, ":name:", 6) == 0) {
                janet_buffer_push_cstring(out, name);
                i += 5;
            } else if (strncmp(template + i, ":native:", 8) == 0) {
#ifdef JANET_WINDOWS
                janet_buffer_push_cstring(out, ".dll");
#else
                janet_buffer_push_cstring(out, ".so");
#endif
                i += 7;
            } else {
                janet_buffer_push_u8(out, (uint8_t) template[i]);
            }
        } else {
            janet_buffer_push_u8(out, (uint8_t) template[i]);
        }
    }

    /* Normalize */
    uint8_t *scan = out->data;
    uint8_t *print = scan;
    uint8_t *scanend = scan + out->count;
    int normal_section_count = 0;
    int dot_count = 0;
    while (scan < scanend) {
        if (*scan == '.') {
            if (dot_count >= 0) {
                dot_count++;
            } else {
                *print++ = '.';
            }
        } else if (is_path_sep(*scan)) {
            if (dot_count == 1) {
                ;
            } else if (dot_count == 2) {
                if (normal_section_count > 0) {
                    /* unprint last separator */
                    print--;
                    /* unprint last section */
                    while (print > out->data && !is_path_sep(*(print - 1)))
                        print--;
                    normal_section_count--;
                } else {
                    *print++ = '.';
                    *print++ = '.';
                    *print++ = '/';
                }
            } else if (scan == out->data || dot_count != 0) {
                while (dot_count > 0) {
                    --dot_count;
                    *print++ = '.';
                }
                if (scan > out->data) {
                    normal_section_count++;
                }
                *print++ = '/';
            }
            dot_count = 0;
        } else {
            while (dot_count > 0) {
                --dot_count;
                *print++ = '.';
            }
            dot_count = -1;
            *print++ = *scan;
        }
        scan++;
    }
    out->count = (int32_t)(print - out->data);
    return janet_wrap_buffer(out);
}

static Janet janet_core_dyn(int32_t argc, Janet *argv) {
    janet_arity(argc, 1, 2);
    Janet value;
    if (janet_vm_fiber->env) {
        value = janet_table_get(janet_vm_fiber->env, argv[0]);
    } else {
        value = janet_wrap_nil();
    }
    if (argc == 2 && janet_checktype(value, JANET_NIL)) {
        return argv[1];
    }
    return value;
}

static Janet janet_core_setdyn(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 2);
    if (!janet_vm_fiber->env) {
        janet_vm_fiber->env = janet_table(2);
    }
    janet_table_put(janet_vm_fiber->env, argv[0], argv[1]);
    return argv[1];
}

static Janet janet_core_native(int32_t argc, Janet *argv) {
    JanetModule init;
    janet_arity(argc, 1, 2);
    const uint8_t *path = janet_getstring(argv, 0);
    const uint8_t *error = NULL;
    JanetTable *env;
    if (argc == 2) {
        env = janet_gettable(argv, 1);
    } else {
        env = janet_table(0);
    }
    init = janet_native((const char *)path, &error);
    if (!init) {
        janet_panicf("could not load native %S: %S", path, error);
    }
    init(env);
    janet_table_put(env, janet_ckeywordv("native"), argv[0]);
    return janet_wrap_table(env);
}

static Janet janet_core_describe(int32_t argc, Janet *argv) {
    JanetBuffer *b = janet_buffer(0);
    for (int32_t i = 0; i < argc; ++i)
        janet_description_b(b, argv[i]);
    return janet_stringv(b->data, b->count);
}

static Janet janet_core_string(int32_t argc, Janet *argv) {
    JanetBuffer *b = janet_buffer(0);
    for (int32_t i = 0; i < argc; ++i)
        janet_to_string_b(b, argv[i]);
    return janet_stringv(b->data, b->count);
}

static Janet janet_core_symbol(int32_t argc, Janet *argv) {
    JanetBuffer *b = janet_buffer(0);
    for (int32_t i = 0; i < argc; ++i)
        janet_to_string_b(b, argv[i]);
    return janet_symbolv(b->data, b->count);
}

static Janet janet_core_keyword(int32_t argc, Janet *argv) {
    JanetBuffer *b = janet_buffer(0);
    for (int32_t i = 0; i < argc; ++i)
        janet_to_string_b(b, argv[i]);
    return janet_keywordv(b->data, b->count);
}

static Janet janet_core_buffer(int32_t argc, Janet *argv) {
    JanetBuffer *b = janet_buffer(0);
    for (int32_t i = 0; i < argc; ++i)
        janet_to_string_b(b, argv[i]);
    return janet_wrap_buffer(b);
}

static Janet janet_core_is_abstract(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    return janet_wrap_boolean(janet_checktype(argv[0], JANET_ABSTRACT));
}

static Janet janet_core_scannumber(int32_t argc, Janet *argv) {
    double number;
    janet_fixarity(argc, 1);
    JanetByteView view = janet_getbytes(argv, 0);
    if (janet_scan_number(view.bytes, view.len, &number))
        return janet_wrap_nil();
    return janet_wrap_number(number);
}

static Janet janet_core_tuple(int32_t argc, Janet *argv) {
    return janet_wrap_tuple(janet_tuple_n(argv, argc));
}

static Janet janet_core_array(int32_t argc, Janet *argv) {
    JanetArray *array = janet_array(argc);
    array->count = argc;
    safe_memcpy(array->data, argv, argc * sizeof(Janet));
    return janet_wrap_array(array);
}

static Janet janet_core_slice(int32_t argc, Janet *argv) {
    JanetRange range;
    JanetByteView bview;
    JanetView iview;
    if (janet_bytes_view(argv[0], &bview.bytes, &bview.len)) {
        range = janet_getslice(argc, argv);
        return janet_stringv(bview.bytes + range.start, range.end - range.start);
    } else if (janet_indexed_view(argv[0], &iview.items, &iview.len)) {
        range = janet_getslice(argc, argv);
        return janet_wrap_tuple(janet_tuple_n(iview.items + range.start, range.end - range.start));
    } else {
        janet_panic_type(argv[0], 0, JANET_TFLAG_BYTES | JANET_TFLAG_INDEXED);
    }
}

static Janet janet_core_table(int32_t argc, Janet *argv) {
    int32_t i;
    if (argc & 1)
        janet_panic("expected even number of arguments");
    JanetTable *table = janet_table(argc >> 1);
    for (i = 0; i < argc; i += 2) {
        janet_table_put(table, argv[i], argv[i + 1]);
    }
    return janet_wrap_table(table);
}

static Janet janet_core_struct(int32_t argc, Janet *argv) {
    int32_t i;
    if (argc & 1)
        janet_panic("expected even number of arguments");
    JanetKV *st = janet_struct_begin(argc >> 1);
    for (i = 0; i < argc; i += 2) {
        janet_struct_put(st, argv[i], argv[i + 1]);
    }
    return janet_wrap_struct(janet_struct_end(st));
}

static Janet janet_core_gensym(int32_t argc, Janet *argv) {
    (void) argv;
    janet_fixarity(argc, 0);
    return janet_wrap_symbol(janet_symbol_gen());
}

static Janet janet_core_gccollect(int32_t argc, Janet *argv) {
    (void) argv;
    (void) argc;
    janet_collect();
    return janet_wrap_nil();
}

static Janet janet_core_gcsetinterval(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    size_t s = janet_getsize(argv, 0);
    /* limit interval to 48 bits */
    if (s > 0xFFFFFFFFFFFFUl) {
        janet_panic("interval too large");
    }
    janet_vm_gc_interval = s;
    return janet_wrap_nil();
}

static Janet janet_core_gcinterval(int32_t argc, Janet *argv) {
    (void) argv;
    janet_fixarity(argc, 0);
    return janet_wrap_number((double) janet_vm_gc_interval);
}

static Janet janet_core_type(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    JanetType t = janet_type(argv[0]);
    if (t == JANET_ABSTRACT) {
        return janet_ckeywordv(janet_abstract_type(janet_unwrap_abstract(argv[0]))->name);
    } else {
        return janet_ckeywordv(janet_type_names[t]);
    }
}

static Janet janet_core_hash(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    return janet_wrap_number(janet_hash(argv[0]));
}

static Janet janet_core_getline(int32_t argc, Janet *argv) {
    FILE *in = janet_dynfile("in", stdin);
    FILE *out = janet_dynfile("out", stdout);
    janet_arity(argc, 0, 3);
    JanetBuffer *buf = (argc >= 2) ? janet_getbuffer(argv, 1) : janet_buffer(10);
    if (argc >= 1) {
        const char *prompt = (const char *) janet_getstring(argv, 0);
        fprintf(out, "%s", prompt);
        fflush(out);
    }
    {
        buf->count = 0;
        int c;
        for (;;) {
            c = fgetc(in);
            if (feof(in) || c < 0) {
                break;
            }
            janet_buffer_push_u8(buf, (uint8_t) c);
            if (c == '\n') break;
        }
    }
    return janet_wrap_buffer(buf);
}

static Janet janet_core_trace(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    JanetFunction *func = janet_getfunction(argv, 0);
    func->gc.flags |= JANET_FUNCFLAG_TRACE;
    return argv[0];
}

static Janet janet_core_untrace(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    JanetFunction *func = janet_getfunction(argv, 0);
    func->gc.flags &= ~JANET_FUNCFLAG_TRACE;
    return argv[0];
}

static Janet janet_core_check_int(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    if (!janet_checktype(argv[0], JANET_NUMBER)) goto ret_false;
    double num = janet_unwrap_number(argv[0]);
    return janet_wrap_boolean(num == (double)((int32_t)num));
ret_false:
    return janet_wrap_false();
}

static Janet janet_core_check_nat(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    if (!janet_checktype(argv[0], JANET_NUMBER)) goto ret_false;
    double num = janet_unwrap_number(argv[0]);
    return janet_wrap_boolean(num >= 0 && (num == (double)((int32_t)num)));
ret_false:
    return janet_wrap_false();
}

static Janet janet_core_signal(int32_t argc, Janet *argv) {
    janet_arity(argc, 1, 2);
    int sig;
    if (janet_checkint(argv[0])) {
        int32_t s = janet_unwrap_integer(argv[0]);
        if (s < 0 || s > 9) {
            janet_panicf("expected user signal between 0 and 9, got %d", s);
        }
        sig = JANET_SIGNAL_USER0 + s;
    } else {
        JanetKeyword kw = janet_getkeyword(argv, 0);
        if (!janet_cstrcmp(kw, "yield")) {
            sig = JANET_SIGNAL_YIELD;
        } else if (!janet_cstrcmp(kw, "error")) {
            sig = JANET_SIGNAL_ERROR;
        } else if (!janet_cstrcmp(kw, "debug")) {
            sig = JANET_SIGNAL_DEBUG;
        } else {
            janet_panicf("unknown signal, expected :yield, :error, or :debug, got %v", argv[0]);
        }
    }
    Janet payload = argc == 2 ? argv[1] : janet_wrap_nil();
    janet_signalv(sig, payload);
}

static const JanetReg corelib_cfuns[] = {
    {
        "native", janet_core_native,
        JDOC("(native path &opt env)\n\n"
             "Load a native module from the given path. The path "
             "must be an absolute or relative path on the file system, and is "
             "usually a .so file on Unix systems, and a .dll file on Windows. "
             "Returns an environment table that contains functions and other values "
             "from the native module.")
    },
    {
        "describe", janet_core_describe,
        JDOC("(describe x)\n\n"
             "Returns a string that is a human readable description of a value x.")
    },
    {
        "string", janet_core_string,
        JDOC("(string & parts)\n\n"
             "Creates a string by concatenating values together. Values are "
             "converted to bytes via describe if they are not byte sequences. "
             "Returns the new string.")
    },
    {
        "symbol", janet_core_symbol,
        JDOC("(symbol & xs)\n\n"
             "Creates a symbol by concatenating values together. Values are "
             "converted to bytes via describe if they are not byte sequences. Returns "
             "the new symbol.")
    },
    {
        "keyword", janet_core_keyword,
        JDOC("(keyword & xs)\n\n"
             "Creates a keyword by concatenating values together. Values are "
             "converted to bytes via describe if they are not byte sequences. Returns "
             "the new keyword.")
    },
    {
        "buffer", janet_core_buffer,
        JDOC("(buffer & xs)\n\n"
             "Creates a new buffer by concatenating values together. Values are "
             "converted to bytes via describe if they are not byte sequences. Returns "
             "the new buffer.")
    },
    {
        "abstract?", janet_core_is_abstract,
        JDOC("(abstract? x)\n\n"
             "Check if x is an abstract type.")
    },
    {
        "table", janet_core_table,
        JDOC("(table & kvs)\n\n"
             "Creates a new table from a variadic number of keys and values. "
             "kvs is a sequence k1, v1, k2, v2, k3, v3, ... If kvs has "
             "an odd number of elements, an error will be thrown. Returns the "
             "new table.")
    },
    {
        "array", janet_core_array,
        JDOC("(array & items)\n\n"
             "Create a new array that contains items. Returns the new array.")
    },
    {
        "scan-number", janet_core_scannumber,
        JDOC("(scan-number str)\n\n"
             "Parse a number from a byte sequence an return that number, either and integer "
             "or a real. The number "
             "must be in the same format as numbers in janet source code. Will return nil "
             "on an invalid number.")
    },
    {
        "tuple", janet_core_tuple,
        JDOC("(tuple & items)\n\n"
             "Creates a new tuple that contains items. Returns the new tuple.")
    },
    {
        "struct", janet_core_struct,
        JDOC("(struct & kvs)\n\n"
             "Create a new struct from a sequence of key value pairs. "
             "kvs is a sequence k1, v1, k2, v2, k3, v3, ... If kvs has "
             "an odd number of elements, an error will be thrown. Returns the "
             "new struct.")
    },
    {
        "gensym", janet_core_gensym,
        JDOC("(gensym)\n\n"
             "Returns a new symbol that is unique across the runtime. This means it "
             "will not collide with any already created symbols during compilation, so "
             "it can be used in macros to generate automatic bindings.")
    },
    {
        "gccollect", janet_core_gccollect,
        JDOC("(gccollect)\n\n"
             "Run garbage collection. You should probably not call this manually.")
    },
    {
        "gcsetinterval", janet_core_gcsetinterval,
        JDOC("(gcsetinterval interval)\n\n"
             "Set an integer number of bytes to allocate before running garbage collection. "
             "Low values for interval will be slower but use less memory. "
             "High values will be faster but use more memory.")
    },
    {
        "gcinterval", janet_core_gcinterval,
        JDOC("(gcinterval)\n\n"
             "Returns the integer number of bytes to allocate before running an iteration "
             "of garbage collection.")
    },
    {
        "type", janet_core_type,
        JDOC("(type x)\n\n"
             "Returns the type of x as a keyword. x is one of\n"
             "\t:nil\n"
             "\t:boolean\n"
             "\t:number\n"
             "\t:array\n"
             "\t:tuple\n"
             "\t:table\n"
             "\t:struct\n"
             "\t:string\n"
             "\t:buffer\n"
             "\t:symbol\n"
             "\t:keyword\n"
             "\t:function\n"
             "\t:cfunction\n\n"
             "or another keyword for an abstract type.")
    },
    {
        "hash", janet_core_hash,
        JDOC("(hash value)\n\n"
             "Gets a hash for any value. The hash is an integer can be used "
             "as a cheap hash function for all values. If two values are strictly equal, "
             "then they will have the same hash value.")
    },
    {
        "getline", janet_core_getline,
        JDOC("(getline &opt prompt buf env)\n\n"
             "Reads a line of input into a buffer, including the newline character, using a prompt. "
             "An optional environment table can be provided for auto-complete. "
             "Returns the modified buffer. "
             "Use this function to implement a simple interface for a terminal program.")
    },
    {
        "dyn", janet_core_dyn,
        JDOC("(dyn key &opt default)\n\n"
             "Get a dynamic binding. Returns the default value (or nil) if no binding found.")
    },
    {
        "setdyn", janet_core_setdyn,
        JDOC("(setdyn key value)\n\n"
             "Set a dynamic binding. Returns value.")
    },
    {
        "trace", janet_core_trace,
        JDOC("(trace func)\n\n"
             "Enable tracing on a function. Returns the function.")
    },
    {
        "untrace", janet_core_untrace,
        JDOC("(untrace func)\n\n"
             "Disables tracing on a function. Returns the function.")
    },
    {
        "module/expand-path", janet_core_expand_path,
        JDOC("(module/expand-path path template)\n\n"
             "Expands a path template as found in module/paths for module/find. "
             "This takes in a path (the argument to require) and a template string, template, "
             "to expand the path to a path that can be "
             "used for importing files. The replacements are as follows:\n\n"
             "\t:all:\tthe value of path verbatim\n"
             "\t:cur:\tthe current file, or (dyn :current-file)\n"
             "\t:dir:\tthe directory containing the current file\n"
             "\t:name:\tthe name component of path, with extension if given\n"
             "\t:native:\tthe extension used to load natives, .so or .dll\n"
             "\t:sys:\tthe system path, or (dyn :syspath)")
    },
    {
        "int?", janet_core_check_int,
        JDOC("(int? x)\n\n"
             "Check if x can be exactly represented as a 32 bit signed two's complement integer.")
    },
    {
        "nat?", janet_core_check_nat,
        JDOC("(nat? x)\n\n"
             "Check if x can be exactly represented as a non-negative 32 bit signed two's complement integer.")
    },
    {
        "slice", janet_core_slice,
        JDOC("(slice x &opt start end)\n\n"
             "Extract a sub-range of an indexed data structure or byte sequence.")
    },
    {
        "signal", janet_core_signal,
        JDOC("(signal what x)\n\n"
             "Raise a signal with payload x. ")
    },
    {NULL, NULL, NULL}
};

#ifdef JANET_BOOTSTRAP

/* Utility for inline assembly */
static void janet_quick_asm(
    JanetTable *env,
    int32_t flags,
    const char *name,
    int32_t arity,
    int32_t min_arity,
    int32_t max_arity,
    int32_t slots,
    const uint32_t *bytecode,
    size_t bytecode_size,
    const char *doc) {
    JanetFuncDef *def = janet_funcdef_alloc();
    def->arity = arity;
    def->min_arity = min_arity;
    def->max_arity = max_arity;
    def->flags = flags;
    def->slotcount = slots;
    def->bytecode = malloc(bytecode_size);
    def->bytecode_length = (int32_t)(bytecode_size / sizeof(uint32_t));
    def->name = janet_cstring(name);
    if (!def->bytecode) {
        JANET_OUT_OF_MEMORY;
    }
    memcpy(def->bytecode, bytecode, bytecode_size);
    janet_def(env, name, janet_wrap_function(janet_thunk(def)), doc);
}

/* Macros for easier inline assembly */
#define SSS(op, a, b, c) ((op) | ((a) << 8) | ((b) << 16) | ((c) << 24))
#define SS(op, a, b) ((op) | ((a) << 8) | ((b) << 16))
#define SSI(op, a, b, I) ((op) | ((a) << 8) | ((b) << 16) | ((uint32_t)(I) << 24))
#define S(op, a) ((op) | ((a) << 8))
#define SI(op, a, I) ((op) | ((a) << 8) | ((uint32_t)(I) << 16))

/* Templatize a varop */
static void templatize_varop(
    JanetTable *env,
    int32_t flags,
    const char *name,
    int32_t nullary,
    int32_t unary,
    uint32_t op,
    const char *doc) {

    /* Variadic operator assembly. Must be templatized for each different opcode. */
    /* Reg 0: Argument tuple (args) */
    /* Reg 1: Argument count (argn) */
    /* Reg 2: Jump flag (jump?) */
    /* Reg 3: Accumulator (accum) */
    /* Reg 4: Next operand (operand) */
    /* Reg 5: Loop iterator (i) */
    uint32_t varop_asm[] = {
        SS(JOP_LENGTH, 1, 0), /* Put number of arguments in register 1 -> argn = count(args) */

        /* Check nullary */
        SSS(JOP_EQUALS_IMMEDIATE, 2, 1, 0), /* Check if numargs equal to 0 */
        SI(JOP_JUMP_IF_NOT, 2, 3), /* If not 0, jump to next check */
        /* Nullary */
        SI(JOP_LOAD_INTEGER, 3, nullary),  /* accum = nullary value */
        S(JOP_RETURN, 3), /* return accum */

        /* Check unary */
        SSI(JOP_EQUALS_IMMEDIATE, 2, 1, 1), /* Check if numargs equal to 1 */
        SI(JOP_JUMP_IF_NOT, 2, 5), /* If not 1, jump to next check */
        /* Unary */
        SI(JOP_LOAD_INTEGER, 3, unary), /* accum = unary value */
        SSI(JOP_GET_INDEX, 4, 0, 0), /* operand = args[0] */
        SSS(op, 3, 3, 4), /* accum = accum op operand */
        S(JOP_RETURN, 3), /* return accum */

        /* Mutli (2 or more) arity */
        /* Prime loop */
        SSI(JOP_GET_INDEX, 3, 0, 0), /* accum = args[0] */
        SI(JOP_LOAD_INTEGER, 5, 1), /* i = 1 */
        /* Main loop */
        SSS(JOP_IN, 4, 0, 5), /* operand = args[i] */
        SSS(op, 3, 3, 4), /* accum = accum op operand */
        SSI(JOP_ADD_IMMEDIATE, 5, 5, 1), /* i++ */
        SSI(JOP_EQUALS, 2, 5, 1), /* jump? = (i == argn) */
        SI(JOP_JUMP_IF_NOT, 2, -4), /* if not jump? go back 4 */

        /* Done, do last and return accumulator */
        S(JOP_RETURN, 3) /* return accum */
    };

    janet_quick_asm(
        env,
        flags | JANET_FUNCDEF_FLAG_VARARG,
        name,
        0,
        0,
        INT32_MAX,
        6,
        varop_asm,
        sizeof(varop_asm),
        doc);
}

/* Templatize variadic comparators */
static void templatize_comparator(
    JanetTable *env,
    int32_t flags,
    const char *name,
    int invert,
    uint32_t op,
    const char *doc) {

    /* Reg 0: Argument tuple (args) */
    /* Reg 1: Argument count (argn) */
    /* Reg 2: Jump flag (jump?) */
    /* Reg 3: Last value (last) */
    /* Reg 4: Next operand (next) */
    /* Reg 5: Loop iterator (i) */
    uint32_t comparator_asm[] = {
        SS(JOP_LENGTH, 1, 0), /* Put number of arguments in register 1 -> argn = count(args) */
        SSS(JOP_LESS_THAN_IMMEDIATE, 2, 1, 2), /* Check if numargs less than 2 */
        SI(JOP_JUMP_IF, 2, 10), /* If numargs < 2, jump to done */

        /* Prime loop */
        SSI(JOP_GET_INDEX, 3, 0, 0), /* last = args[0] */
        SI(JOP_LOAD_INTEGER, 5, 1), /* i = 1 */

        /* Main loop */
        SSS(JOP_IN, 4, 0, 5), /* next = args[i] */
        SSS(op, 2, 3, 4), /* jump? = last compare next */
        SI(JOP_JUMP_IF_NOT, 2, 7), /* if not jump? goto fail (return false) */
        SSI(JOP_ADD_IMMEDIATE, 5, 5, 1), /* i++ */
        SS(JOP_MOVE_NEAR, 3, 4), /* last = next */
        SSI(JOP_EQUALS, 2, 5, 1), /* jump? = (i == argn) */
        SI(JOP_JUMP_IF_NOT, 2, -6), /* if not jump? go back 6 */

        /* Done, return true */
        S(invert ? JOP_LOAD_FALSE : JOP_LOAD_TRUE, 3),
        S(JOP_RETURN, 3),

        /* Failed, return false */
        S(invert ? JOP_LOAD_TRUE : JOP_LOAD_FALSE, 3),
        S(JOP_RETURN, 3)
    };

    janet_quick_asm(
        env,
        flags | JANET_FUNCDEF_FLAG_VARARG,
        name,
        0,
        0,
        INT32_MAX,
        6,
        comparator_asm,
        sizeof(comparator_asm),
        doc);
}

/* Make the apply function */
static void make_apply(JanetTable *env) {
    /* Reg 0: Function (fun) */
    /* Reg 1: Argument tuple (args) */
    /* Reg 2: Argument count (argn) */
    /* Reg 3: Jump flag (jump?) */
    /* Reg 4: Loop iterator (i) */
    /* Reg 5: Loop values (x) */
    uint32_t apply_asm[] = {
        SS(JOP_LENGTH, 2, 1),
        SSS(JOP_EQUALS_IMMEDIATE, 3, 2, 0), /* Immediate tail call if no args */
        SI(JOP_JUMP_IF, 3, 9),

        /* Prime loop */
        SI(JOP_LOAD_INTEGER, 4, 0), /* i = 0 */

        /* Main loop */
        SSS(JOP_IN, 5, 1, 4), /* x = args[i] */
        SSI(JOP_ADD_IMMEDIATE, 4, 4, 1), /* i++ */
        SSI(JOP_EQUALS, 3, 4, 2), /* jump? = (i == argn) */
        SI(JOP_JUMP_IF, 3, 3), /* if jump? go forward 3 */
        S(JOP_PUSH, 5),
        (JOP_JUMP | ((uint32_t)(-5) << 8)),

        /* Push the array */
        S(JOP_PUSH_ARRAY, 5),

        /* Call the funciton */
        S(JOP_TAILCALL, 0)
    };
    janet_quick_asm(env, JANET_FUN_APPLY | JANET_FUNCDEF_FLAG_VARARG,
                    "apply", 1, 1, INT32_MAX, 6, apply_asm, sizeof(apply_asm),
                    JDOC("(apply f & args)\n\n"
                         "Applies a function to a variable number of arguments. Each element in args "
                         "is used as an argument to f, except the last element in args, which is expected to "
                         "be an array-like. Each element in this last argument is then also pushed as an argument to "
                         "f. For example:\n\n"
                         "\t(apply + 1000 (range 10))\n\n"
                         "sums the first 10 integers and 1000."));
}

static const uint32_t error_asm[] = {
    JOP_ERROR
};
static const uint32_t debug_asm[] = {
    JOP_SIGNAL | (2 << 24),
    JOP_RETURN
};
static const uint32_t yield_asm[] = {
    JOP_SIGNAL | (3 << 24),
    JOP_RETURN
};
static const uint32_t resume_asm[] = {
    JOP_RESUME | (1 << 24),
    JOP_RETURN
};
static const uint32_t in_asm[] = {
    JOP_IN | (1 << 24),
    JOP_LOAD_NIL | (3 << 8),
    JOP_EQUALS | (3 << 8) | (3 << 24),
    JOP_JUMP_IF | (3 << 8) | (2 << 16),
    JOP_RETURN,
    JOP_RETURN | (2 << 8)
};
static const uint32_t get_asm[] = {
    JOP_GET | (1 << 24),
    JOP_LOAD_NIL | (3 << 8),
    JOP_EQUALS | (3 << 8) | (3 << 24),
    JOP_JUMP_IF | (3 << 8) | (2 << 16),
    JOP_RETURN,
    JOP_RETURN | (2 << 8)
};
static const uint32_t put_asm[] = {
    JOP_PUT | (1 << 16) | (2 << 24),
    JOP_RETURN
};
static const uint32_t length_asm[] = {
    JOP_LENGTH,
    JOP_RETURN
};
static const uint32_t bnot_asm[] = {
    JOP_BNOT,
    JOP_RETURN
};
static const uint32_t propagate_asm[] = {
    JOP_PROPAGATE | (1 << 24),
    JOP_RETURN
};
static const uint32_t next_asm[] = {
    JOP_NEXT | (1 << 24),
    JOP_RETURN
};
static const uint32_t modulo_asm[] = {
    JOP_MODULO | (1 << 24),
    JOP_RETURN
};
static const uint32_t remainder_asm[] = {
    JOP_REMAINDER | (1 << 24),
    JOP_RETURN
};
#endif /* ifdef JANET_BOOTSTRAP */

/*
 * Setup Environment
 */

static void janet_load_libs(JanetTable *env) {
    janet_core_cfuns(env, NULL, corelib_cfuns);
    janet_lib_io(env);
    janet_lib_math(env);
    janet_lib_array(env);
    janet_lib_tuple(env);
    janet_lib_buffer(env);
    janet_lib_table(env);
    janet_lib_fiber(env);
    janet_lib_os(env);
    janet_lib_parse(env);
    janet_lib_compile(env);
    janet_lib_debug(env);
    janet_lib_string(env);
    janet_lib_marsh(env);
#ifdef JANET_PEG
    janet_lib_peg(env);
#endif
#ifdef JANET_ASSEMBLER
    janet_lib_asm(env);
#endif
#ifdef JANET_TYPED_ARRAY
    janet_lib_typed_array(env);
#endif
#ifdef JANET_INT_TYPES
    janet_lib_inttypes(env);
#endif
#ifdef JANET_THREADS
    janet_lib_thread(env);
#endif
#ifdef JANET_NET
    janet_lib_net(env);
#endif
}

#ifdef JANET_BOOTSTRAP

JanetTable *janet_core_env(JanetTable *replacements) {
    JanetTable *env = (NULL != replacements) ? replacements : janet_table(0);
    janet_quick_asm(env, JANET_FUN_MODULO,
                    "mod", 2, 2, 2, 2, modulo_asm, sizeof(modulo_asm),
                    JDOC("(mod dividend divisor)\n\n"
                         "Returns the modulo of dividend / divisor."));
    janet_quick_asm(env, JANET_FUN_REMAINDER,
                    "%", 2, 2, 2, 2, remainder_asm, sizeof(remainder_asm),
                    JDOC("(% dividend divisor)\n\n"
                         "Returns the remainder of dividend / divisor."));
    janet_quick_asm(env, JANET_FUN_NEXT,
                    "next", 2, 1, 2, 2, next_asm, sizeof(next_asm),
                    JDOC("(next ds &opt key)\n\n"
                         "Gets the next key in a data structure. Can be used to iterate through "
                         "the keys of a data structure in an unspecified order. Keys are guaranteed "
                         "to be seen only once per iteration if they data structure is not mutated "
                         "during iteration. If key is nil, next returns the first key. If next "
                         "returns nil, there are no more keys to iterate through."));
    janet_quick_asm(env, JANET_FUN_PROP,
                    "propagate", 2, 2, 2, 2, propagate_asm, sizeof(propagate_asm),
                    JDOC("(propagate x fiber)\n\n"
                         "Propagate a signal from a fiber to the current fiber. The resulting "
                         "stack trace from the current fiber will include frames from fiber. If "
                         "fiber is in a state that can be resumed, resuming the current fiber will "
                         "first resume fiber. This function can be used to re-raise an error without "
                         "losing the original stack trace."));
    janet_quick_asm(env, JANET_FUN_DEBUG,
                    "debug", 1, 0, 1, 1, debug_asm, sizeof(debug_asm),
                    JDOC("(debug &opt x)\n\n"
                         "Throws a debug signal that can be caught by a parent fiber and used to inspect "
                         "the running state of the current fiber. Returns the value passed in by resume."));
    janet_quick_asm(env, JANET_FUN_ERROR,
                    "error", 1, 1, 1, 1, error_asm, sizeof(error_asm),
                    JDOC("(error e)\n\n"
                         "Throws an error e that can be caught and handled by a parent fiber."));
    janet_quick_asm(env, JANET_FUN_YIELD,
                    "yield", 1, 0, 1, 2, yield_asm, sizeof(yield_asm),
                    JDOC("(yield &opt x)\n\n"
                         "Yield a value to a parent fiber. When a fiber yields, its execution is paused until "
                         "another thread resumes it. The fiber will then resume, and the last yield call will "
                         "return the value that was passed to resume."));
    janet_quick_asm(env, JANET_FUN_RESUME,
                    "resume", 2, 1, 2, 2, resume_asm, sizeof(resume_asm),
                    JDOC("(resume fiber &opt x)\n\n"
                         "Resume a new or suspended fiber and optionally pass in a value to the fiber that "
                         "will be returned to the last yield in the case of a pending fiber, or the argument to "
                         "the dispatch function in the case of a new fiber. Returns either the return result of "
                         "the fiber's dispatch function, or the value from the next yield call in fiber."));
    janet_quick_asm(env, JANET_FUN_IN,
                    "in", 3, 2, 3, 4, in_asm, sizeof(in_asm),
                    JDOC("(in ds key &opt dflt)\n\n"
                         "Get value in ds at key, works on associative data structures. Arrays, tuples, tables, structs, "
                         "strings, symbols, and buffers are all associative and can be used. Arrays, tuples, strings, buffers, "
                         "and symbols must use integer keys that are in bounds or an error is raised. Structs and tables can "
                         "take any value as a key except nil and will return nil or dflt if not found."));
    janet_quick_asm(env, JANET_FUN_GET,
                    "get", 3, 2, 3, 4, get_asm, sizeof(in_asm),
                    JDOC("(get ds key &opt dflt)\n\n"
                         "Get the value mapped to key in data structure ds, and return dflt or nil if not found. "
                         "Similar to in, but will not throw an error if the key is invalid for the data structure "
                         "unless the data structure is an abstract type. In that case, the abstract type getter may throw "
                         "an error."));
    janet_quick_asm(env, JANET_FUN_PUT,
                    "put", 3, 3, 3, 3, put_asm, sizeof(put_asm),
                    JDOC("(put ds key value)\n\n"
                         "Associate a key with a value in any mutable associative data structure. Indexed data structures "
                         "(arrays and buffers) only accept non-negative integer keys, and will expand if an out of bounds "
                         "value is provided. In an array, extra space will be filled with nils, and in a buffer, extra "
                         "space will be filled with 0 bytes. In a table, putting a key that is contained in the table prototype "
                         "will hide the association defined by the prototype, but will not mutate the prototype table. Putting "
                         "a value nil into a table will remove the key from the table. Returns the data structure ds."));
    janet_quick_asm(env, JANET_FUN_LENGTH,
                    "length", 1, 1, 1, 1, length_asm, sizeof(length_asm),
                    JDOC("(length ds)\n\n"
                         "Returns the length or count of a data structure in constant time as an integer. For "
                         "structs and tables, returns the number of key-value pairs in the data structure."));
    janet_quick_asm(env, JANET_FUN_BNOT,
                    "bnot", 1, 1, 1, 1, bnot_asm, sizeof(bnot_asm),
                    JDOC("(bnot x)\n\nReturns the bit-wise inverse of integer x."));
    make_apply(env);

    /* Variadic ops */
    templatize_varop(env, JANET_FUN_ADD, "+", 0, 0, JOP_ADD,
                     JDOC("(+ & xs)\n\n"
                          "Returns the sum of all xs. xs must be integers or real numbers only. If xs is empty, return 0."));
    templatize_varop(env, JANET_FUN_SUBTRACT, "-", 0, 0, JOP_SUBTRACT,
                     JDOC("(- & xs)\n\n"
                          "Returns the difference of xs. If xs is empty, returns 0. If xs has one element, returns the "
                          "negative value of that element. Otherwise, returns the first element in xs minus the sum of "
                          "the rest of the elements."));
    templatize_varop(env, JANET_FUN_MULTIPLY, "*", 1, 1, JOP_MULTIPLY,
                     JDOC("(* & xs)\n\n"
                          "Returns the product of all elements in xs. If xs is empty, returns 1."));
    templatize_varop(env, JANET_FUN_DIVIDE, "/", 1, 1, JOP_DIVIDE,
                     JDOC("(/ & xs)\n\n"
                          "Returns the quotient of xs. If xs is empty, returns 1. If xs has one value x, returns "
                          "the reciprocal of x. Otherwise return the first value of xs repeatedly divided by the remaining "
                          "values."));
    templatize_varop(env, JANET_FUN_BAND, "band", -1, -1, JOP_BAND,
                     JDOC("(band & xs)\n\n"
                          "Returns the bit-wise and of all values in xs. Each x in xs must be an integer."));
    templatize_varop(env, JANET_FUN_BOR, "bor", 0, 0, JOP_BOR,
                     JDOC("(bor & xs)\n\n"
                          "Returns the bit-wise or of all values in xs. Each x in xs must be an integer."));
    templatize_varop(env, JANET_FUN_BXOR, "bxor", 0, 0, JOP_BXOR,
                     JDOC("(bxor & xs)\n\n"
                          "Returns the bit-wise xor of all values in xs. Each in xs must be an integer."));
    templatize_varop(env, JANET_FUN_LSHIFT, "blshift", 1, 1, JOP_SHIFT_LEFT,
                     JDOC("(blshift x & shifts)\n\n"
                          "Returns the value of x bit shifted left by the sum of all values in shifts. x "
                          "and each element in shift must be an integer."));
    templatize_varop(env, JANET_FUN_RSHIFT, "brshift", 1, 1, JOP_SHIFT_RIGHT,
                     JDOC("(brshift x & shifts)\n\n"
                          "Returns the value of x bit shifted right by the sum of all values in shifts. x "
                          "and each element in shift must be an integer."));
    templatize_varop(env, JANET_FUN_RSHIFTU, "brushift", 1, 1, JOP_SHIFT_RIGHT_UNSIGNED,
                     JDOC("(brushift x & shifts)\n\n"
                          "Returns the value of x bit shifted right by the sum of all values in shifts. x "
                          "and each element in shift must be an integer. The sign of x is not preserved, so "
                          "for positive shifts the return value will always be positive."));

    /* Variadic comparators */
    templatize_comparator(env, JANET_FUN_GT, ">", 0, JOP_GREATER_THAN,
                          JDOC("(> & xs)\n\n"
                               "Check if xs is in descending order. Returns a boolean."));
    templatize_comparator(env, JANET_FUN_LT, "<", 0, JOP_LESS_THAN,
                          JDOC("(< & xs)\n\n"
                               "Check if xs is in ascending order. Returns a boolean."));
    templatize_comparator(env, JANET_FUN_GTE, ">=", 0, JOP_GREATER_THAN_EQUAL,
                          JDOC("(>= & xs)\n\n"
                               "Check if xs is in non-ascending order. Returns a boolean."));
    templatize_comparator(env, JANET_FUN_LTE, "<=", 0, JOP_LESS_THAN_EQUAL,
                          JDOC("(<= & xs)\n\n"
                               "Check if xs is in non-descending order. Returns a boolean."));
    templatize_comparator(env, JANET_FUN_EQ, "=", 0, JOP_EQUALS,
                          JDOC("(= & xs)\n\n"
                               "Check if all values in xs are equal. Returns a boolean."));
    templatize_comparator(env, JANET_FUN_NEQ, "not=", 1, JOP_EQUALS,
                          JDOC("(not= & xs)\n\n"
                               "Check if any values in xs are not equal. Returns a boolean."));

    /* Platform detection */
    janet_def(env, "janet/version", janet_cstringv(JANET_VERSION),
              JDOC("The version number of the running janet program."));
    janet_def(env, "janet/build", janet_cstringv(JANET_BUILD),
              JDOC("The build identifier of the running janet program."));
    janet_def(env, "janet/config-bits", janet_wrap_integer(JANET_CURRENT_CONFIG_BITS),
              JDOC("The flag set of config options from janetconf.h which is used to check "
                   "if native modules are compatible with the host program."));

    /* Allow references to the environment */
    janet_def(env, "_env", janet_wrap_table(env), JDOC("The environment table for the current scope."));

    janet_load_libs(env);
    janet_gcroot(janet_wrap_table(env));
    return env;
}

#else

JanetTable *janet_core_env(JanetTable *replacements) {
    /* Memoize core env, ignoring replacements the second time around. */
    if (NULL != janet_vm_core_env) {
        return janet_vm_core_env;
    }

    /* Load core cfunctions (and some built in janet assembly functions) */
    JanetTable *dict = janet_table(300);
    janet_load_libs(dict);

    /* Add replacements */
    if (replacements != NULL) {
        for (int32_t i = 0; i < replacements->capacity; i++) {
            JanetKV kv = replacements->data[i];
            if (!janet_checktype(kv.key, JANET_NIL)) {
                janet_table_put(dict, kv.key, kv.value);
                if (janet_checktype(kv.value, JANET_CFUNCTION)) {
                    janet_table_put(janet_vm_registry, kv.value, kv.key);
                }
            }
        }
    }

    /* Unmarshal bytecode */
    Janet marsh_out = janet_unmarshal(
                          janet_core_image,
                          janet_core_image_size,
                          0,
                          dict,
                          NULL);

    /* Memoize */
    janet_gcroot(marsh_out);
    JanetTable *env = janet_unwrap_table(marsh_out);
    janet_vm_core_env = env;

    return env;
}

#endif


/* src/core/debug.c */
#line 0 "src/core/debug.c"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "gc.h"
#include "state.h"
#include "util.h"
#include "vector.h"
#endif

/* Implements functionality to build a debugger from within janet.
 * The repl should also be able to serve as pretty featured debugger
 * out of the box. */

/* Add a break point to a function */
void janet_debug_break(JanetFuncDef *def, int32_t pc) {
    if (pc >= def->bytecode_length || pc < 0)
        janet_panic("invalid bytecode offset");
    def->bytecode[pc] |= 0x80;
}

/* Remove a break point from a function */
void janet_debug_unbreak(JanetFuncDef *def, int32_t pc) {
    if (pc >= def->bytecode_length || pc < 0)
        janet_panic("invalid bytecode offset");
    def->bytecode[pc] &= ~((uint32_t)0x80);
}

/*
 * Find a location for a breakpoint given a source file an
 * location.
 */
void janet_debug_find(
    JanetFuncDef **def_out, int32_t *pc_out,
    const uint8_t *source, int32_t sourceLine, int32_t sourceColumn) {
    /* Scan the heap for right func def */
    JanetGCObject *current = janet_vm_blocks;
    /* Keep track of the best source mapping we have seen so far */
    int32_t besti = -1;
    int32_t best_line = -1;
    int32_t best_column = -1;
    JanetFuncDef *best_def = NULL;
    while (NULL != current) {
        if ((current->flags & JANET_MEM_TYPEBITS) == JANET_MEMORY_FUNCDEF) {
            JanetFuncDef *def = (JanetFuncDef *)(current);
            if (def->sourcemap &&
                    def->source &&
                    !janet_string_compare(source, def->source)) {
                /* Correct source file, check mappings. The chosen
                 * pc index is the instruction closest to the given line column, but
                 * not after. */
                int32_t i;
                for (i = 0; i < def->bytecode_length; i++) {
                    int32_t line = def->sourcemap[i].line;
                    int32_t column = def->sourcemap[i].column;
                    if (line <= sourceLine && line >= best_line) {
                        if (column <= sourceColumn &&
                                (line > best_line || column > best_column)) {
                            best_line = line;
                            best_column = column;
                            besti = i;
                            best_def = def;
                        }
                    }
                }
            }
        }
        current = current->next;
    }
    if (best_def) {
        *def_out = best_def;
        *pc_out = besti;
    } else {
        janet_panic("could not find breakpoint");
    }
}

/* Error reporting. This can be emulated from within Janet, but for
 * consitency with the top level code it is defined once. */
void janet_stacktrace(JanetFiber *fiber, Janet err) {
    int32_t fi;
    const char *errstr = (const char *)janet_to_string(err);
    JanetFiber **fibers = NULL;
    int wrote_error = 0;

    int print_color = janet_truthy(janet_dyn("err-color"));
    if (print_color) janet_eprintf("\x1b[31m");

    while (fiber) {
        janet_v_push(fibers, fiber);
        fiber = fiber->child;
    }

    for (fi = janet_v_count(fibers) - 1; fi >= 0; fi--) {
        fiber = fibers[fi];
        int32_t i = fiber->frame;
        while (i > 0) {
            JanetStackFrame *frame = (JanetStackFrame *)(fiber->data + i - JANET_FRAME_SIZE);
            JanetFuncDef *def = NULL;
            i = frame->prevframe;

            /* Print prelude to stack frame */
            if (!wrote_error) {
                JanetFiberStatus status = janet_fiber_status(fiber);
                const char *prefix = status == JANET_STATUS_ERROR ? "" : "status ";
                janet_eprintf("%s%s: %s\n",
                              prefix,
                              janet_status_names[status],
                              errstr);
                wrote_error = 1;
            }

            janet_eprintf("  in");

            if (frame->func) {
                def = frame->func->def;
                janet_eprintf(" %s", def->name ? (const char *)def->name : "<anonymous>");
                if (def->source) {
                    janet_eprintf(" [%s]", (const char *)def->source);
                }
            } else {
                JanetCFunction cfun = (JanetCFunction)(frame->pc);
                if (cfun) {
                    Janet name = janet_table_get(janet_vm_registry, janet_wrap_cfunction(cfun));
                    if (!janet_checktype(name, JANET_NIL))
                        janet_eprintf(" %s", (const char *)janet_to_string(name));
                    else
                        janet_eprintf(" <cfunction>");
                }
            }
            if (frame->flags & JANET_STACKFRAME_TAILCALL)
                janet_eprintf(" (tailcall)");
            if (frame->func && frame->pc) {
                int32_t off = (int32_t)(frame->pc - def->bytecode);
                if (def->sourcemap) {
                    JanetSourceMapping mapping = def->sourcemap[off];
                    janet_eprintf(" on line %d, column %d", mapping.line, mapping.column);
                } else {
                    janet_eprintf(" pc=%d", off);
                }
            }
            janet_eprintf("\n");
        }
    }

    if (print_color) janet_eprintf("\x1b[0m");

    janet_v_free(fibers);
}

/*
 * CFuns
 */

/* Helper to find funcdef and bytecode offset to insert or remove breakpoints.
 * Takes a source file name and byte offset. */
static void helper_find(int32_t argc, Janet *argv, JanetFuncDef **def, int32_t *bytecode_offset) {
    janet_fixarity(argc, 3);
    const uint8_t *source = janet_getstring(argv, 0);
    int32_t line = janet_getinteger(argv, 1);
    int32_t col = janet_getinteger(argv, 2);
    janet_debug_find(def, bytecode_offset, source, line, col);
}

/* Helper to find funcdef and bytecode offset to insert or remove breakpoints.
 * Takes a function and byte offset*/
static void helper_find_fun(int32_t argc, Janet *argv, JanetFuncDef **def, int32_t *bytecode_offset) {
    janet_arity(argc, 1, 2);
    JanetFunction *func = janet_getfunction(argv, 0);
    int32_t offset = (argc == 2) ? janet_getinteger(argv, 1) : 0;
    *def = func->def;
    *bytecode_offset = offset;
}

static Janet cfun_debug_break(int32_t argc, Janet *argv) {
    JanetFuncDef *def;
    int32_t offset;
    helper_find(argc, argv, &def, &offset);
    janet_debug_break(def, offset);
    return janet_wrap_nil();
}

static Janet cfun_debug_unbreak(int32_t argc, Janet *argv) {
    JanetFuncDef *def;
    int32_t offset = 0;
    helper_find(argc, argv, &def, &offset);
    janet_debug_unbreak(def, offset);
    return janet_wrap_nil();
}

static Janet cfun_debug_fbreak(int32_t argc, Janet *argv) {
    JanetFuncDef *def;
    int32_t offset = 0;
    helper_find_fun(argc, argv, &def, &offset);
    janet_debug_break(def, offset);
    return janet_wrap_nil();
}

static Janet cfun_debug_unfbreak(int32_t argc, Janet *argv) {
    JanetFuncDef *def;
    int32_t offset;
    helper_find_fun(argc, argv, &def, &offset);
    janet_debug_unbreak(def, offset);
    return janet_wrap_nil();
}

static Janet cfun_debug_lineage(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    JanetFiber *fiber = janet_getfiber(argv, 0);
    JanetArray *array = janet_array(0);
    while (fiber) {
        janet_array_push(array, janet_wrap_fiber(fiber));
        fiber = fiber->child;
    }
    return janet_wrap_array(array);
}

/* Extract info from one stack frame */
static Janet doframe(JanetStackFrame *frame) {
    int32_t off;
    JanetTable *t = janet_table(3);
    JanetFuncDef *def = NULL;
    if (frame->func) {
        janet_table_put(t, janet_ckeywordv("function"), janet_wrap_function(frame->func));
        def = frame->func->def;
        if (def->name) {
            janet_table_put(t, janet_ckeywordv("name"), janet_wrap_string(def->name));
        }
    } else {
        JanetCFunction cfun = (JanetCFunction)(frame->pc);
        if (cfun) {
            Janet name = janet_table_get(janet_vm_registry, janet_wrap_cfunction(cfun));
            if (!janet_checktype(name, JANET_NIL)) {
                janet_table_put(t, janet_ckeywordv("name"), name);
            }
        }
        janet_table_put(t, janet_ckeywordv("c"), janet_wrap_true());
    }
    if (frame->flags & JANET_STACKFRAME_TAILCALL) {
        janet_table_put(t, janet_ckeywordv("tail"), janet_wrap_true());
    }
    if (frame->func && frame->pc) {
        Janet *stack = (Janet *)frame + JANET_FRAME_SIZE;
        JanetArray *slots;
        off = (int32_t)(frame->pc - def->bytecode);
        janet_table_put(t, janet_ckeywordv("pc"), janet_wrap_integer(off));
        if (def->sourcemap) {
            JanetSourceMapping mapping = def->sourcemap[off];
            janet_table_put(t, janet_ckeywordv("source-line"), janet_wrap_integer(mapping.line));
            janet_table_put(t, janet_ckeywordv("source-column"), janet_wrap_integer(mapping.column));
        }
        if (def->source) {
            janet_table_put(t, janet_ckeywordv("source"), janet_wrap_string(def->source));
        }
        /* Add stack arguments */
        slots = janet_array(def->slotcount);
        safe_memcpy(slots->data, stack, sizeof(Janet) * def->slotcount);
        slots->count = def->slotcount;
        janet_table_put(t, janet_ckeywordv("slots"), janet_wrap_array(slots));
    }
    return janet_wrap_table(t);
}

static Janet cfun_debug_stack(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    JanetFiber *fiber = janet_getfiber(argv, 0);
    JanetArray *array = janet_array(0);
    {
        int32_t i = fiber->frame;
        JanetStackFrame *frame;
        while (i > 0) {
            frame = (JanetStackFrame *)(fiber->data + i - JANET_FRAME_SIZE);
            janet_array_push(array, doframe(frame));
            i = frame->prevframe;
        }
    }
    return janet_wrap_array(array);
}

static Janet cfun_debug_stacktrace(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 2);
    JanetFiber *fiber = janet_getfiber(argv, 0);
    janet_stacktrace(fiber, argv[1]);
    return argv[0];
}

static Janet cfun_debug_argstack(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    JanetFiber *fiber = janet_getfiber(argv, 0);
    JanetArray *array = janet_array(fiber->stacktop - fiber->stackstart);
    memcpy(array->data, fiber->data + fiber->stackstart, array->capacity * sizeof(Janet));
    array->count = array->capacity;
    return janet_wrap_array(array);
}

static Janet cfun_debug_step(int32_t argc, Janet *argv) {
    janet_arity(argc, 1, 2);
    JanetFiber *fiber = janet_getfiber(argv, 0);
    Janet out = janet_wrap_nil();
    janet_step(fiber, argc == 1 ? janet_wrap_nil() : argv[1], &out);
    return out;
}

static const JanetReg debug_cfuns[] = {
    {
        "debug/break", cfun_debug_break,
        JDOC("(debug/break source byte-offset)\n\n"
             "Sets a breakpoint with source a key at a given line and column. "
             "Will throw an error if the breakpoint location "
             "cannot be found. For example\n\n"
             "\t(debug/break \"core.janet\" 1000)\n\n"
             "wil set a breakpoint at the 1000th byte of the file core.janet.")
    },
    {
        "debug/unbreak", cfun_debug_unbreak,
        JDOC("(debug/unbreak source line column)\n\n"
             "Remove a breakpoint with a source key at a given line and column. "
             "Will throw an error if the breakpoint "
             "cannot be found.")
    },
    {
        "debug/fbreak", cfun_debug_fbreak,
        JDOC("(debug/fbreak fun &opt pc)\n\n"
             "Set a breakpoint in a given function. pc is an optional offset, which "
             "is in bytecode instructions. fun is a function value. Will throw an error "
             "if the offset is too large or negative.")
    },
    {
        "debug/unfbreak", cfun_debug_unfbreak,
        JDOC("(debug/unfbreak fun &opt pc)\n\n"
             "Unset a breakpoint set with debug/fbreak.")
    },
    {
        "debug/arg-stack", cfun_debug_argstack,
        JDOC("(debug/arg-stack fiber)\n\n"
             "Gets all values currently on the fiber's argument stack. Normally, "
             "this should be empty unless the fiber signals while pushing arguments "
             "to make a function call. Returns a new array.")
    },
    {
        "debug/stack", cfun_debug_stack,
        JDOC("(debug/stack fib)\n\n"
             "Gets information about the stack as an array of tables. Each table "
             "in the array contains information about a stack frame. The top most, current "
             "stack frame is the first table in the array, and the bottom most stack frame "
             "is the last value. Each stack frame contains some of the following attributes:\n\n"
             "\t:c - true if the stack frame is a c function invocation\n"
             "\t:column - the current source column of the stack frame\n"
             "\t:function - the function that the stack frame represents\n"
             "\t:line - the current source line of the stack frame\n"
             "\t:name - the human friendly name of the function\n"
             "\t:pc - integer indicating the location of the program counter\n"
             "\t:source - string with the file path or other identifier for the source code\n"
             "\t:slots - array of all values in each slot\n"
             "\t:tail - boolean indicating a tail call")
    },
    {
        "debug/stacktrace", cfun_debug_stacktrace,
        JDOC("(debug/stacktrace fiber err)\n\n"
             "Prints a nice looking stacktrace for a fiber. The error message "
             "err must be passed to the function as fiber's do not keep track of "
             "the last error they have thrown. Returns the fiber.")
    },
    {
        "debug/lineage", cfun_debug_lineage,
        JDOC("(debug/lineage fib)\n\n"
             "Returns an array of all child fibers from a root fiber. This function "
             "is useful when a fiber signals or errors to an ancestor fiber. Using this function, "
             "the fiber handling the error can see which fiber raised the signal. This function should "
             "be used mostly for debugging purposes.")
    },
    {
        "debug/step", cfun_debug_step,
        JDOC("(debug/step fiber &opt x)\n\n"
             "Run a fiber for one virtual instruction of the Janet machine. Can optionally "
             "pass in a value that will be passed as the resuming value. Returns the signal value, "
             "which will usually be nil, as breakpoints raise nil signals.")
    },
    {NULL, NULL, NULL}
};

/* Module entry point */
void janet_lib_debug(JanetTable *env) {
    janet_core_cfuns(env, NULL, debug_cfuns);
}


/* src/core/emit.c */
#line 0 "src/core/emit.c"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "emit.h"
#include "vector.h"
#include "regalloc.h"
#endif

/* Get a register */
int32_t janetc_allocfar(JanetCompiler *c) {
    int32_t reg = janetc_regalloc_1(&c->scope->ra);
    if (reg > 0xFFFF) {
        janetc_cerror(c, "ran out of internal registers");
    }
    return reg;
}

/* Get a register less than 256 */
int32_t janetc_allocnear(JanetCompiler *c, JanetcRegisterTemp tag) {
    return janetc_regalloc_temp(&c->scope->ra, tag);
}

/* Emit a raw instruction with source mapping. */
void janetc_emit(JanetCompiler *c, uint32_t instr) {
    janet_v_push(c->buffer, instr);
    janet_v_push(c->mapbuffer, c->current_mapping);
}

/* Add a constant to the current scope. Return the index of the constant. */
static int32_t janetc_const(JanetCompiler *c, Janet x) {
    JanetScope *scope = c->scope;
    int32_t i, len;
    /* Get the topmost function scope */
    while (scope) {
        if (scope->flags & JANET_SCOPE_FUNCTION)
            break;
        scope = scope->parent;
    }
    /* Check if already added */
    len = janet_v_count(scope->consts);
    for (i = 0; i < len; i++) {
        if (janet_equals(x, scope->consts[i]))
            return i;
    }
    /* Ensure not too many constants. */
    if (len >= 0xFFFF) {
        janetc_cerror(c, "too many constants");
        return 0;
    }
    janet_v_push(scope->consts, x);
    return len;
}

/* Load a constant into a local register */
static void janetc_loadconst(JanetCompiler *c, Janet k, int32_t reg) {
    switch (janet_type(k)) {
        case JANET_NIL:
            janetc_emit(c, (reg << 8) | JOP_LOAD_NIL);
            break;
        case JANET_BOOLEAN:
            janetc_emit(c, (reg << 8) |
                        (janet_unwrap_boolean(k) ? JOP_LOAD_TRUE : JOP_LOAD_FALSE));
            break;
        case JANET_NUMBER: {
            double dval = janet_unwrap_number(k);
            if (dval < INT16_MIN || dval > INT16_MAX)
                goto do_constant;
            int32_t i = (int32_t) dval;
            if (dval != i)
                goto do_constant;
            uint32_t iu = (uint32_t)i;
            janetc_emit(c,
                        (iu << 16) |
                        (reg << 8) |
                        JOP_LOAD_INTEGER);
            break;
        }
        default:
        do_constant: {
                int32_t cindex = janetc_const(c, k);
                janetc_emit(c,
                            (cindex << 16) |
                            (reg << 8) |
                            JOP_LOAD_CONSTANT);
                break;
            }
    }
}

/* Move a slot to a near register */
static void janetc_movenear(JanetCompiler *c,
                            int32_t dest,
                            JanetSlot src) {
    if (src.flags & (JANET_SLOT_CONSTANT | JANET_SLOT_REF)) {
        janetc_loadconst(c, src.constant, dest);
        /* If we also are a reference, deref the one element array */
        if (src.flags & JANET_SLOT_REF) {
            janetc_emit(c,
                        (dest << 16) |
                        (dest << 8) |
                        JOP_GET_INDEX);
        }
    } else if (src.envindex >= 0) {
        janetc_emit(c,
                    ((uint32_t)(src.index) << 24) |
                    ((uint32_t)(src.envindex) << 16) |
                    ((uint32_t)(dest) << 8) |
                    JOP_LOAD_UPVALUE);
    } else if (src.index > 0xFF || src.index != dest) {
        janetc_emit(c,
                    ((uint32_t)(src.index) << 16) |
                    ((uint32_t)(dest) << 8) |
                    JOP_MOVE_NEAR);
    }
}

/* Move a near register to a Slot. */
static void janetc_moveback(JanetCompiler *c,
                            JanetSlot dest,
                            int32_t src) {
    if (dest.flags & JANET_SLOT_REF) {
        int32_t refreg = janetc_regalloc_temp(&c->scope->ra, JANETC_REGTEMP_5);
        janetc_loadconst(c, dest.constant, refreg);
        janetc_emit(c,
                    (src << 16) |
                    (refreg << 8) |
                    JOP_PUT_INDEX);
        janetc_regalloc_freetemp(&c->scope->ra, refreg, JANETC_REGTEMP_5);
    } else if (dest.envindex >= 0) {
        janetc_emit(c,
                    ((uint32_t)(dest.index) << 24) |
                    ((uint32_t)(dest.envindex) << 16) |
                    ((uint32_t)(src) << 8) |
                    JOP_SET_UPVALUE);
    } else if (dest.index != src) {
        janetc_emit(c,
                    ((uint32_t)(dest.index) << 16) |
                    ((uint32_t)(src) << 8) |
                    JOP_MOVE_FAR);
    }
}

/* Call this to release a register after emitting the instruction. */
static void janetc_free_regnear(JanetCompiler *c, JanetSlot s, int32_t reg, JanetcRegisterTemp tag) {
    if (reg != s.index ||
            s.envindex >= 0 ||
            s.flags & (JANET_SLOT_CONSTANT | JANET_SLOT_REF)) {
        /* We need to free the temporary slot */
        janetc_regalloc_freetemp(&c->scope->ra, reg, tag);
    }
}

/* Convert a slot to a two byte register */
static int32_t janetc_regfar(JanetCompiler *c, JanetSlot s, JanetcRegisterTemp tag) {
    /* check if already near register */
    if (s.envindex < 0 && s.index >= 0) {
        return s.index;
    }
    int32_t reg;
    int32_t nearreg = janetc_regalloc_temp(&c->scope->ra, tag);
    janetc_movenear(c, nearreg, s);
    if (nearreg >= 0xF0) {
        reg = janetc_allocfar(c);
        janetc_emit(c, JOP_MOVE_FAR | (nearreg << 8) | (reg << 16));
        janetc_regalloc_freetemp(&c->scope->ra, nearreg, tag);
    } else {
        reg = nearreg;
        janetc_regalloc_freetemp(&c->scope->ra, nearreg, tag);
        janetc_regalloc_touch(&c->scope->ra, reg);
    }
    return reg;
}

/* Convert a slot to a temporary 1 byte register */
static int32_t janetc_regnear(JanetCompiler *c, JanetSlot s, JanetcRegisterTemp tag) {
    /* check if already near register */
    if (s.envindex < 0 && s.index >= 0 && s.index <= 0xFF) {
        return s.index;
    }
    int32_t reg = janetc_regalloc_temp(&c->scope->ra, tag);
    janetc_movenear(c, reg, s);
    return reg;
}

/* Check if two slots are equal */
static int janetc_sequal(JanetSlot lhs, JanetSlot rhs) {
    if ((lhs.flags & ~JANET_SLOTTYPE_ANY) == (rhs.flags & ~JANET_SLOTTYPE_ANY) &&
            lhs.index == rhs.index &&
            lhs.envindex == rhs.envindex) {
        if (lhs.flags & (JANET_SLOT_REF | JANET_SLOT_CONSTANT)) {
            return janet_equals(lhs.constant, rhs.constant);
        } else {
            return 1;
        }
    }
    return 0;
}

/* Move values from one slot to another. The destination must
 * be writeable (not a literal). */
void janetc_copy(
    JanetCompiler *c,
    JanetSlot dest,
    JanetSlot src) {
    if (dest.flags & JANET_SLOT_CONSTANT) {
        janetc_cerror(c, "cannot write to constant");
        return;
    }
    if (janetc_sequal(dest, src)) return;
    /* If dest is a near register */
    if (dest.envindex < 0 && dest.index >= 0 && dest.index <= 0xFF) {
        janetc_movenear(c, dest.index, src);
        return;
    }
    /* If src is a near register */
    if (src.envindex < 0 && src.index >= 0 && src.index <= 0xFF) {
        janetc_moveback(c, dest, src.index);
        return;
    }
    /* Process: src -> near -> dest */
    int32_t nearreg = janetc_allocnear(c, JANETC_REGTEMP_3);
    janetc_movenear(c, nearreg, src);
    janetc_moveback(c, dest, nearreg);
    /* Cleanup */
    janetc_regalloc_freetemp(&c->scope->ra, nearreg, JANETC_REGTEMP_3);

}
/* Instruction templated emitters */

static int32_t emit1s(JanetCompiler *c, uint8_t op, JanetSlot s, int32_t rest, int wr) {
    int32_t reg = janetc_regnear(c, s, JANETC_REGTEMP_0);
    int32_t label = janet_v_count(c->buffer);
    janetc_emit(c, op | (reg << 8) | ((uint32_t)rest << 16));
    if (wr)
        janetc_moveback(c, s, reg);
    janetc_free_regnear(c, s, reg, JANETC_REGTEMP_0);
    return label;
}

int32_t janetc_emit_s(JanetCompiler *c, uint8_t op, JanetSlot s, int wr) {
    int32_t reg = janetc_regfar(c, s, JANETC_REGTEMP_0);
    int32_t label = janet_v_count(c->buffer);
    janetc_emit(c, op | (reg << 8));
    if (wr)
        janetc_moveback(c, s, reg);
    janetc_free_regnear(c, s, reg, JANETC_REGTEMP_0);
    return label;
}

int32_t janetc_emit_sl(JanetCompiler *c, uint8_t op, JanetSlot s, int32_t label) {
    int32_t current = janet_v_count(c->buffer) - 1;
    int32_t jump = label - current;
    if (jump < INT16_MIN || jump > INT16_MAX) {
        janetc_cerror(c, "jump is too far");
    }
    return emit1s(c, op, s, jump, 0);
}

int32_t janetc_emit_st(JanetCompiler *c, uint8_t op, JanetSlot s, int32_t tflags) {
    return emit1s(c, op, s, tflags, 0);
}

int32_t janetc_emit_si(JanetCompiler *c, uint8_t op, JanetSlot s, int16_t immediate, int wr) {
    return emit1s(c, op, s, immediate, wr);
}

int32_t janetc_emit_su(JanetCompiler *c, uint8_t op, JanetSlot s, uint16_t immediate, int wr) {
    return emit1s(c, op, s, (int32_t) immediate, wr);
}

static int32_t emit2s(JanetCompiler *c, uint8_t op, JanetSlot s1, JanetSlot s2, int32_t rest, int wr) {
    int32_t reg1 = janetc_regnear(c, s1, JANETC_REGTEMP_0);
    int32_t reg2 = janetc_regnear(c, s2, JANETC_REGTEMP_1);
    int32_t label = janet_v_count(c->buffer);
    janetc_emit(c, op | (reg1 << 8) | (reg2 << 16) | ((uint32_t)rest << 24));
    janetc_free_regnear(c, s2, reg2, JANETC_REGTEMP_1);
    if (wr)
        janetc_moveback(c, s1, reg1);
    janetc_free_regnear(c, s1, reg1, JANETC_REGTEMP_0);
    return label;
}

int32_t janetc_emit_ss(JanetCompiler *c, uint8_t op, JanetSlot s1, JanetSlot s2, int wr) {
    int32_t reg1 = janetc_regnear(c, s1, JANETC_REGTEMP_0);
    int32_t reg2 = janetc_regfar(c, s2, JANETC_REGTEMP_1);
    int32_t label = janet_v_count(c->buffer);
    janetc_emit(c, op | (reg1 << 8) | (reg2 << 16));
    janetc_free_regnear(c, s2, reg2, JANETC_REGTEMP_1);
    if (wr)
        janetc_moveback(c, s1, reg1);
    janetc_free_regnear(c, s1, reg1, JANETC_REGTEMP_0);
    return label;
}

int32_t janetc_emit_ssi(JanetCompiler *c, uint8_t op, JanetSlot s1, JanetSlot s2, int8_t immediate, int wr) {
    return emit2s(c, op, s1, s2, immediate, wr);
}

int32_t janetc_emit_ssu(JanetCompiler *c, uint8_t op, JanetSlot s1, JanetSlot s2, uint8_t immediate, int wr) {
    return emit2s(c, op, s1, s2, (int32_t) immediate, wr);
}

int32_t janetc_emit_sss(JanetCompiler *c, uint8_t op, JanetSlot s1, JanetSlot s2, JanetSlot s3, int wr) {
    int32_t reg1 = janetc_regnear(c, s1, JANETC_REGTEMP_0);
    int32_t reg2 = janetc_regnear(c, s2, JANETC_REGTEMP_1);
    int32_t reg3 = janetc_regnear(c, s3, JANETC_REGTEMP_2);
    int32_t label = janet_v_count(c->buffer);
    janetc_emit(c, op | (reg1 << 8) | (reg2 << 16) | ((uint32_t)reg3 << 24));
    janetc_free_regnear(c, s2, reg2, JANETC_REGTEMP_1);
    janetc_free_regnear(c, s3, reg3, JANETC_REGTEMP_2);
    if (wr)
        janetc_moveback(c, s1, reg1);
    janetc_free_regnear(c, s1, reg1, JANETC_REGTEMP_0);
    return label;
}


/* src/core/fiber.c */
#line 0 "src/core/fiber.c"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "fiber.h"
#include "state.h"
#include "gc.h"
#include "util.h"
#endif

static void fiber_reset(JanetFiber *fiber) {
    fiber->maxstack = JANET_STACK_MAX;
    fiber->frame = 0;
    fiber->stackstart = JANET_FRAME_SIZE;
    fiber->stacktop = JANET_FRAME_SIZE;
    fiber->child = NULL;
    fiber->flags = JANET_FIBER_MASK_YIELD | JANET_FIBER_RESUME_NO_USEVAL | JANET_FIBER_RESUME_NO_SKIP;
    fiber->env = NULL;
    janet_fiber_set_status(fiber, JANET_STATUS_NEW);
}

static JanetFiber *fiber_alloc(int32_t capacity) {
    Janet *data;
    JanetFiber *fiber = janet_gcalloc(JANET_MEMORY_FIBER, sizeof(JanetFiber));
    if (capacity < 32) {
        capacity = 32;
    }
    fiber->capacity = capacity;
    data = malloc(sizeof(Janet) * (size_t) capacity);
    if (NULL == data) {
        JANET_OUT_OF_MEMORY;
    }
    janet_vm_next_collection += sizeof(Janet) * capacity;
    fiber->data = data;
    return fiber;
}

/* Create a new fiber with argn values on the stack by reusing a fiber. */
JanetFiber *janet_fiber_reset(JanetFiber *fiber, JanetFunction *callee, int32_t argc, const Janet *argv) {
    int32_t newstacktop;
    fiber_reset(fiber);
    if (argc) {
        newstacktop = fiber->stacktop + argc;
        if (newstacktop >= fiber->capacity) {
            janet_fiber_setcapacity(fiber, 2 * newstacktop);
        }
        if (argv) {
            memcpy(fiber->data + fiber->stacktop, argv, argc * sizeof(Janet));
        } else {
            /* If argv not given, fill with nil */
            for (int32_t i = 0; i < argc; i++) {
                fiber->data[fiber->stacktop + i] = janet_wrap_nil();
            }
        }
        fiber->stacktop = newstacktop;
    }
    if (janet_fiber_funcframe(fiber, callee)) return NULL;
    janet_fiber_frame(fiber)->flags |= JANET_STACKFRAME_ENTRANCE;
    return fiber;
}

/* Create a new fiber with argn values on the stack. */
JanetFiber *janet_fiber(JanetFunction *callee, int32_t capacity, int32_t argc, const Janet *argv) {
    return janet_fiber_reset(fiber_alloc(capacity), callee, argc, argv);
}

/* Ensure that the fiber has enough extra capacity */
void janet_fiber_setcapacity(JanetFiber *fiber, int32_t n) {
    Janet *newData = realloc(fiber->data, sizeof(Janet) * n);
    if (NULL == newData) {
        JANET_OUT_OF_MEMORY;
    }
    fiber->data = newData;
    fiber->capacity = n;
}

/* Grow fiber if needed */
static void janet_fiber_grow(JanetFiber *fiber, int32_t needed) {
    int32_t cap = needed > (INT32_MAX / 2) ? INT32_MAX : 2 * needed;
    janet_fiber_setcapacity(fiber, cap);
}

/* Push a value on the next stack frame */
void janet_fiber_push(JanetFiber *fiber, Janet x) {
    if (fiber->stacktop == INT32_MAX) janet_panic("stack overflow");
    if (fiber->stacktop >= fiber->capacity) {
        janet_fiber_grow(fiber, fiber->stacktop);
    }
    fiber->data[fiber->stacktop++] = x;
}

/* Push 2 values on the next stack frame */
void janet_fiber_push2(JanetFiber *fiber, Janet x, Janet y) {
    if (fiber->stacktop >= INT32_MAX - 1) janet_panic("stack overflow");
    int32_t newtop = fiber->stacktop + 2;
    if (newtop > fiber->capacity) {
        janet_fiber_grow(fiber, newtop);
    }
    fiber->data[fiber->stacktop] = x;
    fiber->data[fiber->stacktop + 1] = y;
    fiber->stacktop = newtop;
}

/* Push 3 values on the next stack frame */
void janet_fiber_push3(JanetFiber *fiber, Janet x, Janet y, Janet z) {
    if (fiber->stacktop >= INT32_MAX - 2) janet_panic("stack overflow");
    int32_t newtop = fiber->stacktop + 3;
    if (newtop > fiber->capacity) {
        janet_fiber_grow(fiber, newtop);
    }
    fiber->data[fiber->stacktop] = x;
    fiber->data[fiber->stacktop + 1] = y;
    fiber->data[fiber->stacktop + 2] = z;
    fiber->stacktop = newtop;
}

/* Push an array on the next stack frame */
void janet_fiber_pushn(JanetFiber *fiber, const Janet *arr, int32_t n) {
    if (fiber->stacktop > INT32_MAX - n) janet_panic("stack overflow");
    int32_t newtop = fiber->stacktop + n;
    if (newtop > fiber->capacity) {
        janet_fiber_grow(fiber, newtop);
    }
    safe_memcpy(fiber->data + fiber->stacktop, arr, n * sizeof(Janet));
    fiber->stacktop = newtop;
}

/* Create a struct with n values. If n is odd, the last value is ignored. */
static Janet make_struct_n(const Janet *args, int32_t n) {
    int32_t i = 0;
    JanetKV *st = janet_struct_begin(n & (~1));
    for (; i < n; i += 2) {
        janet_struct_put(st, args[i], args[i + 1]);
    }
    return janet_wrap_struct(janet_struct_end(st));
}

/* Push a stack frame to a fiber */
int janet_fiber_funcframe(JanetFiber *fiber, JanetFunction *func) {
    JanetStackFrame *newframe;

    int32_t i;
    int32_t oldtop = fiber->stacktop;
    int32_t oldframe = fiber->frame;
    int32_t nextframe = fiber->stackstart;
    int32_t nextstacktop = nextframe + func->def->slotcount + JANET_FRAME_SIZE;
    int32_t next_arity = fiber->stacktop - fiber->stackstart;

    /* Check strict arity before messing with state */
    if (next_arity < func->def->min_arity) return 1;
    if (next_arity > func->def->max_arity) return 1;

    if (fiber->capacity < nextstacktop) {
        janet_fiber_setcapacity(fiber, 2 * nextstacktop);
    }

    /* Nil unset stack arguments (Needed for gc correctness) */
    for (i = fiber->stacktop; i < nextstacktop; ++i) {
        fiber->data[i] = janet_wrap_nil();
    }

    /* Set up the next frame */
    fiber->frame = nextframe;
    fiber->stacktop = fiber->stackstart = nextstacktop;
    newframe = janet_fiber_frame(fiber);
    newframe->prevframe = oldframe;
    newframe->pc = func->def->bytecode;
    newframe->func = func;
    newframe->env = NULL;
    newframe->flags = 0;

    /* Check varargs */
    if (func->def->flags & JANET_FUNCDEF_FLAG_VARARG) {
        int32_t tuplehead = fiber->frame + func->def->arity;
        int st = func->def->flags & JANET_FUNCDEF_FLAG_STRUCTARG;
        if (tuplehead >= oldtop) {
            fiber->data[tuplehead] = st
                                     ? make_struct_n(NULL, 0)
                                     : janet_wrap_tuple(janet_tuple_n(NULL, 0));
        } else {
            fiber->data[tuplehead] = st
                                     ? make_struct_n(
                                         fiber->data + tuplehead,
                                         oldtop - tuplehead)
                                     : janet_wrap_tuple(janet_tuple_n(
                                                 fiber->data + tuplehead,
                                                 oldtop - tuplehead));
        }
    }

    /* Good return */
    return 0;
}

/* If a frame has a closure environment, detach it from
 * the stack and have it keep its own values */
static void janet_env_detach(JanetFuncEnv *env) {
    /* Check for closure environment */
    if (env) {
        janet_env_valid(env);
        int32_t len = env->length;
        size_t s = sizeof(Janet) * (size_t) len;
        Janet *vmem = malloc(s);
        janet_vm_next_collection += (uint32_t) s;
        if (NULL == vmem) {
            JANET_OUT_OF_MEMORY;
        }
        Janet *values = env->as.fiber->data + env->offset;
        safe_memcpy(vmem, values, s);
        uint32_t *bitset = janet_stack_frame(values)->func->def->closure_bitset;
        if (bitset) {
            /* Clear unneeded references in closure environment */
            for (int32_t i = 0; i < len; i += 32) {
                uint32_t mask = ~(bitset[i >> 5]);
                int32_t maxj = i + 32 > len ? len : i + 32;
                for (int32_t j = i; j < maxj; j++) {
                    if (mask & 1) vmem[j] = janet_wrap_nil();
                    mask >>= 1;
                }
            }
        }
        env->offset = 0;
        env->as.values = vmem;
    }
}

/* Validate potentially untrusted func env (unmarshalled envs are difficult to verify) */
int janet_env_valid(JanetFuncEnv *env) {
    if (env->offset < 0) {
        int32_t real_offset = -(env->offset);
        JanetFiber *fiber = env->as.fiber;
        int32_t i = fiber->frame;
        while (i > 0) {
            JanetStackFrame *frame = (JanetStackFrame *)(fiber->data + i - JANET_FRAME_SIZE);
            if (real_offset == i &&
                    frame->env == env &&
                    frame->func &&
                    frame->func->def->slotcount == env->length) {
                env->offset = real_offset;
                return 1;
            }
            i = frame->prevframe;
        }
        /* Invalid, set to empty off-stack variant. */
        env->offset = 0;
        env->length = 0;
        env->as.values = NULL;
        return 0;
    } else {
        return 1;
    }
}

/* Detach a fiber from the env if the target fiber has stopped mutating */
void janet_env_maybe_detach(JanetFuncEnv *env) {
    /* Check for detachable closure envs */
    janet_env_valid(env);
    if (env->offset > 0) {
        JanetFiberStatus s = janet_fiber_status(env->as.fiber);
        int isFinished = s == JANET_STATUS_DEAD ||
                         s == JANET_STATUS_ERROR ||
                         s == JANET_STATUS_USER0 ||
                         s == JANET_STATUS_USER1 ||
                         s == JANET_STATUS_USER2 ||
                         s == JANET_STATUS_USER3 ||
                         s == JANET_STATUS_USER4;
        if (isFinished) {
            janet_env_detach(env);
        }
    }
}

/* Create a tail frame for a function */
int janet_fiber_funcframe_tail(JanetFiber *fiber, JanetFunction *func) {
    int32_t i;
    int32_t nextframetop = fiber->frame + func->def->slotcount;
    int32_t nextstacktop = nextframetop + JANET_FRAME_SIZE;
    int32_t next_arity = fiber->stacktop - fiber->stackstart;
    int32_t stacksize;

    /* Check strict arity before messing with state */
    if (next_arity < func->def->min_arity) return 1;
    if (next_arity > func->def->max_arity) return 1;

    if (fiber->capacity < nextstacktop) {
        janet_fiber_setcapacity(fiber, 2 * nextstacktop);
    }

    Janet *stack = fiber->data + fiber->frame;
    Janet *args = fiber->data + fiber->stackstart;

    /* Detach old function */
    if (NULL != janet_fiber_frame(fiber)->func)
        janet_env_detach(janet_fiber_frame(fiber)->env);
    janet_fiber_frame(fiber)->env = NULL;

    /* Check varargs */
    if (func->def->flags & JANET_FUNCDEF_FLAG_VARARG) {
        int32_t tuplehead = fiber->stackstart + func->def->arity;
        int st = func->def->flags & JANET_FUNCDEF_FLAG_STRUCTARG;
        if (tuplehead >= fiber->stacktop) {
            if (tuplehead >= fiber->capacity) janet_fiber_setcapacity(fiber, 2 * (tuplehead + 1));
            for (i = fiber->stacktop; i < tuplehead; ++i) fiber->data[i] = janet_wrap_nil();
            fiber->data[tuplehead] = st
                                     ? make_struct_n(NULL, 0)
                                     : janet_wrap_tuple(janet_tuple_n(NULL, 0));
        } else {
            fiber->data[tuplehead] = st
                                     ? make_struct_n(
                                         fiber->data + tuplehead,
                                         fiber->stacktop - tuplehead)
                                     : janet_wrap_tuple(janet_tuple_n(
                                                 fiber->data + tuplehead,
                                                 fiber->stacktop - tuplehead));
        }
        stacksize = tuplehead - fiber->stackstart + 1;
    } else {
        stacksize = fiber->stacktop - fiber->stackstart;
    }

    if (stacksize) memmove(stack, args, stacksize * sizeof(Janet));

    /* Nil unset locals (Needed for functional correctness) */
    for (i = fiber->frame + stacksize; i < nextframetop; ++i)
        fiber->data[i] = janet_wrap_nil();

    /* Set stack stuff */
    fiber->stacktop = fiber->stackstart = nextstacktop;

    /* Set frame stuff */
    janet_fiber_frame(fiber)->func = func;
    janet_fiber_frame(fiber)->pc = func->def->bytecode;
    janet_fiber_frame(fiber)->flags |= JANET_STACKFRAME_TAILCALL;

    /* Good return */
    return 0;
}

/* Push a stack frame to a fiber for a c function */
void janet_fiber_cframe(JanetFiber *fiber, JanetCFunction cfun) {
    JanetStackFrame *newframe;

    int32_t oldframe = fiber->frame;
    int32_t nextframe = fiber->stackstart;
    int32_t nextstacktop = fiber->stacktop + JANET_FRAME_SIZE;

    if (fiber->capacity < nextstacktop) {
        janet_fiber_setcapacity(fiber, 2 * nextstacktop);
    }

    /* Set the next frame */
    fiber->frame = nextframe;
    fiber->stacktop = fiber->stackstart = nextstacktop;
    newframe = janet_fiber_frame(fiber);

    /* Set up the new frame */
    newframe->prevframe = oldframe;
    newframe->pc = (uint32_t *) cfun;
    newframe->func = NULL;
    newframe->env = NULL;
    newframe->flags = 0;
}

/* Pop a stack frame from the fiber. Returns the new stack frame, or
 * NULL if there are no more frames */
void janet_fiber_popframe(JanetFiber *fiber) {
    JanetStackFrame *frame = janet_fiber_frame(fiber);
    if (fiber->frame == 0) return;

    /* Clean up the frame (detach environments) */
    if (NULL != frame->func)
        janet_env_detach(frame->env);

    /* Shrink stack */
    fiber->stacktop = fiber->stackstart = fiber->frame;
    fiber->frame = frame->prevframe;
}

JanetFiberStatus janet_fiber_status(JanetFiber *f) {
    return ((f)->flags & JANET_FIBER_STATUS_MASK) >> JANET_FIBER_STATUS_OFFSET;
}

JanetFiber *janet_current_fiber(void) {
    return janet_vm_fiber;
}

JanetFiber *janet_root_fiber(void) {
    return janet_vm_root_fiber;
}

/* CFuns */

static Janet cfun_fiber_getenv(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    JanetFiber *fiber = janet_getfiber(argv, 0);
    return fiber->env ?
           janet_wrap_table(fiber->env) :
           janet_wrap_nil();
}

static Janet cfun_fiber_setenv(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 2);
    JanetFiber *fiber = janet_getfiber(argv, 0);
    if (janet_checktype(argv[1], JANET_NIL)) {
        fiber->env = NULL;
    } else {
        fiber->env = janet_gettable(argv, 1);
    }
    return argv[0];
}

static Janet cfun_fiber_new(int32_t argc, Janet *argv) {
    janet_arity(argc, 1, 2);
    JanetFunction *func = janet_getfunction(argv, 0);
    JanetFiber *fiber;
    if (func->def->min_arity > 1) {
        janet_panicf("fiber function must accept 0 or 1 arguments");
    }
    fiber = janet_fiber(func, 64, func->def->min_arity, NULL);
    if (argc == 2) {
        int32_t i;
        JanetByteView view = janet_getbytes(argv, 1);
        fiber->flags = JANET_FIBER_RESUME_NO_USEVAL | JANET_FIBER_RESUME_NO_SKIP;
        janet_fiber_set_status(fiber, JANET_STATUS_NEW);
        for (i = 0; i < view.len; i++) {
            if (view.bytes[i] >= '0' && view.bytes[i] <= '9') {
                fiber->flags |= JANET_FIBER_MASK_USERN(view.bytes[i] - '0');
            } else {
                switch (view.bytes[i]) {
                    default:
                        janet_panicf("invalid flag %c, expected a, t, d, e, u, y, i, or p", view.bytes[i]);
                        break;
                    case 'a':
                        fiber->flags |=
                            JANET_FIBER_MASK_DEBUG |
                            JANET_FIBER_MASK_ERROR |
                            JANET_FIBER_MASK_USER |
                            JANET_FIBER_MASK_YIELD;
                        break;
                    case 't':
                        fiber->flags |=
                            JANET_FIBER_MASK_ERROR |
                            JANET_FIBER_MASK_USER0 |
                            JANET_FIBER_MASK_USER1 |
                            JANET_FIBER_MASK_USER2 |
                            JANET_FIBER_MASK_USER3 |
                            JANET_FIBER_MASK_USER4;
                        break;
                    case 'd':
                        fiber->flags |= JANET_FIBER_MASK_DEBUG;
                        break;
                    case 'e':
                        fiber->flags |= JANET_FIBER_MASK_ERROR;
                        break;
                    case 'u':
                        fiber->flags |= JANET_FIBER_MASK_USER;
                        break;
                    case 'y':
                        fiber->flags |= JANET_FIBER_MASK_YIELD;
                        break;
                    case 'i':
                        if (!janet_vm_fiber->env) {
                            janet_vm_fiber->env = janet_table(0);
                        }
                        fiber->env = janet_vm_fiber->env;
                        break;
                    case 'p':
                        if (!janet_vm_fiber->env) {
                            janet_vm_fiber->env = janet_table(0);
                        }
                        fiber->env = janet_table(0);
                        fiber->env->proto = janet_vm_fiber->env;
                        break;
                }
            }
        }
    }
    return janet_wrap_fiber(fiber);
}

static Janet cfun_fiber_status(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    JanetFiber *fiber = janet_getfiber(argv, 0);
    uint32_t s = janet_fiber_status(fiber);
    return janet_ckeywordv(janet_status_names[s]);
}

static Janet cfun_fiber_current(int32_t argc, Janet *argv) {
    (void) argv;
    janet_fixarity(argc, 0);
    return janet_wrap_fiber(janet_vm_fiber);
}

static Janet cfun_fiber_root(int32_t argc, Janet *argv) {
    (void) argv;
    janet_fixarity(argc, 0);
    return janet_wrap_fiber(janet_vm_root_fiber);
}

static Janet cfun_fiber_maxstack(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    JanetFiber *fiber = janet_getfiber(argv, 0);
    return janet_wrap_integer(fiber->maxstack);
}

static Janet cfun_fiber_setmaxstack(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 2);
    JanetFiber *fiber = janet_getfiber(argv, 0);
    int32_t maxs = janet_getinteger(argv, 1);
    if (maxs < 0) {
        janet_panic("expected positive integer");
    }
    fiber->maxstack = maxs;
    return argv[0];
}

static Janet cfun_fiber_can_resume(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    JanetFiber *fiber = janet_getfiber(argv, 0);
    JanetFiberStatus s = janet_fiber_status(fiber);
    int isFinished = s == JANET_STATUS_DEAD ||
                     s == JANET_STATUS_ERROR ||
                     s == JANET_STATUS_USER0 ||
                     s == JANET_STATUS_USER1 ||
                     s == JANET_STATUS_USER2 ||
                     s == JANET_STATUS_USER3 ||
                     s == JANET_STATUS_USER4;
    return janet_wrap_boolean(!isFinished);
}

static const JanetReg fiber_cfuns[] = {
    {
        "fiber/new", cfun_fiber_new,
        JDOC("(fiber/new func &opt sigmask)\n\n"
             "Create a new fiber with function body func. Can optionally "
             "take a set of signals to block from the current parent fiber "
             "when called. The mask is specified as a keyword where each character "
             "is used to indicate a signal to block. The default sigmask is :y. "
             "For example, \n\n"
             "\t(fiber/new myfun :e123)\n\n"
             "blocks error signals and user signals 1, 2 and 3. The signals are "
             "as follows: \n\n"
             "\ta - block all signals\n"
             "\td - block debug signals\n"
             "\te - block error signals\n"
             "\tt - block termination signals: error + user[0-4]\n"
             "\tu - block user signals\n"
             "\ty - block yield signals\n"
             "\t0-9 - block a specific user signal\n\n"
             "The sigmask argument also can take environment flags. If any mutually "
             "exclusive flags are present, the last flag takes precedence.\n\n"
             "\ti - inherit the environment from the current fiber\n"
             "\tp - the environment table's prototype is the current environment table")
    },
    {
        "fiber/status", cfun_fiber_status,
        JDOC("(fiber/status fib)\n\n"
             "Get the status of a fiber. The status will be one of:\n\n"
             "\t:dead - the fiber has finished\n"
             "\t:error - the fiber has errored out\n"
             "\t:debug - the fiber is suspended in debug mode\n"
             "\t:pending - the fiber has been yielded\n"
             "\t:user(0-9) - the fiber is suspended by a user signal\n"
             "\t:alive - the fiber is currently running and cannot be resumed\n"
             "\t:new - the fiber has just been created and not yet run")
    },
    {
        "fiber/root", cfun_fiber_root,
        JDOC("(fiber/root)\n\n"
             "Returns the current root fiber. The root fiber is the oldest ancestor "
             "that does not have a parent.")
    },
    {
        "fiber/current", cfun_fiber_current,
        JDOC("(fiber/current)\n\n"
             "Returns the currently running fiber.")
    },
    {
        "fiber/maxstack", cfun_fiber_maxstack,
        JDOC("(fiber/maxstack fib)\n\n"
             "Gets the maximum stack size in janet values allowed for a fiber. While memory for "
             "the fiber's stack is not allocated up front, the fiber will not allocated more "
             "than this amount and will throw a stack-overflow error if more memory is needed. ")
    },
    {
        "fiber/setmaxstack", cfun_fiber_setmaxstack,
        JDOC("(fiber/setmaxstack fib maxstack)\n\n"
             "Sets the maximum stack size in janet values for a fiber. By default, the "
             "maximum stack size is usually 8192.")
    },
    {
        "fiber/getenv", cfun_fiber_getenv,
        JDOC("(fiber/getenv fiber)\n\n"
             "Gets the environment for a fiber. Returns nil if no such table is "
             "set yet.")
    },
    {
        "fiber/setenv", cfun_fiber_setenv,
        JDOC("(fiber/setenv fiber table)\n\n"
             "Sets the environment table for a fiber. Set to nil to remove the current "
             "environment.")
    },
    {
        "fiber/can-resume?", cfun_fiber_can_resume,
        JDOC("(fiber/can-resume? fiber)\n\n"
             "Check if a fiber is finished and cannot be resumed.")
    },
    {NULL, NULL, NULL}
};

/* Module entry point */
void janet_lib_fiber(JanetTable *env) {
    janet_core_cfuns(env, NULL, fiber_cfuns);
}


/* src/core/gc.c */
#line 0 "src/core/gc.c"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "state.h"
#include "symcache.h"
#include "gc.h"
#include "util.h"
#include "fiber.h"
#endif

struct JanetScratch {
    JanetScratchFinalizer finalize;
    long long mem[]; /* for proper alignment */
};

/* GC State */
JANET_THREAD_LOCAL void *janet_vm_blocks;
JANET_THREAD_LOCAL size_t janet_vm_gc_interval;
JANET_THREAD_LOCAL size_t janet_vm_next_collection;
JANET_THREAD_LOCAL int janet_vm_gc_suspend = 0;

/* Roots */
JANET_THREAD_LOCAL Janet *janet_vm_roots;
JANET_THREAD_LOCAL size_t janet_vm_root_count;
JANET_THREAD_LOCAL size_t janet_vm_root_capacity;

/* Scratch Memory */
JANET_THREAD_LOCAL JanetScratch **janet_scratch_mem;
JANET_THREAD_LOCAL size_t janet_scratch_cap;
JANET_THREAD_LOCAL size_t janet_scratch_len;

/* Helpers for marking the various gc types */
static void janet_mark_funcenv(JanetFuncEnv *env);
static void janet_mark_funcdef(JanetFuncDef *def);
static void janet_mark_function(JanetFunction *func);
static void janet_mark_array(JanetArray *array);
static void janet_mark_table(JanetTable *table);
static void janet_mark_struct(const JanetKV *st);
static void janet_mark_tuple(const Janet *tuple);
static void janet_mark_buffer(JanetBuffer *buffer);
static void janet_mark_string(const uint8_t *str);
static void janet_mark_fiber(JanetFiber *fiber);
static void janet_mark_abstract(void *adata);

/* Local state that is only temporary for gc */
static JANET_THREAD_LOCAL uint32_t depth = JANET_RECURSION_GUARD;
static JANET_THREAD_LOCAL size_t orig_rootcount;

/* Hint to the GC that we may need to collect */
void janet_gcpressure(size_t s) {
    janet_vm_next_collection += s;
}

/* Mark a value */
void janet_mark(Janet x) {
    if (depth) {
        depth--;
        switch (janet_type(x)) {
            default:
                break;
            case JANET_STRING:
            case JANET_KEYWORD:
            case JANET_SYMBOL:
                janet_mark_string(janet_unwrap_string(x));
                break;
            case JANET_FUNCTION:
                janet_mark_function(janet_unwrap_function(x));
                break;
            case JANET_ARRAY:
                janet_mark_array(janet_unwrap_array(x));
                break;
            case JANET_TABLE:
                janet_mark_table(janet_unwrap_table(x));
                break;
            case JANET_STRUCT:
                janet_mark_struct(janet_unwrap_struct(x));
                break;
            case JANET_TUPLE:
                janet_mark_tuple(janet_unwrap_tuple(x));
                break;
            case JANET_BUFFER:
                janet_mark_buffer(janet_unwrap_buffer(x));
                break;
            case JANET_FIBER:
                janet_mark_fiber(janet_unwrap_fiber(x));
                break;
            case JANET_ABSTRACT:
                janet_mark_abstract(janet_unwrap_abstract(x));
                break;
        }
        depth++;
    } else {
        janet_gcroot(x);
    }
}

static void janet_mark_string(const uint8_t *str) {
    janet_gc_mark(janet_string_head(str));
}

static void janet_mark_buffer(JanetBuffer *buffer) {
    janet_gc_mark(buffer);
}

static void janet_mark_abstract(void *adata) {
    if (janet_gc_reachable(janet_abstract_head(adata)))
        return;
    janet_gc_mark(janet_abstract_head(adata));
    if (janet_abstract_head(adata)->type->gcmark) {
        janet_abstract_head(adata)->type->gcmark(adata, janet_abstract_size(adata));
    }
}

/* Mark a bunch of items in memory */
static void janet_mark_many(const Janet *values, int32_t n) {
    const Janet *end = values + n;
    while (values < end) {
        janet_mark(*values);
        values += 1;
    }
}

/* Mark a bunch of key values items in memory */
static void janet_mark_kvs(const JanetKV *kvs, int32_t n) {
    const JanetKV *end = kvs + n;
    while (kvs < end) {
        janet_mark(kvs->key);
        janet_mark(kvs->value);
        kvs++;
    }
}

static void janet_mark_array(JanetArray *array) {
    if (janet_gc_reachable(array))
        return;
    janet_gc_mark(array);
    janet_mark_many(array->data, array->count);
}

static void janet_mark_table(JanetTable *table) {
recur: /* Manual tail recursion */
    if (janet_gc_reachable(table))
        return;
    janet_gc_mark(table);
    janet_mark_kvs(table->data, table->capacity);
    if (table->proto) {
        table = table->proto;
        goto recur;
    }
}

static void janet_mark_struct(const JanetKV *st) {
    if (janet_gc_reachable(janet_struct_head(st)))
        return;
    janet_gc_mark(janet_struct_head(st));
    janet_mark_kvs(st, janet_struct_capacity(st));
}

static void janet_mark_tuple(const Janet *tuple) {
    if (janet_gc_reachable(janet_tuple_head(tuple)))
        return;
    janet_gc_mark(janet_tuple_head(tuple));
    janet_mark_many(tuple, janet_tuple_length(tuple));
}

/* Helper to mark function environments */
static void janet_mark_funcenv(JanetFuncEnv *env) {
    if (janet_gc_reachable(env))
        return;
    janet_gc_mark(env);
    /* If closure env references a dead fiber, we can just copy out the stack frame we need so
     * we don't need to keep around the whole dead fiber. */
    janet_env_maybe_detach(env);
    if (env->offset > 0) {
        /* On stack */
        janet_mark_fiber(env->as.fiber);
    } else {
        /* Not on stack */
        janet_mark_many(env->as.values, env->length);
    }
}

/* GC helper to mark a FuncDef */
static void janet_mark_funcdef(JanetFuncDef *def) {
    int32_t i;
    if (janet_gc_reachable(def))
        return;
    janet_gc_mark(def);
    janet_mark_many(def->constants, def->constants_length);
    for (i = 0; i < def->defs_length; ++i) {
        janet_mark_funcdef(def->defs[i]);
    }
    if (def->source)
        janet_mark_string(def->source);
    if (def->name)
        janet_mark_string(def->name);
}

static void janet_mark_function(JanetFunction *func) {
    int32_t i;
    int32_t numenvs;
    if (janet_gc_reachable(func))
        return;
    janet_gc_mark(func);
    numenvs = func->def->environments_length;
    for (i = 0; i < numenvs; ++i) {
        janet_mark_funcenv(func->envs[i]);
    }
    janet_mark_funcdef(func->def);
}

static void janet_mark_fiber(JanetFiber *fiber) {
    int32_t i, j;
    JanetStackFrame *frame;
recur:
    if (janet_gc_reachable(fiber))
        return;
    janet_gc_mark(fiber);

    /* Mark values on the argument stack */
    janet_mark_many(fiber->data + fiber->stackstart,
                    fiber->stacktop - fiber->stackstart);

    i = fiber->frame;
    j = fiber->stackstart - JANET_FRAME_SIZE;
    while (i > 0) {
        frame = (JanetStackFrame *)(fiber->data + i - JANET_FRAME_SIZE);
        if (NULL != frame->func)
            janet_mark_function(frame->func);
        if (NULL != frame->env)
            janet_mark_funcenv(frame->env);
        /* Mark all values in the stack frame */
        janet_mark_many(fiber->data + i, j - i);
        j = i - JANET_FRAME_SIZE;
        i = frame->prevframe;
    }

    if (fiber->env)
        janet_mark_table(fiber->env);

    /* Explicit tail recursion */
    if (fiber->child) {
        fiber = fiber->child;
        goto recur;
    }
}

/* Deinitialize a block of memory */
static void janet_deinit_block(JanetGCObject *mem) {
    switch (mem->flags & JANET_MEM_TYPEBITS) {
        default:
        case JANET_MEMORY_FUNCTION:
            break; /* Do nothing for non gc types */
        case JANET_MEMORY_SYMBOL:
            janet_symbol_deinit(((JanetStringHead *) mem)->data);
            break;
        case JANET_MEMORY_ARRAY:
            free(((JanetArray *) mem)->data);
            break;
        case JANET_MEMORY_TABLE:
            free(((JanetTable *) mem)->data);
            break;
        case JANET_MEMORY_FIBER:
            free(((JanetFiber *)mem)->data);
            break;
        case JANET_MEMORY_BUFFER:
            janet_buffer_deinit((JanetBuffer *) mem);
            break;
        case JANET_MEMORY_ABSTRACT: {
            JanetAbstractHead *head = (JanetAbstractHead *)mem;
            if (head->type->gc) {
                janet_assert(!head->type->gc(head->data, head->size), "finalizer failed");
            }
        }
        break;
        case JANET_MEMORY_FUNCENV: {
            JanetFuncEnv *env = (JanetFuncEnv *)mem;
            if (0 == env->offset)
                free(env->as.values);
        }
        break;
        case JANET_MEMORY_FUNCDEF: {
            JanetFuncDef *def = (JanetFuncDef *)mem;
            /* TODO - get this all with one alloc and one free */
            free(def->defs);
            free(def->environments);
            free(def->constants);
            free(def->bytecode);
            free(def->sourcemap);
            free(def->closure_bitset);
        }
        break;
    }
}

/* Iterate over all allocated memory, and free memory that is not
 * marked as reachable. Flip the gc color flag for next sweep. */
void janet_sweep() {
    JanetGCObject *previous = NULL;
    JanetGCObject *current = janet_vm_blocks;
    JanetGCObject *next;
    while (NULL != current) {
        next = current->next;
        if (current->flags & (JANET_MEM_REACHABLE | JANET_MEM_DISABLED)) {
            previous = current;
            current->flags &= ~JANET_MEM_REACHABLE;
        } else {
            janet_deinit_block(current);
            if (NULL != previous) {
                previous->next = next;
            } else {
                janet_vm_blocks = next;
            }
            free(current);
        }
        current = next;
    }
}

/* Allocate some memory that is tracked for garbage collection */
void *janet_gcalloc(enum JanetMemoryType type, size_t size) {
    JanetGCObject *mem;

    /* Make sure everything is inited */
    janet_assert(NULL != janet_vm_cache, "please initialize janet before use");
    mem = malloc(size);

    /* Check for bad malloc */
    if (NULL == mem) {
        JANET_OUT_OF_MEMORY;
    }

    /* Configure block */
    mem->flags = type;

    /* Prepend block to heap list */
    janet_vm_next_collection += size;
    mem->next = janet_vm_blocks;
    janet_vm_blocks = mem;

    return (void *)mem;
}

static void free_one_scratch(JanetScratch *s) {
    if (NULL != s->finalize) {
        s->finalize((char *) s->mem);
    }
    free(s);
}

/* Free all allocated scratch memory */
static void janet_free_all_scratch(void) {
    for (size_t i = 0; i < janet_scratch_len; i++) {
        free_one_scratch(janet_scratch_mem[i]);
    }
    janet_scratch_len = 0;
}

static JanetScratch *janet_mem2scratch(void *mem) {
    JanetScratch *s = (JanetScratch *)mem;
    return s - 1;
}

/* Run garbage collection */
void janet_collect(void) {
    uint32_t i;
    if (janet_vm_gc_suspend) return;
    depth = JANET_RECURSION_GUARD;
    orig_rootcount = janet_vm_root_count;
#ifdef JANET_NET
    janet_net_markloop();
#endif
    for (i = 0; i < orig_rootcount; i++)
        janet_mark(janet_vm_roots[i]);
    while (orig_rootcount < janet_vm_root_count) {
        Janet x = janet_vm_roots[--janet_vm_root_count];
        janet_mark(x);
    }
    janet_sweep();
    janet_vm_next_collection = 0;
    janet_free_all_scratch();
}

/* Add a root value to the GC. This prevents the GC from removing a value
 * and all of its children. If gcroot is called on a value n times, unroot
 * must also be called n times to remove it as a gc root. */
void janet_gcroot(Janet root) {
    size_t newcount = janet_vm_root_count + 1;
    if (newcount > janet_vm_root_capacity) {
        size_t newcap = 2 * newcount;
        janet_vm_roots = realloc(janet_vm_roots, sizeof(Janet) * newcap);
        if (NULL == janet_vm_roots) {
            JANET_OUT_OF_MEMORY;
        }
        janet_vm_root_capacity = newcap;
    }
    janet_vm_roots[janet_vm_root_count] = root;
    janet_vm_root_count = newcount;
}

/* Identity equality for GC purposes */
static int janet_gc_idequals(Janet lhs, Janet rhs) {
    if (janet_type(lhs) != janet_type(rhs))
        return 0;
    switch (janet_type(lhs)) {
        case JANET_BOOLEAN:
        case JANET_NIL:
        case JANET_NUMBER:
            /* These values don't really matter to the gc so returning 1 all the time is fine. */
            return 1;
        default:
            return janet_unwrap_pointer(lhs) == janet_unwrap_pointer(rhs);
    }
}

/* Remove a root value from the GC. This allows the gc to potentially reclaim
 * a value and all its children. */
int janet_gcunroot(Janet root) {
    Janet *vtop = janet_vm_roots + janet_vm_root_count;
    /* Search from top to bottom as access is most likely LIFO */
    for (Janet *v = janet_vm_roots; v < vtop; v++) {
        if (janet_gc_idequals(root, *v)) {
            *v = janet_vm_roots[--janet_vm_root_count];
            return 1;
        }
    }
    return 0;
}

/* Remove a root value from the GC. This sets the effective reference count to 0. */
int janet_gcunrootall(Janet root) {
    Janet *vtop = janet_vm_roots + janet_vm_root_count;
    int ret = 0;
    /* Search from top to bottom as access is most likely LIFO */
    for (Janet *v = janet_vm_roots; v < vtop; v++) {
        if (janet_gc_idequals(root, *v)) {
            *v = janet_vm_roots[--janet_vm_root_count];
            vtop--;
            ret = 1;
        }
    }
    return ret;
}

/* Free all allocated memory */
void janet_clear_memory(void) {
    JanetGCObject *current = janet_vm_blocks;
    while (NULL != current) {
        janet_deinit_block(current);
        JanetGCObject *next = current->next;
        free(current);
        current = next;
    }
    janet_vm_blocks = NULL;
    janet_free_all_scratch();
    free(janet_scratch_mem);
}

/* Primitives for suspending GC. */
int janet_gclock(void) {
    return janet_vm_gc_suspend++;
}
void janet_gcunlock(int handle) {
    janet_vm_gc_suspend = handle;
}

/* Scratch memory API */

void *janet_smalloc(size_t size) {
    JanetScratch *s = malloc(sizeof(JanetScratch) + size);
    if (NULL == s) {
        JANET_OUT_OF_MEMORY;
    }
    s->finalize = NULL;
    if (janet_scratch_len == janet_scratch_cap) {
        size_t newcap = 2 * janet_scratch_cap + 2;
        JanetScratch **newmem = (JanetScratch **) realloc(janet_scratch_mem, newcap * sizeof(JanetScratch));
        if (NULL == newmem) {
            JANET_OUT_OF_MEMORY;
        }
        janet_scratch_cap = newcap;
        janet_scratch_mem = newmem;
    }
    janet_scratch_mem[janet_scratch_len++] = s;
    return (char *)(s->mem);
}

void *janet_scalloc(size_t nmemb, size_t size) {
    if (nmemb && size > SIZE_MAX / nmemb) {
        JANET_OUT_OF_MEMORY;
    }
    size_t n = nmemb * size;
    void *p = janet_smalloc(n);
    memset(p, 0, n);
    return p;
}

void *janet_srealloc(void *mem, size_t size) {
    if (NULL == mem) return janet_smalloc(size);
    JanetScratch *s = janet_mem2scratch(mem);
    if (janet_scratch_len) {
        for (size_t i = janet_scratch_len - 1; ; i--) {
            if (janet_scratch_mem[i] == s) {
                JanetScratch *news = realloc(s, size + sizeof(JanetScratch));
                if (NULL == news) {
                    JANET_OUT_OF_MEMORY;
                }
                janet_scratch_mem[i] = news;
                return (char *)(news->mem);
            }
            if (i == 0) break;
        }
    }
    JANET_EXIT("invalid janet_srealloc");
}

void janet_sfinalizer(void *mem, JanetScratchFinalizer finalizer) {
    JanetScratch *s = janet_mem2scratch(mem);
    s->finalize = finalizer;
}

void janet_sfree(void *mem) {
    if (NULL == mem) return;
    JanetScratch *s = janet_mem2scratch(mem);
    if (janet_scratch_len) {
        for (size_t i = janet_scratch_len - 1; ; i--) {
            if (janet_scratch_mem[i] == s) {
                janet_scratch_mem[i] = janet_scratch_mem[--janet_scratch_len];
                free_one_scratch(s);
                return;
            }
            if (i == 0) break;
        }
    }
    JANET_EXIT("invalid janet_sfree");
}


/* src/core/inttypes.c */
#line 0 "src/core/inttypes.c"

/*
* Copyright (c) 2020 Calvin Rose & contributors
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#include <errno.h>
#include <stdlib.h>
#include <limits.h>
#include <inttypes.h>
#include <math.h>

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "util.h"
#endif

/* Conditional compilation */
#ifdef JANET_INT_TYPES

#define MAX_INT_IN_DBL 9007199254740992ULL /* 2^53 */

static int it_s64_get(void *p, Janet key, Janet *out);
static int it_u64_get(void *p, Janet key, Janet *out);

static int32_t janet_int64_hash(void *p1, size_t size) {
    (void) size;
    int32_t *words = p1;
    return words[0] ^ words[1];
}

static int janet_int64_compare(void *p1, void *p2) {
    int64_t x = *((int64_t *)p1);
    int64_t y = *((int64_t *)p2);
    return x == y ? 0 : x < y ? -1 : 1;
}

static int janet_uint64_compare(void *p1, void *p2) {
    uint64_t x = *((uint64_t *)p1);
    uint64_t y = *((uint64_t *)p2);
    return x == y ? 0 : x < y ? -1 : 1;
}

static void int64_marshal(void *p, JanetMarshalContext *ctx) {
    janet_marshal_abstract(ctx, p);
    janet_marshal_int64(ctx, *((int64_t *)p));
}

static void *int64_unmarshal(JanetMarshalContext *ctx) {
    int64_t *p = janet_unmarshal_abstract(ctx, sizeof(int64_t));
    p[0] = janet_unmarshal_int64(ctx);
    return p;
}

static void it_s64_tostring(void *p, JanetBuffer *buffer) {
    char str[32];
    sprintf(str, "%" PRId64, *((int64_t *)p));
    janet_buffer_push_cstring(buffer, str);
}

static void it_u64_tostring(void *p, JanetBuffer *buffer) {
    char str[32];
    sprintf(str, "%" PRIu64, *((uint64_t *)p));
    janet_buffer_push_cstring(buffer, str);
}

const JanetAbstractType janet_s64_type = {
    "core/s64",
    NULL,
    NULL,
    it_s64_get,
    NULL,
    int64_marshal,
    int64_unmarshal,
    it_s64_tostring,
    janet_int64_compare,
    janet_int64_hash,
    JANET_ATEND_HASH
};

const JanetAbstractType janet_u64_type = {
    "core/u64",
    NULL,
    NULL,
    it_u64_get,
    NULL,
    int64_marshal,
    int64_unmarshal,
    it_u64_tostring,
    janet_uint64_compare,
    janet_int64_hash,
    JANET_ATEND_HASH
};

int64_t janet_unwrap_s64(Janet x) {
    switch (janet_type(x)) {
        default:
            break;
        case JANET_NUMBER : {
            double dbl = janet_unwrap_number(x);
            if (fabs(dbl) <=  MAX_INT_IN_DBL)
                return (int64_t)dbl;
            break;
        }
        case JANET_STRING: {
            int64_t value;
            const uint8_t *str = janet_unwrap_string(x);
            if (janet_scan_int64(str, janet_string_length(str), &value))
                return value;
            break;
        }
        case JANET_ABSTRACT: {
            void *abst = janet_unwrap_abstract(x);
            if (janet_abstract_type(abst) == &janet_s64_type ||
                    (janet_abstract_type(abst) == &janet_u64_type))
                return *(int64_t *)abst;
            break;
        }
    }
    janet_panic("bad s64 initializer");
    return 0;
}

uint64_t janet_unwrap_u64(Janet x) {
    switch (janet_type(x)) {
        default:
            break;
        case JANET_NUMBER : {
            double dbl = janet_unwrap_number(x);
            if ((dbl >= 0) && (dbl <= MAX_INT_IN_DBL))
                return (uint64_t)dbl;
            break;
        }
        case JANET_STRING: {
            uint64_t value;
            const uint8_t *str = janet_unwrap_string(x);
            if (janet_scan_uint64(str, janet_string_length(str), &value))
                return value;
            break;
        }
        case JANET_ABSTRACT: {
            void *abst = janet_unwrap_abstract(x);
            if (janet_abstract_type(abst) == &janet_s64_type ||
                    (janet_abstract_type(abst) == &janet_u64_type))
                return *(uint64_t *)abst;
            break;
        }
    }
    janet_panic("bad u64 initializer");
    return 0;
}

JanetIntType janet_is_int(Janet x) {
    if (!janet_checktype(x, JANET_ABSTRACT)) return JANET_INT_NONE;
    const JanetAbstractType *at = janet_abstract_type(janet_unwrap_abstract(x));
    return (at == &janet_s64_type) ? JANET_INT_S64 :
           ((at == &janet_u64_type) ? JANET_INT_U64 :
            JANET_INT_NONE);
}

Janet janet_wrap_s64(int64_t x) {
    int64_t *box = janet_abstract(&janet_s64_type, sizeof(int64_t));
    *box = (int64_t)x;
    return janet_wrap_abstract(box);
}

Janet janet_wrap_u64(uint64_t x) {
    uint64_t *box = janet_abstract(&janet_u64_type, sizeof(uint64_t));
    *box = (uint64_t)x;
    return janet_wrap_abstract(box);
}

static Janet cfun_it_s64_new(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    return janet_wrap_s64(janet_unwrap_s64(argv[0]));
}

static Janet cfun_it_u64_new(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    return janet_wrap_u64(janet_unwrap_u64(argv[0]));
}

// Code to support polymorphic comparison.
//
// int/u64 and int/s64 support a "compare" method that allows
// comparison to each other, and to Janet numbers, using the
// "compare" "compare<" ... functions.
//
// In the following code explicit casts are sometimes used to help
// make it clear when int/float conversions are happening.
//
static int compare_double_double(double x, double y) {
    return (x < y) ? -1 : ((x > y) ? 1 : 0);
}

static int compare_int64_double(int64_t x, double y) {
    if (isnan(y)) {
        return 0; // clojure and python do this
    } else if ((y > (- ((double) MAX_INT_IN_DBL))) && (y < ((double) MAX_INT_IN_DBL))) {
        double dx = (double) x;
        return compare_double_double(dx, y);
    } else if (y > ((double) INT64_MAX)) {
        return -1;
    } else if (y < ((double) INT64_MIN)) {
        return 1;
    } else {
        int64_t yi = (int64_t) y;
        return (x < yi) ? -1 : ((x > yi) ? 1 : 0);
    }
}

static int compare_uint64_double(uint64_t x, double y) {
    if (isnan(y)) {
        return 0; // clojure and python do this
    } else if (y < 0) {
        return 1;
    } else if ((y >= 0) && (y < ((double) MAX_INT_IN_DBL))) {
        double dx = (double) x;
        return compare_double_double(dx, y);
    } else if (y > ((double) UINT64_MAX)) {
        return -1;
    } else {
        uint64_t yi = (uint64_t) y;
        return (x < yi) ? -1 : ((x > yi) ? 1 : 0);
    }
}


static Janet cfun_it_s64_compare(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 2);
    if (janet_is_int(argv[0]) != JANET_INT_S64)
        janet_panic("compare method requires int/s64 as first argument");
    int64_t x = janet_unwrap_s64(argv[0]);
    switch (janet_type(argv[1])) {
        default:
            break;
        case JANET_NUMBER : {
            double y = janet_unwrap_number(argv[1]);
            return janet_wrap_number(compare_int64_double(x, y));
        }
        case JANET_ABSTRACT: {
            void *abst = janet_unwrap_abstract(argv[1]);
            if (janet_abstract_type(abst) == &janet_s64_type) {
                int64_t y = *(int64_t *)abst;
                return janet_wrap_number((x < y) ? -1 : (x > y ? 1 : 0));
            } else if (janet_abstract_type(abst) == &janet_u64_type) {
                // comparing signed to unsigned -- be careful!
                uint64_t y = *(uint64_t *)abst;
                if (x < 0) {
                    return janet_wrap_number(-1);
                } else if (y > INT64_MAX) {
                    return janet_wrap_number(-1);
                } else {
                    int64_t y2 = (int64_t) y;
                    return janet_wrap_number((x < y2) ? -1 : (x > y2 ? 1 : 0));
                }
            }
            break;
        }
    }
    return janet_wrap_nil();
}

static Janet cfun_it_u64_compare(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 2);
    if (janet_is_int(argv[0]) != JANET_INT_U64)  // is this needed?
        janet_panic("compare method requires int/u64 as first argument");
    uint64_t x = janet_unwrap_u64(argv[0]);
    switch (janet_type(argv[1])) {
        default:
            break;
        case JANET_NUMBER : {
            double y = janet_unwrap_number(argv[1]);
            return janet_wrap_number(compare_uint64_double(x, y));
        }
        case JANET_ABSTRACT: {
            void *abst = janet_unwrap_abstract(argv[1]);
            if (janet_abstract_type(abst) == &janet_u64_type) {
                uint64_t y = *(uint64_t *)abst;
                return janet_wrap_number((x < y) ? -1 : (x > y ? 1 : 0));
            } else if (janet_abstract_type(abst) == &janet_s64_type) {
                // comparing unsigned to signed -- be careful!
                int64_t y = *(int64_t *)abst;
                if (y < 0) {
                    return janet_wrap_number(1);
                } else if (x > INT64_MAX) {
                    return janet_wrap_number(1);
                } else {
                    int64_t x2 = (int64_t) x;
                    return janet_wrap_number((x2 < y) ? -1 : (x2 > y ? 1 : 0));
                }
            }
            break;
        }
    }
    return janet_wrap_nil();
}

#define OPMETHOD(T, type, name, oper) \
static Janet cfun_it_##type##_##name(int32_t argc, Janet *argv) { \
    janet_arity(argc, 2, -1); \
    T *box = janet_abstract(&janet_##type##_type, sizeof(T)); \
    *box = janet_unwrap_##type(argv[0]); \
    for (int32_t i = 1; i < argc; i++) \
        *box oper##= janet_unwrap_##type(argv[i]); \
    return janet_wrap_abstract(box); \
} \

#define OPMETHODINVERT(T, type, name, oper) \
static Janet cfun_it_##type##_##name(int32_t argc, Janet *argv) { \
    janet_fixarity(argc, 2); \
    T *box = janet_abstract(&janet_##type##_type, sizeof(T)); \
    *box = janet_unwrap_##type(argv[1]); \
    *box oper##= janet_unwrap_##type(argv[0]); \
    return janet_wrap_abstract(box); \
} \

#define DIVMETHOD(T, type, name, oper) \
static Janet cfun_it_##type##_##name(int32_t argc, Janet *argv) { \
    janet_arity(argc, 2, -1);                       \
    T *box = janet_abstract(&janet_##type##_type, sizeof(T)); \
    *box = janet_unwrap_##type(argv[0]); \
    for (int32_t i = 1; i < argc; i++) { \
      T value = janet_unwrap_##type(argv[i]); \
      if (value == 0) janet_panic("division by zero"); \
      *box oper##= value; \
    } \
    return janet_wrap_abstract(box); \
} \

#define DIVMETHODINVERT(T, type, name, oper) \
static Janet cfun_it_##type##_##name(int32_t argc, Janet *argv) { \
    janet_fixarity(argc, 2);                       \
    T *box = janet_abstract(&janet_##type##_type, sizeof(T)); \
    *box = janet_unwrap_##type(argv[1]); \
    T value = janet_unwrap_##type(argv[0]); \
    if (value == 0) janet_panic("division by zero"); \
    *box oper##= value; \
    return janet_wrap_abstract(box); \
} \

#define DIVMETHOD_SIGNED(T, type, name, oper) \
static Janet cfun_it_##type##_##name(int32_t argc, Janet *argv) { \
    janet_arity(argc, 2, -1);                       \
    T *box = janet_abstract(&janet_##type##_type, sizeof(T)); \
    *box = janet_unwrap_##type(argv[0]); \
    for (int32_t i = 1; i < argc; i++) { \
      T value = janet_unwrap_##type(argv[i]); \
      if (value == 0) janet_panic("division by zero"); \
      if ((value == -1) && (*box == INT64_MIN)) janet_panic("INT64_MIN divided by -1"); \
      *box oper##= value; \
    } \
    return janet_wrap_abstract(box); \
} \

#define DIVMETHODINVERT_SIGNED(T, type, name, oper) \
static Janet cfun_it_##type##_##name(int32_t argc, Janet *argv) { \
    janet_fixarity(argc, 2);                       \
    T *box = janet_abstract(&janet_##type##_type, sizeof(T)); \
    *box = janet_unwrap_##type(argv[1]); \
    T value = janet_unwrap_##type(argv[0]); \
    if (value == 0) janet_panic("division by zero"); \
    if ((value == -1) && (*box == INT64_MIN)) janet_panic("INT64_MIN divided by -1"); \
    *box oper##= value; \
    return janet_wrap_abstract(box); \
} \

static Janet cfun_it_s64_mod(int32_t argc, Janet *argv) {
    janet_arity(argc, 2, -1);
    int64_t *box = janet_abstract(&janet_s64_type, sizeof(int64_t));
    *box = janet_unwrap_s64(argv[0]);
    for (int32_t i = 1; i < argc; i++) {
        int64_t value = janet_unwrap_s64(argv[i]);
        if (value == 0) janet_panic("division by zero");
        int64_t x = *box % value;
        if (x < 0) {
            x = (*box < 0) ? x - *box : x + *box;
        }
        *box = x;
    }
    return janet_wrap_abstract(box);
}

static Janet cfun_it_s64_modi(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 2);
    int64_t *box = janet_abstract(&janet_s64_type, sizeof(int64_t));
    int64_t op1 = janet_unwrap_s64(argv[0]);
    int64_t op2 = janet_unwrap_s64(argv[1]);
    int64_t x = op1 % op2;
    if (x < 0) {
        x = (op1 < 0) ? x - op1 : x + op1;
    }
    *box = x;
    return janet_wrap_abstract(box);
}

OPMETHOD(int64_t, s64, add, +)
OPMETHOD(int64_t, s64, sub, -)
OPMETHODINVERT(int64_t, s64, subi, -)
OPMETHOD(int64_t, s64, mul, *)
DIVMETHOD_SIGNED(int64_t, s64, div, /)
DIVMETHOD_SIGNED(int64_t, s64, rem, %)
DIVMETHODINVERT_SIGNED(int64_t, s64, divi, /)
DIVMETHODINVERT_SIGNED(int64_t, s64, remi, %)
OPMETHOD(int64_t, s64, and, &)
OPMETHOD(int64_t, s64, or, |)
OPMETHOD(int64_t, s64, xor, ^)
OPMETHOD(int64_t, s64, lshift, <<)
OPMETHOD(int64_t, s64, rshift, >>)
OPMETHOD(uint64_t, u64, add, +)
OPMETHOD(uint64_t, u64, sub, -)
OPMETHODINVERT(uint64_t, u64, subi, -)
OPMETHOD(uint64_t, u64, mul, *)
DIVMETHOD(uint64_t, u64, div, /)
DIVMETHOD(uint64_t, u64, mod, %)
DIVMETHODINVERT(uint64_t, u64, divi, /)
DIVMETHODINVERT(uint64_t, u64, modi, %)
OPMETHOD(uint64_t, u64, and, &)
OPMETHOD(uint64_t, u64, or, |)
OPMETHOD(uint64_t, u64, xor, ^)
OPMETHOD(uint64_t, u64, lshift, <<)
OPMETHOD(uint64_t, u64, rshift, >>)

#undef OPMETHOD
#undef DIVMETHOD
#undef DIVMETHOD_SIGNED
#undef COMPMETHOD


static JanetMethod it_s64_methods[] = {
    {"+", cfun_it_s64_add},
    {"r+", cfun_it_s64_add},
    {"-", cfun_it_s64_sub},
    {"r-", cfun_it_s64_subi},
    {"*", cfun_it_s64_mul},
    {"r*", cfun_it_s64_mul},
    {"/", cfun_it_s64_div},
    {"r/", cfun_it_s64_divi},
    {"mod", cfun_it_s64_mod},
    {"rmod", cfun_it_s64_modi},
    {"%", cfun_it_s64_rem},
    {"r%", cfun_it_s64_remi},
    {"&", cfun_it_s64_and},
    {"r&", cfun_it_s64_and},
    {"|", cfun_it_s64_or},
    {"r|", cfun_it_s64_or},
    {"^", cfun_it_s64_xor},
    {"r^", cfun_it_s64_xor},
    {"<<", cfun_it_s64_lshift},
    {">>", cfun_it_s64_rshift},
    {"compare", cfun_it_s64_compare},

    {NULL, NULL}
};

static JanetMethod it_u64_methods[] = {
    {"+", cfun_it_u64_add},
    {"r+", cfun_it_u64_add},
    {"-", cfun_it_u64_sub},
    {"r-", cfun_it_u64_subi},
    {"*", cfun_it_u64_mul},
    {"r*", cfun_it_u64_mul},
    {"/", cfun_it_u64_div},
    {"r/", cfun_it_u64_divi},
    {"mod", cfun_it_u64_mod},
    {"rmod", cfun_it_u64_modi},
    {"%", cfun_it_u64_mod},
    {"r%", cfun_it_u64_modi},
    {"&", cfun_it_u64_and},
    {"r&", cfun_it_u64_and},
    {"|", cfun_it_u64_or},
    {"r|", cfun_it_u64_or},
    {"^", cfun_it_u64_xor},
    {"r^", cfun_it_u64_xor},
    {"<<", cfun_it_u64_lshift},
    {">>", cfun_it_u64_rshift},
    {"compare", cfun_it_u64_compare},

    {NULL, NULL}
};

static int it_s64_get(void *p, Janet key, Janet *out) {
    (void) p;
    if (!janet_checktype(key, JANET_KEYWORD))
        return 0;
    return janet_getmethod(janet_unwrap_keyword(key), it_s64_methods, out);
}

static int it_u64_get(void *p, Janet key, Janet *out) {
    (void) p;
    if (!janet_checktype(key, JANET_KEYWORD))
        return 0;
    return janet_getmethod(janet_unwrap_keyword(key), it_u64_methods, out);
}

static const JanetReg it_cfuns[] = {
    {
        "int/s64", cfun_it_s64_new,
        JDOC("(int/s64 value)\n\n"
             "Create a boxed signed 64 bit integer from a string value.")
    },
    {
        "int/u64", cfun_it_u64_new,
        JDOC("(int/u64 value)\n\n"
             "Create a boxed unsigned 64 bit integer from a string value.")
    },
    {NULL, NULL, NULL}
};

/* Module entry point */
void janet_lib_inttypes(JanetTable *env) {
    janet_core_cfuns(env, NULL, it_cfuns);
    janet_register_abstract_type(&janet_s64_type);
    janet_register_abstract_type(&janet_u64_type);
}

#endif


/* src/core/io.c */
#line 0 "src/core/io.c"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "util.h"
#endif

#include <stdio.h>
#include <errno.h>

#ifndef JANET_WINDOWS
#include <fcntl.h>
#include <sys/wait.h>
#include <unistd.h>
#endif

static int cfun_io_gc(void *p, size_t len);
static int io_file_get(void *p, Janet key, Janet *out);

const JanetAbstractType janet_file_type = {
    "core/file",
    cfun_io_gc,
    NULL,
    io_file_get,
    JANET_ATEND_GET
};

/* Check arguments to fopen */
static int checkflags(const uint8_t *str) {
    int flags = 0;
    int32_t i;
    int32_t len = janet_string_length(str);
    if (!len || len > 3)
        janet_panic("file mode must have a length between 1 and 3");
    switch (*str) {
        default:
            janet_panicf("invalid flag %c, expected w, a, or r", *str);
            break;
        case 'w':
            flags |= JANET_FILE_WRITE;
            break;
        case 'a':
            flags |= JANET_FILE_APPEND;
            break;
        case 'r':
            flags |= JANET_FILE_READ;
            break;
    }
    for (i = 1; i < len; i++) {
        switch (str[i]) {
            default:
                janet_panicf("invalid flag %c, expected + or b", str[i]);
                break;
            case '+':
                if (flags & JANET_FILE_UPDATE) return -1;
                flags |= JANET_FILE_UPDATE;
                break;
            case 'b':
                if (flags & JANET_FILE_BINARY) return -1;
                flags |= JANET_FILE_BINARY;
                break;
        }
    }
    return flags;
}

static Janet makef(FILE *f, int flags) {
    JanetFile *iof = (JanetFile *) janet_abstract(&janet_file_type, sizeof(JanetFile));
    iof->file = f;
    iof->flags = flags;
#ifndef JANET_WINDOWS
    /* While we would like fopen to set cloexec by default (like O_CLOEXEC) with the e flag, that is
     * not standard. */
    if (!(flags & JANET_FILE_NOT_CLOSEABLE))
        fcntl(fileno(f), F_SETFD, FD_CLOEXEC);
#endif
    return janet_wrap_abstract(iof);
}

/* Open a process */
#ifndef JANET_NO_PROCESSES
static Janet cfun_io_popen(int32_t argc, Janet *argv) {
    janet_arity(argc, 1, 2);
    const uint8_t *fname = janet_getstring(argv, 0);
    const uint8_t *fmode = NULL;
    int flags;
    if (argc == 2) {
        fmode = janet_getkeyword(argv, 1);
        if (janet_string_length(fmode) != 1 ||
                !(fmode[0] == 'r' || fmode[0] == 'w')) {
            janet_panicf("invalid file mode :%S, expected :r or :w", fmode);
        }
        flags = JANET_FILE_PIPED | (fmode[0] == 'r' ? JANET_FILE_READ : JANET_FILE_WRITE);
    } else {
        fmode = (const uint8_t *)"r";
        flags = JANET_FILE_PIPED | JANET_FILE_READ;
    }
#ifdef JANET_WINDOWS
#define popen _popen
#endif
    FILE *f = popen((const char *)fname, (const char *)fmode);
    if (!f) {
        return janet_wrap_nil();
    }
    return makef(f, flags);
}
#endif

static Janet cfun_io_temp(int32_t argc, Janet *argv) {
    (void)argv;
    janet_fixarity(argc, 0);
    // XXX use mkostemp when we can to avoid CLOEXEC race.
    FILE *tmp = tmpfile();
    if (!tmp)
        janet_panicf("unable to create temporary file - %s", strerror(errno));
    return janet_makefile(tmp, JANET_FILE_WRITE | JANET_FILE_READ | JANET_FILE_BINARY);
}

static Janet cfun_io_fopen(int32_t argc, Janet *argv) {
    janet_arity(argc, 1, 2);
    const uint8_t *fname = janet_getstring(argv, 0);
    const uint8_t *fmode;
    int flags;
    if (argc == 2) {
        fmode = janet_getkeyword(argv, 1);
        flags = checkflags(fmode);
    } else {
        fmode = (const uint8_t *)"r";
        flags = JANET_FILE_READ;
    }
    FILE *f = fopen((const char *)fname, (const char *)fmode);
    return f ? makef(f, flags) : janet_wrap_nil();
}

/* Read up to n bytes into buffer. */
static void read_chunk(JanetFile *iof, JanetBuffer *buffer, int32_t nBytesMax) {
    if (!(iof->flags & (JANET_FILE_READ | JANET_FILE_UPDATE)))
        janet_panic("file is not readable");
    janet_buffer_extra(buffer, nBytesMax);
    size_t ntoread = nBytesMax;
    size_t nread = fread((char *)(buffer->data + buffer->count), 1, ntoread, iof->file);
    if (nread != ntoread && ferror(iof->file))
        janet_panic("could not read file");
    buffer->count += (int32_t) nread;
}

/* Read a certain number of bytes into memory */
static Janet cfun_io_fread(int32_t argc, Janet *argv) {
    janet_arity(argc, 2, 3);
    JanetFile *iof = janet_getabstract(argv, 0, &janet_file_type);
    if (iof->flags & JANET_FILE_CLOSED) janet_panic("file is closed");
    JanetBuffer *buffer;
    if (argc == 2) {
        buffer = janet_buffer(0);
    } else {
        buffer = janet_getbuffer(argv, 2);
    }
    int32_t bufstart = buffer->count;
    if (janet_checktype(argv[1], JANET_KEYWORD)) {
        const uint8_t *sym = janet_unwrap_keyword(argv[1]);
        if (!janet_cstrcmp(sym, "all")) {
            int32_t sizeBefore;
            do {
                sizeBefore = buffer->count;
                read_chunk(iof, buffer, 4096);
            } while (sizeBefore < buffer->count);
            /* Never return nil for :all */
            return janet_wrap_buffer(buffer);
        } else if (!janet_cstrcmp(sym, "line")) {
            for (;;) {
                int x = fgetc(iof->file);
                if (x != EOF) janet_buffer_push_u8(buffer, (uint8_t)x);
                if (x == EOF || x == '\n') break;
            }
        } else {
            janet_panicf("expected one of :all, :line, got %v", argv[1]);
        }
    } else {
        int32_t len = janet_getinteger(argv, 1);
        if (len < 0) janet_panic("expected positive integer");
        read_chunk(iof, buffer, len);
    }
    if (bufstart == buffer->count) return janet_wrap_nil();
    return janet_wrap_buffer(buffer);
}

/* Write bytes to a file */
static Janet cfun_io_fwrite(int32_t argc, Janet *argv) {
    janet_arity(argc, 1, -1);
    JanetFile *iof = janet_getabstract(argv, 0, &janet_file_type);
    if (iof->flags & JANET_FILE_CLOSED)
        janet_panic("file is closed");
    if (!(iof->flags & (JANET_FILE_WRITE | JANET_FILE_APPEND | JANET_FILE_UPDATE)))
        janet_panic("file is not writeable");
    int32_t i;
    /* Verify all arguments before writing to file */
    for (i = 1; i < argc; i++)
        janet_getbytes(argv, i);
    for (i = 1; i < argc; i++) {
        JanetByteView view = janet_getbytes(argv, i);
        if (view.len) {
            if (!fwrite(view.bytes, view.len, 1, iof->file)) {
                janet_panic("error writing to file");
            }
        }
    }
    return argv[0];
}

/* Flush the bytes in the file */
static Janet cfun_io_fflush(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    JanetFile *iof = janet_getabstract(argv, 0, &janet_file_type);
    if (iof->flags & JANET_FILE_CLOSED)
        janet_panic("file is closed");
    if (!(iof->flags & (JANET_FILE_WRITE | JANET_FILE_APPEND | JANET_FILE_UPDATE)))
        janet_panic("file is not writeable");
    if (fflush(iof->file))
        janet_panic("could not flush file");
    return argv[0];
}

#ifdef JANET_WINDOWS
#define pclose _pclose
#define WEXITSTATUS(x) x
#endif

/* Cleanup a file */
static int cfun_io_gc(void *p, size_t len) {
    (void) len;
    JanetFile *iof = (JanetFile *)p;
    if (!(iof->flags & (JANET_FILE_NOT_CLOSEABLE | JANET_FILE_CLOSED))) {
        /* We can't panic inside a gc, so just ignore bad statuses here */
        if (iof->flags & JANET_FILE_PIPED) {
#ifndef JANET_NO_PROCESSES
            pclose(iof->file);
#endif
        } else {
            fclose(iof->file);
        }
    }
    return 0;
}

/* Close a file */
static Janet cfun_io_fclose(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    JanetFile *iof = janet_getabstract(argv, 0, &janet_file_type);
    if (iof->flags & JANET_FILE_CLOSED)
        return janet_wrap_nil();
    if (iof->flags & (JANET_FILE_NOT_CLOSEABLE))
        janet_panic("file not closable");
    if (iof->flags & JANET_FILE_PIPED) {
#ifndef JANET_NO_PROCESSES
        int status = pclose(iof->file);
        iof->flags |= JANET_FILE_CLOSED;
        if (status == -1) janet_panic("could not close file");
        return janet_wrap_integer(WEXITSTATUS(status));
#endif
    } else {
        if (fclose(iof->file)) {
            iof->flags |= JANET_FILE_NOT_CLOSEABLE;
            janet_panic("could not close file");
        }
        iof->flags |= JANET_FILE_CLOSED;
        return janet_wrap_nil();
    }
}

/* Seek a file */
static Janet cfun_io_fseek(int32_t argc, Janet *argv) {
    janet_arity(argc, 2, 3);
    JanetFile *iof = janet_getabstract(argv, 0, &janet_file_type);
    if (iof->flags & JANET_FILE_CLOSED)
        janet_panic("file is closed");
    long int offset = 0;
    int whence = SEEK_CUR;
    if (argc >= 2) {
        const uint8_t *whence_sym = janet_getkeyword(argv, 1);
        if (!janet_cstrcmp(whence_sym, "cur")) {
            whence = SEEK_CUR;
        } else if (!janet_cstrcmp(whence_sym, "set")) {
            whence = SEEK_SET;
        } else if (!janet_cstrcmp(whence_sym, "end")) {
            whence = SEEK_END;
        } else {
            janet_panicf("expected one of :cur, :set, :end, got %v", argv[1]);
        }
        if (argc == 3) {
            offset = (long) janet_getinteger64(argv, 2);
        }
    }
    if (fseek(iof->file, offset, whence)) janet_panic("error seeking file");
    return argv[0];
}

static JanetMethod io_file_methods[] = {
    {"close", cfun_io_fclose},
    {"flush", cfun_io_fflush},
    {"read", cfun_io_fread},
    {"seek", cfun_io_fseek},
    {"write", cfun_io_fwrite},
    {NULL, NULL}
};

static int io_file_get(void *p, Janet key, Janet *out) {
    (void) p;
    if (!janet_checktype(key, JANET_KEYWORD))
        return 0;
    return janet_getmethod(janet_unwrap_keyword(key), io_file_methods, out);
}

FILE *janet_dynfile(const char *name, FILE *def) {
    Janet x = janet_dyn(name);
    if (!janet_checktype(x, JANET_ABSTRACT)) return def;
    void *abstract = janet_unwrap_abstract(x);
    if (janet_abstract_type(abstract) != &janet_file_type) return def;
    JanetFile *iofile = abstract;
    return iofile->file;
}

static Janet cfun_io_print_impl(int32_t argc, Janet *argv,
                                int newline, const char *name, FILE *dflt_file) {
    FILE *f;
    Janet x = janet_dyn(name);
    switch (janet_type(x)) {
        default:
            /* Other values simply do nothing */
            return janet_wrap_nil();
        case JANET_BUFFER: {
            /* Special case buffer */
            JanetBuffer *buf = janet_unwrap_buffer(x);
            for (int32_t i = 0; i < argc; ++i) {
                janet_to_string_b(buf, argv[i]);
            }
            if (newline)
                janet_buffer_push_u8(buf, '\n');
            return janet_wrap_nil();
        }
        case JANET_NIL:
            f = dflt_file;
            break;
        case JANET_ABSTRACT: {
            void *abstract = janet_unwrap_abstract(x);
            if (janet_abstract_type(abstract) != &janet_file_type)
                return janet_wrap_nil();
            JanetFile *iofile = abstract;
            f = iofile->file;
            break;
        }
    }
    for (int32_t i = 0; i < argc; ++i) {
        int32_t len;
        const uint8_t *vstr;
        if (janet_checktype(argv[i], JANET_BUFFER)) {
            JanetBuffer *b = janet_unwrap_buffer(argv[i]);
            vstr = b->data;
            len = b->count;
        } else {
            vstr = janet_to_string(argv[i]);
            len = janet_string_length(vstr);
        }
        if (len) {
            if (1 != fwrite(vstr, len, 1, f)) {
                janet_panicf("could not print %d bytes to (dyn :%s)", len, name);
            }
        }
    }
    if (newline)
        putc('\n', f);
    return janet_wrap_nil();
}

static Janet cfun_io_print(int32_t argc, Janet *argv) {
    return cfun_io_print_impl(argc, argv, 1, "out", stdout);
}

static Janet cfun_io_prin(int32_t argc, Janet *argv) {
    return cfun_io_print_impl(argc, argv, 0, "out", stdout);
}

static Janet cfun_io_eprint(int32_t argc, Janet *argv) {
    return cfun_io_print_impl(argc, argv, 1, "err", stderr);
}

static Janet cfun_io_eprin(int32_t argc, Janet *argv) {
    return cfun_io_print_impl(argc, argv, 0, "err", stderr);
}

static Janet cfun_io_printf_impl(int32_t argc, Janet *argv, int newline,
                                 const char *name, FILE *dflt_file) {
    FILE *f;
    janet_arity(argc, 1, -1);
    const char *fmt = janet_getcstring(argv, 0);
    Janet x = janet_dyn(name);
    switch (janet_type(x)) {
        default:
            /* Other values simply do nothing */
            return janet_wrap_nil();
        case JANET_BUFFER: {
            /* Special case buffer */
            JanetBuffer *buf = janet_unwrap_buffer(x);
            janet_buffer_format(buf, fmt, 0, argc, argv);
            if (newline) janet_buffer_push_u8(buf, '\n');
            return janet_wrap_nil();
        }
        case JANET_NIL:
            f = dflt_file;
            break;
        case JANET_ABSTRACT: {
            void *abstract = janet_unwrap_abstract(x);
            if (janet_abstract_type(abstract) != &janet_file_type)
                return janet_wrap_nil();
            JanetFile *iofile = abstract;
            f = iofile->file;
            break;
        }
    }
    JanetBuffer *buf = janet_buffer(10);
    janet_buffer_format(buf, fmt, 0, argc, argv);
    if (newline) janet_buffer_push_u8(buf, '\n');
    if (buf->count) {
        if (1 != fwrite(buf->data, buf->count, 1, f)) {
            janet_panicf("could not print %d bytes to file", buf->count, name);
        }
    }
    /* Clear buffer to make things easier for GC */
    buf->count = 0;
    buf->capacity = 0;
    free(buf->data);
    buf->data = NULL;
    return janet_wrap_nil();
}

static Janet cfun_io_printf(int32_t argc, Janet *argv) {
    return cfun_io_printf_impl(argc, argv, 1, "out", stdout);
}

static Janet cfun_io_prinf(int32_t argc, Janet *argv) {
    return cfun_io_printf_impl(argc, argv, 0, "out", stdout);
}

static Janet cfun_io_eprintf(int32_t argc, Janet *argv) {
    return cfun_io_printf_impl(argc, argv, 1, "err", stderr);
}

static Janet cfun_io_eprinf(int32_t argc, Janet *argv) {
    return cfun_io_printf_impl(argc, argv, 0, "err", stderr);
}

static void janet_flusher(const char *name, FILE *dflt_file) {
    Janet x = janet_dyn(name);
    switch (janet_type(x)) {
        default:
            break;
        case JANET_NIL:
            fflush(dflt_file);
            break;
        case JANET_ABSTRACT: {
            void *abstract = janet_unwrap_abstract(x);
            if (janet_abstract_type(abstract) != &janet_file_type) break;
            JanetFile *iofile = abstract;
            fflush(iofile->file);
            break;
        }
    }
}

static Janet cfun_io_flush(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 0);
    (void) argv;
    janet_flusher("out", stdout);
    return janet_wrap_nil();
}

static Janet cfun_io_eflush(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 0);
    (void) argv;
    janet_flusher("err", stderr);
    return janet_wrap_nil();
}

void janet_dynprintf(const char *name, FILE *dflt_file, const char *format, ...) {
    va_list args;
    va_start(args, format);
    Janet x = janet_dyn(name);
    JanetType xtype = janet_type(x);
    switch (xtype) {
        default:
            /* Other values simply do nothing */
            break;
        case JANET_NIL:
        case JANET_ABSTRACT: {
            FILE *f = dflt_file;
            JanetBuffer buffer;
            int32_t len = 0;
            while (format[len]) len++;
            janet_buffer_init(&buffer, len);
            janet_formatbv(&buffer, format, args);
            if (xtype == JANET_ABSTRACT) {
                void *abstract = janet_unwrap_abstract(x);
                if (janet_abstract_type(abstract) != &janet_file_type)
                    break;
                JanetFile *iofile = abstract;
                f = iofile->file;
            }
            fwrite(buffer.data, buffer.count, 1, f);
            janet_buffer_deinit(&buffer);
            break;
        }
        case JANET_BUFFER:
            janet_formatbv(janet_unwrap_buffer(x), format, args);
            break;
    }
    va_end(args);
    return;
}

static const JanetReg io_cfuns[] = {
    {
        "print", cfun_io_print,
        JDOC("(print & xs)\n\n"
             "Print values to the console (standard out). Value are converted "
             "to strings if they are not already. After printing all values, a "
             "newline character is printed. Use the value of (dyn :out stdout) to determine "
             "what to push characters to. Expects (dyn :out stdout) to be either a core/file or "
             "a buffer. Returns nil.")
    },
    {
        "prin", cfun_io_prin,
        JDOC("(prin & xs)\n\n"
             "Same as print, but does not add trailing newline.")
    },
    {
        "printf", cfun_io_printf,
        JDOC("(printf fmt & xs)\n\n"
             "Prints output formatted as if with (string/format fmt ;xs) to (dyn :out stdout) with a trailing newline.")
    },
    {
        "prinf", cfun_io_prinf,
        JDOC("(prinf fmt & xs)\n\n"
             "Like printf but with no trailing newline.")
    },
    {
        "eprin", cfun_io_eprin,
        JDOC("(eprin & xs)\n\n"
             "Same as prin, but uses (dyn :err stderr) instead of (dyn :out stdout).")
    },
    {
        "eprint", cfun_io_eprint,
        JDOC("(eprint & xs)\n\n"
             "Same as print, but uses (dyn :err stderr) instead of (dyn :out stdout).")
    },
    {
        "eprintf", cfun_io_eprintf,
        JDOC("(eprintf fmt & xs)\n\n"
             "Prints output formatted as if with (string/format fmt ;xs) to (dyn :err stderr) with a trailing newline.")
    },
    {
        "eprinf", cfun_io_eprinf,
        JDOC("(eprinf fmt & xs)\n\n"
             "Like eprintf but with no trailing newline.")
    },
    {
        "flush", cfun_io_flush,
        JDOC("(flush)\n\n"
             "Flush (dyn :out stdout) if it is a file, otherwise do nothing.")
    },
    {
        "eflush", cfun_io_eflush,
        JDOC("(eflush)\n\n"
             "Flush (dyn :err stderr) if it is a file, otherwise do nothing.")
    },
    {
        "file/temp", cfun_io_temp,
        JDOC("(file/temp)\n\n"
             "Open an anonymous temporary file that is removed on close."
             "Raises an error on failure.")
    },
    {
        "file/open", cfun_io_fopen,
        JDOC("(file/open path &opt mode)\n\n"
             "Open a file. path is an absolute or relative path, and "
             "mode is a set of flags indicating the mode to open the file in. "
             "mode is a keyword where each character represents a flag. If the file "
             "cannot be opened, returns nil, otherwise returns the new file handle. "
             "Mode flags:\n\n"
             "\tr - allow reading from the file\n"
             "\tw - allow writing to the file\n"
             "\ta - append to the file\n"
             "\tb - open the file in binary mode (rather than text mode)\n"
             "\t+ - append to the file instead of overwriting it")
    },
    {
        "file/close", cfun_io_fclose,
        JDOC("(file/close f)\n\n"
             "Close a file and release all related resources. When you are "
             "done reading a file, close it to prevent a resource leak and let "
             "other processes read the file. If the file is the result of a file/popen "
             "call, close waits for and returns the process exit status.")
    },
    {
        "file/read", cfun_io_fread,
        JDOC("(file/read f what &opt buf)\n\n"
             "Read a number of bytes from a file into a buffer. A buffer can "
             "be provided as an optional fourth argument, otherwise a new buffer "
             "is created. 'what' can either be an integer or a keyword. Returns the "
             "buffer with file contents. "
             "Values for 'what':\n\n"
             "\t:all - read the whole file\n"
             "\t:line - read up to and including the next newline character\n"
             "\tn (integer) - read up to n bytes from the file")
    },
    {
        "file/write", cfun_io_fwrite,
        JDOC("(file/write f bytes)\n\n"
             "Writes to a file. 'bytes' must be string, buffer, or symbol. Returns the "
             "file.")
    },
    {
        "file/flush", cfun_io_fflush,
        JDOC("(file/flush f)\n\n"
             "Flush any buffered bytes to the file system. In most files, writes are "
             "buffered for efficiency reasons. Returns the file handle.")
    },
    {
        "file/seek", cfun_io_fseek,
        JDOC("(file/seek f &opt whence n)\n\n"
             "Jump to a relative location in the file. 'whence' must be one of\n\n"
             "\t:cur - jump relative to the current file location\n"
             "\t:set - jump relative to the beginning of the file\n"
             "\t:end - jump relative to the end of the file\n\n"
             "By default, 'whence' is :cur. Optionally a value n may be passed "
             "for the relative number of bytes to seek in the file. n may be a real "
             "number to handle large files of more the 4GB. Returns the file handle.")
    },
#ifndef JANET_NO_PROCESSES
    {
        "file/popen", cfun_io_popen,
        JDOC("(file/popen path &opt mode)\n\n"
             "Open a file that is backed by a process. The file must be opened in either "
             "the :r (read) or the :w (write) mode. In :r mode, the stdout of the "
             "process can be read from the file. In :w mode, the stdin of the process "
             "can be written to. Returns the new file.")
    },
#endif
    {NULL, NULL, NULL}
};

/* C API */

FILE *janet_getfile(const Janet *argv, int32_t n, int *flags) {
    JanetFile *iof = janet_getabstract(argv, n, &janet_file_type);
    if (NULL != flags) *flags = iof->flags;
    return iof->file;
}

Janet janet_makefile(FILE *f, int flags) {
    return makef(f, flags);
}

JanetAbstract janet_checkfile(Janet j) {
    return janet_checkabstract(j, &janet_file_type);
}

FILE *janet_unwrapfile(Janet j, int *flags) {
    JanetFile *iof = janet_unwrap_abstract(j);
    if (NULL != flags) *flags = iof->flags;
    return iof->file;
}

/* Module entry point */
void janet_lib_io(JanetTable *env) {
    janet_core_cfuns(env, NULL, io_cfuns);

    /* stdout */
    janet_core_def(env, "stdout",
                   makef(stdout, JANET_FILE_APPEND | JANET_FILE_NOT_CLOSEABLE | JANET_FILE_SERIALIZABLE),
                   JDOC("The standard output file."));
    /* stderr */
    janet_core_def(env, "stderr",
                   makef(stderr, JANET_FILE_APPEND | JANET_FILE_NOT_CLOSEABLE | JANET_FILE_SERIALIZABLE),
                   JDOC("The standard error file."));
    /* stdin */
    janet_core_def(env, "stdin",
                   makef(stdin, JANET_FILE_READ | JANET_FILE_NOT_CLOSEABLE | JANET_FILE_SERIALIZABLE),
                   JDOC("The standard input file."));

}


/* src/core/marsh.c */
#line 0 "src/core/marsh.c"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "state.h"
#include "vector.h"
#include "gc.h"
#include "fiber.h"
#include "util.h"
#endif

typedef struct {
    JanetBuffer *buf;
    JanetTable seen;
    JanetTable *rreg;
    JanetFuncEnv **seen_envs;
    JanetFuncDef **seen_defs;
    int32_t nextid;
} MarshalState;

/* Lead bytes in marshaling protocol */
enum {
    LB_REAL = 200,
    LB_NIL, /* 201 */
    LB_FALSE, /* 202 */
    LB_TRUE,  /* 203 */
    LB_FIBER, /* 204 */
    LB_INTEGER, /* 205 */
    LB_STRING, /* 206 */
    LB_SYMBOL, /* 207 */
    LB_KEYWORD, /* 208 */
    LB_ARRAY, /* 209 */
    LB_TUPLE, /* 210 */
    LB_TABLE, /* 211 */
    LB_TABLE_PROTO, /* 212 */
    LB_STRUCT, /* 213 */
    LB_BUFFER, /* 214 */
    LB_FUNCTION, /* 215 */
    LB_REGISTRY, /* 216 */
    LB_ABSTRACT, /* 217 */
    LB_REFERENCE, /* 218 */
    LB_FUNCENV_REF, /* 219 */
    LB_FUNCDEF_REF, /* 220 */
    LB_UNSAFE_CFUNCTION, /* 221 */
    LB_UNSAFE_POINTER /* 222 */
} LeadBytes;

/* Helper to look inside an entry in an environment */
static Janet entry_getval(Janet env_entry) {
    if (janet_checktype(env_entry, JANET_TABLE)) {
        JanetTable *entry = janet_unwrap_table(env_entry);
        Janet checkval = janet_table_get(entry, janet_ckeywordv("value"));
        if (janet_checktype(checkval, JANET_NIL)) {
            checkval = janet_table_get(entry, janet_ckeywordv("ref"));
        }
        return checkval;
    } else if (janet_checktype(env_entry, JANET_STRUCT)) {
        const JanetKV *entry = janet_unwrap_struct(env_entry);
        Janet checkval = janet_struct_get(entry, janet_ckeywordv("value"));
        if (janet_checktype(checkval, JANET_NIL)) {
            checkval = janet_struct_get(entry, janet_ckeywordv("ref"));
        }
        return checkval;
    } else {
        return janet_wrap_nil();
    }
}

/* Merge values from an environment into an existing lookup table. */
void janet_env_lookup_into(JanetTable *renv, JanetTable *env, const char *prefix, int recurse) {
    while (env) {
        for (int32_t i = 0; i < env->capacity; i++) {
            if (janet_checktype(env->data[i].key, JANET_SYMBOL)) {
                if (prefix) {
                    int32_t prelen = (int32_t) strlen(prefix);
                    const uint8_t *oldsym = janet_unwrap_symbol(env->data[i].key);
                    int32_t oldlen = janet_string_length(oldsym);
                    uint8_t *symbuf = janet_smalloc(prelen + oldlen);
                    safe_memcpy(symbuf, prefix, prelen);
                    safe_memcpy(symbuf + prelen, oldsym, oldlen);
                    Janet s = janet_symbolv(symbuf, prelen + oldlen);
                    janet_sfree(symbuf);
                    janet_table_put(renv, s, entry_getval(env->data[i].value));
                } else {
                    janet_table_put(renv,
                                    env->data[i].key,
                                    entry_getval(env->data[i].value));
                }
            }
        }
        env = recurse ? env->proto : NULL;
    }
}

/* Make a forward lookup table from an environment (for unmarshaling) */
JanetTable *janet_env_lookup(JanetTable *env) {
    JanetTable *renv = janet_table(env->count);
    janet_env_lookup_into(renv, env, NULL, 1);
    return renv;
}

/* Marshal an integer onto the buffer */
static void pushint(MarshalState *st, int32_t x) {
    if (x >= 0 && x < 128) {
        janet_buffer_push_u8(st->buf, x);
    } else if (x <= 8191 && x >= -8192) {
        uint8_t intbuf[2];
        intbuf[0] = ((x >> 8) & 0x3F) | 0x80;
        intbuf[1] = x & 0xFF;
        janet_buffer_push_bytes(st->buf, intbuf, 2);
    } else {
        uint8_t intbuf[5];
        intbuf[0] = LB_INTEGER;
        intbuf[1] = (x >> 24) & 0xFF;
        intbuf[2] = (x >> 16) & 0xFF;
        intbuf[3] = (x >> 8) & 0xFF;
        intbuf[4] = x & 0xFF;
        janet_buffer_push_bytes(st->buf, intbuf, 5);
    }
}

static void pushbyte(MarshalState *st, uint8_t b) {
    janet_buffer_push_u8(st->buf, b);
}

static void pushbytes(MarshalState *st, const uint8_t *bytes, int32_t len) {
    janet_buffer_push_bytes(st->buf, bytes, len);
}

/* Marshal a size_t onto the buffer */
static void push64(MarshalState *st, uint64_t x) {
    if (x <= 0xF0) {
        /* Single byte */
        pushbyte(st, (uint8_t) x);
    } else {
        /* Multibyte, little endian */
        uint8_t bytes[9];
        int nbytes = 0;
        while (x) {
            bytes[++nbytes] = x & 0xFF;
            x >>= 8;
        }
        bytes[0] = 0xF0 + nbytes;
        pushbytes(st, bytes, nbytes + 1);
    }
}

/* Forward declaration to enable mutual recursion. */
static void marshal_one(MarshalState *st, Janet x, int flags);
static void marshal_one_fiber(MarshalState *st, JanetFiber *fiber, int flags);
static void marshal_one_def(MarshalState *st, JanetFuncDef *def, int flags);
static void marshal_one_env(MarshalState *st, JanetFuncEnv *env, int flags);

/* Prevent stack overflows */
#define MARSH_STACKCHECK if ((flags & 0xFFFF) > JANET_RECURSION_GUARD) janet_panic("stack overflow")

/* Marshal a function env */
static void marshal_one_env(MarshalState *st, JanetFuncEnv *env, int flags) {
    MARSH_STACKCHECK;
    for (int32_t i = 0; i < janet_v_count(st->seen_envs); i++) {
        if (st->seen_envs[i] == env) {
            pushbyte(st, LB_FUNCENV_REF);
            pushint(st, i);
            return;
        }
    }
    janet_env_valid(env);
    janet_v_push(st->seen_envs, env);
    if (env->offset > 0 && (JANET_STATUS_ALIVE == janet_fiber_status(env->as.fiber))) {
        pushint(st, 0);
        pushint(st, env->length);
        Janet *values = env->as.fiber->data + env->offset;
        uint32_t *bitset = janet_stack_frame(values)->func->def->closure_bitset;
        for (int32_t i = 0; i < env->length; i++) {
            if (1 & (bitset[i >> 5] >> (i & 0x1F))) {
                marshal_one(st, values[i], flags + 1);
            } else {
                pushbyte(st, LB_NIL);
            }
        }
    } else {
        janet_env_maybe_detach(env);
        pushint(st, env->offset);
        pushint(st, env->length);
        if (env->offset > 0) {
            /* On stack variant */
            marshal_one(st, janet_wrap_fiber(env->as.fiber), flags + 1);
        } else {
            /* Off stack variant */
            for (int32_t i = 0; i < env->length; i++)
                marshal_one(st, env->as.values[i], flags + 1);
        }
    }
}

/* Add function flags to janet functions */
static void janet_func_addflags(JanetFuncDef *def) {
    if (def->name) def->flags |= JANET_FUNCDEF_FLAG_HASNAME;
    if (def->source) def->flags |= JANET_FUNCDEF_FLAG_HASSOURCE;
    if (def->defs) def->flags |= JANET_FUNCDEF_FLAG_HASDEFS;
    if (def->environments) def->flags |= JANET_FUNCDEF_FLAG_HASENVS;
    if (def->sourcemap) def->flags |= JANET_FUNCDEF_FLAG_HASSOURCEMAP;
}

/* Marshal a sequence of u32s */
static void janet_marshal_u32s(MarshalState *st, const uint32_t *u32s, int32_t n) {
    for (int32_t i = 0; i < n; i++) {
        pushbyte(st, u32s[i] & 0xFF);
        pushbyte(st, (u32s[i] >> 8) & 0xFF);
        pushbyte(st, (u32s[i] >> 16) & 0xFF);
        pushbyte(st, (u32s[i] >> 24) & 0xFF);
    }
}

/* Marshal a function def */
static void marshal_one_def(MarshalState *st, JanetFuncDef *def, int flags) {
    MARSH_STACKCHECK;
    for (int32_t i = 0; i < janet_v_count(st->seen_defs); i++) {
        if (st->seen_defs[i] == def) {
            pushbyte(st, LB_FUNCDEF_REF);
            pushint(st, i);
            return;
        }
    }
    janet_func_addflags(def);
    /* Add to lookup */
    janet_v_push(st->seen_defs, def);
    pushint(st, def->flags);
    pushint(st, def->slotcount);
    pushint(st, def->arity);
    pushint(st, def->min_arity);
    pushint(st, def->max_arity);
    pushint(st, def->constants_length);
    pushint(st, def->bytecode_length);
    if (def->flags & JANET_FUNCDEF_FLAG_HASENVS)
        pushint(st, def->environments_length);
    if (def->flags & JANET_FUNCDEF_FLAG_HASDEFS)
        pushint(st, def->defs_length);
    if (def->flags & JANET_FUNCDEF_FLAG_HASNAME)
        marshal_one(st, janet_wrap_string(def->name), flags);
    if (def->flags & JANET_FUNCDEF_FLAG_HASSOURCE)
        marshal_one(st, janet_wrap_string(def->source), flags);

    /* marshal constants */
    for (int32_t i = 0; i < def->constants_length; i++)
        marshal_one(st, def->constants[i], flags);

    /* marshal the bytecode */
    janet_marshal_u32s(st, def->bytecode, def->bytecode_length);

    /* marshal the environments if needed */
    for (int32_t i = 0; i < def->environments_length; i++)
        pushint(st, def->environments[i]);

    /* marshal the sub funcdefs if needed */
    for (int32_t i = 0; i < def->defs_length; i++)
        marshal_one_def(st, def->defs[i], flags);

    /* marshal source maps if needed */
    if (def->flags & JANET_FUNCDEF_FLAG_HASSOURCEMAP) {
        int32_t current = 0;
        for (int32_t i = 0; i < def->bytecode_length; i++) {
            JanetSourceMapping map = def->sourcemap[i];
            pushint(st, map.line - current);
            pushint(st, map.column);
            current = map.line;
        }
    }

    /* Marshal closure bitset, if needed */
    if (def->flags & JANET_FUNCDEF_FLAG_HASCLOBITSET) {
        janet_marshal_u32s(st, def->closure_bitset, ((def->slotcount + 31) >> 5));
    }
}

#define JANET_FIBER_FLAG_HASCHILD (1 << 29)
#define JANET_FIBER_FLAG_HASENV (1 << 28)
#define JANET_STACKFRAME_HASENV (1 << 30)

/* Marshal a fiber */
static void marshal_one_fiber(MarshalState *st, JanetFiber *fiber, int flags) {
    MARSH_STACKCHECK;
    int32_t fflags = fiber->flags;
    if (fiber->child) fflags |= JANET_FIBER_FLAG_HASCHILD;
    if (fiber->env) fflags |= JANET_FIBER_FLAG_HASENV;
    if (janet_fiber_status(fiber) == JANET_STATUS_ALIVE)
        janet_panic("cannot marshal alive fiber");
    pushint(st, fflags);
    pushint(st, fiber->frame);
    pushint(st, fiber->stackstart);
    pushint(st, fiber->stacktop);
    pushint(st, fiber->maxstack);
    /* Do frames */
    int32_t i = fiber->frame;
    int32_t j = fiber->stackstart - JANET_FRAME_SIZE;
    while (i > 0) {
        JanetStackFrame *frame = (JanetStackFrame *)(fiber->data + i - JANET_FRAME_SIZE);
        if (frame->env) frame->flags |= JANET_STACKFRAME_HASENV;
        if (!frame->func) janet_panic("cannot marshal fiber with c stackframe");
        pushint(st, frame->flags);
        pushint(st, frame->prevframe);
        int32_t pcdiff = (int32_t)(frame->pc - frame->func->def->bytecode);
        pushint(st, pcdiff);
        marshal_one(st, janet_wrap_function(frame->func), flags + 1);
        if (frame->env) marshal_one_env(st, frame->env, flags + 1);
        /* Marshal all values in the stack frame */
        for (int32_t k = i; k < j; k++)
            marshal_one(st, fiber->data[k], flags + 1);
        j = i - JANET_FRAME_SIZE;
        i = frame->prevframe;
    }
    if (fiber->env) {
        marshal_one(st, janet_wrap_table(fiber->env), flags + 1);
    }
    if (fiber->child)
        marshal_one(st, janet_wrap_fiber(fiber->child), flags + 1);
}

void janet_marshal_size(JanetMarshalContext *ctx, size_t value) {
    janet_marshal_int64(ctx, (int64_t) value);
}

void janet_marshal_int64(JanetMarshalContext *ctx, int64_t value) {
    MarshalState *st = (MarshalState *)(ctx->m_state);
    push64(st, (uint64_t) value);
}

void janet_marshal_int(JanetMarshalContext *ctx, int32_t value) {
    MarshalState *st = (MarshalState *)(ctx->m_state);
    pushint(st, value);
}

void janet_marshal_byte(JanetMarshalContext *ctx, uint8_t value) {
    MarshalState *st = (MarshalState *)(ctx->m_state);
    pushbyte(st, value);
}

void janet_marshal_bytes(JanetMarshalContext *ctx, const uint8_t *bytes, size_t len) {
    MarshalState *st = (MarshalState *)(ctx->m_state);
    if (len > INT32_MAX) janet_panic("size_t too large to fit in buffer");
    pushbytes(st, bytes, (int32_t) len);
}

void janet_marshal_janet(JanetMarshalContext *ctx, Janet x) {
    MarshalState *st = (MarshalState *)(ctx->m_state);
    marshal_one(st, x, ctx->flags + 1);
}

void janet_marshal_abstract(JanetMarshalContext *ctx, void *abstract) {
    MarshalState *st = (MarshalState *)(ctx->m_state);
    janet_table_put(&st->seen,
                    janet_wrap_abstract(abstract),
                    janet_wrap_integer(st->nextid++));
}

#define MARK_SEEN() \
    janet_table_put(&st->seen, x, janet_wrap_integer(st->nextid++))

static void marshal_one_abstract(MarshalState *st, Janet x, int flags) {
    void *abstract = janet_unwrap_abstract(x);
    const JanetAbstractType *at = janet_abstract_type(abstract);
    if (at->marshal) {
        pushbyte(st, LB_ABSTRACT);
        marshal_one(st, janet_csymbolv(at->name), flags + 1);
        JanetMarshalContext context = {st, NULL, flags, NULL, at};
        at->marshal(abstract, &context);
    } else {
        janet_panicf("try to marshal unregistered abstract type, cannot marshal %p", x);
    }
}

/* The main body of the marshaling function. Is the main
 * entry point for the mutually recursive functions. */
static void marshal_one(MarshalState *st, Janet x, int flags) {
    MARSH_STACKCHECK;
    JanetType type = janet_type(x);

    /* Check simple primitives (non reference types, no benefit from memoization) */
    switch (type) {
        default:
            break;
        case JANET_NIL:
            pushbyte(st, LB_NIL);
            return;
        case JANET_BOOLEAN:
            pushbyte(st, janet_unwrap_boolean(x) ? LB_TRUE : LB_FALSE);
            return;
        case JANET_NUMBER: {
            double xval = janet_unwrap_number(x);
            if (janet_checkintrange(xval)) {
                pushint(st, (int32_t) xval);
                return;
            }
            break;
        }
    }

    /* Check reference and registry value */
    {
        Janet check = janet_table_get(&st->seen, x);
        if (janet_checkint(check)) {
            pushbyte(st, LB_REFERENCE);
            pushint(st, janet_unwrap_integer(check));
            return;
        }
        if (st->rreg) {
            check = janet_table_get(st->rreg, x);
            if (janet_checktype(check, JANET_SYMBOL)) {
                MARK_SEEN();
                const uint8_t *regname = janet_unwrap_symbol(check);
                pushbyte(st, LB_REGISTRY);
                pushint(st, janet_string_length(regname));
                pushbytes(st, regname, janet_string_length(regname));
                return;
            }
        }
    }

    /* Reference types */
    switch (type) {
        case JANET_NUMBER: {
            union {
                double d;
                uint8_t bytes[8];
            } u;
            u.d = janet_unwrap_number(x);
#ifdef JANET_BIG_ENDIAN
            /* Swap byte order */
            uint8_t temp;
            temp = u.bytes[7];
            u.bytes[7] = u.bytes[0];
            u.bytes[0] = temp;
            temp = u.bytes[6];
            u.bytes[6] = u.bytes[1];
            u.bytes[1] = temp;
            temp = u.bytes[5];
            u.bytes[5] = u.bytes[2];
            u.bytes[2] = temp;
            temp = u.bytes[4];
            u.bytes[4] = u.bytes[3];
            u.bytes[3] = temp;
#endif
            pushbyte(st, LB_REAL);
            pushbytes(st, u.bytes, 8);
            MARK_SEEN();
            return;
        }
        case JANET_STRING:
        case JANET_SYMBOL:
        case JANET_KEYWORD: {
            const uint8_t *str = janet_unwrap_string(x);
            int32_t length = janet_string_length(str);
            /* Record reference */
            MARK_SEEN();
            uint8_t lb = (type == JANET_STRING) ? LB_STRING :
                         (type == JANET_SYMBOL) ? LB_SYMBOL :
                         LB_KEYWORD;
            pushbyte(st, lb);
            pushint(st, length);
            pushbytes(st, str, length);
            return;
        }
        case JANET_BUFFER: {
            JanetBuffer *buffer = janet_unwrap_buffer(x);
            /* Record reference */
            MARK_SEEN();
            pushbyte(st, LB_BUFFER);
            pushint(st, buffer->count);
            pushbytes(st, buffer->data, buffer->count);
            return;
        }
        case JANET_ARRAY: {
            int32_t i;
            JanetArray *a = janet_unwrap_array(x);
            MARK_SEEN();
            pushbyte(st, LB_ARRAY);
            pushint(st, a->count);
            for (i = 0; i < a->count; i++)
                marshal_one(st, a->data[i], flags + 1);
            return;
        }
        case JANET_TUPLE: {
            int32_t i, count, flag;
            const Janet *tup = janet_unwrap_tuple(x);
            count = janet_tuple_length(tup);
            flag = janet_tuple_flag(tup) >> 16;
            pushbyte(st, LB_TUPLE);
            pushint(st, count);
            pushint(st, flag);
            for (i = 0; i < count; i++)
                marshal_one(st, tup[i], flags + 1);
            /* Mark as seen AFTER marshaling */
            MARK_SEEN();
            return;
        }
        case JANET_TABLE: {
            JanetTable *t = janet_unwrap_table(x);
            MARK_SEEN();
            pushbyte(st, t->proto ? LB_TABLE_PROTO : LB_TABLE);
            pushint(st, t->count);
            if (t->proto)
                marshal_one(st, janet_wrap_table(t->proto), flags + 1);
            for (int32_t i = 0; i < t->capacity; i++) {
                if (janet_checktype(t->data[i].key, JANET_NIL))
                    continue;
                marshal_one(st, t->data[i].key, flags + 1);
                marshal_one(st, t->data[i].value, flags + 1);
            }
            return;
        }
        case JANET_STRUCT: {
            int32_t count;
            const JanetKV *struct_ = janet_unwrap_struct(x);
            count = janet_struct_length(struct_);
            pushbyte(st, LB_STRUCT);
            pushint(st, count);
            for (int32_t i = 0; i < janet_struct_capacity(struct_); i++) {
                if (janet_checktype(struct_[i].key, JANET_NIL))
                    continue;
                marshal_one(st, struct_[i].key, flags + 1);
                marshal_one(st, struct_[i].value, flags + 1);
            }
            /* Mark as seen AFTER marshaling */
            MARK_SEEN();
            return;
        }
        case JANET_ABSTRACT: {
            marshal_one_abstract(st, x, flags);
            return;
        }
        case JANET_FUNCTION: {
            pushbyte(st, LB_FUNCTION);
            JanetFunction *func = janet_unwrap_function(x);
            marshal_one_def(st, func->def, flags);
            /* Mark seen after reading def, but before envs */
            MARK_SEEN();
            for (int32_t i = 0; i < func->def->environments_length; i++)
                marshal_one_env(st, func->envs[i], flags + 1);
            return;
        }
        case JANET_FIBER: {
            MARK_SEEN();
            pushbyte(st, LB_FIBER);
            marshal_one_fiber(st, janet_unwrap_fiber(x), flags + 1);
            return;
        }
        case JANET_CFUNCTION: {
            if (!(flags & JANET_MARSHAL_UNSAFE)) goto no_registry;
            MARK_SEEN();
            pushbyte(st, LB_UNSAFE_CFUNCTION);
            JanetCFunction cfn = janet_unwrap_cfunction(x);
            pushbytes(st, (uint8_t *) &cfn, sizeof(JanetCFunction));
            return;
        }
        case JANET_POINTER: {
            if (!(flags & JANET_MARSHAL_UNSAFE)) goto no_registry;
            MARK_SEEN();
            pushbyte(st, LB_UNSAFE_POINTER);
            void *ptr = janet_unwrap_pointer(x);
            pushbytes(st, (uint8_t *) &ptr, sizeof(void *));
            return;
        }
    no_registry:
        default: {
            janet_panicf("no registry value and cannot marshal %p", x);
        }
    }
#undef MARK_SEEN
}

void janet_marshal(
    JanetBuffer *buf,
    Janet x,
    JanetTable *rreg,
    int flags) {
    MarshalState st;
    st.buf = buf;
    st.nextid = 0;
    st.seen_defs = NULL;
    st.seen_envs = NULL;
    st.rreg = rreg;
    janet_table_init(&st.seen, 0);
    marshal_one(&st, x, flags);
    janet_table_deinit(&st.seen);
    janet_v_free(st.seen_envs);
    janet_v_free(st.seen_defs);
}

typedef struct {
    jmp_buf err;
    Janet *lookup;
    JanetTable *reg;
    JanetFuncEnv **lookup_envs;
    JanetFuncDef **lookup_defs;
    const uint8_t *start;
    const uint8_t *end;
} UnmarshalState;

#define MARSH_EOS(st, data) do { \
    if ((data) >= (st)->end) janet_panic("unexpected end of source");\
} while (0)

/* Helper to read a 32 bit integer from an unmarshal state */
static int32_t readint(UnmarshalState *st, const uint8_t **atdata) {
    const uint8_t *data = *atdata;
    int32_t ret;
    MARSH_EOS(st, data);
    if (*data < 128) {
        ret = *data++;
    } else if (*data < 192) {
        MARSH_EOS(st, data + 1);
        uint32_t uret = ((data[0] & 0x3F) << 8) + data[1];
        /* Sign extend 18 MSBs */
        uret |= (uret >> 13) ? 0xFFFFC000 : 0;
        ret = (int32_t)uret;
        data += 2;
    } else if (*data == LB_INTEGER) {
        MARSH_EOS(st, data + 4);
        uint32_t ui = ((uint32_t)(data[1]) << 24) |
                      ((uint32_t)(data[2]) << 16) |
                      ((uint32_t)(data[3]) << 8) |
                      (uint32_t)(data[4]);
        ret = (int32_t)ui;
        data += 5;
    } else {
        janet_panicf("expected integer, got byte %x at index %d",
                     *data,
                     data - st->start);
        ret = 0;
    }
    *atdata = data;
    return ret;
}

/* Helper to read a natural number (int >= 0). */
static int32_t readnat(UnmarshalState *st, const uint8_t **atdata) {
    int32_t ret = readint(st, atdata);
    if (ret < 0) {
        janet_panicf("expected integer >= 0, got %d", ret);
    }
    return ret;
}

/* Helper to read a size_t (up to 8 bytes unsigned). */
static uint64_t read64(UnmarshalState *st, const uint8_t **atdata) {
    uint64_t ret;
    const uint8_t *data = *atdata;
    MARSH_EOS(st, data);
    if (*data <= 0xF0) {
        /* Single byte */
        ret = *data;
        *atdata = data + 1;
    } else {
        /* Multibyte, little endian */
        int nbytes = *data - 0xF0;
        ret = 0;
        if (nbytes > 8) janet_panic("invalid 64 bit integer");
        MARSH_EOS(st, data + nbytes);
        for (int i = nbytes; i > 0; i--)
            ret = (ret << 8) + data[i];
        *atdata = data + nbytes + 1;
    }
    return ret;
}

/* Assert a janet type */
static void janet_asserttype(Janet x, JanetType t) {
    if (!janet_checktype(x, t)) {
        janet_panicf("expected type %T, got %v", 1 << t, x);
    }
}

/* Forward declarations for mutual recursion */
static const uint8_t *unmarshal_one(
    UnmarshalState *st,
    const uint8_t *data,
    Janet *out,
    int flags);
static const uint8_t *unmarshal_one_env(
    UnmarshalState *st,
    const uint8_t *data,
    JanetFuncEnv **out,
    int flags);
static const uint8_t *unmarshal_one_def(
    UnmarshalState *st,
    const uint8_t *data,
    JanetFuncDef **out,
    int flags);
static const uint8_t *unmarshal_one_fiber(
    UnmarshalState *st,
    const uint8_t *data,
    JanetFiber **out,
    int flags);

/* Unmarshal a funcenv */
static const uint8_t *unmarshal_one_env(
    UnmarshalState *st,
    const uint8_t *data,
    JanetFuncEnv **out,
    int flags) {
    MARSH_EOS(st, data);
    if (*data == LB_FUNCENV_REF) {
        data++;
        int32_t index = readint(st, &data);
        if (index < 0 || index >= janet_v_count(st->lookup_envs))
            janet_panicf("invalid funcenv reference %d", index);
        *out = st->lookup_envs[index];
    } else {
        JanetFuncEnv *env = janet_gcalloc(JANET_MEMORY_FUNCENV, sizeof(JanetFuncEnv));
        env->length = 0;
        env->offset = 0;
        env->as.values = NULL;
        janet_v_push(st->lookup_envs, env);
        int32_t offset = readnat(st, &data);
        int32_t length = readnat(st, &data);
        if (offset > 0) {
            Janet fiberv;
            /* On stack variant */
            data = unmarshal_one(st, data, &fiberv, flags);
            janet_asserttype(fiberv, JANET_FIBER);
            env->as.fiber = janet_unwrap_fiber(fiberv);
            /* Negative offset indicates untrusted input */
            env->offset = -offset;
        } else {
            /* Off stack variant */
            if (length == 0) {
                janet_panic("invalid funcenv length");
            }
            env->as.values = malloc(sizeof(Janet) * (size_t) length);
            if (!env->as.values) {
                JANET_OUT_OF_MEMORY;
            }
            env->offset = 0;
            for (int32_t i = 0; i < length; i++)
                data = unmarshal_one(st, data, env->as.values + i, flags);
        }
        env->length = length;
        *out = env;
    }
    return data;
}

/* Unmarshal a series of u32s */
static const uint8_t *janet_unmarshal_u32s(UnmarshalState *st, const uint8_t *data, uint32_t *into, int32_t n) {
    for (int32_t i = 0; i < n; i++) {
        MARSH_EOS(st, data + 3);
        into[i] =
            (uint32_t)(data[0]) |
            ((uint32_t)(data[1]) << 8) |
            ((uint32_t)(data[2]) << 16) |
            ((uint32_t)(data[3]) << 24);
        data += 4;
    }
    return data;
}

/* Unmarshal a funcdef */
static const uint8_t *unmarshal_one_def(
    UnmarshalState *st,
    const uint8_t *data,
    JanetFuncDef **out,
    int flags) {
    MARSH_EOS(st, data);
    if (*data == LB_FUNCDEF_REF) {
        data++;
        int32_t index = readint(st, &data);
        if (index < 0 || index >= janet_v_count(st->lookup_defs))
            janet_panicf("invalid funcdef reference %d", index);
        *out = st->lookup_defs[index];
    } else {
        /* Initialize with values that will not break garbage collection
         * if unmarshalling fails. */
        JanetFuncDef *def = janet_gcalloc(JANET_MEMORY_FUNCDEF, sizeof(JanetFuncDef));
        def->environments_length = 0;
        def->defs_length = 0;
        def->constants_length = 0;
        def->bytecode_length = 0;
        def->name = NULL;
        def->source = NULL;
        def->closure_bitset = NULL;
        def->defs = NULL;
        def->environments = NULL;
        def->constants = NULL;
        def->bytecode = NULL;
        def->sourcemap = NULL;
        janet_v_push(st->lookup_defs, def);

        /* Set default lengths to zero */
        int32_t bytecode_length = 0;
        int32_t constants_length = 0;
        int32_t environments_length = 0;
        int32_t defs_length = 0;

        /* Read flags and other fixed values */
        def->flags = readint(st, &data);
        def->slotcount = readnat(st, &data);
        def->arity = readnat(st, &data);
        def->min_arity = readnat(st, &data);
        def->max_arity = readnat(st, &data);

        /* Read some lengths */
        constants_length = readnat(st, &data);
        bytecode_length = readnat(st, &data);
        if (def->flags & JANET_FUNCDEF_FLAG_HASENVS)
            environments_length = readnat(st, &data);
        if (def->flags & JANET_FUNCDEF_FLAG_HASDEFS)
            defs_length = readnat(st, &data);

        /* Check name and source (optional) */
        if (def->flags & JANET_FUNCDEF_FLAG_HASNAME) {
            Janet x;
            data = unmarshal_one(st, data, &x, flags + 1);
            janet_asserttype(x, JANET_STRING);
            def->name = janet_unwrap_string(x);
        }
        if (def->flags & JANET_FUNCDEF_FLAG_HASSOURCE) {
            Janet x;
            data = unmarshal_one(st, data, &x, flags + 1);
            janet_asserttype(x, JANET_STRING);
            def->source = janet_unwrap_string(x);
        }

        /* Unmarshal constants */
        if (constants_length) {
            def->constants = malloc(sizeof(Janet) * constants_length);
            if (!def->constants) {
                JANET_OUT_OF_MEMORY;
            }
            for (int32_t i = 0; i < constants_length; i++)
                data = unmarshal_one(st, data, def->constants + i, flags + 1);
        } else {
            def->constants = NULL;
        }
        def->constants_length = constants_length;

        /* Unmarshal bytecode */
        def->bytecode = malloc(sizeof(uint32_t) * bytecode_length);
        if (!def->bytecode) {
            JANET_OUT_OF_MEMORY;
        }
        data = janet_unmarshal_u32s(st, data, def->bytecode, bytecode_length);
        def->bytecode_length = bytecode_length;

        /* Unmarshal environments */
        if (def->flags & JANET_FUNCDEF_FLAG_HASENVS) {
            def->environments = calloc(1, sizeof(int32_t) * (size_t) environments_length);
            if (!def->environments) {
                JANET_OUT_OF_MEMORY;
            }
            for (int32_t i = 0; i < environments_length; i++) {
                def->environments[i] = readint(st, &data);
            }
        } else {
            def->environments = NULL;
        }
        def->environments_length = environments_length;

        /* Unmarshal sub funcdefs */
        if (def->flags & JANET_FUNCDEF_FLAG_HASDEFS) {
            def->defs = calloc(1, sizeof(JanetFuncDef *) * (size_t) defs_length);
            if (!def->defs) {
                JANET_OUT_OF_MEMORY;
            }
            for (int32_t i = 0; i < defs_length; i++) {
                data = unmarshal_one_def(st, data, def->defs + i, flags + 1);
            }
        } else {
            def->defs = NULL;
        }
        def->defs_length = defs_length;

        /* Unmarshal source maps if needed */
        if (def->flags & JANET_FUNCDEF_FLAG_HASSOURCEMAP) {
            int32_t current = 0;
            def->sourcemap = malloc(sizeof(JanetSourceMapping) * (size_t) bytecode_length);
            if (!def->sourcemap) {
                JANET_OUT_OF_MEMORY;
            }
            for (int32_t i = 0; i < bytecode_length; i++) {
                current += readint(st, &data);
                def->sourcemap[i].line = current;
                def->sourcemap[i].column = readnat(st, &data);
            }
        } else {
            def->sourcemap = NULL;
        }

        /* Unmarshal closure bitset if needed */
        if (def->flags & JANET_FUNCDEF_FLAG_HASCLOBITSET) {
            def->closure_bitset = malloc(sizeof(uint32_t) * def->slotcount);
            if (NULL == def->closure_bitset) {
                JANET_OUT_OF_MEMORY;
            }
            data = janet_unmarshal_u32s(st, data, def->closure_bitset, (def->slotcount + 31) >> 5);
        }

        /* Validate */
        if (janet_verify(def))
            janet_panic("funcdef has invalid bytecode");

        /* Set def */
        *out = def;
    }
    return data;
}

/* Unmarshal a fiber */
static const uint8_t *unmarshal_one_fiber(
    UnmarshalState *st,
    const uint8_t *data,
    JanetFiber **out,
    int flags) {

    /* Initialize a new fiber with gc friendly defaults */
    JanetFiber *fiber = janet_gcalloc(JANET_MEMORY_FIBER, sizeof(JanetFiber));
    fiber->flags = 0;
    fiber->frame = 0;
    fiber->stackstart = 0;
    fiber->stacktop = 0;
    fiber->capacity = 0;
    fiber->maxstack = 0;
    fiber->data = NULL;
    fiber->child = NULL;
    fiber->env = NULL;

    /* Push fiber to seen stack */
    janet_v_push(st->lookup, janet_wrap_fiber(fiber));

    /* Read ints */
    int32_t fiber_flags = readint(st, &data);
    int32_t frame = readnat(st, &data);
    int32_t fiber_stackstart = readnat(st, &data);
    int32_t fiber_stacktop = readnat(st, &data);
    int32_t fiber_maxstack = readnat(st, &data);
    JanetTable *fiber_env = NULL;

    /* Check for bad flags and ints */
    if ((int32_t)(frame + JANET_FRAME_SIZE) > fiber_stackstart ||
            fiber_stackstart > fiber_stacktop ||
            fiber_stacktop > fiber_maxstack) {
        janet_panic("fiber has incorrect stack setup");
    }

    /* Allocate stack memory */
    fiber->capacity = fiber_stacktop + 10;
    fiber->data = malloc(sizeof(Janet) * fiber->capacity);
    if (!fiber->data) {
        JANET_OUT_OF_MEMORY;
    }
    for (int32_t i = 0; i < fiber->capacity; i++) {
        fiber->data[i] = janet_wrap_nil();
    }

    /* get frames */
    int32_t stack = frame;
    int32_t stacktop = fiber_stackstart - JANET_FRAME_SIZE;
    while (stack > 0) {
        JanetFunction *func = NULL;
        JanetFuncDef *def = NULL;
        JanetFuncEnv *env = NULL;
        int32_t frameflags = readint(st, &data);
        int32_t prevframe = readnat(st, &data);
        int32_t pcdiff = readnat(st, &data);

        /* Get frame items */
        Janet *framestack = fiber->data + stack;
        JanetStackFrame *framep = janet_stack_frame(framestack);

        /* Get function */
        Janet funcv;
        data = unmarshal_one(st, data, &funcv, flags + 1);
        janet_asserttype(funcv, JANET_FUNCTION);
        func = janet_unwrap_function(funcv);
        def = func->def;

        /* Check env */
        if (frameflags & JANET_STACKFRAME_HASENV) {
            frameflags &= ~JANET_STACKFRAME_HASENV;
            data = unmarshal_one_env(st, data, &env, flags + 1);
        }

        /* Error checking */
        int32_t expected_framesize = def->slotcount;
        if (expected_framesize != stacktop - stack) {
            janet_panic("fiber stackframe size mismatch");
        }
        if (pcdiff >= def->bytecode_length) {
            janet_panic("fiber stackframe has invalid pc");
        }
        if ((int32_t)(prevframe + JANET_FRAME_SIZE) > stack) {
            janet_panic("fiber stackframe does not align with previous frame");
        }

        /* Get stack items */
        for (int32_t i = stack; i < stacktop; i++)
            data = unmarshal_one(st, data, fiber->data + i, flags + 1);

        /* Set frame */
        framep->env = env;
        framep->pc = def->bytecode + pcdiff;
        framep->prevframe = prevframe;
        framep->flags = frameflags;
        framep->func = func;

        /* Goto previous frame */
        stacktop = stack - JANET_FRAME_SIZE;
        stack = prevframe;
    }
    if (stack < 0) {
        janet_panic("fiber has too many stackframes");
    }

    /* Check for fiber env */
    if (fiber_flags & JANET_FIBER_FLAG_HASENV) {
        Janet envv;
        fiber_flags &= ~JANET_FIBER_FLAG_HASENV;
        data = unmarshal_one(st, data, &envv, flags + 1);
        janet_asserttype(envv, JANET_TABLE);
        fiber_env = janet_unwrap_table(envv);
    }

    /* Check for child fiber */
    if (fiber_flags & JANET_FIBER_FLAG_HASCHILD) {
        Janet fiberv;
        fiber_flags &= ~JANET_FIBER_FLAG_HASCHILD;
        data = unmarshal_one(st, data, &fiberv, flags + 1);
        janet_asserttype(fiberv, JANET_FIBER);
        fiber->child = janet_unwrap_fiber(fiberv);
    }

    /* We have valid fiber, finally construct remaining fields. */
    fiber->frame = frame;
    fiber->flags = fiber_flags;
    fiber->stackstart = fiber_stackstart;
    fiber->stacktop = fiber_stacktop;
    fiber->maxstack = fiber_maxstack;
    fiber->env = fiber_env;

    /* Return data */
    *out = fiber;
    return data;
}

void janet_unmarshal_ensure(JanetMarshalContext *ctx, size_t size) {
    UnmarshalState *st = (UnmarshalState *)(ctx->u_state);
    MARSH_EOS(st, ctx->data + size);
}

int32_t janet_unmarshal_int(JanetMarshalContext *ctx) {
    UnmarshalState *st = (UnmarshalState *)(ctx->u_state);
    return readint(st, &(ctx->data));
}

size_t janet_unmarshal_size(JanetMarshalContext *ctx) {
    return (size_t) janet_unmarshal_int64(ctx);
}

int64_t janet_unmarshal_int64(JanetMarshalContext *ctx) {
    UnmarshalState *st = (UnmarshalState *)(ctx->u_state);
    return read64(st, &(ctx->data));
}

uint8_t janet_unmarshal_byte(JanetMarshalContext *ctx) {
    UnmarshalState *st = (UnmarshalState *)(ctx->u_state);
    MARSH_EOS(st, ctx->data);
    return *(ctx->data++);
}

void janet_unmarshal_bytes(JanetMarshalContext *ctx, uint8_t *dest, size_t len) {
    UnmarshalState *st = (UnmarshalState *)(ctx->u_state);
    MARSH_EOS(st, ctx->data + len - 1);
    safe_memcpy(dest, ctx->data, len);
    ctx->data += len;
}

Janet janet_unmarshal_janet(JanetMarshalContext *ctx) {
    Janet ret;
    UnmarshalState *st = (UnmarshalState *)(ctx->u_state);
    ctx->data = unmarshal_one(st, ctx->data, &ret, ctx->flags);
    return ret;
}

void *janet_unmarshal_abstract(JanetMarshalContext *ctx, size_t size) {
    UnmarshalState *st = (UnmarshalState *)(ctx->u_state);
    if (ctx->at == NULL) {
        janet_panicf("janet_unmarshal_abstract called more than once");
    }
    void *p = janet_abstract(ctx->at, size);
    janet_v_push(st->lookup, janet_wrap_abstract(p));
    ctx->at = NULL;
    return p;
}

static const uint8_t *unmarshal_one_abstract(UnmarshalState *st, const uint8_t *data, Janet *out, int flags) {
    Janet key;
    data = unmarshal_one(st, data, &key, flags + 1);
    const JanetAbstractType *at = janet_get_abstract_type(key);
    if (at == NULL) goto oops;
    if (at->unmarshal) {
        JanetMarshalContext context = {NULL, st, flags, data, at};
        *out = janet_wrap_abstract(at->unmarshal(&context));
        if (context.at != NULL) {
            janet_panicf("janet_unmarshal_abstract not called");
        }
        return context.data;
    }
oops:
    janet_panic("invalid abstract type");
}

static const uint8_t *unmarshal_one(
    UnmarshalState *st,
    const uint8_t *data,
    Janet *out,
    int flags) {
    uint8_t lead;
    MARSH_STACKCHECK;
    MARSH_EOS(st, data);
    lead = data[0];
    if (lead < LB_REAL) {
        *out = janet_wrap_integer(readint(st, &data));
        return data;
    }
    switch (lead) {
        case LB_NIL:
            *out = janet_wrap_nil();
            return data + 1;
        case LB_FALSE:
            *out = janet_wrap_false();
            return data + 1;
        case LB_TRUE:
            *out = janet_wrap_true();
            return data + 1;
        case LB_INTEGER:
            /* Long integer */
            MARSH_EOS(st, data + 4);
            uint32_t ui = ((uint32_t)(data[4])) |
                          ((uint32_t)(data[3]) << 8) |
                          ((uint32_t)(data[2]) << 16) |
                          ((uint32_t)(data[1]) << 24);
            int32_t si = (int32_t)ui;
            *out = janet_wrap_integer(si);
            return data + 5;
        case LB_REAL:
            /* Real */
        {
            union {
                double d;
                uint8_t bytes[8];
            } u;
            MARSH_EOS(st, data + 8);
#ifdef JANET_BIG_ENDIAN
            u.bytes[0] = data[8];
            u.bytes[1] = data[7];
            u.bytes[2] = data[6];
            u.bytes[3] = data[5];
            u.bytes[4] = data[4];
            u.bytes[5] = data[3];
            u.bytes[6] = data[2];
            u.bytes[7] = data[1];
#else
            memcpy(&u.bytes, data + 1, sizeof(double));
#endif
            *out = janet_wrap_number_safe(u.d);
            janet_v_push(st->lookup, *out);
            return data + 9;
        }
        case LB_STRING:
        case LB_SYMBOL:
        case LB_BUFFER:
        case LB_KEYWORD:
        case LB_REGISTRY: {
            data++;
            int32_t len = readnat(st, &data);
            MARSH_EOS(st, data - 1 + len);
            if (lead == LB_STRING) {
                const uint8_t *str = janet_string(data, len);
                *out = janet_wrap_string(str);
            } else if (lead == LB_SYMBOL) {
                const uint8_t *str = janet_symbol(data, len);
                *out = janet_wrap_symbol(str);
            } else if (lead == LB_KEYWORD) {
                const uint8_t *str = janet_keyword(data, len);
                *out = janet_wrap_keyword(str);
            } else if (lead == LB_REGISTRY) {
                if (st->reg) {
                    Janet regkey = janet_symbolv(data, len);
                    *out = janet_table_get(st->reg, regkey);
                } else {
                    *out = janet_wrap_nil();
                }
            } else { /* (lead == LB_BUFFER) */
                JanetBuffer *buffer = janet_buffer(len);
                buffer->count = len;
                safe_memcpy(buffer->data, data, len);
                *out = janet_wrap_buffer(buffer);
            }
            janet_v_push(st->lookup, *out);
            return data + len;
        }
        case LB_FIBER: {
            JanetFiber *fiber;
            data = unmarshal_one_fiber(st, data + 1, &fiber, flags);
            *out = janet_wrap_fiber(fiber);
            return data;
        }
        case LB_FUNCTION: {
            JanetFunction *func;
            JanetFuncDef *def;
            data = unmarshal_one_def(st, data + 1, &def, flags + 1);
            func = janet_gcalloc(JANET_MEMORY_FUNCTION, sizeof(JanetFunction) +
                                 def->environments_length * sizeof(JanetFuncEnv));
            func->def = def;
            *out = janet_wrap_function(func);
            janet_v_push(st->lookup, *out);
            for (int32_t i = 0; i < def->environments_length; i++) {
                data = unmarshal_one_env(st, data, &(func->envs[i]), flags + 1);
            }
            return data;
        }
        case LB_ABSTRACT: {
            data++;
            return unmarshal_one_abstract(st, data, out, flags);
        }
        case LB_REFERENCE:
        case LB_ARRAY:
        case LB_TUPLE:
        case LB_STRUCT:
        case LB_TABLE:
        case LB_TABLE_PROTO:
            /* Things that open with integers */
        {
            data++;
            int32_t len = readnat(st, &data);
            /* DOS check */
            if (lead != LB_REFERENCE) {
                MARSH_EOS(st, data - 1 + len);
            }
            if (lead == LB_ARRAY) {
                /* Array */
                JanetArray *array = janet_array(len);
                array->count = len;
                *out = janet_wrap_array(array);
                janet_v_push(st->lookup, *out);
                for (int32_t i = 0; i < len; i++) {
                    data = unmarshal_one(st, data, array->data + i, flags + 1);
                }
            } else if (lead == LB_TUPLE) {
                /* Tuple */
                Janet *tup = janet_tuple_begin(len);
                int32_t flag = readint(st, &data);
                janet_tuple_flag(tup) |= flag << 16;
                for (int32_t i = 0; i < len; i++) {
                    data = unmarshal_one(st, data, tup + i, flags + 1);
                }
                *out = janet_wrap_tuple(janet_tuple_end(tup));
                janet_v_push(st->lookup, *out);
            } else if (lead == LB_STRUCT) {
                /* Struct */
                JanetKV *struct_ = janet_struct_begin(len);
                for (int32_t i = 0; i < len; i++) {
                    Janet key, value;
                    data = unmarshal_one(st, data, &key, flags + 1);
                    data = unmarshal_one(st, data, &value, flags + 1);
                    janet_struct_put(struct_, key, value);
                }
                *out = janet_wrap_struct(janet_struct_end(struct_));
                janet_v_push(st->lookup, *out);
            } else if (lead == LB_REFERENCE) {
                if (len >= janet_v_count(st->lookup))
                    janet_panicf("invalid reference %d", len);
                *out = st->lookup[len];
            } else {
                /* Table */
                JanetTable *t = janet_table(len);
                *out = janet_wrap_table(t);
                janet_v_push(st->lookup, *out);
                if (lead == LB_TABLE_PROTO) {
                    Janet proto;
                    data = unmarshal_one(st, data, &proto, flags + 1);
                    janet_asserttype(proto, JANET_TABLE);
                    t->proto = janet_unwrap_table(proto);
                }
                for (int32_t i = 0; i < len; i++) {
                    Janet key, value;
                    data = unmarshal_one(st, data, &key, flags + 1);
                    data = unmarshal_one(st, data, &value, flags + 1);
                    janet_table_put(t, key, value);
                }
            }
            return data;
        }
        case LB_UNSAFE_POINTER: {
            MARSH_EOS(st, data + sizeof(void *));
            data++;
            if (!(flags & JANET_MARSHAL_UNSAFE)) {
                janet_panicf("unsafe flag not given, "
                             "will not unmarshal raw pointer at index %d",
                             (int)(data - st->start));
            }
            union {
                void *ptr;
                uint8_t bytes[sizeof(void *)];
            } u;
            memcpy(u.bytes, data, sizeof(void *));
            data += sizeof(void *);
            *out = janet_wrap_pointer(u.ptr);
            janet_v_push(st->lookup, *out);
            return data;
        }
        case LB_UNSAFE_CFUNCTION: {
            MARSH_EOS(st, data + sizeof(JanetCFunction));
            data++;
            if (!(flags & JANET_MARSHAL_UNSAFE)) {
                janet_panicf("unsafe flag not given, "
                             "will not unmarshal function pointer at index %d",
                             (int)(data - st->start));
            }
            union {
                JanetCFunction ptr;
                uint8_t bytes[sizeof(JanetCFunction)];
            } u;
            memcpy(u.bytes, data, sizeof(JanetCFunction));
            data += sizeof(JanetCFunction);
            *out = janet_wrap_cfunction(u.ptr);
            janet_v_push(st->lookup, *out);
            return data;
        }
        default: {
            janet_panicf("unknown byte %x at index %d",
                         *data,
                         (int)(data - st->start));
            return NULL;
        }
    }
#undef EXTRA
}

Janet janet_unmarshal(
    const uint8_t *bytes,
    size_t len,
    int flags,
    JanetTable *reg,
    const uint8_t **next) {
    UnmarshalState st;
    st.start = bytes;
    st.end = bytes + len;
    st.lookup_defs = NULL;
    st.lookup_envs = NULL;
    st.lookup = NULL;
    st.reg = reg;
    Janet out;
    const uint8_t *nextbytes = unmarshal_one(&st, bytes, &out, flags);
    if (next) *next = nextbytes;
    janet_v_free(st.lookup_defs);
    janet_v_free(st.lookup_envs);
    janet_v_free(st.lookup);
    return out;
}

/* C functions */

static Janet cfun_env_lookup(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    JanetTable *env = janet_gettable(argv, 0);
    return janet_wrap_table(janet_env_lookup(env));
}

static Janet cfun_marshal(int32_t argc, Janet *argv) {
    janet_arity(argc, 1, 3);
    JanetBuffer *buffer;
    JanetTable *rreg = NULL;
    if (argc > 1) {
        rreg = janet_gettable(argv, 1);
    }
    if (argc > 2) {
        buffer = janet_getbuffer(argv, 2);
    } else {
        buffer = janet_buffer(10);
    }
    janet_marshal(buffer, argv[0], rreg, 0);
    return janet_wrap_buffer(buffer);
}

static Janet cfun_unmarshal(int32_t argc, Janet *argv) {
    janet_arity(argc, 1, 2);
    JanetByteView view = janet_getbytes(argv, 0);
    JanetTable *reg = NULL;
    if (argc > 1) {
        reg = janet_gettable(argv, 1);
    }
    return janet_unmarshal(view.bytes, (size_t) view.len, 0, reg, NULL);
}

static const JanetReg marsh_cfuns[] = {
    {
        "marshal", cfun_marshal,
        JDOC("(marshal x &opt reverse-lookup buffer)\n\n"
             "Marshal a value into a buffer and return the buffer. The buffer "
             "can the later be unmarshalled to reconstruct the initial value. "
             "Optionally, one can pass in a reverse lookup table to not marshal "
             "aliased values that are found in the table. Then a forward"
             "lookup table can be used to recover the original value when "
             "unmarshalling.")
    },
    {
        "unmarshal", cfun_unmarshal,
        JDOC("(unmarshal buffer &opt lookup)\n\n"
             "Unmarshal a value from a buffer. An optional lookup table "
             "can be provided to allow for aliases to be resolved. Returns the value "
             "unmarshalled from the buffer.")
    },
    {
        "env-lookup", cfun_env_lookup,
        JDOC("(env-lookup env)\n\n"
             "Creates a forward lookup table for unmarshalling from an environment. "
             "To create a reverse lookup table, use the invert function to swap keys "
             "and values in the returned table.")
    },
    {NULL, NULL, NULL}
};

/* Module entry point */
void janet_lib_marsh(JanetTable *env) {
    janet_core_cfuns(env, NULL, marsh_cfuns);
}


/* src/core/math.c */
#line 0 "src/core/math.c"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "util.h"
#endif

#include <math.h>

static JANET_THREAD_LOCAL JanetRNG janet_vm_rng = {0, 0, 0, 0, 0};

static int janet_rng_get(void *p, Janet key, Janet *out);

static void janet_rng_marshal(void *p, JanetMarshalContext *ctx) {
    JanetRNG *rng = (JanetRNG *)p;
    janet_marshal_abstract(ctx, p);
    janet_marshal_int(ctx, (int32_t) rng->a);
    janet_marshal_int(ctx, (int32_t) rng->b);
    janet_marshal_int(ctx, (int32_t) rng->c);
    janet_marshal_int(ctx, (int32_t) rng->d);
    janet_marshal_int(ctx, (int32_t) rng->counter);
}

static void *janet_rng_unmarshal(JanetMarshalContext *ctx) {
    JanetRNG *rng = janet_unmarshal_abstract(ctx, sizeof(JanetRNG));
    rng->a = (uint32_t) janet_unmarshal_int(ctx);
    rng->b = (uint32_t) janet_unmarshal_int(ctx);
    rng->c = (uint32_t) janet_unmarshal_int(ctx);
    rng->d = (uint32_t) janet_unmarshal_int(ctx);
    rng->counter = (uint32_t) janet_unmarshal_int(ctx);
    return rng;
}

const JanetAbstractType janet_rng_type = {
    "core/rng",
    NULL,
    NULL,
    janet_rng_get,
    NULL,
    janet_rng_marshal,
    janet_rng_unmarshal,
    JANET_ATEND_UNMARSHAL
};

JanetRNG *janet_default_rng(void) {
    return &janet_vm_rng;
}

void janet_rng_seed(JanetRNG *rng, uint32_t seed) {
    rng->a = seed;
    rng->b = 0x97654321u;
    rng->c = 123871873u;
    rng->d = 0xf23f56c8u;
    rng->counter = 0u;
    /* First several numbers aren't that random. */
    for (int i = 0; i < 16; i++) janet_rng_u32(rng);
}

void janet_rng_longseed(JanetRNG *rng, const uint8_t *bytes, int32_t len) {
    uint8_t state[16] = {0};
    for (int32_t i = 0; i < len; i++)
        state[i & 0xF] ^= bytes[i];
    rng->a = state[0] + (state[1] << 8) + (state[2] << 16) + (state[3] << 24);
    rng->b = state[4] + (state[5] << 8) + (state[6] << 16) + (state[7] << 24);
    rng->c = state[8] + (state[9] << 8) + (state[10] << 16) + (state[11] << 24);
    rng->d = state[12] + (state[13] << 8) + (state[14] << 16) + (state[15] << 24);
    rng->counter = 0u;
    /* a, b, c, d can't all be 0 */
    if (rng->a == 0) rng->a = 1u;
    for (int i = 0; i < 16; i++) janet_rng_u32(rng);
}

uint32_t janet_rng_u32(JanetRNG *rng) {
    /* Algorithm "xorwow" from p. 5 of Marsaglia, "Xorshift RNGs" */
    uint32_t t = rng->d;
    uint32_t const s = rng->a;
    rng->d = rng->c;
    rng->c = rng->b;
    rng->b = s;
    t ^= t >> 2;
    t ^= t << 1;
    t ^= s ^ (s << 4);
    rng->a = t;
    rng->counter += 362437;
    return t + rng->counter;
}

double janet_rng_double(JanetRNG *rng) {
    uint32_t hi = janet_rng_u32(rng);
    uint32_t lo = janet_rng_u32(rng);
    uint64_t big = (uint64_t)(lo) | (((uint64_t) hi) << 32);
    return ldexp((double)(big >> (64 - 52)), -52);
}

static Janet cfun_rng_make(int32_t argc, Janet *argv) {
    janet_arity(argc, 0, 1);
    JanetRNG *rng = janet_abstract(&janet_rng_type, sizeof(JanetRNG));
    if (argc == 1) {
        if (janet_checkint(argv[0])) {
            uint32_t seed = (uint32_t)(janet_getinteger(argv, 0));
            janet_rng_seed(rng, seed);
        } else {
            JanetByteView bytes = janet_getbytes(argv, 0);
            janet_rng_longseed(rng, bytes.bytes, bytes.len);
        }
    } else {
        janet_rng_seed(rng, 0);
    }
    return janet_wrap_abstract(rng);
}

static Janet cfun_rng_uniform(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    JanetRNG *rng = janet_getabstract(argv, 0, &janet_rng_type);
    return janet_wrap_number(janet_rng_double(rng));
}

static Janet cfun_rng_int(int32_t argc, Janet *argv) {
    janet_arity(argc, 1, 2);
    JanetRNG *rng = janet_getabstract(argv, 0, &janet_rng_type);
    if (argc == 1) {
        uint32_t word = janet_rng_u32(rng) >> 1;
        return janet_wrap_integer(word);
    } else {
        int32_t max = janet_optnat(argv, argc, 1, INT32_MAX);
        if (max == 0) return janet_wrap_number(0.0);
        uint32_t modulo = (uint32_t) max;
        uint32_t maxgen = INT32_MAX;
        uint32_t maxword = maxgen - (maxgen % modulo);
        uint32_t word;
        do {
            word = janet_rng_u32(rng) >> 1;
        } while (word > maxword);
        return janet_wrap_integer(word % modulo);
    }
}

static void rng_get_4bytes(JanetRNG *rng, uint8_t *buf) {
    uint32_t word = janet_rng_u32(rng);
    buf[0] = word & 0xFF;
    buf[1] = (word >> 8) & 0xFF;
    buf[2] = (word >> 16) & 0xFF;
    buf[3] = (word >> 24) & 0xFF;
}

static Janet cfun_rng_buffer(int32_t argc, Janet *argv) {
    janet_arity(argc, 2, 3);
    JanetRNG *rng = janet_getabstract(argv, 0, &janet_rng_type);
    int32_t n = janet_getnat(argv, 1);
    JanetBuffer *buffer = janet_optbuffer(argv, argc, 2, n);

    /* Split into first part (that is divisible by 4), and rest */
    int32_t first_part = n & ~3;
    int32_t second_part = n - first_part;

    /* Get first part in chunks of 4 bytes */
    janet_buffer_extra(buffer, n);
    uint8_t *buf = buffer->data + buffer->count;
    for (int32_t i = 0; i < first_part; i += 4) rng_get_4bytes(rng, buf + i);
    buffer->count += first_part;

    /* Get remaining 0 - 3 bytes */
    if (second_part) {
        uint8_t wordbuf[4] = {0};
        rng_get_4bytes(rng, wordbuf);
        janet_buffer_push_bytes(buffer, wordbuf, second_part);
    }

    return janet_wrap_buffer(buffer);
}

static const JanetMethod rng_methods[] = {
    {"uniform", cfun_rng_uniform},
    {"int", cfun_rng_int},
    {"buffer", cfun_rng_buffer},
    {NULL, NULL}
};

static int janet_rng_get(void *p, Janet key, Janet *out) {
    (void) p;
    if (!janet_checktype(key, JANET_KEYWORD)) return 0;
    return janet_getmethod(janet_unwrap_keyword(key), rng_methods, out);
}

/* Get a random number */
static Janet janet_rand(int32_t argc, Janet *argv) {
    (void) argv;
    janet_fixarity(argc, 0);
    return janet_wrap_number(janet_rng_double(&janet_vm_rng));
}

/* Seed the random number generator */
static Janet janet_srand(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    if (janet_checkint(argv[0])) {
        uint32_t seed = (uint32_t)(janet_getinteger(argv, 0));
        janet_rng_seed(&janet_vm_rng, seed);
    } else {
        JanetByteView bytes = janet_getbytes(argv, 0);
        janet_rng_longseed(&janet_vm_rng, bytes.bytes, bytes.len);
    }
    return janet_wrap_nil();
}

#define JANET_DEFINE_MATHOP(name, fop)\
static Janet janet_##name(int32_t argc, Janet *argv) {\
    janet_fixarity(argc, 1); \
    double x = janet_getnumber(argv, 0); \
    return janet_wrap_number(fop(x)); \
}

JANET_DEFINE_MATHOP(acos, acos)
JANET_DEFINE_MATHOP(asin, asin)
JANET_DEFINE_MATHOP(atan, atan)
JANET_DEFINE_MATHOP(cos, cos)
JANET_DEFINE_MATHOP(cosh, cosh)
JANET_DEFINE_MATHOP(acosh, acosh)
JANET_DEFINE_MATHOP(sin, sin)
JANET_DEFINE_MATHOP(sinh, sinh)
JANET_DEFINE_MATHOP(asinh, asinh)
JANET_DEFINE_MATHOP(tan, tan)
JANET_DEFINE_MATHOP(tanh, tanh)
JANET_DEFINE_MATHOP(atanh, atanh)
JANET_DEFINE_MATHOP(exp, exp)
JANET_DEFINE_MATHOP(exp2, exp2)
JANET_DEFINE_MATHOP(expm1, expm1)
JANET_DEFINE_MATHOP(log, log)
JANET_DEFINE_MATHOP(log10, log10)
JANET_DEFINE_MATHOP(log2, log2)
JANET_DEFINE_MATHOP(sqrt, sqrt)
JANET_DEFINE_MATHOP(cbrt, cbrt)
JANET_DEFINE_MATHOP(ceil, ceil)
JANET_DEFINE_MATHOP(fabs, fabs)
JANET_DEFINE_MATHOP(floor, floor)
JANET_DEFINE_MATHOP(trunc, trunc)
JANET_DEFINE_MATHOP(round, round)
JANET_DEFINE_MATHOP(gamma, lgamma)
JANET_DEFINE_MATHOP(log1p, log1p)
JANET_DEFINE_MATHOP(erf, erf)
JANET_DEFINE_MATHOP(erfc, erfc)

#define JANET_DEFINE_MATH2OP(name, fop)\
static Janet janet_##name(int32_t argc, Janet *argv) {\
    janet_fixarity(argc, 2); \
    double lhs = janet_getnumber(argv, 0); \
    double rhs = janet_getnumber(argv, 1); \
    return janet_wrap_number(fop(lhs, rhs)); \
}\

JANET_DEFINE_MATH2OP(atan2, atan2)
JANET_DEFINE_MATH2OP(pow, pow)
JANET_DEFINE_MATH2OP(hypot, hypot)
JANET_DEFINE_MATH2OP(nextafter, nextafter)

static Janet janet_not(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    return janet_wrap_boolean(!janet_truthy(argv[0]));
}

static const JanetReg math_cfuns[] = {
    {
        "not", janet_not,
        JDOC("(not x)\n\nReturns the boolean inverse of x.")
    },
    {
        "math/random", janet_rand,
        JDOC("(math/random)\n\n"
             "Returns a uniformly distributed random number between 0 and 1.")
    },
    {
        "math/seedrandom", janet_srand,
        JDOC("(math/seedrandom seed)\n\n"
             "Set the seed for the random number generator. seed should be "
             "an integer or a buffer.")
    },
    {
        "math/cos", janet_cos,
        JDOC("(math/cos x)\n\n"
             "Returns the cosine of x.")
    },
    {
        "math/sin", janet_sin,
        JDOC("(math/sin x)\n\n"
             "Returns the sine of x.")
    },
    {
        "math/tan", janet_tan,
        JDOC("(math/tan x)\n\n"
             "Returns the tangent of x.")
    },
    {
        "math/acos", janet_acos,
        JDOC("(math/acos x)\n\n"
             "Returns the arccosine of x.")
    },
    {
        "math/asin", janet_asin,
        JDOC("(math/asin x)\n\n"
             "Returns the arcsine of x.")
    },
    {
        "math/atan", janet_atan,
        JDOC("(math/atan x)\n\n"
             "Returns the arctangent of x.")
    },
    {
        "math/exp", janet_exp,
        JDOC("(math/exp x)\n\n"
             "Returns e to the power of x.")
    },
    {
        "math/log", janet_log,
        JDOC("(math/log x)\n\n"
             "Returns log base natural number of x.")
    },
    {
        "math/log10", janet_log10,
        JDOC("(math/log10 x)\n\n"
             "Returns log base 10 of x.")
    },
    {
        "math/log2", janet_log2,
        JDOC("(math/log2 x)\n\n"
             "Returns log base 2 of x.")
    },
    {
        "math/sqrt", janet_sqrt,
        JDOC("(math/sqrt x)\n\n"
             "Returns the square root of x.")
    },
    {
        "math/cbrt", janet_cbrt,
        JDOC("(math/cbrt x)\n\n"
             "Returns the cube root of x.")
    },
    {
        "math/floor", janet_floor,
        JDOC("(math/floor x)\n\n"
             "Returns the largest integer value number that is not greater than x.")
    },
    {
        "math/ceil", janet_ceil,
        JDOC("(math/ceil x)\n\n"
             "Returns the smallest integer value number that is not less than x.")
    },
    {
        "math/pow", janet_pow,
        JDOC("(math/pow a x)\n\n"
             "Return a to the power of x.")
    },
    {
        "math/abs", janet_fabs,
        JDOC("(math/abs x)\n\n"
             "Return the absolute value of x.")
    },
    {
        "math/sinh", janet_sinh,
        JDOC("(math/sinh x)\n\n"
             "Return the hyperbolic sine of x.")
    },
    {
        "math/cosh", janet_cosh,
        JDOC("(math/cosh x)\n\n"
             "Return the hyperbolic cosine of x.")
    },
    {
        "math/tanh", janet_tanh,
        JDOC("(math/tanh x)\n\n"
             "Return the hyperbolic tangent of x.")
    },
    {
        "math/atanh", janet_atanh,
        JDOC("(math/atanh x)\n\n"
             "Return the hyperbolic arctangent of x.")
    },
    {
        "math/asinh", janet_asinh,
        JDOC("(math/asinh x)\n\n"
             "Return the hyperbolic arcsine of x.")
    },
    {
        "math/acosh", janet_acosh,
        JDOC("(math/acosh x)\n\n"
             "Return the hyperbolic arccosine of x.")
    },
    {
        "math/atan2", janet_atan2,
        JDOC("(math/atan2 y x)\n\n"
             "Return the arctangent of y/x. Works even when x is 0.")
    },
    {
        "math/rng", cfun_rng_make,
        JDOC("(math/rng &opt seed)\n\n"
             "Creates a Psuedo-Random number generator, with an optional seed. "
             "The seed should be an unsigned 32 bit integer or a buffer. "
             "Do not use this for cryptography. Returns a core/rng abstract type.")
    },
    {
        "math/rng-uniform", cfun_rng_uniform,
        JDOC("(math/rng-seed rng seed)\n\n"
             "Extract a random number in the range [0, 1) from the RNG.")
    },
    {
        "math/rng-int", cfun_rng_int,
        JDOC("(math/rng-int rng &opt max)\n\n"
             "Extract a random random integer in the range [0, max] from the RNG. If "
             "no max is given, the default is 2^31 - 1.")
    },
    {
        "math/rng-buffer", cfun_rng_buffer,
        JDOC("(math/rng-buffer rng n &opt buf)\n\n"
             "Get n random bytes and put them in a buffer. Creates a new buffer if no buffer is "
             "provided, otherwise appends to the given buffer. Returns the buffer.")
    },
    {
        "math/hypot", janet_hypot,
        JDOC("(math/hypot a b)\n\n"
             "Returns the c from the equation c^2 = a^2 + b^2")
    },
    {
        "math/exp2", janet_exp2,
        JDOC("(math/exp2 x)\n\n"
             "Returns 2 to the power of x.")
    },
    {
        "math/log1p", janet_log1p,
        JDOC("(math/log1p x)\n\n"
             "Returns (log base e of x) + 1 more accurately than (+ (math/log x) 1)")
    },
    {
        "math/gamma", janet_gamma,
        JDOC("(math/gamma x)\n\n"
             "Returns gamma(x).")
    },
    {
        "math/erfc", janet_erfc,
        JDOC("(math/erfc x)\n\n"
             "Returns the complementary error function of x.")
    },
    {
        "math/erf", janet_erf,
        JDOC("(math/erf x)\n\n"
             "Returns the error function of x.")
    },
    {
        "math/expm1", janet_expm1,
        JDOC("(math/expm1 x)\n\n"
             "Returns e to the power of x minus 1.")
    },
    {
        "math/trunc", janet_trunc,
        JDOC("(math/trunc x)\n\n"
             "Returns the integer between x and 0 nearest to x.")
    },
    {
        "math/round", janet_round,
        JDOC("(math/round x)\n\n"
             "Returns the integer nearest to x.")
    },
    {
        "math/next", janet_nextafter,
        JDOC("(math/next x y)\n\n"
             "Returns the next representable floating point value after x in the direction of y.")
    },
    {NULL, NULL, NULL}
};

/* Module entry point */
void janet_lib_math(JanetTable *env) {
    janet_core_cfuns(env, NULL, math_cfuns);
    janet_register_abstract_type(&janet_rng_type);
#ifdef JANET_BOOTSTRAP
    janet_def(env, "math/pi", janet_wrap_number(3.1415926535897931),
              JDOC("The value pi."));
    janet_def(env, "math/e", janet_wrap_number(2.7182818284590451),
              JDOC("The base of the natural log."));
    janet_def(env, "math/inf", janet_wrap_number(INFINITY),
              JDOC("The number representing positive infinity"));
    janet_def(env, "math/-inf", janet_wrap_number(-INFINITY),
              JDOC("The number representing negative infinity"));
#endif
}


/* src/core/net.c */
#line 0 "src/core/net.c"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "util.h"
#endif

#ifdef JANET_NET

#ifdef JANET_WINDOWS
#include <winsock2.h>
#include <windows.h>
#include <ws2tcpip.h>
#pragma comment (lib, "Ws2_32.lib")
#pragma comment (lib, "Mswsock.lib")
#pragma comment (lib, "Advapi32.lib")
#else
#include <unistd.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <poll.h>
#include <netdb.h>
#include <fcntl.h>
#endif

/*
 * Streams
 */

#define JANET_STREAM_CLOSED 1
#define JANET_STREAM_READABLE 2
#define JANET_STREAM_WRITABLE 4

static int janet_stream_close(void *p, size_t s);
static int janet_stream_getter(void *p, Janet key, Janet *out);
static const JanetAbstractType StreamAT = {
    "core/stream",
    janet_stream_close,
    NULL,
    janet_stream_getter,
    JANET_ATEND_GET
};

#ifdef JANET_WINDOWS
typedef struct {
    SOCKET fd;
    int flags;
} JanetStream;
#define JSOCKCLOSE(x) closesocket(x)
#define JSOCKDEFAULT INVALID_SOCKET
#define JLASTERR WSAGetLastError()
#define JSOCKVALID(x) ((x) != INVALID_SOCKET)
#define JEINTR WSAEINTR
#define JEWOULDBLOCK WSAEWOULDBLOCK
#define JEAGAIN WSAEWOULDBLOCK
#define JPOLL WSAPoll
#define JPollStruct WSAPOLLFD
#define JSock SOCKET
#define JReadInt long
#define JSOCKFLAGS 0
static JanetStream *make_stream(SOCKET fd, int flags) {
    u_long iMode = 0;
    JanetStream *stream = janet_abstract(&StreamAT, sizeof(JanetStream));
    ioctlsocket(fd, FIONBIO, &iMode);
    stream->fd = fd;
    stream->flags = flags;
    return stream;
}
#else
typedef struct {
    int fd;
    int flags;
} JanetStream;
#define JSOCKCLOSE(x) close(x)
#define JSOCKDEFAULT 0
#define JLASTERR errno
#define JSOCKVALID(x) ((x) >= 0)
#define JEINTR EINTR
#define JEWOULDBLOCK EWOULDBLOCK
#define JEAGAIN EAGAIN
#define JPOLL poll
#define JPollStruct struct pollfd
#define JSock int
#define JReadInt ssize_t
#ifdef SOCK_CLOEXEC
#define JSOCKFLAGS SOCK_CLOEXEC
#else
#define JSOCKFLAGS 0
#endif
static JanetStream *make_stream(int fd, int flags) {
    JanetStream *stream = janet_abstract(&StreamAT, sizeof(JanetStream));
#ifndef SOCK_CLOEXEC
    int extra = O_CLOEXEC;
#else
    int extra = 0;
#endif
    fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) | O_NONBLOCK | extra);
    stream->fd = fd;
    stream->flags = flags;
    return stream;
}
#endif

/* We pass this flag to all send calls to prevent sigpipe */
#ifndef MSG_NOSIGNAL
#define MSG_NOSIGNAL 0
#endif

static int janet_stream_close(void *p, size_t s) {
    (void) s;
    JanetStream *stream = p;
    if (!(stream->flags & JANET_STREAM_CLOSED)) {
        stream->flags |= JANET_STREAM_CLOSED;
        JSOCKCLOSE(stream->fd);
    }
    return 0;
}

/*
 * Event loop
 */

/* This large struct describes a waiting file descriptor, as well
 * as what to do when we get an event for it. It is a variant type, where
 * each variant implements a simple state machine. */
typedef struct {

    /* File descriptor to listen for events on. */
    JanetStream *stream;

    /* Fiber to resume when event finishes. Can be NULL, in which case,
     * no fiber is resumed when event completes. */
    JanetFiber *fiber;

    /* What kind of event we are listening for.
     * As more IO functionality get's added, we can
     * expand this. */
    enum {
        JLE_READ_CHUNK,
        JLE_READ_SOME,
        JLE_READ_ACCEPT,
        JLE_CONNECT,
        JLE_WRITE_FROM_BUFFER,
        JLE_WRITE_FROM_STRINGLIKE
    } event_type;

    /* Each variant can have a different payload. */
    union {

        /* JLE_READ_CHUNK/JLE_READ_SOME */
        struct {
            int32_t bytes_left;
            JanetBuffer *buf;
        } read_chunk;

        /* JLE_READ_ACCEPT */
        struct {
            JanetFunction *handler;
        } read_accept;

        /* JLE_WRITE_FROM_BUFFER */
        struct {
            JanetBuffer *buf;
            int32_t start;
        } write_from_buffer;

        /* JLE_WRITE_FROM_STRINGLIKE */
        struct {
            const uint8_t *str;
            int32_t start;
        } write_from_stringlike;

    } data;

} JanetLoopFD;

#define JANET_LOOPFD_MAX 1024

/* Global loop data */
JANET_THREAD_LOCAL JPollStruct janet_vm_pollfds[JANET_LOOPFD_MAX];
JANET_THREAD_LOCAL JanetLoopFD janet_vm_loopfds[JANET_LOOPFD_MAX];
JANET_THREAD_LOCAL int janet_vm_loop_count;

/* We could also add/remove gc roots. This is easier for now. */
void janet_net_markloop(void) {
    for (int i = 0; i < janet_vm_loop_count; i++) {
        JanetLoopFD lfd = janet_vm_loopfds[i];
        if (lfd.fiber != NULL) {
            janet_mark(janet_wrap_fiber(lfd.fiber));
        }
        janet_mark(janet_wrap_abstract(lfd.stream));
        switch (lfd.event_type) {
            default:
                break;
            case JLE_READ_CHUNK:
            case JLE_READ_SOME:
                janet_mark(janet_wrap_buffer(lfd.data.read_chunk.buf));
                break;
            case JLE_READ_ACCEPT:
                janet_mark(janet_wrap_function(lfd.data.read_accept.handler));
                break;
            case JLE_CONNECT:
                break;
            case JLE_WRITE_FROM_BUFFER:
                janet_mark(janet_wrap_buffer(lfd.data.write_from_buffer.buf));
                break;
            case JLE_WRITE_FROM_STRINGLIKE:
                janet_mark(janet_wrap_string(lfd.data.write_from_stringlike.str));
        }
    }
}

/* Add a loop fd to the global event loop */
static int janet_loop_schedule(JanetLoopFD lfd, short events) {
    if (janet_vm_loop_count == JANET_LOOPFD_MAX) {
        return -1;
    }
    int index = janet_vm_loop_count++;
    janet_vm_loopfds[index] = lfd;
    janet_vm_pollfds[index].fd = lfd.stream->fd;
    janet_vm_pollfds[index].events = events;
    janet_vm_pollfds[index].revents = 0;
    return index;
}

/* Remove event from list */
static void janet_loop_rmindex(int index) {
    janet_vm_loopfds[index] = janet_vm_loopfds[--janet_vm_loop_count];
    janet_vm_pollfds[index] = janet_vm_pollfds[janet_vm_loop_count];
}


/* Return delta in number of loop fds. Abstracted out so
 * we can separate out the polling logic */
static size_t janet_loop_event(size_t index) {
    JanetLoopFD *jlfd = janet_vm_loopfds + index;
    JanetStream *stream = jlfd->stream;
    JSock fd = stream->fd;
    int ret = 1;
    int should_resume = 0;
    Janet resumeval = janet_wrap_nil();
    if (stream->flags & JANET_STREAM_CLOSED) {
        should_resume = 1;
        ret = 0;
    } else {
        switch (jlfd->event_type) {
            case JLE_READ_CHUNK:
            case JLE_READ_SOME: {
                JanetBuffer *buffer = jlfd->data.read_chunk.buf;
                int32_t bytes_left = jlfd->data.read_chunk.bytes_left;
                janet_buffer_extra(buffer, bytes_left);
                if (!(stream->flags & JANET_STREAM_READABLE)) {
                    should_resume = 1;
                    ret = 0;
                    break;
                }
                JReadInt nread;
                do {
                    nread = recv(fd, buffer->data + buffer->count, bytes_left, 0);
                } while (nread == -1 && JLASTERR == JEINTR);
                if (JLASTERR == JEAGAIN || JLASTERR == JEWOULDBLOCK) {
                    ret = 1;
                    break;
                }

                if (nread > 0) {
                    buffer->count += nread;
                    bytes_left -= nread;
                } else {
                    bytes_left = 0;
                }
                if (jlfd->event_type == JLE_READ_SOME || bytes_left == 0) {
                    should_resume = 1;
                    if (nread > 0) {
                        resumeval = janet_wrap_buffer(buffer);
                    }
                    ret = 0;
                } else {
                    jlfd->data.read_chunk.bytes_left = bytes_left;
                    ret = 1;
                }
                break;
            }
            case JLE_READ_ACCEPT: {
                JSock connfd = accept(fd, NULL, NULL);
                if (JSOCKVALID(connfd)) {
                    /* Made a new connection socket */
                    JanetStream *stream = make_stream(connfd, JANET_STREAM_READABLE | JANET_STREAM_WRITABLE);
                    Janet streamv = janet_wrap_abstract(stream);
                    JanetFunction *handler = jlfd->data.read_accept.handler;
                    Janet out;
                    JanetFiber *fiberp = NULL;
                    /* Launch connection fiber */
                    JanetSignal sig = janet_pcall(handler, 1, &streamv, &out, &fiberp);
                    if (sig != JANET_SIGNAL_OK && sig != JANET_SIGNAL_EVENT) {
                        janet_stacktrace(fiberp, out);
                    }
                }
                ret = JANET_LOOPFD_MAX;
                break;
            }
            case JLE_WRITE_FROM_BUFFER:
            case JLE_WRITE_FROM_STRINGLIKE: {
                int32_t start, len;
                const uint8_t *bytes;
                if (!(stream->flags & JANET_STREAM_WRITABLE)) {
                    should_resume = 1;
                    ret = 0;
                    break;
                }
                if (jlfd->event_type == JLE_WRITE_FROM_BUFFER) {
                    JanetBuffer *buffer = jlfd->data.write_from_buffer.buf;
                    bytes = buffer->data;
                    len = buffer->count;
                    start = jlfd->data.write_from_buffer.start;
                } else {
                    bytes = jlfd->data.write_from_stringlike.str;
                    len = janet_string_length(bytes);
                    start = jlfd->data.write_from_stringlike.start;
                }
                if (start < len) {
                    int32_t nbytes = len - start;
                    JReadInt nwrote;
                    do {
                        nwrote = send(fd, bytes + start, nbytes, MSG_NOSIGNAL);
                    } while (nwrote == -1 && JLASTERR == JEINTR);
                    if (nwrote > 0) {
                        start += nwrote;
                    } else {
                        start = len;
                    }
                }
                if (start >= len) {
                    should_resume = 1;
                    ret = 0;
                } else {
                    if (jlfd->event_type == JLE_WRITE_FROM_BUFFER) {
                        jlfd->data.write_from_buffer.start = start;
                    } else {
                        jlfd->data.write_from_stringlike.start = start;
                    }
                    ret = 1;
                }
                break;
            }
            case JLE_CONNECT: {
                break;
            }
        }
    }

    /* Resume a fiber for some events */
    if (NULL != jlfd->fiber && should_resume) {
        /* Resume the fiber */
        Janet out;
        JanetSignal sig = janet_continue(jlfd->fiber, resumeval, &out);
        if (sig != JANET_SIGNAL_OK && sig != JANET_SIGNAL_EVENT) {
            janet_stacktrace(jlfd->fiber, out);
        }
    }

    /* Remove this handler from the handler pool. */
    if (should_resume) janet_loop_rmindex((int) index);

    return ret;
}

static void janet_loop1(void) {
    /* Remove closed file descriptors */
    for (int i = 0; i < janet_vm_loop_count;) {
        if (janet_vm_loopfds[i].stream->flags & JANET_STREAM_CLOSED) {
            janet_loop_rmindex(i);
        } else {
            i++;
        }
    }
    /* Poll */
    if (janet_vm_loop_count == 0) return;
    int ready;
    do {
        ready = JPOLL(janet_vm_pollfds, janet_vm_loop_count, -1);
    } while (ready == -1 && JLASTERR == JEINTR);
    if (ready == -1) return;
    /* Handle events */
    for (int i = 0; i < janet_vm_loop_count;) {
        int revents = janet_vm_pollfds[i].revents;
        janet_vm_pollfds[i].revents = 0;
        if ((janet_vm_pollfds[i].events | POLLHUP | POLLERR) & revents) {
            size_t delta = janet_loop_event(i);
            i += (int) delta;
        } else {
            i++;
        }
    }
}

void janet_loop(void) {
    while (janet_vm_loop_count) {
        janet_loop1();
    }
}

/*
 * Scheduling Helpers
 */

#define JANET_SCHED_FSOME 1

JANET_NO_RETURN static void janet_sched_read(JanetStream *stream, JanetBuffer *buf, int32_t nbytes, int flags) {
    JanetLoopFD lfd;
    lfd.stream = stream;
    lfd.fiber = janet_root_fiber();
    lfd.event_type = (flags & JANET_SCHED_FSOME) ? JLE_READ_SOME : JLE_READ_CHUNK;
    lfd.data.read_chunk.buf = buf;
    lfd.data.read_chunk.bytes_left = nbytes;
    janet_loop_schedule(lfd, POLLIN);
    janet_signalv(JANET_SIGNAL_EVENT, janet_wrap_nil());
}

JANET_NO_RETURN static void janet_sched_write_buffer(JanetStream *stream, JanetBuffer *buf) {
    JanetLoopFD lfd;
    lfd.stream = stream;
    lfd.fiber = janet_root_fiber();
    lfd.event_type = JLE_WRITE_FROM_BUFFER;
    lfd.data.write_from_buffer.buf = buf;
    lfd.data.write_from_buffer.start = 0;
    janet_loop_schedule(lfd, POLLOUT);
    janet_signalv(JANET_SIGNAL_EVENT, janet_wrap_nil());
}

JANET_NO_RETURN static void janet_sched_write_stringlike(JanetStream *stream, const uint8_t *str) {
    JanetLoopFD lfd;
    lfd.stream = stream;
    lfd.fiber = janet_root_fiber();
    lfd.event_type = JLE_WRITE_FROM_STRINGLIKE;
    lfd.data.write_from_stringlike.str = str;
    lfd.data.write_from_stringlike.start = 0;
    janet_loop_schedule(lfd, POLLOUT);
    janet_signalv(JANET_SIGNAL_EVENT, janet_wrap_nil());
}

/* Needs argc >= offset + 2 */
static struct addrinfo *janet_get_addrinfo(Janet *argv, int32_t offset) {
    /* Get host and port */
    const char *host = janet_getcstring(argv, offset);
    const char *port;
    if (janet_checkint(argv[offset + 1])) {
        port = (const char *)janet_to_string(argv[offset + 1]);
    } else {
        port = janet_getcstring(argv, offset + 1);
    }
    /* getaddrinfo */
    struct addrinfo *ai = NULL;
    struct addrinfo hints;
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_protocol = 0;
    hints.ai_flags = AI_PASSIVE;
    int status = getaddrinfo(host, port, &hints, &ai);
    if (status) {
        janet_panicf("could not get address info: %s", gai_strerror(status));
    }
    return ai;
}

/*
 * C Funs
 */

static Janet cfun_net_connect(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 2);

    struct addrinfo *ai = janet_get_addrinfo(argv, 0);

    /* Create socket */
    JSock sock = socket(ai->ai_family, ai->ai_socktype | JSOCKFLAGS, ai->ai_protocol);
    if (!JSOCKVALID(sock)) {
        freeaddrinfo(ai);
        janet_panic("could not create socket");
    }

    /* Connect to socket */
    int status = connect(sock, ai->ai_addr, (int) ai->ai_addrlen);
    freeaddrinfo(ai);
    if (status == -1) {
        JSOCKCLOSE(sock);
        janet_panic("could not connect to socket");
    }

    /* Wrap socket in abstract type JanetStream */
    JanetStream *stream = make_stream(sock, JANET_STREAM_READABLE | JANET_STREAM_WRITABLE);
    return janet_wrap_abstract(stream);
}

static Janet cfun_net_server(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 3);

    /* Get host, port, and handler*/
    JanetFunction *fun = janet_getfunction(argv, 2);

    struct addrinfo *ai = janet_get_addrinfo(argv, 0);

    /* Check all addrinfos in a loop for the first that we can bind to. */
    JSock sfd = JSOCKDEFAULT;
    struct addrinfo *rp = NULL;
    for (rp = ai; rp != NULL; rp = rp->ai_next) {
        sfd = socket(rp->ai_family, rp->ai_socktype | JSOCKFLAGS, rp->ai_protocol);
        if (!JSOCKVALID(sfd)) continue;
        /* Set various socket options */
        int enable = 1;
        if (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (char *) &enable, sizeof(int)) < 0) {
            JSOCKCLOSE(sfd);
            janet_panic("setsockopt(SO_REUSEADDR) failed");
        }
#ifdef SO_NOSIGPIPE
        if (setsockopt(sfd, SOL_SOCKET, SO_NOSIGPIPE, &enable, sizeof(int)) < 0) {
            JSOCKCLOSE(sfd);
            janet_panic("setsockopt(SO_NOSIGPIPE) failed");
        }
#endif
#ifdef SO_REUSEPORT
        if (setsockopt(sfd, SOL_SOCKET, SO_REUSEPORT, &enable, sizeof(int)) < 0) {
            JSOCKCLOSE(sfd);
            janet_panic("setsockopt(SO_REUSEPORT) failed");
        }
#endif
        /* Bind */
        if (bind(sfd, rp->ai_addr, (int) rp->ai_addrlen) == 0) break;
        JSOCKCLOSE(sfd);
    }
    if (NULL == rp) {
        freeaddrinfo(ai);
        janet_panic("could not bind to any sockets");
    }

    /* listen */
    int status = listen(sfd, 1024);
    freeaddrinfo(ai);
    if (status) {
        JSOCKCLOSE(sfd);
        janet_panic("could not listen on file descriptor");
    }

    /* Put sfd on our loop */
    JanetLoopFD lfd = {0};
    lfd.stream = make_stream(sfd, 0);
    lfd.event_type = JLE_READ_ACCEPT;
    lfd.data.read_accept.handler = fun;
    janet_loop_schedule(lfd, POLLIN);

    return janet_wrap_abstract(lfd.stream);
}

static Janet cfun_stream_read(int32_t argc, Janet *argv) {
    janet_arity(argc, 2, 3);
    JanetStream *stream = janet_getabstract(argv, 0, &StreamAT);
    int32_t n = janet_getnat(argv, 1);
    JanetBuffer *buffer = janet_optbuffer(argv, argc, 2, 10);
    janet_sched_read(stream, buffer, n, JANET_SCHED_FSOME);
}

static Janet cfun_stream_chunk(int32_t argc, Janet *argv) {
    janet_arity(argc, 2, 3);
    JanetStream *stream = janet_getabstract(argv, 0, &StreamAT);
    int32_t n = janet_getnat(argv, 1);
    JanetBuffer *buffer = janet_optbuffer(argv, argc, 2, 10);
    janet_sched_read(stream, buffer, n, 0);
}

static Janet cfun_stream_close(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    JanetStream *stream = janet_getabstract(argv, 0, &StreamAT);
    janet_stream_close(stream, 0);
    return janet_wrap_nil();
}

static Janet cfun_stream_write(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 2);
    JanetStream *stream = janet_getabstract(argv, 0, &StreamAT);
    if (janet_checktype(argv[1], JANET_BUFFER)) {
        janet_sched_write_buffer(stream, janet_getbuffer(argv, 1));
    } else {
        JanetByteView bytes = janet_getbytes(argv, 1);
        janet_sched_write_stringlike(stream, bytes.bytes);
    }
}

static const JanetMethod stream_methods[] = {
    {"chunk", cfun_stream_chunk},
    {"close", cfun_stream_close},
    {"read", cfun_stream_read},
    {"write", cfun_stream_write},
    {NULL, NULL}
};

static int janet_stream_getter(void *p, Janet key, Janet *out) {
    (void) p;
    if (!janet_checktype(key, JANET_KEYWORD)) return 0;
    return janet_getmethod(janet_unwrap_keyword(key), stream_methods, out);
}

static const JanetReg net_cfuns[] = {
    {
        "net/server", cfun_net_server,
        JDOC("(net/server host port handler)\n\n"
             "Start a TCP server. handler is a function that will be called with a stream "
             "on each connection to the server. Returns a new stream that is neither readable nor "
             "writeable.")
    },
    {
        "net/read", cfun_stream_read,
        JDOC("(net/read stream nbytes &opt buf)\n\n"
             "Read up to n bytes from a stream, suspending the current fiber until the bytes are available. "
             "If less than n bytes are available (and more than 0), will push those bytes and return early. "
             "Returns a buffer with up to n more bytes in it.")
    },
    {
        "net/chunk", cfun_stream_chunk,
        JDOC("(net/chunk stream nbytes &opt buf)\n\n"
             "Same a net/read, but will wait for all n bytes to arrive rather than return early.")
    },
    {
        "net/write", cfun_stream_write,
        JDOC("(net/write stream data)\n\n"
             "Write data to a stream, suspending the current fiber until the write "
             "completes. Returns stream.")
    },
    {
        "net/close", cfun_stream_close,
        JDOC("(net/close stream)\n\n"
             "Close a stream so that no further communication can occur.")
    },
    {
        "net/connect", cfun_net_connect,
        JDOC("(net/connect host port)\n\n"
             "Open a connection to communicate with a server. Returns a duplex stream "
             "that can be used to communicate with the server.")
    },
    {NULL, NULL, NULL}
};

void janet_lib_net(JanetTable *env) {
    janet_vm_loop_count = 0;
#ifdef JANET_WINDOWS
    WSADATA wsaData;
    janet_assert(!WSAStartup(MAKEWORD(2, 2), &wsaData), "could not start winsock");
#endif
    janet_core_cfuns(env, NULL, net_cfuns);
}

void janet_net_deinit(void) {
#ifdef JANET_WINDOWS
    WSACleanup();
#endif
}

#endif


/* src/core/os.c */
#line 0 "src/core/os.c"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "util.h"
#endif

#ifndef JANET_REDUCED_OS

#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <string.h>
#include <sys/stat.h>

#define RETRY_EINTR(RC, CALL) do { (RC) = CALL; } while((RC) < 0 && errno == EINTR)

#ifdef JANET_WINDOWS
#include <windows.h>
#include <direct.h>
#include <sys/utime.h>
#include <io.h>
#include <process.h>
#else
#include <spawn.h>
#include <utime.h>
#include <unistd.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/wait.h>
extern char **environ;
#ifdef JANET_THREADS
#include <pthread.h>
#endif
#endif

/* For macos */
#ifdef __MACH__
#include <mach/clock.h>
#include <mach/mach.h>
#endif

/* Setting C99 standard makes this not available, but it should
 * work/link properly if we detect a BSD */
#if defined(JANET_BSD) || defined(JANET_APPLE)
void arc4random_buf(void *buf, size_t nbytes);
#endif

/* Not POSIX, but all Unixes but Solaris have this function. */
#if defined(JANET_POSIX) && !defined(__sun)
time_t timegm(struct tm *tm);
#elif defined(JANET_WINDOWS)
#define timegm _mkgmtime
#endif

/* Access to some global variables should be synchronized if not in single threaded mode, as
 * setenv/getenv are not thread safe. */
#ifdef JANET_THREADS
# ifdef JANET_WINDOWS
static int env_lock_initialized = 0;
static CRITICAL_SECTION env_lock;
static void janet_lock_environ(void) {
    EnterCriticalSection(&env_lock);
}
static void janet_unlock_environ(void) {
    LeaveCriticalSection(&env_lock);
}
# else
static pthread_mutex_t env_lock = PTHREAD_MUTEX_INITIALIZER;
static void janet_lock_environ(void) {
    pthread_mutex_lock(&env_lock);
}
static void janet_unlock_environ(void) {
    pthread_mutex_unlock(&env_lock);
}
# endif
#else
static void janet_lock_environ(void) {
}
static void janet_unlock_environ(void) {
}
#endif

#endif /* JANET_REDCUED_OS */

/* Core OS functions */

/* Full OS functions */

#define janet_stringify1(x) #x
#define janet_stringify(x) janet_stringify1(x)

static Janet os_which(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 0);
    (void) argv;
#if defined(JANET_OS_NAME)
    return janet_ckeywordv(janet_stringify(JANET_OS_NAME));
#elif defined(JANET_WINDOWS)
    return janet_ckeywordv("windows");
#elif defined(JANET_APPLE)
    return janet_ckeywordv("macos");
#elif defined(__EMSCRIPTEN__)
    return janet_ckeywordv("web");
#elif defined(JANET_LINUX)
    return janet_ckeywordv("linux");
#elif defined(__FreeBSD__)
    return janet_ckeywordv("freebsd");
#elif defined(__NetBSD__)
    return janet_ckeywordv("netbsd");
#elif defined(__OpenBSD__)
    return janet_ckeywordv("openbsd");
#elif defined(JANET_BSD)
    return janet_ckeywordv("bsd");
#else
    return janet_ckeywordv("posix");
#endif
}

/* Detect the ISA we are compiled for */
static Janet os_arch(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 0);
    (void) argv;
    /* Check 64-bit vs 32-bit */
#if defined(JANET_ARCH_NAME)
    return janet_ckeywordv(janet_stringify(JANET_ARCH_NAME));
#elif defined(__EMSCRIPTEN__)
    return janet_ckeywordv("wasm");
#elif (defined(__x86_64__) || defined(_M_X64))
    return janet_ckeywordv("x64");
#elif defined(__i386) || defined(_M_IX86)
    return janet_ckeywordv("x86");
#elif defined(_M_ARM64) || defined(__aarch64__)
    return janet_ckeywordv("aarch64");
#elif defined(_M_ARM) || defined(__arm__)
    return janet_ckeywordv("arm");
#elif (defined(__sparc__))
    return janet_ckeywordv("sparc");
#else
    return janet_ckeywordv("unknown");
#endif
}

#undef janet_stringify1
#undef janet_stringify

static Janet os_exit(int32_t argc, Janet *argv) {
    janet_arity(argc, 0, 1);
    int status;
    if (argc == 0) {
        status = EXIT_SUCCESS;
    } else if (janet_checkint(argv[0])) {
        status = janet_unwrap_integer(argv[0]);
    } else {
        status = EXIT_FAILURE;
    }
    janet_deinit();
    exit(status);
    return janet_wrap_nil();
}

#ifndef JANET_REDUCED_OS

#ifndef JANET_NO_PROCESSES
/* Get env for os_execute */
static char **os_execute_env(int32_t argc, const Janet *argv) {
    char **envp = NULL;
    if (argc > 2) {
        JanetDictView dict = janet_getdictionary(argv, 2);
        envp = janet_smalloc(sizeof(char *) * ((size_t)dict.len + 1));
        int32_t j = 0;
        for (int32_t i = 0; i < dict.cap; i++) {
            const JanetKV *kv = dict.kvs + i;
            if (!janet_checktype(kv->key, JANET_STRING)) continue;
            if (!janet_checktype(kv->value, JANET_STRING)) continue;
            const uint8_t *keys = janet_unwrap_string(kv->key);
            const uint8_t *vals = janet_unwrap_string(kv->value);
            int32_t klen = janet_string_length(keys);
            int32_t vlen = janet_string_length(vals);
            /* Check keys has no embedded 0s or =s. */
            int skip = 0;
            for (int32_t k = 0; k < klen; k++) {
                if (keys[k] == '\0' || keys[k] == '=') {
                    skip = 1;
                    break;
                }
            }
            if (skip) continue;
            char *envitem = janet_smalloc((size_t) klen + (size_t) vlen + 2);
            memcpy(envitem, keys, klen);
            envitem[klen] = '=';
            memcpy(envitem + klen + 1, vals, vlen);
            envitem[klen + vlen + 1] = 0;
            envp[j++] = envitem;
        }
        envp[j] = NULL;
    }
    return envp;
}

/* Free memory from os_execute */
static void os_execute_cleanup(char **envp, const char **child_argv) {
#ifdef JANET_WINDOWS
    (void) child_argv;
#else
    janet_sfree((void *)child_argv);
#endif
    if (NULL != envp) {
        char **envitem = envp;
        while (*envitem != NULL) {
            janet_sfree(*envitem);
            envitem++;
        }
    }
    janet_sfree(envp);
}

#ifdef JANET_WINDOWS
/* Windows processes created via CreateProcess get only one command line argument string, and
 * must parse this themselves. Each processes is free to do this however they like, but the
 * standard parsing method is CommandLineToArgvW. We need to properly escape arguments into
 * a single string of this format. Returns a buffer that can be cast into a c string. */
static JanetBuffer *os_exec_escape(JanetView args) {
    JanetBuffer *b = janet_buffer(0);
    for (int32_t i = 0; i < args.len; i++) {
        const char *arg = janet_getcstring(args.items, i);

        /* Push leading space if not first */
        if (i) janet_buffer_push_u8(b, ' ');

        /* Find first special character */
        const char *first_spec = arg;
        while (*first_spec) {
            switch (*first_spec) {
                case ' ':
                case '\t':
                case '\v':
                case '\n':
                case '"':
                    goto found;
                case '\0':
                    janet_panic("embedded 0 not allowed in command line string");
                default:
                    first_spec++;
                    break;
            }
        }
    found:

        /* Check if needs escape */
        if (*first_spec == '\0') {
            /* No escape needed */
            janet_buffer_push_cstring(b, arg);
        } else {
            /* Escape */
            janet_buffer_push_u8(b, '"');
            for (const char *c = arg; ; c++) {
                unsigned numBackSlashes = 0;
                while (*c == '\\') {
                    c++;
                    numBackSlashes++;
                }
                if (*c == '"') {
                    /* Escape all backslashes and double quote mark */
                    int32_t n = 2 * numBackSlashes + 1;
                    janet_buffer_extra(b, n + 1);
                    memset(b->data + b->count, '\\', n);
                    b->count += n;
                    janet_buffer_push_u8(b, '"');
                } else if (*c) {
                    /* Don't escape backslashes. */
                    int32_t n = numBackSlashes;
                    janet_buffer_extra(b, n + 1);
                    memset(b->data + b->count, '\\', n);
                    b->count += n;
                    janet_buffer_push_u8(b, *c);
                } else {
                    /* we finished Escape all backslashes */
                    int32_t n = 2 * numBackSlashes;
                    janet_buffer_extra(b, n + 1);
                    memset(b->data + b->count, '\\', n);
                    b->count += n;
                    break;
                }
            }
            janet_buffer_push_u8(b, '"');
        }
    }
    janet_buffer_push_u8(b, 0);
    return b;
}
#endif

static Janet os_execute(int32_t argc, Janet *argv) {
    janet_arity(argc, 1, 3);

    /* Get flags */
    uint64_t flags = 0;
    if (argc > 1) {
        flags = janet_getflags(argv, 1, "ep");
    }

    /* Get environment */
    char **envp = os_execute_env(argc, argv);

    /* Get arguments */
    JanetView exargs = janet_getindexed(argv, 0);
    if (exargs.len < 1) {
        janet_panic("expected at least 1 command line argument");
    }

    /* Result */
    int status = 0;

#ifdef JANET_WINDOWS

    JanetBuffer *buf = os_exec_escape(exargs);
    if (buf->count > 8191) {
        janet_panic("command line string too long (max 8191 characters)");
    }
    const char *path = (const char *) janet_unwrap_string(exargs.items[0]);
    char *cargv[2] = {(char *) buf->data, NULL};

    /* Use _spawn family of functions. */
    /* Windows docs say do this before any spawns. */
    _flushall();

    /* Use an empty env instead when envp is NULL to be consistent with other implementation. */
    char *empty_env[1] = {NULL};
    char **envp1 = (NULL == envp) ? empty_env : envp;

    if (janet_flag_at(flags, 1) && janet_flag_at(flags, 0)) {
        status = (int) _spawnvpe(_P_WAIT, path, cargv, envp1);
    } else if (janet_flag_at(flags, 1)) {
        status = (int) _spawnvp(_P_WAIT, path, cargv);
    } else if (janet_flag_at(flags, 0)) {
        status = (int) _spawnve(_P_WAIT, path, cargv, envp1);
    } else {
        status = (int) _spawnv(_P_WAIT, path, cargv);
    }
    os_execute_cleanup(envp, NULL);

    /* Check error */
    if (-1 == status) {
        janet_panicf("%p: %s", argv[0], strerror(errno));
    }

    return janet_wrap_integer(status);
#else

    const char **child_argv = janet_smalloc(sizeof(char *) * ((size_t) exargs.len + 1));
    for (int32_t i = 0; i < exargs.len; i++)
        child_argv[i] = janet_getcstring(exargs.items, i);
    child_argv[exargs.len] = NULL;
    /* Coerce to form that works for spawn. I'm fairly confident no implementation
     * of posix_spawn would modify the argv array passed in. */
    char *const *cargv = (char *const *)child_argv;

    /* Use posix_spawn to spawn new process */

    int use_environ = !janet_flag_at(flags, 0);

    if (use_environ) {
        janet_lock_environ();
    }

    pid_t pid;
    if (janet_flag_at(flags, 1)) {
        status = posix_spawnp(&pid,
                              child_argv[0], NULL, NULL, cargv,
                              use_environ ? environ : envp);
    } else {
        status = posix_spawn(&pid,
                             child_argv[0], NULL, NULL, cargv,
                             use_environ ? environ : envp);
    }

    if (use_environ) {
        janet_unlock_environ();
    }

    /* Wait for child */
    if (status) {
        os_execute_cleanup(envp, child_argv);
        janet_panicf("%p: %s", argv[0], strerror(errno));
    } else {
        waitpid(pid, &status, 0);
    }

    os_execute_cleanup(envp, child_argv);
    /* Use POSIX shell semantics for interpreting signals */
    int ret;
    if (WIFEXITED(status)) {
        ret = WEXITSTATUS(status);
    } else if (WIFSTOPPED(status)) {
        ret = WSTOPSIG(status) + 128;
    } else {
        ret = WTERMSIG(status) + 128;
    }
    return janet_wrap_integer(ret);
#endif
}

static Janet os_shell(int32_t argc, Janet *argv) {
    janet_arity(argc, 0, 1);
    const char *cmd = argc
                      ? janet_getcstring(argv, 0)
                      : NULL;
    int stat = system(cmd);
    return argc
           ? janet_wrap_integer(stat)
           : janet_wrap_boolean(stat);
}

#endif /* JANET_NO_PROCESSES */

static Janet os_environ(int32_t argc, Janet *argv) {
    (void) argv;
    janet_fixarity(argc, 0);
    int32_t nenv = 0;
    janet_lock_environ();
    char **env = environ;
    while (*env++)
        nenv += 1;
    JanetTable *t = janet_table(nenv);
    for (int32_t i = 0; i < nenv; i++) {
        char *e = environ[i];
        char *eq = strchr(e, '=');
        if (!eq) {
            janet_unlock_environ();
            janet_panic("no '=' in environ");
        }
        char *v = eq + 1;
        int32_t full_len = (int32_t) strlen(e);
        int32_t val_len = (int32_t) strlen(v);
        janet_table_put(
            t,
            janet_stringv((const uint8_t *)e, full_len - val_len - 1),
            janet_stringv((const uint8_t *)v, val_len)
        );
    }
    janet_unlock_environ();
    return janet_wrap_table(t);
}

static Janet os_getenv(int32_t argc, Janet *argv) {
    janet_arity(argc, 1, 2);
    const char *cstr = janet_getcstring(argv, 0);
    const char *res = getenv(cstr);
    janet_lock_environ();
    Janet ret = res
                ? janet_cstringv(res)
                : argc == 2
                ? argv[1]
                : janet_wrap_nil();
    janet_unlock_environ();
    return ret;
}

static Janet os_setenv(int32_t argc, Janet *argv) {
#ifdef JANET_WINDOWS
#define SETENV(K,V) _putenv_s(K, V)
#define UNSETENV(K) _putenv_s(K, "")
#else
#define SETENV(K,V) setenv(K, V, 1)
#define UNSETENV(K) unsetenv(K)
#endif
    janet_arity(argc, 1, 2);
    const char *ks = janet_getcstring(argv, 0);
    const char *vs = janet_optcstring(argv, argc, 1, NULL);
    janet_lock_environ();
    if (NULL == vs) {
        UNSETENV(ks);
    } else {
        SETENV(ks, vs);
    }
    janet_unlock_environ();
    return janet_wrap_nil();
}

static Janet os_time(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 0);
    (void) argv;
    double dtime = (double)(time(NULL));
    return janet_wrap_number(dtime);
}

/* Clock shims */
#ifdef JANET_WINDOWS
static int gettime(struct timespec *spec) {
    FILETIME ftime;
    GetSystemTimeAsFileTime(&ftime);
    int64_t wintime = (int64_t)(ftime.dwLowDateTime) | ((int64_t)(ftime.dwHighDateTime) << 32);
    /* Windows epoch is January 1, 1601 apparently */
    wintime -= 116444736000000000LL;
    spec->tv_sec  = wintime / 10000000LL;
    /* Resolution is 100 nanoseconds. */
    spec->tv_nsec = wintime % 10000000LL * 100;
    return 0;
}
#elif defined(__MACH__)
static int gettime(struct timespec *spec) {
    clock_serv_t cclock;
    mach_timespec_t mts;
    host_get_clock_service(mach_host_self(), CALENDAR_CLOCK, &cclock);
    clock_get_time(cclock, &mts);
    mach_port_deallocate(mach_task_self(), cclock);
    spec->tv_sec = mts.tv_sec;
    spec->tv_nsec = mts.tv_nsec;
    return 0;
}
#else
#define gettime(TV) clock_gettime(CLOCK_MONOTONIC, (TV))
#endif

static Janet os_clock(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 0);
    (void) argv;
    struct timespec tv;
    if (gettime(&tv)) janet_panic("could not get time");
    double dtime = tv.tv_sec + (tv.tv_nsec / 1E9);
    return janet_wrap_number(dtime);
}

static Janet os_sleep(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    double delay = janet_getnumber(argv, 0);
    if (delay < 0) janet_panic("invalid argument to sleep");
#ifdef JANET_WINDOWS
    Sleep((DWORD)(delay * 1000));
#else
    int rc;
    struct timespec ts;
    ts.tv_sec = (time_t) delay;
    ts.tv_nsec = (delay <= UINT32_MAX)
                 ? (long)((delay - ((uint32_t)delay)) * 1000000000)
                 : 0;
    RETRY_EINTR(rc, nanosleep(&ts, &ts));
#endif
    return janet_wrap_nil();
}

static Janet os_cwd(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 0);
    (void) argv;
    char buf[FILENAME_MAX];
    char *ptr;
#ifdef JANET_WINDOWS
    ptr = _getcwd(buf, FILENAME_MAX);
#else
    ptr = getcwd(buf, FILENAME_MAX);
#endif
    if (NULL == ptr) janet_panic("could not get current directory");
    return janet_cstringv(ptr);
}

static Janet os_cryptorand(int32_t argc, Janet *argv) {
    JanetBuffer *buffer;
    const char *genericerr = "unable to get sufficient random data";
    janet_arity(argc, 1, 2);
    int32_t offset;
    int32_t n = janet_getinteger(argv, 0);
    if (n < 0) janet_panic("expected positive integer");
    if (argc == 2) {
        buffer = janet_getbuffer(argv, 1);
        offset = buffer->count;
    } else {
        offset = 0;
        buffer = janet_buffer(n);
    }
    /* We could optimize here by adding setcount_uninit */
    janet_buffer_setcount(buffer, offset + n);

#ifdef JANET_WINDOWS
    for (int32_t i = offset; i < buffer->count; i += sizeof(unsigned int)) {
        unsigned int v;
        if (rand_s(&v))
            janet_panic(genericerr);
        for (int32_t j = 0; (j < sizeof(unsigned int)) && (i + j < buffer->count); j++) {
            buffer->data[i + j] = v & 0xff;
            v = v >> 8;
        }
    }
#elif defined(JANET_LINUX)
    /* We should be able to call getrandom on linux, but it doesn't seem
       to be uniformly supported on linux distros.
       In both cases, use this fallback path for now... */
    int rc;
    int randfd;
    RETRY_EINTR(randfd, open("/dev/urandom", O_RDONLY | O_CLOEXEC));
    if (randfd < 0)
        janet_panic(genericerr);
    while (n > 0) {
        ssize_t nread;
        RETRY_EINTR(nread, read(randfd, buffer->data + offset, n));
        if (nread <= 0) {
            RETRY_EINTR(rc, close(randfd));
            janet_panic(genericerr);
        }
        offset += nread;
        n -= nread;
    }
    RETRY_EINTR(rc, close(randfd));
#elif defined(JANET_BSD) || defined(JANET_APPLE)
    (void) genericerr;
    arc4random_buf(buffer->data + offset, n);
#else
    (void) genericerr;
    janet_panic("cryptorand currently unsupported on this platform");
#endif
    return janet_wrap_buffer(buffer);
}

static Janet os_date(int32_t argc, Janet *argv) {
    janet_arity(argc, 0, 2);
    (void) argv;
    time_t t;
    struct tm t_infos;
    struct tm *t_info = NULL;
    if (argc) {
        int64_t integer = janet_getinteger64(argv, 0);
        t = (time_t) integer;
    } else {
        time(&t);
    }
    if (argc >= 2 && janet_truthy(argv[1])) {
        /* local time */
#ifdef JANET_WINDOWS
        localtime_s(&t_infos, &t);
        t_info = &t_infos;
#else
        tzset();
        t_info = localtime_r(&t, &t_infos);
#endif
    } else {
        /* utc time */
#ifdef JANET_WINDOWS
        gmtime_s(&t_infos, &t);
        t_info = &t_infos;
#else
        t_info = gmtime_r(&t, &t_infos);
#endif
    }
    JanetKV *st = janet_struct_begin(9);
    janet_struct_put(st, janet_ckeywordv("seconds"), janet_wrap_number(t_info->tm_sec));
    janet_struct_put(st, janet_ckeywordv("minutes"), janet_wrap_number(t_info->tm_min));
    janet_struct_put(st, janet_ckeywordv("hours"), janet_wrap_number(t_info->tm_hour));
    janet_struct_put(st, janet_ckeywordv("month-day"), janet_wrap_number(t_info->tm_mday - 1));
    janet_struct_put(st, janet_ckeywordv("month"), janet_wrap_number(t_info->tm_mon));
    janet_struct_put(st, janet_ckeywordv("year"), janet_wrap_number(t_info->tm_year + 1900));
    janet_struct_put(st, janet_ckeywordv("week-day"), janet_wrap_number(t_info->tm_wday));
    janet_struct_put(st, janet_ckeywordv("year-day"), janet_wrap_number(t_info->tm_yday));
    janet_struct_put(st, janet_ckeywordv("dst"), janet_wrap_boolean(t_info->tm_isdst));
    return janet_wrap_struct(janet_struct_end(st));
}

static int entry_getdst(Janet env_entry) {
    Janet v;
    if (janet_checktype(env_entry, JANET_TABLE)) {
        JanetTable *entry = janet_unwrap_table(env_entry);
        v = janet_table_get(entry, janet_ckeywordv("dst"));
    } else if (janet_checktype(env_entry, JANET_STRUCT)) {
        const JanetKV *entry = janet_unwrap_struct(env_entry);
        v = janet_struct_get(entry, janet_ckeywordv("dst"));
    } else {
        v = janet_wrap_nil();
    }
    if (janet_checktype(v, JANET_NIL)) {
        return -1;
    } else {
        return janet_truthy(v);
    }
}

#ifdef JANET_WINDOWS
typedef int32_t timeint_t;
#else
typedef int64_t timeint_t;
#endif

static timeint_t entry_getint(Janet env_entry, char *field) {
    Janet i;
    if (janet_checktype(env_entry, JANET_TABLE)) {
        JanetTable *entry = janet_unwrap_table(env_entry);
        i = janet_table_get(entry, janet_ckeywordv(field));
    } else if (janet_checktype(env_entry, JANET_STRUCT)) {
        const JanetKV *entry = janet_unwrap_struct(env_entry);
        i = janet_struct_get(entry, janet_ckeywordv(field));
    } else {
        return 0;
    }

    if (janet_checktype(i, JANET_NIL)) {
        return 0;
    }

#ifdef JANET_WINDOWS
    if (!janet_checkint(i)) {
        janet_panicf("bad slot #%s, expected 32 bit signed integer, got %v",
                     field, i);
    }
#else
    if (!janet_checkint64(i)) {
        janet_panicf("bad slot #%s, expected 64 bit signed integer, got %v",
                     field, i);
    }
#endif

    return (timeint_t)janet_unwrap_number(i);
}

static Janet os_mktime(int32_t argc, Janet *argv) {
    janet_arity(argc, 1, 2);
    time_t t;
    struct tm t_info;

    /* Use memset instead of = {0} to silence paranoid warning in macos */
    memset(&t_info, 0, sizeof(t_info));

    if (!janet_checktype(argv[0], JANET_TABLE) &&
            !janet_checktype(argv[0], JANET_STRUCT))
        janet_panic_type(argv[0], 0, JANET_TFLAG_DICTIONARY);

    t_info.tm_sec = entry_getint(argv[0], "seconds");
    t_info.tm_min = entry_getint(argv[0], "minutes");
    t_info.tm_hour = entry_getint(argv[0], "hours");
    t_info.tm_mday = entry_getint(argv[0], "month-day") + 1;
    t_info.tm_mon = entry_getint(argv[0], "month");
    t_info.tm_year = entry_getint(argv[0], "year") - 1900;
    t_info.tm_isdst = entry_getdst(argv[0]);

    if (argc >= 2 && janet_truthy(argv[1])) {
        /* local time */
        t = mktime(&t_info);
    } else {
        /* utc time */
#ifdef JANET_NO_UTC_MKTIME
        janet_panic("os/mktime UTC not supported on this platform");
        return janet_wrap_nil();
#else
        t = timegm(&t_info);
#endif
    }

    if (t == (time_t) -1) {
        janet_panicf("%s", strerror(errno));
    }

    return janet_wrap_number((double)t);
}

#ifdef JANET_NO_SYMLINKS
#define j_symlink link
#else
#define j_symlink symlink
#endif

static Janet os_link(int32_t argc, Janet *argv) {
    janet_arity(argc, 2, 3);
#ifdef JANET_WINDOWS
    (void) argc;
    (void) argv;
    janet_panic("os/link not supported on Windows");
    return janet_wrap_nil();
#else
    const char *oldpath = janet_getcstring(argv, 0);
    const char *newpath = janet_getcstring(argv, 1);
    int res = ((argc == 3 && janet_truthy(argv[2])) ? j_symlink : link)(oldpath, newpath);
    if (-1 == res) janet_panicf("%s: %s -> %s", strerror(errno), oldpath, newpath);
    return janet_wrap_nil();
#endif
}

static Janet os_symlink(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 2);
#ifdef JANET_WINDOWS
    (void) argc;
    (void) argv;
    janet_panic("os/symlink not supported on Windows");
    return janet_wrap_nil();
#else
    const char *oldpath = janet_getcstring(argv, 0);
    const char *newpath = janet_getcstring(argv, 1);
    int res = j_symlink(oldpath, newpath);
    if (-1 == res) janet_panicf("%s: %s -> %s", strerror(errno), oldpath, newpath);
    return janet_wrap_nil();
#endif
}

#undef j_symlink

static Janet os_mkdir(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    const char *path = janet_getcstring(argv, 0);
#ifdef JANET_WINDOWS
    int res = _mkdir(path);
#else
    int res = mkdir(path, S_IRUSR | S_IWUSR | S_IXUSR | S_IRGRP | S_IWGRP | S_IXGRP | S_IROTH | S_IXOTH);
#endif
    if (res == 0) return janet_wrap_true();
    if (errno == EEXIST) return janet_wrap_false();
    janet_panicf("%s: %s", strerror(errno), path);
}

static Janet os_rmdir(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    const char *path = janet_getcstring(argv, 0);
#ifdef JANET_WINDOWS
    int res = _rmdir(path);
#else
    int res = rmdir(path);
#endif
    if (-1 == res) janet_panicf("%s: %s", strerror(errno), path);
    return janet_wrap_nil();
}

static Janet os_cd(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    const char *path = janet_getcstring(argv, 0);
#ifdef JANET_WINDOWS
    int res = _chdir(path);
#else
    int res = chdir(path);
#endif
    if (-1 == res) janet_panicf("%s: %s", strerror(errno), path);
    return janet_wrap_nil();
}

static Janet os_touch(int32_t argc, Janet *argv) {
    janet_arity(argc, 1, 3);
    const char *path = janet_getcstring(argv, 0);
    struct utimbuf timebuf, *bufp;
    if (argc >= 2) {
        bufp = &timebuf;
        timebuf.actime = (time_t) janet_getnumber(argv, 1);
        if (argc >= 3) {
            timebuf.modtime = (time_t) janet_getnumber(argv, 2);
        } else {
            timebuf.modtime = timebuf.actime;
        }
    } else {
        bufp = NULL;
    }
    int res = utime(path, bufp);
    if (-1 == res) janet_panic(strerror(errno));
    return janet_wrap_nil();
}

static Janet os_remove(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    const char *path = janet_getcstring(argv, 0);
    int status = remove(path);
    if (-1 == status) janet_panicf("%s: %s", strerror(errno), path);
    return janet_wrap_nil();
}

#ifndef JANET_NO_SYMLINKS
static Janet os_readlink(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
#ifdef JANET_WINDOWS
    (void) argc;
    (void) argv;
    janet_panic("os/readlink not supported on Windows");
    return janet_wrap_nil();
#else
    static char buffer[PATH_MAX];
    const char *path = janet_getcstring(argv, 0);
    ssize_t len = readlink(path, buffer, sizeof buffer);
    if (len < 0 || (size_t)len >= sizeof buffer)
        janet_panicf("%s: %s", strerror(errno), path);
    return janet_stringv((const uint8_t *)buffer, len);
#endif
}
#endif

#ifdef JANET_WINDOWS

typedef struct _stat jstat_t;
typedef unsigned short jmode_t;

static int32_t janet_perm_to_unix(unsigned short m) {
    int32_t ret = 0;
    if (m & S_IEXEC) ret |= 0111;
    if (m & S_IWRITE) ret |= 0222;
    if (m & S_IREAD) ret |= 0444;
    return ret;
}

static unsigned short janet_perm_from_unix(int32_t x) {
    unsigned short m = 0;
    if (x & 111) m |= S_IEXEC;
    if (x & 222) m |= S_IWRITE;
    if (x & 444) m |= S_IREAD;
    return m;
}

static const uint8_t *janet_decode_mode(unsigned short m) {
    const char *str = "other";
    if (m & _S_IFREG) str = "file";
    else if (m & _S_IFDIR) str = "directory";
    else if (m & _S_IFCHR) str = "character";
    return janet_ckeyword(str);
}

static int32_t janet_decode_permissions(jmode_t mode) {
    return (int32_t)(mode & (S_IEXEC | S_IWRITE | S_IREAD));
}

#else

typedef struct stat jstat_t;
typedef mode_t jmode_t;

static int32_t janet_perm_to_unix(mode_t m) {
    return (int32_t) m;
}

static mode_t janet_perm_from_unix(int32_t x) {
    return (mode_t) x;
}

static const uint8_t *janet_decode_mode(mode_t m) {
    const char *str = "other";
    if (S_ISREG(m)) str = "file";
    else if (S_ISDIR(m)) str = "directory";
    else if (S_ISFIFO(m)) str = "fifo";
    else if (S_ISBLK(m)) str = "block";
    else if (S_ISSOCK(m)) str = "socket";
    else if (S_ISLNK(m)) str = "link";
    else if (S_ISCHR(m)) str = "character";
    return janet_ckeyword(str);
}

static int32_t janet_decode_permissions(jmode_t mode) {
    return (int32_t)(mode & 0777);
}

#endif

static int32_t os_parse_permstring(const uint8_t *perm) {
    int32_t m = 0;
    if (perm[0] == 'r') m |= 0400;
    if (perm[1] == 'w') m |= 0200;
    if (perm[2] == 'x') m |= 0100;
    if (perm[3] == 'r') m |= 0040;
    if (perm[4] == 'w') m |= 0020;
    if (perm[5] == 'x') m |= 0010;
    if (perm[6] == 'r') m |= 0004;
    if (perm[7] == 'w') m |= 0002;
    if (perm[8] == 'x') m |= 0001;
    return m;
}

static Janet os_make_permstring(int32_t permissions) {
    uint8_t bytes[9] = {0};
    bytes[0] = (permissions & 0400) ? 'r' : '-';
    bytes[1] = (permissions & 0200) ? 'w' : '-';
    bytes[2] = (permissions & 0100) ? 'x' : '-';
    bytes[3] = (permissions & 0040) ? 'r' : '-';
    bytes[4] = (permissions & 0020) ? 'w' : '-';
    bytes[5] = (permissions & 0010) ? 'x' : '-';
    bytes[6] = (permissions & 0004) ? 'r' : '-';
    bytes[7] = (permissions & 0002) ? 'w' : '-';
    bytes[8] = (permissions & 0001) ? 'x' : '-';
    return janet_stringv(bytes, sizeof(bytes));
}

static int32_t os_get_unix_mode(const Janet *argv, int32_t n) {
    int32_t unix_mode;
    if (janet_checkint(argv[n])) {
        /* Integer mode */
        int32_t x = janet_unwrap_integer(argv[n]);
        if (x < 0 || x > 0777) {
            janet_panicf("bad slot #%d, expected integer in range [0, 8r777], got %v", n, argv[n]);
        }
        unix_mode = x;
    } else {
        /* Bytes mode */
        JanetByteView bytes = janet_getbytes(argv, n);
        if (bytes.len != 9) {
            janet_panicf("bad slot #%d: expected byte sequence of length 9, got %v", n, argv[n]);
        }
        unix_mode = os_parse_permstring(bytes.bytes);
    }
    return unix_mode;
}

static jmode_t os_getmode(const Janet *argv, int32_t n) {
    return janet_perm_from_unix(os_get_unix_mode(argv, n));
}

/* Getters */
static Janet os_stat_dev(jstat_t *st) {
    return janet_wrap_number(st->st_dev);
}
static Janet os_stat_inode(jstat_t *st) {
    return janet_wrap_number(st->st_ino);
}
static Janet os_stat_mode(jstat_t *st) {
    return janet_wrap_keyword(janet_decode_mode(st->st_mode));
}
static Janet os_stat_int_permissions(jstat_t *st) {
    return janet_wrap_integer(janet_perm_to_unix(janet_decode_permissions(st->st_mode)));
}
static Janet os_stat_permissions(jstat_t *st) {
    return os_make_permstring(janet_perm_to_unix(janet_decode_permissions(st->st_mode)));
}
static Janet os_stat_uid(jstat_t *st) {
    return janet_wrap_number(st->st_uid);
}
static Janet os_stat_gid(jstat_t *st) {
    return janet_wrap_number(st->st_gid);
}
static Janet os_stat_nlink(jstat_t *st) {
    return janet_wrap_number(st->st_nlink);
}
static Janet os_stat_rdev(jstat_t *st) {
    return janet_wrap_number(st->st_rdev);
}
static Janet os_stat_size(jstat_t *st) {
    return janet_wrap_number(st->st_size);
}
static Janet os_stat_accessed(jstat_t *st) {
    return janet_wrap_number((double) st->st_atime);
}
static Janet os_stat_modified(jstat_t *st) {
    return janet_wrap_number((double) st->st_mtime);
}
static Janet os_stat_changed(jstat_t *st) {
    return janet_wrap_number((double) st->st_ctime);
}
#ifdef JANET_WINDOWS
static Janet os_stat_blocks(jstat_t *st) {
    return janet_wrap_number(0);
}
static Janet os_stat_blocksize(jstat_t *st) {
    return janet_wrap_number(0);
}
#else
static Janet os_stat_blocks(jstat_t *st) {
    return janet_wrap_number(st->st_blocks);
}
static Janet os_stat_blocksize(jstat_t *st) {
    return janet_wrap_number(st->st_blksize);
}
#endif

struct OsStatGetter {
    const char *name;
    Janet(*fn)(jstat_t *st);
};

static const struct OsStatGetter os_stat_getters[] = {
    {"dev", os_stat_dev},
    {"inode", os_stat_inode},
    {"mode", os_stat_mode},
    {"int-permissions", os_stat_int_permissions},
    {"permissions", os_stat_permissions},
    {"uid", os_stat_uid},
    {"gid", os_stat_gid},
    {"nlink", os_stat_nlink},
    {"rdev", os_stat_rdev},
    {"size", os_stat_size},
    {"blocks", os_stat_blocks},
    {"blocksize", os_stat_blocksize},
    {"accessed", os_stat_accessed},
    {"modified", os_stat_modified},
    {"changed", os_stat_changed},
    {NULL, NULL}
};

static Janet os_stat_or_lstat(int do_lstat, int32_t argc, Janet *argv) {
    janet_arity(argc, 1, 2);
    const char *path = janet_getcstring(argv, 0);
    JanetTable *tab = NULL;
    int getall = 1;
    const uint8_t *key;
    if (argc == 2) {
        if (janet_checktype(argv[1], JANET_KEYWORD)) {
            getall = 0;
            key = janet_getkeyword(argv, 1);
        } else {
            tab = janet_gettable(argv, 1);
        }
    } else {
        tab = janet_table(0);
    }

    /* Build result */
    jstat_t st;
#ifdef JANET_WINDOWS
    (void) do_lstat;
    int res = _stat(path, &st);
#else
    int res;
    if (do_lstat) {
        res = lstat(path, &st);
    } else {
        res = stat(path, &st);
    }
#endif
    if (-1 == res) {
        return janet_wrap_nil();
    }

    if (getall) {
        /* Put results in table */
        for (const struct OsStatGetter *sg = os_stat_getters; sg->name != NULL; sg++) {
            janet_table_put(tab, janet_ckeywordv(sg->name), sg->fn(&st));
        }
        return janet_wrap_table(tab);
    } else {
        /* Get one result */
        for (const struct OsStatGetter *sg = os_stat_getters; sg->name != NULL; sg++) {
            if (janet_cstrcmp(key, sg->name)) continue;
            return sg->fn(&st);
        }
        janet_panicf("unexpected keyword %v", janet_wrap_keyword(key));
        return janet_wrap_nil();
    }
}

static Janet os_stat(int32_t argc, Janet *argv) {
    return os_stat_or_lstat(0, argc, argv);
}

static Janet os_lstat(int32_t argc, Janet *argv) {
    return os_stat_or_lstat(1, argc, argv);
}

static Janet os_chmod(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 2);
    const char *path = janet_getcstring(argv, 0);
#ifdef JANET_WINDOWS
    int res = _chmod(path, os_getmode(argv, 1));
#else
    int res = chmod(path, os_getmode(argv, 1));
#endif
    if (-1 == res) janet_panicf("%s: %s", strerror(errno), path);
    return janet_wrap_nil();
}

#ifndef JANET_NO_UMASK
static Janet os_umask(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    int mask = (int) os_getmode(argv, 0);
#ifdef JANET_WINDOWS
    int res = _umask(mask);
#else
    int res = umask(mask);
#endif
    return janet_wrap_integer(janet_perm_to_unix(res));
}
#endif

static Janet os_dir(int32_t argc, Janet *argv) {
    janet_arity(argc, 1, 2);
    const char *dir = janet_getcstring(argv, 0);
    JanetArray *paths = (argc == 2) ? janet_getarray(argv, 1) : janet_array(0);
#ifdef JANET_WINDOWS
    /* Read directory items with FindFirstFile / FindNextFile / FindClose */
    struct _finddata_t afile;
    char pattern[MAX_PATH + 1];
    if (strlen(dir) > (sizeof(pattern) - 3))
        janet_panicf("path too long: %s", dir);
    sprintf(pattern, "%s/*", dir);
    intptr_t res = _findfirst(pattern, &afile);
    if (-1 == res) janet_panicv(janet_cstringv(strerror(errno)));
    do {
        if (strcmp(".", afile.name) && strcmp("..", afile.name)) {
            janet_array_push(paths, janet_cstringv(afile.name));
        }
    } while (_findnext(res, &afile) != -1);
    _findclose(res);
#else
    /* Read directory items with opendir / readdir / closedir */
    struct dirent *dp;
    DIR *dfd = opendir(dir);
    if (dfd == NULL) janet_panicf("cannot open directory %s", dir);
    while ((dp = readdir(dfd)) != NULL) {
        if (!strcmp(dp->d_name, ".") || !strcmp(dp->d_name, "..")) {
            continue;
        }
        janet_array_push(paths, janet_cstringv(dp->d_name));
    }
    closedir(dfd);
#endif
    return janet_wrap_array(paths);
}

static Janet os_rename(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 2);
    const char *src = janet_getcstring(argv, 0);
    const char *dest = janet_getcstring(argv, 1);
    int status = rename(src, dest);
    if (status) {
        janet_panic(strerror(errno));
    }
    return janet_wrap_nil();
}

static Janet os_realpath(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    const char *src = janet_getcstring(argv, 0);
#ifdef JANET_NO_REALPATH
    janet_panic("os/realpath not enabled for this platform");
#else
#ifdef JANET_WINDOWS
    char *dest = _fullpath(NULL, src, _MAX_PATH);
#else
    char *dest = realpath(src, NULL);
#endif
    if (NULL == dest) janet_panicf("%s: %s", strerror(errno), src);
    Janet ret = janet_cstringv(dest);
    free(dest);
    return ret;
#endif
}

static Janet os_permission_string(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    return os_make_permstring(os_get_unix_mode(argv, 0));
}

static Janet os_permission_int(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    return janet_wrap_integer(os_get_unix_mode(argv, 0));
}

#endif /* JANET_REDUCED_OS */

static const JanetReg os_cfuns[] = {
    {
        "os/exit", os_exit,
        JDOC("(os/exit &opt x)\n\n"
             "Exit from janet with an exit code equal to x. If x is not an integer, "
             "the exit with status equal the hash of x.")
    },
    {
        "os/which", os_which,
        JDOC("(os/which)\n\n"
             "Check the current operating system. Returns one of:\n\n"
             "\t:windows\n"
             "\t:macos\n"
             "\t:web - Web assembly (emscripten)\n"
             "\t:linux\n"
             "\t:freebsd\n"
             "\t:openbsd\n"
             "\t:netbsd\n"
             "\t:posix - A POSIX compatible system (default)\n\n"
             "May also return a custom keyword specified at build time.")
    },
    {
        "os/arch", os_arch,
        JDOC("(os/arch)\n\n"
             "Check the ISA that janet was compiled for. Returns one of:\n\n"
             "\t:x86\n"
             "\t:x86-64\n"
             "\t:arm\n"
             "\t:aarch64\n"
             "\t:sparc\n"
             "\t:wasm\n"
             "\t:unknown\n")
    },
#ifndef JANET_REDUCED_OS
    {
        "os/environ", os_environ,
        JDOC("(os/environ)\n\n"
             "Get a copy of the os environment table.")
    },
    {
        "os/getenv", os_getenv,
        JDOC("(os/getenv variable &opt dflt)\n\n"
             "Get the string value of an environment variable.")
    },
    {
        "os/dir", os_dir,
        JDOC("(os/dir dir &opt array)\n\n"
             "Iterate over files and subdirectories in a directory. Returns an array of paths parts, "
             "with only the file name or directory name and no prefix.")
    },
    {
        "os/stat", os_stat,
        JDOC("(os/stat path &opt tab|key)\n\n"
             "Gets information about a file or directory. Returns a table If the third argument is a keyword, returns "
             " only that information from stat. If the file or directory does not exist, returns nil. The keys are\n\n"
             "\t:dev - the device that the file is on\n"
             "\t:mode - the type of file, one of :file, :directory, :block, :character, :fifo, :socket, :link, or :other\n"
             "\t:int-permissions - A Unix permission integer like 8r744\n"
             "\t:permissions - A Unix permission string like \"rwxr--r--\"\n"
             "\t:uid - File uid\n"
             "\t:gid - File gid\n"
             "\t:nlink - number of links to file\n"
             "\t:rdev - Real device of file. 0 on windows.\n"
             "\t:size - size of file in bytes\n"
             "\t:blocks - number of blocks in file. 0 on windows\n"
             "\t:blocksize - size of blocks in file. 0 on windows\n"
             "\t:accessed - timestamp when file last accessed\n"
             "\t:changed - timestamp when file last changed (permissions changed)\n"
             "\t:modified - timestamp when file last modified (content changed)\n")
    },
    {
        "os/lstat", os_lstat,
        JDOC("(os/lstat path &opt tab|key)\n\n"
             "Like os/stat, but don't follow symlinks.\n")
    },
    {
        "os/chmod", os_chmod,
        JDOC("(os/chmod path mode)\n\n"
             "Change file permissions, where mode is a permission string as returned by "
             "os/perm-string, or an integer as returned by os/perm-int. "
             "When mode is an integer, it is interpreted as a Unix permission value, best specified in octal, like "
             "8r666 or 8r400. Windows will not differentiate between user, group, and other permissions, and thus will combine all of these permissions. Returns nil.")
    },
    {
        "os/touch", os_touch,
        JDOC("(os/touch path &opt actime modtime)\n\n"
             "Update the access time and modification times for a file. By default, sets "
             "times to the current time.")
    },
    {
        "os/cd", os_cd,
        JDOC("(os/cd path)\n\n"
             "Change current directory to path. Returns nil on success, errors on failure.")
    },
#ifndef JANET_NO_UMASK
    {
        "os/umask", os_umask,
        JDOC("(os/umask mask)\n\n"
             "Set a new umask, returns the old umask.")
    },
#endif
    {
        "os/mkdir", os_mkdir,
        JDOC("(os/mkdir path)\n\n"
             "Create a new directory. The path will be relative to the current directory if relative, otherwise "
             "it will be an absolute path. Returns true if the directory was created, false if the directory already exists, and "
             "errors otherwise.")
    },
    {
        "os/rmdir", os_rmdir,
        JDOC("(os/rmdir path)\n\n"
             "Delete a directory. The directory must be empty to succeed.")
    },
    {
        "os/rm", os_remove,
        JDOC("(os/rm path)\n\n"
             "Delete a file. Returns nil.")
    },
    {
        "os/link", os_link,
        JDOC("(os/link oldpath newpath &opt symlink)\n\n"
             "Create a link at newpath that points to oldpath and returns nil. "
             "Iff symlink is truthy, creates a symlink. "
             "Iff symlink is falsey or not provided, "
             "creates a hard link. Does not work on Windows.")
    },
#ifndef JANET_NO_SYMLINKS
    {
        "os/symlink", os_symlink,
        JDOC("(os/symlink oldpath newpath)\n\n"
             "Create a symlink from oldpath to newpath, returning nil. Same as (os/link oldpath newpath true).")
    },
    {
        "os/readlink", os_readlink,
        JDOC("(os/readlink path)\n\n"
             "Read the contents of a symbolic link. Does not work on Windows.\n")
    },
#endif
#ifndef JANET_NO_PROCESSES
    {
        "os/execute", os_execute,
        JDOC("(os/execute args &opts flags env)\n\n"
             "Execute a program on the system and pass it string arguments. Flags "
             "is a keyword that modifies how the program will execute.\n\n"
             "\t:e - enables passing an environment to the program. Without :e, the "
             "current environment is inherited.\n"
             "\t:p - allows searching the current PATH for the binary to execute. "
             "Without this flag, binaries must use absolute paths.\n\n"
             "env is a table or struct mapping environment variables to values. "
             "Returns the exit status of the program.")
    },
    {
        "os/shell", os_shell,
        JDOC("(os/shell str)\n\n"
             "Pass a command string str directly to the system shell.")
    },
#endif
    {
        "os/setenv", os_setenv,
        JDOC("(os/setenv variable value)\n\n"
             "Set an environment variable.")
    },
    {
        "os/time", os_time,
        JDOC("(os/time)\n\n"
             "Get the current time expressed as the number of seconds since "
             "January 1, 1970, the Unix epoch. Returns a real number.")
    },
    {
        "os/mktime", os_mktime,
        JDOC("(os/mktime date-struct &opt local)\n\n"
             "Get the broken down date-struct time expressed as the number "
             " of seconds since January 1, 1970, the Unix epoch. "
             "Returns a real number. "
             "Date is given in UTC unless local is truthy, in which case the "
             "date is computed for the local timezone.\n\n"
             "Inverse function to os/date.")
    },
    {
        "os/clock", os_clock,
        JDOC("(os/clock)\n\n"
             "Return the number of seconds since some fixed point in time. The clock "
             "is guaranteed to be non decreasing in real time.")
    },
    {
        "os/sleep", os_sleep,
        JDOC("(os/sleep nsec)\n\n"
             "Suspend the program for nsec seconds. 'nsec' can be a real number. Returns "
             "nil.")
    },
    {
        "os/cwd", os_cwd,
        JDOC("(os/cwd)\n\n"
             "Returns the current working directory.")
    },
    {
        "os/cryptorand", os_cryptorand,
        JDOC("(os/cryptorand n &opt buf)\n\n"
             "Get or append n bytes of good quality random data provided by the OS. Returns a new buffer or buf.")
    },
    {
        "os/date", os_date,
        JDOC("(os/date &opt time local)\n\n"
             "Returns the given time as a date struct, or the current time if no time is given. "
             "Returns a struct with following key values. Note that all numbers are 0-indexed. "
             "Date is given in UTC unless local is truthy, in which case the date is formatted for "
             "the local timezone.\n\n"
             "\t:seconds - number of seconds [0-61]\n"
             "\t:minutes - number of minutes [0-59]\n"
             "\t:hours - number of hours [0-23]\n"
             "\t:month-day - day of month [0-30]\n"
             "\t:month - month of year [0, 11]\n"
             "\t:year - years since year 0 (e.g. 2019)\n"
             "\t:week-day - day of the week [0-6]\n"
             "\t:year-day - day of the year [0-365]\n"
             "\t:dst - If Day Light Savings is in effect")
    },
    {
        "os/rename", os_rename,
        JDOC("(os/rename oldname newname)\n\n"
             "Rename a file on disk to a new path. Returns nil.")
    },
    {
        "os/realpath", os_realpath,
        JDOC("(os/realpath path)\n\n"
             "Get the absolute path for a given path, following ../, ./, and symlinks. "
             "Returns an absolute path as a string. Will raise an error on Windows.")
    },
    {
        "os/perm-string", os_permission_string,
        JDOC("(os/perm-string int)\n\n"
             "Convert a Unix octal permission value from a permission integer as returned by os/stat "
             "to a human readable string, that follows the formatting "
             "of unix tools like ls. Returns the string as a 9 character string of r, w, x and - characters. Does not "
             "include the file/directory/symlink character as rendered by `ls`.")
    },
    {
        "os/perm-int", os_permission_int,
        JDOC("(os/perm-int bytes)\n\n"
             "Parse a 9 character permission string and return an integer that can be used by chmod.")
    },
#endif
    {NULL, NULL, NULL}
};

/* Module entry point */
void janet_lib_os(JanetTable *env) {
#if !defined(JANET_REDUCED_OS) && defined(JANET_WINDOWS) && defined(JANET_THREADS)
    /* During start up, the top-most abstract machine (thread)
     * in the thread tree sets up the critical section. */
    if (!env_lock_initialized) {
        InitializeCriticalSection(&env_lock);
        env_lock_initialized = 1;
    }
#endif
    janet_core_cfuns(env, NULL, os_cfuns);
}


/* src/core/parse.c */
#line 0 "src/core/parse.c"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "util.h"
#endif

#define JANET_PARSER_DEAD 0x1
#define JANET_PARSER_GENERATED_ERROR 0x2

/* Check if a character is whitespace */
static int is_whitespace(uint8_t c) {
    return c == ' '
           || c == '\t'
           || c == '\n'
           || c == '\r'
           || c == '\0'
           || c == '\v'
           || c == '\f';
}

/* Code generated by tools/symcharsgen.c.
 * The table contains 256 bits, where each bit is 1
 * if the corresponding ascii code is a symbol char, and 0
 * if not. The upper characters are also considered symbol
 * chars and are then checked for utf-8 compliance. */
static const uint32_t symchars[8] = {
    0x00000000, 0xf7ffec72, 0xc7ffffff, 0x07fffffe,
    0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff
};

/* Check if a character is a valid symbol character
 * symbol chars are A-Z, a-z, 0-9, or one of !$&*+-./:<=>@\^_~| */
static int is_symbol_char(uint8_t c) {
    return symchars[c >> 5] & ((uint32_t)1 << (c & 0x1F));
}

/* Validate some utf8. Useful for identifiers. Only validates
 * the encoding, does not check for valid code points (they
 * are less well defined than the encoding). */
static int valid_utf8(const uint8_t *str, int32_t len) {
    int32_t i = 0;
    int32_t j;
    while (i < len) {
        int32_t nexti;
        uint8_t c = str[i];

        /* Check the number of bytes in code point */
        if (c < 0x80) nexti = i + 1;
        else if ((c >> 5) == 0x06) nexti = i + 2;
        else if ((c >> 4) == 0x0E) nexti = i + 3;
        else if ((c >> 3) == 0x1E) nexti = i + 4;
        /* Don't allow 5 or 6 byte code points */
        else return 0;

        /* No overflow */
        if (nexti > len) return 0;

        /* Ensure trailing bytes are well formed (10XX XXXX) */
        for (j = i + 1; j < nexti; j++) {
            if ((str[j] >> 6) != 2) return 0;
        }

        /* Check for overlong encoding */
        if ((nexti == i + 2) && str[i] < 0xC2) return 0;
        if ((str[i] == 0xE0) && str[i + 1] < 0xA0) return 0;
        if ((str[i] == 0xF0) && str[i + 1] < 0x90) return 0;

        i = nexti;
    }
    return 1;
}

/* Get hex digit from a letter */
static int to_hex(uint8_t c) {
    if (c >= '0' && c <= '9') {
        return c - '0';
    } else if (c >= 'A' && c <= 'F') {
        return 10 + c - 'A';
    } else if (c >= 'a' && c <= 'f') {
        return 10 + c - 'a';
    } else {
        return -1;
    }
}

typedef int (*Consumer)(JanetParser *p, JanetParseState *state, uint8_t c);
struct JanetParseState {
    int32_t counter;
    int32_t argn;
    int flags;
    size_t line;
    size_t column;
    Consumer consumer;
};

/* Define a stack on the main parser struct */
#define DEF_PARSER_STACK(NAME, T, STACK, STACKCOUNT, STACKCAP) \
static void NAME(JanetParser *p, T x) { \
    size_t oldcount = p->STACKCOUNT; \
    size_t newcount = oldcount + 1; \
    if (newcount > p->STACKCAP) { \
        T *next; \
        size_t newcap = 2 * newcount; \
        next = realloc(p->STACK, sizeof(T) * newcap); \
        if (NULL == next) { \
            JANET_OUT_OF_MEMORY; \
        } \
        p->STACK = next; \
        p->STACKCAP = newcap; \
    } \
    p->STACK[oldcount] = x; \
    p->STACKCOUNT = newcount; \
}

DEF_PARSER_STACK(push_buf, uint8_t, buf, bufcount, bufcap)
DEF_PARSER_STACK(push_arg, Janet, args, argcount, argcap)
DEF_PARSER_STACK(_pushstate, JanetParseState, states, statecount, statecap)

#undef DEF_PARSER_STACK

#define PFLAG_CONTAINER 0x100
#define PFLAG_BUFFER 0x200
#define PFLAG_PARENS 0x400
#define PFLAG_SQRBRACKETS 0x800
#define PFLAG_CURLYBRACKETS 0x1000
#define PFLAG_STRING 0x2000
#define PFLAG_LONGSTRING 0x4000
#define PFLAG_READERMAC 0x8000
#define PFLAG_ATSYM 0x10000
#define PFLAG_COMMENT 0x20000
#define PFLAG_TOKEN 0x40000

static void pushstate(JanetParser *p, Consumer consumer, int flags) {
    JanetParseState s;
    s.counter = 0;
    s.argn = 0;
    s.flags = flags;
    s.consumer = consumer;
    s.line = p->line;
    s.column = p->column;
    _pushstate(p, s);
}

static void popstate(JanetParser *p, Janet val) {
    for (;;) {
        JanetParseState top = p->states[--p->statecount];
        JanetParseState *newtop = p->states + p->statecount - 1;
        /* Source mapping info */
        if (janet_checktype(val, JANET_TUPLE)) {
            janet_tuple_sm_line(janet_unwrap_tuple(val)) = (int32_t) top.line;
            janet_tuple_sm_column(janet_unwrap_tuple(val)) = (int32_t) top.column;
        }
        if (newtop->flags & PFLAG_CONTAINER) {
            newtop->argn++;
            /* Keep track of number of values in the root state */
            if (p->statecount == 1) p->pending++;
            push_arg(p, val);
            return;
        } else if (newtop->flags & PFLAG_READERMAC) {
            Janet *t = janet_tuple_begin(2);
            int c = newtop->flags & 0xFF;
            const char *which =
                (c == '\'') ? "quote" :
                (c == ',') ? "unquote" :
                (c == ';') ? "splice" :
                (c == '|') ? "short-fn" :
                (c == '~') ? "quasiquote" : "<unknown>";
            t[0] = janet_csymbolv(which);
            t[1] = val;
            /* Quote source mapping info */
            janet_tuple_sm_line(t) = (int32_t) newtop->line;
            janet_tuple_sm_column(t) = (int32_t) newtop->column;
            val = janet_wrap_tuple(janet_tuple_end(t));
        } else {
            return;
        }
    }
}

static int checkescape(uint8_t c) {
    switch (c) {
        default:
            return -1;
        case 'x':
        case 'u':
        case 'U':
            return 1;
        case 'n':
            return '\n';
        case 't':
            return '\t';
        case 'r':
            return '\r';
        case '0':
            return '\0';
        case 'z':
            return '\0';
        case 'f':
            return '\f';
        case 'v':
            return '\v';
        case 'e':
            return 27;
        case '"':
            return '"';
        case '\\':
            return '\\';
    }
}

/* Forward declare */
static int stringchar(JanetParser *p, JanetParseState *state, uint8_t c);

static void write_codepoint(JanetParser *p, int32_t codepoint) {
    if (codepoint <= 0x7F) {
        push_buf(p, (uint8_t) codepoint);
    } else if (codepoint <= 0x7FF) {
        push_buf(p, (uint8_t)((codepoint >>  6) & 0x1F) | 0xC0);
        push_buf(p, (uint8_t)((codepoint >>  0) & 0x3F) | 0x80);
    } else if (codepoint <= 0xFFFF) {
        push_buf(p, (uint8_t)((codepoint >> 12) & 0x0F) | 0xE0);
        push_buf(p, (uint8_t)((codepoint >>  6) & 0x3F) | 0x80);
        push_buf(p, (uint8_t)((codepoint >>  0) & 0x3F) | 0x80);
    } else {
        push_buf(p, (uint8_t)((codepoint >> 18) & 0x07) | 0xF0);
        push_buf(p, (uint8_t)((codepoint >> 12) & 0x3F) | 0x80);
        push_buf(p, (uint8_t)((codepoint >>  6) & 0x3F) | 0x80);
        push_buf(p, (uint8_t)((codepoint >>  0) & 0x3F) | 0x80);
    }
}

static int escapeh(JanetParser *p, JanetParseState *state, uint8_t c) {
    int digit = to_hex(c);
    if (digit < 0) {
        p->error = "invalid hex digit in hex escape";
        return 1;
    }
    state->argn = (state->argn << 4) + digit;
    state->counter--;
    if (!state->counter) {
        push_buf(p, (uint8_t)(state->argn & 0xFF));
        state->argn = 0;
        state->consumer = stringchar;
    }
    return 1;
}

static int escapeu(JanetParser *p, JanetParseState *state, uint8_t c) {
    int digit = to_hex(c);
    if (digit < 0) {
        p->error = "invalid hex digit in unicode escape";
        return 1;
    }
    state->argn = (state->argn << 4) + digit;
    state->counter--;
    if (!state->counter) {
        if (state->argn > 0x10FFFF) {
            p->error = "invalid unicode codepoint";
            return 1;
        }
        write_codepoint(p, state->argn);
        state->argn = 0;
        state->consumer = stringchar;
    }
    return 1;
}

static int escape1(JanetParser *p, JanetParseState *state, uint8_t c) {
    int e = checkescape(c);
    if (e < 0) {
        p->error = "invalid string escape sequence";
        return 1;
    }
    if (c == 'x') {
        state->counter = 2;
        state->argn = 0;
        state->consumer = escapeh;
    } else if (c == 'u' || c == 'U') {
        state->counter = c == 'u' ? 4 : 6;
        state->argn = 0;
        state->consumer = escapeu;
    } else {
        push_buf(p, (uint8_t) e);
        state->consumer = stringchar;
    }
    return 1;
}

static int stringend(JanetParser *p, JanetParseState *state) {
    Janet ret;
    uint8_t *bufstart = p->buf;
    int32_t buflen = (int32_t) p->bufcount;
    if (state->flags & PFLAG_LONGSTRING) {
        /* Check for leading newline character so we can remove it */
        if (bufstart[0] == '\n') {
            bufstart++;
            buflen--;
        }
        if (buflen > 0 && bufstart[buflen - 1] == '\n') {
            buflen--;
        }
    }
    if (state->flags & PFLAG_BUFFER) {
        JanetBuffer *b = janet_buffer(buflen);
        janet_buffer_push_bytes(b, bufstart, buflen);
        ret = janet_wrap_buffer(b);
    } else {
        ret = janet_wrap_string(janet_string(bufstart, buflen));
    }
    p->bufcount = 0;
    popstate(p, ret);
    return 1;
}

static int stringchar(JanetParser *p, JanetParseState *state, uint8_t c) {
    /* Enter escape */
    if (c == '\\') {
        state->consumer = escape1;
        return 1;
    }
    /* String end */
    if (c == '"') {
        return stringend(p, state);
    }
    /* normal char */
    if (c != '\n' && c != '\r')
        push_buf(p, c);
    return 1;
}

/* Check for string equality in the buffer */
static int check_str_const(const char *cstr, const uint8_t *str, int32_t len) {
    int32_t index;
    for (index = 0; index < len; index++) {
        uint8_t c = str[index];
        uint8_t k = ((const uint8_t *)cstr)[index];
        if (c < k) return -1;
        if (c > k) return 1;
        if (k == '\0') break;
    }
    return (cstr[index] == '\0') ? 0 : -1;
}

static int tokenchar(JanetParser *p, JanetParseState *state, uint8_t c) {
    Janet ret;
    double numval;
    int32_t blen;
    if (is_symbol_char(c)) {
        push_buf(p, (uint8_t) c);
        if (c > 127) state->argn = 1; /* Use to indicate non ascii */
        return 1;
    }
    /* Token finished */
    blen = (int32_t) p->bufcount;
    int start_dig = p->buf[0] >= '0' && p->buf[0] <= '9';
    int start_num = start_dig || p->buf[0] == '-' || p->buf[0] == '+' || p->buf[0] == '.';
    if (p->buf[0] == ':') {
        /* Don't do full utf-8 check unless we have seen non ascii characters. */
        int valid = (!state->argn) || valid_utf8(p->buf + 1, blen - 1);
        if (!valid) {
            p->error = "invalid utf-8 in keyword";
            return 0;
        }
        ret = janet_keywordv(p->buf + 1, blen - 1);
    } else if (start_num && !janet_scan_number(p->buf, blen, &numval)) {
        ret = janet_wrap_number(numval);
    } else if (!check_str_const("nil", p->buf, blen)) {
        ret = janet_wrap_nil();
    } else if (!check_str_const("false", p->buf, blen)) {
        ret = janet_wrap_false();
    } else if (!check_str_const("true", p->buf, blen)) {
        ret = janet_wrap_true();
    } else {
        if (start_dig) {
            p->error = "symbol literal cannot start with a digit";
            return 0;
        } else {
            /* Don't do full utf-8 check unless we have seen non ascii characters. */
            int valid = (!state->argn) || valid_utf8(p->buf, blen);
            if (!valid) {
                p->error = "invalid utf-8 in symbol";
                return 0;
            }
            ret = janet_symbolv(p->buf, blen);
        }
    }
    p->bufcount = 0;
    popstate(p, ret);
    return 0;
}

static int comment(JanetParser *p, JanetParseState *state, uint8_t c) {
    (void) state;
    if (c == '\n') {
        p->statecount--;
        p->bufcount = 0;
    } else {
        push_buf(p, c);
    }
    return 1;
}

static Janet close_tuple(JanetParser *p, JanetParseState *state, int32_t flag) {
    Janet *ret = janet_tuple_begin(state->argn);
    janet_tuple_flag(ret) |= flag;
    for (int32_t i = state->argn - 1; i >= 0; i--)
        ret[i] = p->args[--p->argcount];
    return janet_wrap_tuple(janet_tuple_end(ret));
}

static Janet close_array(JanetParser *p, JanetParseState *state) {
    JanetArray *array = janet_array(state->argn);
    for (int32_t i = state->argn - 1; i >= 0; i--)
        array->data[i] = p->args[--p->argcount];
    array->count = state->argn;
    return janet_wrap_array(array);
}

static Janet close_struct(JanetParser *p, JanetParseState *state) {
    JanetKV *st = janet_struct_begin(state->argn >> 1);
    for (size_t i = p->argcount - state->argn; i < p->argcount; i += 2) {
        Janet key = p->args[i];
        Janet value = p->args[i + 1];
        janet_struct_put(st, key, value);
    }
    p->argcount -= state->argn;
    return janet_wrap_struct(janet_struct_end(st));
}

static Janet close_table(JanetParser *p, JanetParseState *state) {
    JanetTable *table = janet_table(state->argn >> 1);
    for (size_t i = p->argcount - state->argn; i < p->argcount; i += 2) {
        Janet key = p->args[i];
        Janet value = p->args[i + 1];
        janet_table_put(table, key, value);
    }
    p->argcount -= state->argn;
    return janet_wrap_table(table);
}

#define PFLAG_INSTRING 0x100000
#define PFLAG_END_CANDIDATE 0x200000
static int longstring(JanetParser *p, JanetParseState *state, uint8_t c) {
    if (state->flags & PFLAG_INSTRING) {
        /* We are inside the long string */
        if (c == '`') {
            state->flags |= PFLAG_END_CANDIDATE;
            state->flags &= ~PFLAG_INSTRING;
            state->counter = 1; /* Use counter to keep track of number of '=' seen */
            return 1;
        }
        push_buf(p, c);
        return 1;
    } else if (state->flags & PFLAG_END_CANDIDATE) {
        int i;
        /* We are checking a potential end of the string */
        if (state->counter == state->argn) {
            stringend(p, state);
            return 0;
        }
        if (c == '`' && state->counter < state->argn) {
            state->counter++;
            return 1;
        }
        /* Failed end candidate */
        for (i = 0; i < state->counter; i++) {
            push_buf(p, '`');
        }
        push_buf(p, c);
        state->counter = 0;
        state->flags &= ~PFLAG_END_CANDIDATE;
        state->flags |= PFLAG_INSTRING;
        return 1;
    } else {
        /* We are at beginning of string */
        state->argn++;
        if (c != '`') {
            state->flags |= PFLAG_INSTRING;
            push_buf(p, c);
        }
        return 1;
    }
}

static int root(JanetParser *p, JanetParseState *state, uint8_t c);

static int atsign(JanetParser *p, JanetParseState *state, uint8_t c) {
    (void) state;
    p->statecount--;
    switch (c) {
        case '{':
            pushstate(p, root, PFLAG_CONTAINER | PFLAG_CURLYBRACKETS | PFLAG_ATSYM);
            return 1;
        case '"':
            pushstate(p, stringchar, PFLAG_BUFFER | PFLAG_STRING);
            return 1;
        case '`':
            pushstate(p, longstring, PFLAG_BUFFER | PFLAG_LONGSTRING);
            return 1;
        case '[':
            pushstate(p, root, PFLAG_CONTAINER | PFLAG_SQRBRACKETS | PFLAG_ATSYM);
            return 1;
        case '(':
            pushstate(p, root, PFLAG_CONTAINER | PFLAG_PARENS | PFLAG_ATSYM);
            return 1;
        default:
            break;
    }
    pushstate(p, tokenchar, PFLAG_TOKEN);
    push_buf(p, '@'); /* Push the leading at-sign that was dropped */
    return 0;
}

/* The root state of the parser */
static int root(JanetParser *p, JanetParseState *state, uint8_t c) {
    switch (c) {
        default:
            if (is_whitespace(c)) return 1;
            if (!is_symbol_char(c)) {
                p->error = "unexpected character";
                return 1;
            }
            pushstate(p, tokenchar, PFLAG_TOKEN);
            return 0;
        case '\'':
        case ',':
        case ';':
        case '~':
        case '|':
            pushstate(p, root, PFLAG_READERMAC | c);
            return 1;
        case '"':
            pushstate(p, stringchar, PFLAG_STRING);
            return 1;
        case '#':
            pushstate(p, comment, PFLAG_COMMENT);
            return 1;
        case '@':
            pushstate(p, atsign, PFLAG_ATSYM);
            return 1;
        case '`':
            pushstate(p, longstring, PFLAG_LONGSTRING);
            return 1;
        case ')':
        case ']':
        case '}': {
            Janet ds;
            if (p->statecount == 1) {
                p->error = "unexpected delimiter";
                return 1;
            }
            if ((c == ')' && (state->flags & PFLAG_PARENS)) ||
                    (c == ']' && (state->flags & PFLAG_SQRBRACKETS))) {
                if (state->flags & PFLAG_ATSYM) {
                    ds = close_array(p, state);
                } else {
                    ds = close_tuple(p, state, c == ']' ? JANET_TUPLE_FLAG_BRACKETCTOR : 0);
                }
            } else if (c == '}' && (state->flags & PFLAG_CURLYBRACKETS)) {
                if (state->argn & 1) {
                    p->error = "struct and table literals expect even number of arguments";
                    return 1;
                }
                if (state->flags & PFLAG_ATSYM) {
                    ds = close_table(p, state);
                } else {
                    ds = close_struct(p, state);
                }
            } else {
                p->error = "mismatched delimiter";
                return 1;
            }
            popstate(p, ds);
        }
        return 1;
        case '(':
            pushstate(p, root, PFLAG_CONTAINER | PFLAG_PARENS);
            return 1;
        case '[':
            pushstate(p, root, PFLAG_CONTAINER | PFLAG_SQRBRACKETS);
            return 1;
        case '{':
            pushstate(p, root, PFLAG_CONTAINER | PFLAG_CURLYBRACKETS);
            return 1;
    }
}

static void janet_parser_checkdead(JanetParser *parser) {
    if (parser->flag) janet_panic("parser is dead, cannot consume");
    if (parser->error) janet_panic("parser has unchecked error, cannot consume");
}

/* Public API */

void janet_parser_consume(JanetParser *parser, uint8_t c) {
    int consumed = 0;
    janet_parser_checkdead(parser);
    if (c == '\r') {
        parser->line++;
        parser->column = 0;
    } else if (c == '\n') {
        parser->column = 0;
        if (parser->lookback != '\r')
            parser->line++;
    } else {
        parser->column++;
    }
    while (!consumed && !parser->error) {
        JanetParseState *state = parser->states + parser->statecount - 1;
        consumed = state->consumer(parser, state, c);
    }
    parser->lookback = c;
}

void janet_parser_eof(JanetParser *parser) {
    janet_parser_checkdead(parser);
    size_t oldcolumn = parser->column;
    size_t oldline = parser->line;
    janet_parser_consume(parser, '\n');
    if (parser->statecount > 1) {
        JanetParseState *s = parser->states + (parser->statecount - 1);
        JanetBuffer *buffer = janet_buffer(40);
        janet_buffer_push_cstring(buffer, "unexpected end of source, ");
        if (s->flags & PFLAG_PARENS) {
            janet_buffer_push_u8(buffer, '(');
        } else if (s->flags & PFLAG_SQRBRACKETS) {
            janet_buffer_push_u8(buffer, '[');
        } else if (s->flags & PFLAG_CURLYBRACKETS) {
            janet_buffer_push_u8(buffer, '{');
        } else if (s->flags & PFLAG_STRING) {
            janet_buffer_push_u8(buffer, '"');
        } else if (s->flags & PFLAG_LONGSTRING) {
            int32_t i;
            for (i = 0; i < s->argn; i++) {
                janet_buffer_push_u8(buffer, '`');
            }
        }
        janet_formatb(buffer, " opened at line %d, column %d", s->line, s->column);
        parser->error = (const char *) janet_string(buffer->data, buffer->count);
        parser->flag |= JANET_PARSER_GENERATED_ERROR;
    }
    parser->line = oldline;
    parser->column = oldcolumn;
    parser->flag |= JANET_PARSER_DEAD;
}

enum JanetParserStatus janet_parser_status(JanetParser *parser) {
    if (parser->error) return JANET_PARSE_ERROR;
    if (parser->flag) return JANET_PARSE_DEAD;
    if (parser->statecount > 1) return JANET_PARSE_PENDING;
    return JANET_PARSE_ROOT;
}

void janet_parser_flush(JanetParser *parser) {
    parser->argcount = 0;
    parser->statecount = 1;
    parser->bufcount = 0;
    parser->pending = 0;
}

const char *janet_parser_error(JanetParser *parser) {
    enum JanetParserStatus status = janet_parser_status(parser);
    if (status == JANET_PARSE_ERROR) {
        const char *e = parser->error;
        parser->error = NULL;
        parser->flag &= ~JANET_PARSER_GENERATED_ERROR;
        janet_parser_flush(parser);
        return e;
    }
    return NULL;
}

Janet janet_parser_produce(JanetParser *parser) {
    Janet ret;
    size_t i;
    if (parser->pending == 0) return janet_wrap_nil();
    ret = parser->args[0];
    for (i = 1; i < parser->argcount; i++) {
        parser->args[i - 1] = parser->args[i];
    }
    parser->pending--;
    parser->argcount--;
    return ret;
}

void janet_parser_init(JanetParser *parser) {
    parser->args = NULL;
    parser->states = NULL;
    parser->buf = NULL;
    parser->argcount = 0;
    parser->argcap = 0;
    parser->bufcount = 0;
    parser->bufcap = 0;
    parser->statecount = 0;
    parser->statecap = 0;
    parser->error = NULL;
    parser->lookback = -1;
    parser->line = 1;
    parser->column = 0;
    parser->pending = 0;
    parser->flag = 0;

    pushstate(parser, root, PFLAG_CONTAINER);
}

void janet_parser_deinit(JanetParser *parser) {
    free(parser->args);
    free(parser->buf);
    free(parser->states);
}

void janet_parser_clone(const JanetParser *src, JanetParser *dest) {
    /* Misc fields */
    dest->flag = src->flag;
    dest->pending = src->pending;
    dest->lookback = src->lookback;
    dest->line = src->line;
    dest->column = src->column;
    dest->error = src->error;

    /* Keep counts */
    dest->argcount = src->argcount;
    dest->bufcount = src->bufcount;
    dest->statecount = src->statecount;

    /* Capacities are equal to counts */
    dest->bufcap = dest->bufcount;
    dest->statecap = dest->statecount;
    dest->argcap = dest->argcount;

    /* Deep cloned fields */
    dest->args = NULL;
    dest->states = NULL;
    dest->buf = NULL;
    if (dest->bufcap) {
        dest->buf = malloc(dest->bufcap);
        if (!dest->buf) goto nomem;
        memcpy(dest->buf, src->buf, dest->bufcap);
    }
    if (dest->argcap) {
        dest->args = malloc(sizeof(Janet) * dest->argcap);
        if (!dest->args) goto nomem;
        memcpy(dest->args, src->args, dest->argcap * sizeof(Janet));
    }
    if (dest->statecap) {
        dest->states = malloc(sizeof(JanetParseState) * dest->statecap);
        if (!dest->states) goto nomem;
        memcpy(dest->states, src->states, dest->statecap * sizeof(JanetParseState));
    }

    return;

nomem:
    JANET_OUT_OF_MEMORY;
}

int janet_parser_has_more(JanetParser *parser) {
    return !!parser->pending;
}

/* C functions */

static int parsermark(void *p, size_t size) {
    size_t i;
    JanetParser *parser = (JanetParser *)p;
    (void) size;
    for (i = 0; i < parser->argcount; i++) {
        janet_mark(parser->args[i]);
    }
    if (parser->flag & JANET_PARSER_GENERATED_ERROR) {
        janet_mark(janet_wrap_string((const uint8_t *) parser->error));
    }
    return 0;
}

static int parsergc(void *p, size_t size) {
    JanetParser *parser = (JanetParser *)p;
    (void) size;
    janet_parser_deinit(parser);
    return 0;
}

static int parserget(void *p, Janet key, Janet *out);

const JanetAbstractType janet_parser_type = {
    "core/parser",
    parsergc,
    parsermark,
    parserget,
    JANET_ATEND_GET
};

/* C Function parser */
static Janet cfun_parse_parser(int32_t argc, Janet *argv) {
    (void) argv;
    janet_fixarity(argc, 0);
    JanetParser *p = janet_abstract(&janet_parser_type, sizeof(JanetParser));
    janet_parser_init(p);
    return janet_wrap_abstract(p);
}

static Janet cfun_parse_consume(int32_t argc, Janet *argv) {
    janet_arity(argc, 2, 3);
    JanetParser *p = janet_getabstract(argv, 0, &janet_parser_type);
    JanetByteView view = janet_getbytes(argv, 1);
    if (argc == 3) {
        int32_t offset = janet_getinteger(argv, 2);
        if (offset < 0 || offset > view.len)
            janet_panicf("invalid offset %d out of range [0,%d]", offset, view.len);
        view.len -= offset;
        view.bytes += offset;
    }
    int32_t i;
    for (i = 0; i < view.len; i++) {
        janet_parser_consume(p, view.bytes[i]);
        switch (janet_parser_status(p)) {
            case JANET_PARSE_ROOT:
            case JANET_PARSE_PENDING:
                break;
            default:
                return janet_wrap_integer(i + 1);
        }
    }
    return janet_wrap_integer(i);
}

static Janet cfun_parse_eof(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    JanetParser *p = janet_getabstract(argv, 0, &janet_parser_type);
    janet_parser_eof(p);
    return argv[0];
}

static Janet cfun_parse_insert(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 2);
    JanetParser *p = janet_getabstract(argv, 0, &janet_parser_type);
    JanetParseState *s = p->states + p->statecount - 1;
    if (s->consumer == tokenchar) {
        janet_parser_consume(p, ' ');
        p->column--;
        s = p->states + p->statecount - 1;
    }
    if (s->flags & PFLAG_COMMENT) s--;
    if (s->flags & PFLAG_CONTAINER) {
        s->argn++;
        if (p->statecount == 1) p->pending++;
        push_arg(p, argv[1]);
    } else if (s->flags & (PFLAG_STRING | PFLAG_LONGSTRING)) {
        const uint8_t *str = janet_to_string(argv[1]);
        int32_t slen = janet_string_length(str);
        size_t newcount = p->bufcount + slen;
        if (p->bufcap < newcount) {
            size_t newcap = 2 * newcount;
            p->buf = realloc(p->buf, newcap);
            if (p->buf == NULL) {
                JANET_OUT_OF_MEMORY;
            }
            p->bufcap = newcap;
        }
        safe_memcpy(p->buf + p->bufcount, str, slen);
        p->bufcount = newcount;
    } else {
        janet_panic("cannot insert value into parser");
    }
    return argv[0];
}

static Janet cfun_parse_has_more(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    JanetParser *p = janet_getabstract(argv, 0, &janet_parser_type);
    return janet_wrap_boolean(janet_parser_has_more(p));
}

static Janet cfun_parse_byte(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 2);
    JanetParser *p = janet_getabstract(argv, 0, &janet_parser_type);
    int32_t i = janet_getinteger(argv, 1);
    janet_parser_consume(p, 0xFF & i);
    return argv[0];
}

static Janet cfun_parse_status(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    JanetParser *p = janet_getabstract(argv, 0, &janet_parser_type);
    const char *stat = NULL;
    switch (janet_parser_status(p)) {
        case JANET_PARSE_PENDING:
            stat = "pending";
            break;
        case JANET_PARSE_ERROR:
            stat = "error";
            break;
        case JANET_PARSE_ROOT:
            stat = "root";
            break;
        case JANET_PARSE_DEAD:
            stat = "dead";
            break;
    }
    return janet_ckeywordv(stat);
}

static Janet cfun_parse_error(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    JanetParser *p = janet_getabstract(argv, 0, &janet_parser_type);
    const char *err = janet_parser_error(p);
    if (err) {
        return (p->flag & JANET_PARSER_GENERATED_ERROR)
               ? janet_wrap_string((const uint8_t *) err)
               : janet_cstringv(err);
    }
    return janet_wrap_nil();
}

static Janet cfun_parse_produce(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    JanetParser *p = janet_getabstract(argv, 0, &janet_parser_type);
    return janet_parser_produce(p);
}

static Janet cfun_parse_flush(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    JanetParser *p = janet_getabstract(argv, 0, &janet_parser_type);
    janet_parser_flush(p);
    return argv[0];
}

static Janet cfun_parse_where(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    JanetParser *p = janet_getabstract(argv, 0, &janet_parser_type);
    Janet *tup = janet_tuple_begin(2);
    tup[0] = janet_wrap_integer(p->line);
    tup[1] = janet_wrap_integer(p->column);
    return janet_wrap_tuple(janet_tuple_end(tup));
}

static Janet janet_wrap_parse_state(JanetParseState *s, Janet *args,
                                    uint8_t *buff, uint32_t bufcount) {
    JanetTable *state = janet_table(0);
    const uint8_t *buffer;
    int add_buffer = 0;
    const char *type = NULL;

    if (s->flags & PFLAG_CONTAINER) {
        JanetArray *container_args = janet_array(s->argn);
        container_args->count = s->argn;
        safe_memcpy(container_args->data, args, sizeof(args[0])*s->argn);
        janet_table_put(state, janet_ckeywordv("args"),
                        janet_wrap_array(container_args));
    }

    if (s->flags & PFLAG_PARENS || s->flags & PFLAG_SQRBRACKETS) {
        if (s->flags & PFLAG_ATSYM) {
            type = "array";
        } else {
            type = "tuple";
        }
    } else if (s->flags & PFLAG_CURLYBRACKETS) {
        if (s->flags & PFLAG_ATSYM) {
            type = "table";
        } else {
            type = "struct";
        }
    } else if (s->flags & PFLAG_STRING || s->flags & PFLAG_LONGSTRING) {
        if (s->flags & PFLAG_BUFFER) {
            type = "buffer";
        } else {
            type = "string";
        }
        add_buffer = 1;
    } else if (s->flags & PFLAG_COMMENT) {
        type = "comment";
        add_buffer = 1;
    } else if (s->flags & PFLAG_TOKEN) {
        type = "token";
        add_buffer = 1;
    } else if (s->flags & PFLAG_ATSYM) {
        type = "at";
    } else if (s->flags & PFLAG_READERMAC) {
        int c = s->flags & 0xFF;
        type = (c == '\'') ? "quote" :
               (c == ',') ? "unquote" :
               (c == ';') ? "splice" :
               (c == '~') ? "quasiquote" : "<reader>";
    } else {
        type = "root";
    }

    if (type) {
        janet_table_put(state, janet_ckeywordv("type"),
                        janet_ckeywordv(type));
    }

    if (add_buffer) {
        buffer = janet_string(buff, bufcount);
        janet_table_put(state, janet_ckeywordv("buffer"), janet_wrap_string(buffer));
    }

    janet_table_put(state, janet_ckeywordv("line"), janet_wrap_integer(s->line));
    janet_table_put(state, janet_ckeywordv("column"), janet_wrap_integer(s->column));
    return janet_wrap_table(state);
}

struct ParserStateGetter {
    const char *name;
    Janet(*fn)(const JanetParser *p);
};

static Janet parser_state_delimiters(const JanetParser *_p) {
    JanetParser *p = (JanetParser *)_p;
    size_t i;
    const uint8_t *str;
    size_t oldcount;
    oldcount = p->bufcount;
    for (i = 0; i < p->statecount; i++) {
        JanetParseState *s = p->states + i;
        if (s->flags & PFLAG_PARENS) {
            push_buf(p, '(');
        } else if (s->flags & PFLAG_SQRBRACKETS) {
            push_buf(p, '[');
        } else if (s->flags & PFLAG_CURLYBRACKETS) {
            push_buf(p, '{');
        } else if (s->flags & PFLAG_STRING) {
            push_buf(p, '"');
        } else if (s->flags & PFLAG_LONGSTRING) {
            int32_t i;
            for (i = 0; i < s->argn; i++) {
                push_buf(p, '`');
            }
        }
    }
    str = janet_string(p->buf + oldcount, (int32_t)(p->bufcount - oldcount));
    p->bufcount = oldcount;
    return janet_wrap_string(str);
}

static Janet parser_state_frames(const JanetParser *p) {
    int32_t count = (int32_t) p->statecount;
    JanetArray *states = janet_array(count);
    states->count = count;
    uint8_t *buf = p->buf;
    Janet *args = p->args;
    for (int32_t i = count - 1; i >= 0; --i) {
        JanetParseState *s = p->states + i;
        states->data[i] = janet_wrap_parse_state(s, args, buf, (uint32_t) p->bufcount);
        args -= s->argn;
    }
    return janet_wrap_array(states);
}

static const struct ParserStateGetter parser_state_getters[] = {
    {"frames", parser_state_frames},
    {"delimiters", parser_state_delimiters},
    {NULL, NULL}
};

static Janet cfun_parse_state(int32_t argc, Janet *argv) {
    janet_arity(argc, 1, 2);
    const uint8_t *key = NULL;
    JanetParser *p = janet_getabstract(argv, 0, &janet_parser_type);
    if (argc == 2) {
        key = janet_getkeyword(argv, 1);
    }

    if (key) {
        /* Get one result */
        for (const struct ParserStateGetter *sg = parser_state_getters;
                sg->name != NULL; sg++) {
            if (janet_cstrcmp(key, sg->name)) continue;
            return sg->fn(p);
        }
        janet_panicf("unexpected keyword %v", janet_wrap_keyword(key));
        return janet_wrap_nil();
    } else {
        /* Put results in table */
        JanetTable *tab = janet_table(0);
        for (const struct ParserStateGetter *sg = parser_state_getters;
                sg->name != NULL; sg++) {
            janet_table_put(tab, janet_ckeywordv(sg->name), sg->fn(p));
        }
        return janet_wrap_table(tab);
    }
}

static Janet cfun_parse_clone(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    JanetParser *src = janet_getabstract(argv, 0, &janet_parser_type);
    JanetParser *dest = janet_abstract(&janet_parser_type, sizeof(JanetParser));
    janet_parser_clone(src, dest);
    return janet_wrap_abstract(dest);
}

static const JanetMethod parser_methods[] = {
    {"byte", cfun_parse_byte},
    {"clone", cfun_parse_clone},
    {"consume", cfun_parse_consume},
    {"eof", cfun_parse_eof},
    {"error", cfun_parse_error},
    {"flush", cfun_parse_flush},
    {"has-more", cfun_parse_has_more},
    {"insert", cfun_parse_insert},
    {"produce", cfun_parse_produce},
    {"state", cfun_parse_state},
    {"status", cfun_parse_status},
    {"where", cfun_parse_where},
    {NULL, NULL}
};

static int parserget(void *p, Janet key, Janet *out) {
    (void) p;
    if (!janet_checktype(key, JANET_KEYWORD)) return 0;
    return janet_getmethod(janet_unwrap_keyword(key), parser_methods, out);
}

static const JanetReg parse_cfuns[] = {
    {
        "parser/new", cfun_parse_parser,
        JDOC("(parser/new)\n\n"
             "Creates and returns a new parser object. Parsers are state machines "
             "that can receive bytes, and generate a stream of values.")
    },
    {
        "parser/clone", cfun_parse_clone,
        JDOC("(parser/clone p)\n\n"
             "Creates a deep clone of a parser that is identical to the input parser. "
             "This cloned parser can be used to continue parsing from a good checkpoint "
             "if parsing later fails. Returns a new parser.")
    },
    {
        "parser/has-more", cfun_parse_has_more,
        JDOC("(parser/has-more parser)\n\n"
             "Check if the parser has more values in the value queue.")
    },
    {
        "parser/produce", cfun_parse_produce,
        JDOC("(parser/produce parser)\n\n"
             "Dequeue the next value in the parse queue. Will return nil if "
             "no parsed values are in the queue, otherwise will dequeue the "
             "next value.")
    },
    {
        "parser/consume", cfun_parse_consume,
        JDOC("(parser/consume parser bytes &opt index)\n\n"
             "Input bytes into the parser and parse them. Will not throw errors "
             "if there is a parse error. Starts at the byte index given by index. Returns "
             "the number of bytes read.")
    },
    {
        "parser/byte", cfun_parse_byte,
        JDOC("(parser/byte parser b)\n\n"
             "Input a single byte into the parser byte stream. Returns the parser.")
    },
    {
        "parser/error", cfun_parse_error,
        JDOC("(parser/error parser)\n\n"
             "If the parser is in the error state, returns the message associated with "
             "that error. Otherwise, returns nil. Also flushes the parser state and parser "
             "queue, so be sure to handle everything in the queue before calling "
             "parser/error.")
    },
    {
        "parser/status", cfun_parse_status,
        JDOC("(parser/status parser)\n\n"
             "Gets the current status of the parser state machine. The status will "
             "be one of:\n\n"
             "\t:pending - a value is being parsed.\n"
             "\t:error - a parsing error was encountered.\n"
             "\t:root - the parser can either read more values or safely terminate.")
    },
    {
        "parser/flush", cfun_parse_flush,
        JDOC("(parser/flush parser)\n\n"
             "Clears the parser state and parse queue. Can be used to reset the parser "
             "if an error was encountered. Does not reset the line and column counter, so "
             "to begin parsing in a new context, create a new parser.")
    },
    {
        "parser/state", cfun_parse_state,
        JDOC("(parser/state parser &opt key)\n\n"
             "Returns a representation of the internal state of the parser. If a key is passed, "
             "only that information about the state is returned. Allowed keys are:\n\n"
             "\t:delimiters - Each byte in the string represents a nested data structure. For example, "
             "if the parser state is '([\"', then the parser is in the middle of parsing a "
             "string inside of square brackets inside parentheses. Can be used to augment a REPL prompt."
             "\t:frames - Each table in the array represents a 'frame' in the parser state. Frames "
             "contain information about the start of the expression being parsed as well as the "
             "type of that expression and some type-specific information.")
    },
    {
        "parser/where", cfun_parse_where,
        JDOC("(parser/where parser)\n\n"
             "Returns the current line number and column of the parser's internal state.")
    },
    {
        "parser/eof", cfun_parse_eof,
        JDOC("(parser/eof parser)\n\n"
             "Indicate that the end of file was reached to the parser. This puts the parser in the :dead state.")
    },
    {
        "parser/insert", cfun_parse_insert,
        JDOC("(parser/insert parser value)\n\n"
             "Insert a value into the parser. This means that the parser state can be manipulated "
             "in between chunks of bytes. This would allow a user to add extra elements to arrays "
             "and tuples, for example. Returns the parser.")
    },
    {NULL, NULL, NULL}
};

/* Load the library */
void janet_lib_parse(JanetTable *env) {
    janet_core_cfuns(env, NULL, parse_cfuns);
}


/* src/core/peg.c */
#line 0 "src/core/peg.c"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include <string.h>
#include "util.h"
#include "vector.h"
#include "util.h"
#endif

#ifdef JANET_PEG

/*
 * Runtime
 */

/* Hold captured patterns and match state */
typedef struct {
    const uint8_t *text_start;
    const uint8_t *text_end;
    const uint32_t *bytecode;
    const Janet *constants;
    JanetArray *captures;
    JanetBuffer *scratch;
    JanetBuffer *tags;
    const Janet *extrav;
    int32_t extrac;
    int32_t depth;
    enum {
        PEG_MODE_NORMAL,
        PEG_MODE_ACCUMULATE
    } mode;
} PegState;

/* Allow backtrack with captures. We need
 * to save state at branches, and then reload
 * if one branch fails and try a new branch. */
typedef struct {
    int32_t cap;
    int32_t scratch;
} CapState;

/* Save the current capture state */
static CapState cap_save(PegState *s) {
    CapState cs;
    cs.scratch = s->scratch->count;
    cs.cap = s->captures->count;
    return cs;
}

/* Load a saved capture state in the case of failure */
static void cap_load(PegState *s, CapState cs) {
    s->scratch->count = cs.scratch;
    s->captures->count = cs.cap;
    s->tags->count = cs.cap;
}

/* Add a capture */
static void pushcap(PegState *s, Janet capture, uint32_t tag) {
    if (s->mode == PEG_MODE_ACCUMULATE) {
        janet_to_string_b(s->scratch, capture);
    }
    if (tag || s->mode == PEG_MODE_NORMAL) {
        janet_array_push(s->captures, capture);
        janet_buffer_push_u8(s->tags, tag);
    }
}

/* Prevent stack overflow */
#define down1(s) do { \
    if (0 == --((s)->depth)) janet_panic("peg/match recursed too deeply"); \
} while (0)
#define up1(s) ((s)->depth++)

/* Evaluate a peg rule
 * Pre-conditions: s is in a valid state
 * Post-conditions: If there is a match, returns a pointer to the next text.
 * All captures on the capture stack are valid. If there is no match,
 * returns NULL. Extra captures from successful child expressions can be
 * left on the capture stack.
 */
static const uint8_t *peg_rule(
    PegState *s,
    const uint32_t *rule,
    const uint8_t *text) {
tail:
    switch (*rule & 0x1F) {
        default:
            janet_panic("unexpected opcode");
            return NULL;

        case RULE_LITERAL: {
            uint32_t len = rule[1];
            if (text + len > s->text_end) return NULL;
            return memcmp(text, rule + 2, len) ? NULL : text + len;
        }

        case RULE_NCHAR: {
            uint32_t n = rule[1];
            return (text + n > s->text_end) ? NULL : text + n;
        }

        case RULE_NOTNCHAR: {
            uint32_t n = rule[1];
            return (text + n > s->text_end) ? text : NULL;
        }

        case RULE_RANGE: {
            uint8_t lo = rule[1] & 0xFF;
            uint8_t hi = (rule[1] >> 16) & 0xFF;
            return (text < s->text_end &&
                    text[0] >= lo &&
                    text[0] <= hi)
                   ? text + 1
                   : NULL;
        }

        case RULE_SET: {
            uint32_t word = rule[1 + (text[0] >> 5)];
            uint32_t mask = (uint32_t)1 << (text[0] & 0x1F);
            return (text < s->text_end && (word & mask))
                   ? text + 1
                   : NULL;
        }

        case RULE_LOOK: {
            text += ((int32_t *)rule)[1];
            if (text < s->text_start || text > s->text_end) return NULL;
            down1(s);
            const uint8_t *result = peg_rule(s, s->bytecode + rule[2], text);
            up1(s);
            text -= ((int32_t *)rule)[1];
            return result ? text : NULL;
        }

        case RULE_CHOICE: {
            uint32_t len = rule[1];
            const uint32_t *args = rule + 2;
            if (len == 0) return NULL;
            down1(s);
            CapState cs = cap_save(s);
            for (uint32_t i = 0; i < len - 1; i++) {
                const uint8_t *result = peg_rule(s, s->bytecode + args[i], text);
                if (result) {
                    up1(s);
                    return result;
                }
                cap_load(s, cs);
            }
            up1(s);
            rule = s->bytecode + args[len - 1];
            goto tail;
        }

        case RULE_SEQUENCE: {
            uint32_t len = rule[1];
            const uint32_t *args = rule + 2;
            if (len == 0) return text;
            down1(s);
            for (uint32_t i = 0; text && i < len - 1; i++)
                text = peg_rule(s, s->bytecode + args[i], text);
            up1(s);
            if (!text) return NULL;
            rule = s->bytecode + args[len - 1];
            goto tail;
        }

        case RULE_IF:
        case RULE_IFNOT: {
            const uint32_t *rule_a = s->bytecode + rule[1];
            const uint32_t *rule_b = s->bytecode + rule[2];
            down1(s);
            const uint8_t *result = peg_rule(s, rule_a, text);
            up1(s);
            if (rule[0] == RULE_IF ? !result : !!result) return NULL;
            rule = rule_b;
            goto tail;
        }

        case RULE_NOT: {
            const uint32_t *rule_a = s->bytecode + rule[1];
            down1(s);
            const uint8_t *result = peg_rule(s, rule_a, text);
            up1(s);
            return (result) ? NULL : text;
        }

        case RULE_THRU:
        case RULE_TO: {
            const uint32_t *rule_a = s->bytecode + rule[1];
            const uint8_t *next_text;
            CapState cs = cap_save(s);
            down1(s);
            while (text < s->text_end) {
                CapState cs2 = cap_save(s);
                next_text = peg_rule(s, rule_a, text);
                if (next_text) {
                    if (rule[0] == RULE_TO) cap_load(s, cs2);
                    break;
                }
                text++;
            }
            up1(s);
            if (text >= s->text_end) {
                cap_load(s, cs);
                return NULL;
            }
            return rule[0] == RULE_TO ? text : next_text;
        }

        case RULE_BETWEEN: {
            uint32_t lo = rule[1];
            uint32_t hi = rule[2];
            const uint32_t *rule_a = s->bytecode + rule[3];
            uint32_t captured = 0;
            const uint8_t *next_text;
            CapState cs = cap_save(s);
            down1(s);
            while (captured < hi) {
                CapState cs2 = cap_save(s);
                next_text = peg_rule(s, rule_a, text);
                if (!next_text || next_text == text) {
                    cap_load(s, cs2);
                    break;
                }
                captured++;
                text = next_text;
            }
            up1(s);
            if (captured < lo) {
                cap_load(s, cs);
                return NULL;
            }
            return text;
        }

        /* Capturing rules */

        case RULE_GETTAG: {
            uint32_t search = rule[1];
            uint32_t tag = rule[2];
            for (int32_t i = s->tags->count - 1; i >= 0; i--) {
                if (s->tags->data[i] == search) {
                    pushcap(s, s->captures->data[i], tag);
                    return text;
                }
            }
            return NULL;
        }

        case RULE_POSITION: {
            pushcap(s, janet_wrap_number((double)(text - s->text_start)), rule[1]);
            return text;
        }

        case RULE_ARGUMENT: {
            int32_t index = ((int32_t *)rule)[1];
            Janet capture = (index >= s->extrac) ? janet_wrap_nil() : s->extrav[index];
            pushcap(s, capture, rule[2]);
            return text;
        }

        case RULE_CONSTANT: {
            pushcap(s, s->constants[rule[1]], rule[2]);
            return text;
        }

        case RULE_CAPTURE: {
            uint32_t tag = rule[2];
            down1(s);
            const uint8_t *result = peg_rule(s, s->bytecode + rule[1], text);
            up1(s);
            if (!result) return NULL;
            /* Specialized pushcap - avoid intermediate string creation */
            if (!tag && s->mode == PEG_MODE_ACCUMULATE) {
                janet_buffer_push_bytes(s->scratch, text, (int32_t)(result - text));
            } else {
                pushcap(s, janet_stringv(text, (int32_t)(result - text)), tag);
            }
            return result;
        }

        case RULE_ACCUMULATE: {
            uint32_t tag = rule[2];
            int oldmode = s->mode;
            if (!tag && oldmode == PEG_MODE_ACCUMULATE) {
                rule = s->bytecode + rule[1];
                goto tail;
            }
            CapState cs = cap_save(s);
            s->mode = PEG_MODE_ACCUMULATE;
            down1(s);
            const uint8_t *result = peg_rule(s, s->bytecode + rule[1], text);
            up1(s);
            s->mode = oldmode;
            if (!result) return NULL;
            Janet cap = janet_stringv(s->scratch->data + cs.scratch,
                                      s->scratch->count - cs.scratch);
            cap_load(s, cs);
            pushcap(s, cap, tag);
            return result;
        }

        case RULE_DROP: {
            CapState cs = cap_save(s);
            down1(s);
            const uint8_t *result = peg_rule(s, s->bytecode + rule[1], text);
            up1(s);
            if (!result) return NULL;
            cap_load(s, cs);
            return result;
        }

        case RULE_GROUP: {
            uint32_t tag = rule[2];
            int oldmode = s->mode;
            CapState cs = cap_save(s);
            s->mode = PEG_MODE_NORMAL;
            down1(s);
            const uint8_t *result = peg_rule(s, s->bytecode + rule[1], text);
            up1(s);
            s->mode = oldmode;
            if (!result) return NULL;
            int32_t num_sub_captures = s->captures->count - cs.cap;
            JanetArray *sub_captures = janet_array(num_sub_captures);
            safe_memcpy(sub_captures->data,
                        s->captures->data + cs.cap,
                        sizeof(Janet) * num_sub_captures);
            sub_captures->count = num_sub_captures;
            cap_load(s, cs);
            pushcap(s, janet_wrap_array(sub_captures), tag);
            return result;
        }

        case RULE_REPLACE:
        case RULE_MATCHTIME: {
            uint32_t tag = rule[3];
            int oldmode = s->mode;
            CapState cs = cap_save(s);
            s->mode = PEG_MODE_NORMAL;
            down1(s);
            const uint8_t *result = peg_rule(s, s->bytecode + rule[1], text);
            up1(s);
            s->mode = oldmode;
            if (!result) return NULL;

            Janet cap = janet_wrap_nil();
            Janet constant = s->constants[rule[2]];
            switch (janet_type(constant)) {
                default:
                    cap = constant;
                    break;
                case JANET_STRUCT:
                    if (s->captures->count) {
                        cap = janet_struct_get(janet_unwrap_struct(constant),
                                               s->captures->data[s->captures->count - 1]);
                    }
                    break;
                case JANET_TABLE:
                    if (s->captures->count) {
                        cap = janet_table_get(janet_unwrap_table(constant),
                                              s->captures->data[s->captures->count - 1]);
                    }
                    break;
                case JANET_CFUNCTION:
                    cap = janet_unwrap_cfunction(constant)(s->captures->count - cs.cap,
                                                           s->captures->data + cs.cap);
                    break;
                case JANET_FUNCTION:
                    cap = janet_call(janet_unwrap_function(constant),
                                     s->captures->count - cs.cap,
                                     s->captures->data + cs.cap);
                    break;
            }
            cap_load(s, cs);
            if (rule[0] == RULE_MATCHTIME && !janet_truthy(cap)) return NULL;
            pushcap(s, cap, tag);
            return result;
        }

        case RULE_ERROR: {
            int oldmode = s->mode;
            s->mode = PEG_MODE_NORMAL;
            int32_t old_cap = s->captures->count;
            down1(s);
            const uint8_t *result = peg_rule(s, s->bytecode + rule[1], text);
            up1(s);
            s->mode = oldmode;
            if (!result) return NULL;
            if (s->captures->count > old_cap) {
                /* Throw last capture */
                janet_panicv(s->captures->data[s->captures->count - 1]);
            } else {
                /* Throw generic error */
                int32_t start = (int32_t)(text - s->text_start);
                int32_t end = (int32_t)(result - s->text_start);
                janet_panicf("match error in range (%d:%d)", start, end);
            }
            return NULL;
        }

        case RULE_BACKMATCH: {
            uint32_t search = rule[1];
            for (int32_t i = s->tags->count - 1; i >= 0; i--) {
                if (s->tags->data[i] == search) {
                    Janet capture = s->captures->data[i];
                    if (!janet_checktype(capture, JANET_STRING))
                        return NULL;
                    const uint8_t *bytes = janet_unwrap_string(capture);
                    int32_t len = janet_string_length(bytes);
                    if (text + len > s->text_end)
                        return NULL;
                    return memcmp(text, bytes, len) ? NULL : text + len;
                }
            }
            return NULL;
        }

        case RULE_LENPREFIX: {
            int oldmode = s->mode;
            s->mode = PEG_MODE_NORMAL;
            const uint8_t *next_text;
            CapState cs = cap_save(s);
            down1(s);
            next_text = peg_rule(s, s->bytecode + rule[1], text);
            up1(s);
            if (NULL == next_text) return NULL;
            s->mode = oldmode;
            int32_t num_sub_captures = s->captures->count - cs.cap;
            Janet lencap;
            if (num_sub_captures <= 0 ||
                    (lencap = s->captures->data[cs.cap], !janet_checkint(lencap))) {
                cap_load(s, cs);
                return NULL;
            }
            int32_t nrep = janet_unwrap_integer(lencap);
            /* drop captures from len pattern */
            cap_load(s, cs);
            for (int32_t i = 0; i < nrep; i++) {
                down1(s);
                next_text = peg_rule(s, s->bytecode + rule[2], next_text);
                up1(s);
                if (NULL == next_text) {
                    cap_load(s, cs);
                    return NULL;
                }
            }
            return next_text;
        }

    }
}

/*
 * Compilation
 */

typedef struct {
    JanetTable *grammar;
    JanetTable *default_grammar;
    JanetTable *tags;
    Janet *constants;
    uint32_t *bytecode;
    Janet form;
    int depth;
    uint32_t nexttag;
} Builder;

/* Forward declaration to allow recursion */
static uint32_t peg_compile1(Builder *b, Janet peg);

/*
 * Errors
 */

static void builder_cleanup(Builder *b) {
    janet_v_free(b->constants);
    janet_v_free(b->bytecode);
}

JANET_NO_RETURN static void peg_panic(Builder *b, const char *msg) {
    builder_cleanup(b);
    janet_panicf("grammar error in %p, %s", b->form, msg);
}

#define peg_panicf(b,...) peg_panic((b), (const char *) janet_formatc(__VA_ARGS__))

static void peg_fixarity(Builder *b, int32_t argc, int32_t arity) {
    if (argc != arity) {
        peg_panicf(b, "expected %d argument%s, got %d",
                   arity,
                   arity == 1 ? "" : "s",
                   argc);
    }
}

static void peg_arity(Builder *b, int32_t arity, int32_t min, int32_t max) {
    if (min >= 0 && arity < min)
        peg_panicf(b, "arity mismatch, expected at least %d, got %d", min, arity);
    if (max >= 0 && arity > max)
        peg_panicf(b, "arity mismatch, expected at most %d, got %d", max, arity);
}

static const uint8_t *peg_getset(Builder *b, Janet x) {
    if (!janet_checktype(x, JANET_STRING))
        peg_panic(b, "expected string for character set");
    const uint8_t *str = janet_unwrap_string(x);
    return str;
}

static const uint8_t *peg_getrange(Builder *b, Janet x) {
    if (!janet_checktype(x, JANET_STRING))
        peg_panic(b, "expected string for character range");
    const uint8_t *str = janet_unwrap_string(x);
    if (janet_string_length(str) != 2)
        peg_panicf(b, "expected string to have length 2, got %v", x);
    if (str[1] < str[0])
        peg_panicf(b, "range %v is empty", x);
    return str;
}

static int32_t peg_getinteger(Builder *b, Janet x) {
    if (!janet_checkint(x))
        peg_panicf(b, "expected integer, got %v", x);
    return janet_unwrap_integer(x);
}

static int32_t peg_getnat(Builder *b, Janet x) {
    int32_t i = peg_getinteger(b, x);
    if (i < 0)
        peg_panicf(b, "expected non-negative integer, got %v", x);
    return i;
}

/*
 * Emission
 */

static uint32_t emit_constant(Builder *b, Janet c) {
    uint32_t cindex = (uint32_t) janet_v_count(b->constants);
    janet_v_push(b->constants, c);
    return cindex;
}

static uint32_t emit_tag(Builder *b, Janet t) {
    if (!janet_checktype(t, JANET_KEYWORD))
        peg_panicf(b, "expected keyword for capture tag, got %v", t);
    Janet check = janet_table_get(b->tags, t);
    if (janet_checktype(check, JANET_NIL)) {
        uint32_t tag = b->nexttag++;
        if (tag > 255) {
            peg_panic(b, "too many tags - up to 255 tags are supported per peg");
        }
        Janet val = janet_wrap_number(tag);
        janet_table_put(b->tags, t, val);
        return tag;
    } else {
        return (uint32_t) janet_unwrap_number(check);
    }
}

/* Reserve space in bytecode for a rule. When a special emits a rule,
 * it must place that rule immediately on the bytecode stack. This lets
 * the compiler know where the rule is going to be before it is complete,
 * allowing recursive rules. */
typedef struct {
    Builder *builder;
    uint32_t index;
    int32_t size;
} Reserve;

static Reserve reserve(Builder *b, int32_t size) {
    Reserve r;
    r.index = janet_v_count(b->bytecode);
    r.builder = b;
    r.size = size;
    for (int32_t i = 0; i < size; i++)
        janet_v_push(b->bytecode, 0);
    return r;
}

/* Emit a rule in the builder. Returns the index of the new rule */
static void emit_rule(Reserve r, int32_t op, int32_t n, const uint32_t *body) {
    janet_assert(r.size == n + 1, "bad reserve");
    r.builder->bytecode[r.index] = op;
    memcpy(r.builder->bytecode + r.index + 1, body, n * sizeof(uint32_t));
}

/* For RULE_LITERAL */
static void emit_bytes(Builder *b, uint32_t op, int32_t len, const uint8_t *bytes) {
    uint32_t next_rule = janet_v_count(b->bytecode);
    janet_v_push(b->bytecode, op);
    janet_v_push(b->bytecode, len);
    int32_t words = ((len + 3) >> 2);
    for (int32_t i = 0; i < words; i++)
        janet_v_push(b->bytecode, 0);
    memcpy(b->bytecode + next_rule + 2, bytes, len);
}

/* For fixed arity rules of arities 1, 2, and 3 */
static void emit_1(Reserve r, uint32_t op, uint32_t arg) {
    emit_rule(r, op, 1, &arg);
}
static void emit_2(Reserve r, uint32_t op, uint32_t arg1, uint32_t arg2) {
    uint32_t arr[2] = {arg1, arg2};
    emit_rule(r, op, 2, arr);
}
static void emit_3(Reserve r, uint32_t op, uint32_t arg1, uint32_t arg2, uint32_t arg3) {
    uint32_t arr[3] = {arg1, arg2, arg3};
    emit_rule(r, op, 3, arr);
}

/*
 * Specials
 */

static void bitmap_set(uint32_t *bitmap, uint8_t c) {
    bitmap[c >> 5] |= ((uint32_t)1) << (c & 0x1F);
}

static void spec_range(Builder *b, int32_t argc, const Janet *argv) {
    peg_arity(b, argc, 1, -1);
    if (argc == 1) {
        Reserve r = reserve(b, 2);
        const uint8_t *str = peg_getrange(b, argv[0]);
        uint32_t arg = str[0] | (str[1] << 16);
        emit_1(r, RULE_RANGE, arg);
    } else {
        /* Compile as a set */
        Reserve r = reserve(b, 9);
        uint32_t bitmap[8] = {0};
        for (int32_t i = 0; i < argc; i++) {
            const uint8_t *str = peg_getrange(b, argv[i]);
            for (uint32_t c = str[0]; c <= str[1]; c++)
                bitmap_set(bitmap, c);
        }
        emit_rule(r, RULE_SET, 8, bitmap);
    }
}

static void spec_set(Builder *b, int32_t argc, const Janet *argv) {
    peg_fixarity(b, argc, 1);
    Reserve r = reserve(b, 9);
    const uint8_t *str = peg_getset(b, argv[0]);
    uint32_t bitmap[8] = {0};
    for (int32_t i = 0; i < janet_string_length(str); i++)
        bitmap_set(bitmap, str[i]);
    emit_rule(r, RULE_SET, 8, bitmap);
}

static void spec_look(Builder *b, int32_t argc, const Janet *argv) {
    peg_arity(b, argc, 1, 2);
    Reserve r = reserve(b, 3);
    int32_t rulearg = argc == 2 ? 1 : 0;
    int32_t offset = argc == 2 ? peg_getinteger(b, argv[0]) : 0;
    uint32_t subrule = peg_compile1(b, argv[rulearg]);
    emit_2(r, RULE_LOOK, (uint32_t) offset, subrule);
}

/* Rule of the form [len, rules...] */
static void spec_variadic(Builder *b, int32_t argc, const Janet *argv, uint32_t op) {
    uint32_t rule = janet_v_count(b->bytecode);
    janet_v_push(b->bytecode, op);
    janet_v_push(b->bytecode, argc);
    for (int32_t i = 0; i < argc; i++)
        janet_v_push(b->bytecode, 0);
    for (int32_t i = 0; i < argc; i++) {
        uint32_t rulei = peg_compile1(b, argv[i]);
        b->bytecode[rule + 2 + i] = rulei;
    }
}

static void spec_choice(Builder *b, int32_t argc, const Janet *argv) {
    spec_variadic(b, argc, argv, RULE_CHOICE);
}
static void spec_sequence(Builder *b, int32_t argc, const Janet *argv) {
    spec_variadic(b, argc, argv, RULE_SEQUENCE);
}

/* For (if a b) and (if-not a b) */
static void spec_branch(Builder *b, int32_t argc, const Janet *argv, uint32_t rule) {
    peg_fixarity(b, argc, 2);
    Reserve r = reserve(b, 3);
    uint32_t rule_a = peg_compile1(b, argv[0]);
    uint32_t rule_b = peg_compile1(b, argv[1]);
    emit_2(r, rule, rule_a, rule_b);
}

static void spec_if(Builder *b, int32_t argc, const Janet *argv) {
    spec_branch(b, argc, argv, RULE_IF);
}
static void spec_ifnot(Builder *b, int32_t argc, const Janet *argv) {
    spec_branch(b, argc, argv, RULE_IFNOT);
}
static void spec_lenprefix(Builder *b, int32_t argc, const Janet *argv) {
    spec_branch(b, argc, argv, RULE_LENPREFIX);
}

static void spec_between(Builder *b, int32_t argc, const Janet *argv) {
    peg_fixarity(b, argc, 3);
    Reserve r = reserve(b, 4);
    int32_t lo = peg_getnat(b, argv[0]);
    int32_t hi = peg_getnat(b, argv[1]);
    uint32_t subrule = peg_compile1(b, argv[2]);
    emit_3(r, RULE_BETWEEN, lo, hi, subrule);
}

static void spec_repeater(Builder *b, int32_t argc, const Janet *argv, int32_t min) {
    peg_fixarity(b, argc, 1);
    Reserve r = reserve(b, 4);
    uint32_t subrule = peg_compile1(b, argv[0]);
    emit_3(r, RULE_BETWEEN, min, UINT32_MAX, subrule);
}

static void spec_some(Builder *b, int32_t argc, const Janet *argv) {
    spec_repeater(b, argc, argv, 1);
}
static void spec_any(Builder *b, int32_t argc, const Janet *argv) {
    spec_repeater(b, argc, argv, 0);
}

static void spec_atleast(Builder *b, int32_t argc, const Janet *argv) {
    peg_fixarity(b, argc, 2);
    Reserve r = reserve(b, 4);
    int32_t n = peg_getnat(b, argv[0]);
    uint32_t subrule = peg_compile1(b, argv[1]);
    emit_3(r, RULE_BETWEEN, n, UINT32_MAX, subrule);
}

static void spec_atmost(Builder *b, int32_t argc, const Janet *argv) {
    peg_fixarity(b, argc, 2);
    Reserve r = reserve(b, 4);
    int32_t n = peg_getnat(b, argv[0]);
    uint32_t subrule = peg_compile1(b, argv[1]);
    emit_3(r, RULE_BETWEEN, 0, n, subrule);
}

static void spec_opt(Builder *b, int32_t argc, const Janet *argv) {
    peg_fixarity(b, argc, 1);
    Reserve r = reserve(b, 4);
    uint32_t subrule = peg_compile1(b, argv[0]);
    emit_3(r, RULE_BETWEEN, 0, 1, subrule);
}

static void spec_repeat(Builder *b, int32_t argc, const Janet *argv) {
    peg_fixarity(b, argc, 2);
    Reserve r = reserve(b, 4);
    int32_t n = peg_getnat(b, argv[0]);
    uint32_t subrule = peg_compile1(b, argv[1]);
    emit_3(r, RULE_BETWEEN, n, n, subrule);
}

/* Rule of the form [rule] */
static void spec_onerule(Builder *b, int32_t argc, const Janet *argv, uint32_t op) {
    peg_fixarity(b, argc, 1);
    Reserve r = reserve(b, 2);
    uint32_t rule = peg_compile1(b, argv[0]);
    emit_1(r, op, rule);
}

static void spec_not(Builder *b, int32_t argc, const Janet *argv) {
    spec_onerule(b, argc, argv, RULE_NOT);
}
static void spec_error(Builder *b, int32_t argc, const Janet *argv) {
    spec_onerule(b, argc, argv, RULE_ERROR);
}
static void spec_drop(Builder *b, int32_t argc, const Janet *argv) {
    spec_onerule(b, argc, argv, RULE_DROP);
}
static void spec_to(Builder *b, int32_t argc, const Janet *argv) {
    spec_onerule(b, argc, argv, RULE_TO);
}
static void spec_thru(Builder *b, int32_t argc, const Janet *argv) {
    spec_onerule(b, argc, argv, RULE_THRU);
}

/* Rule of the form [rule, tag] */
static void spec_cap1(Builder *b, int32_t argc, const Janet *argv, uint32_t op) {
    peg_arity(b, argc, 1, 2);
    Reserve r = reserve(b, 3);
    uint32_t tag = (argc == 2) ? emit_tag(b, argv[1]) : 0;
    uint32_t rule = peg_compile1(b, argv[0]);
    emit_2(r, op, rule, tag);
}

static void spec_capture(Builder *b, int32_t argc, const Janet *argv) {
    spec_cap1(b, argc, argv, RULE_CAPTURE);
}
static void spec_accumulate(Builder *b, int32_t argc, const Janet *argv) {
    spec_cap1(b, argc, argv, RULE_ACCUMULATE);
}
static void spec_group(Builder *b, int32_t argc, const Janet *argv) {
    spec_cap1(b, argc, argv, RULE_GROUP);
}

static void spec_reference(Builder *b, int32_t argc, const Janet *argv) {
    peg_arity(b, argc, 1, 2);
    Reserve r = reserve(b, 3);
    uint32_t search = emit_tag(b, argv[0]);
    uint32_t tag = (argc == 2) ? emit_tag(b, argv[1]) : 0;
    emit_2(r, RULE_GETTAG, search, tag);
}

static void spec_tag1(Builder *b, int32_t argc, const Janet *argv, uint32_t op) {
    peg_arity(b, argc, 0, 1);
    Reserve r = reserve(b, 2);
    uint32_t tag = (argc) ? emit_tag(b, argv[0]) : 0;
    (void) argv;
    emit_1(r, op, tag);
}

static void spec_position(Builder *b, int32_t argc, const Janet *argv) {
    spec_tag1(b, argc, argv, RULE_POSITION);
}

static void spec_backmatch(Builder *b, int32_t argc, const Janet *argv) {
    spec_tag1(b, argc, argv, RULE_BACKMATCH);
}

static void spec_argument(Builder *b, int32_t argc, const Janet *argv) {
    peg_arity(b, argc, 1, 2);
    Reserve r = reserve(b, 3);
    uint32_t tag = (argc == 2) ? emit_tag(b, argv[1]) : 0;
    int32_t index = peg_getnat(b, argv[0]);
    emit_2(r, RULE_ARGUMENT, index, tag);
}

static void spec_constant(Builder *b, int32_t argc, const Janet *argv) {
    janet_arity(argc, 1, 2);
    Reserve r = reserve(b, 3);
    uint32_t tag = (argc == 2) ? emit_tag(b, argv[1]) : 0;
    emit_2(r, RULE_CONSTANT, emit_constant(b, argv[0]), tag);
}

static void spec_replace(Builder *b, int32_t argc, const Janet *argv) {
    peg_arity(b, argc, 2, 3);
    Reserve r = reserve(b, 4);
    uint32_t subrule = peg_compile1(b, argv[0]);
    uint32_t constant = emit_constant(b, argv[1]);
    uint32_t tag = (argc == 3) ? emit_tag(b, argv[2]) : 0;
    emit_3(r, RULE_REPLACE, subrule, constant, tag);
}

static void spec_matchtime(Builder *b, int32_t argc, const Janet *argv) {
    peg_arity(b, argc, 2, 3);
    Reserve r = reserve(b, 4);
    uint32_t subrule = peg_compile1(b, argv[0]);
    Janet fun = argv[1];
    if (!janet_checktype(fun, JANET_FUNCTION) &&
            !janet_checktype(fun, JANET_CFUNCTION)) {
        peg_panicf(b, "expected function|cfunction, got %v", fun);
    }
    uint32_t tag = (argc == 3) ? emit_tag(b, argv[2]) : 0;
    uint32_t cindex = emit_constant(b, fun);
    emit_3(r, RULE_MATCHTIME, subrule, cindex, tag);
}

/* Special compiler form */
typedef void (*Special)(Builder *b, int32_t argc, const Janet *argv);
typedef struct {
    const char *name;
    Special special;
} SpecialPair;

/* Keep in lexical order (vim :sort works well) */
static const SpecialPair peg_specials[] = {
    {"!", spec_not},
    {"$", spec_position},
    {"%", spec_accumulate},
    {"*", spec_sequence},
    {"+", spec_choice},
    {"->", spec_reference},
    {"/", spec_replace},
    {"<-", spec_capture},
    {">", spec_look},
    {"?", spec_opt},
    {"accumulate", spec_accumulate},
    {"any", spec_any},
    {"argument", spec_argument},
    {"at-least", spec_atleast},
    {"at-most", spec_atmost},
    {"backmatch", spec_backmatch},
    {"backref", spec_reference},
    {"between", spec_between},
    {"capture", spec_capture},
    {"choice", spec_choice},
    {"cmt", spec_matchtime},
    {"constant", spec_constant},
    {"drop", spec_drop},
    {"error", spec_error},
    {"group", spec_group},
    {"if", spec_if},
    {"if-not", spec_ifnot},
    {"lenprefix", spec_lenprefix},
    {"look", spec_look},
    {"not", spec_not},
    {"opt", spec_opt},
    {"position", spec_position},
    {"quote", spec_capture},
    {"range", spec_range},
    {"repeat", spec_repeat},
    {"replace", spec_replace},
    {"sequence", spec_sequence},
    {"set", spec_set},
    {"some", spec_some},
    {"thru", spec_thru},
    {"to", spec_to},
};

/* Compile a janet value into a rule and return the rule index. */
static uint32_t peg_compile1(Builder *b, Janet peg) {

    /* Keep track of the form being compiled for error purposes */
    Janet old_form = b->form;
    JanetTable *old_grammar = b->grammar;
    b->form = peg;

    /* Resolve keyword references */
    int i = JANET_RECURSION_GUARD;
    JanetTable *grammar = old_grammar;
    for (; i > 0 && janet_checktype(peg, JANET_KEYWORD); --i) {
        Janet nextPeg = janet_table_get_ex(grammar, peg, &grammar);
        if (!grammar || janet_checktype(nextPeg, JANET_NIL)) {
            nextPeg = janet_table_get(b->default_grammar, peg);
            if (janet_checktype(nextPeg, JANET_NIL)) {
                peg_panic(b, "unknown rule");
            }
        }
        peg = nextPeg;
        b->form = peg;
        b->grammar = grammar;
    }
    if (i == 0)
        peg_panic(b, "reference chain too deep");

    /* Check cache - for tuples we check only the local cache, as
     * in a different grammar, the same tuple can compile to a different
     * rule - for example, (+ :a :b) depends on whatever :a and :b are bound to. */
    Janet check = janet_checktype(peg, JANET_TUPLE)
                  ? janet_table_rawget(grammar, peg)
                  : janet_table_get(grammar, peg);
    if (!janet_checktype(check, JANET_NIL)) {
        b->form = old_form;
        b->grammar = old_grammar;
        return (uint32_t) janet_unwrap_number(check);
    }

    /* Check depth */
    if (b->depth-- == 0)
        peg_panic(b, "peg grammar recursed too deeply");

    /* The final rule to return */
    uint32_t rule = janet_v_count(b->bytecode);

    /* Add to cache. Do not cache structs, as we don't yet know
     * what rule they will return! We can just as effectively cache
     * the structs main rule. */
    if (!janet_checktype(peg, JANET_STRUCT)) {
        JanetTable *which_grammar = grammar;
        /* If we are a primitive pattern, add to the global cache (root grammar table) */
        if (!janet_checktype(peg, JANET_TUPLE)) {
            while (which_grammar->proto)
                which_grammar = which_grammar->proto;
        }
        janet_table_put(which_grammar, peg, janet_wrap_number(rule));
    }

    switch (janet_type(peg)) {
        default:
            peg_panic(b, "unexpected peg source");
            return 0;
        case JANET_NUMBER: {
            int32_t n = peg_getinteger(b, peg);
            Reserve r = reserve(b, 2);
            if (n < 0) {
                emit_1(r, RULE_NOTNCHAR, -n);
            } else {
                emit_1(r, RULE_NCHAR, n);
            }
            break;
        }
        case JANET_STRING: {
            const uint8_t *str = janet_unwrap_string(peg);
            int32_t len = janet_string_length(str);
            emit_bytes(b, RULE_LITERAL, len, str);
            break;
        }
        case JANET_STRUCT: {
            /* Build grammar table */
            const JanetKV *st = janet_unwrap_struct(peg);
            JanetTable *new_grammar = janet_table(2 * janet_struct_capacity(st));
            for (int32_t i = 0; i < janet_struct_capacity(st); i++) {
                if (janet_checktype(st[i].key, JANET_KEYWORD)) {
                    janet_table_put(new_grammar, st[i].key, st[i].value);
                }
            }
            new_grammar->proto = grammar;
            b->grammar = grammar = new_grammar;
            /* Run the main rule */
            Janet main_rule = janet_table_rawget(grammar, janet_ckeywordv("main"));
            if (janet_checktype(main_rule, JANET_NIL))
                peg_panic(b, "grammar requires :main rule");
            rule = peg_compile1(b, main_rule);
            break;
        }
        case JANET_TUPLE: {
            const Janet *tup = janet_unwrap_tuple(peg);
            int32_t len = janet_tuple_length(tup);
            if (len == 0) peg_panic(b, "tuple in grammar must have non-zero length");
            if (janet_checkint(tup[0])) {
                int32_t n = janet_unwrap_integer(tup[0]);
                if (n < 0) {
                    peg_panicf(b, "expected non-negative integer, got %d", n);
                }
                spec_repeat(b, len, tup);
                break;
            }
            if (!janet_checktype(tup[0], JANET_SYMBOL))
                peg_panicf(b, "expected grammar command, found %v", tup[0]);
            const uint8_t *sym = janet_unwrap_symbol(tup[0]);
            const SpecialPair *sp = janet_strbinsearch(
                                        &peg_specials,
                                        sizeof(peg_specials) / sizeof(SpecialPair),
                                        sizeof(SpecialPair),
                                        sym);
            if (sp) {
                sp->special(b, len - 1, tup + 1);
            } else {
                peg_panicf(b, "unknown special %S", sym);
            }
            break;
        }
    }

    /* Increase depth again */
    b->depth++;
    b->form = old_form;
    b->grammar = old_grammar;
    return rule;
}

/*
 * Post-Compilation
 */

static int peg_mark(void *p, size_t size) {
    (void) size;
    JanetPeg *peg = (JanetPeg *)p;
    if (NULL != peg->constants)
        for (uint32_t i = 0; i < peg->num_constants; i++)
            janet_mark(peg->constants[i]);
    return 0;
}

static void peg_marshal(void *p, JanetMarshalContext *ctx) {
    JanetPeg *peg = (JanetPeg *)p;
    janet_marshal_size(ctx, peg->bytecode_len);
    janet_marshal_int(ctx, (int32_t)peg->num_constants);
    janet_marshal_abstract(ctx, p);
    for (size_t i = 0; i < peg->bytecode_len; i++)
        janet_marshal_int(ctx, (int32_t) peg->bytecode[i]);
    for (uint32_t j = 0; j < peg->num_constants; j++)
        janet_marshal_janet(ctx, peg->constants[j]);
}

/* Used to ensure that if we place several arrays in one memory chunk, each
 * array will be correctly aligned */
static size_t size_padded(size_t offset, size_t size) {
    size_t x = size + offset - 1;
    return x - (x % size);
}

static void *peg_unmarshal(JanetMarshalContext *ctx) {
    size_t bytecode_len = janet_unmarshal_size(ctx);
    uint32_t num_constants = (uint32_t) janet_unmarshal_int(ctx);

    /* Calculate offsets. Should match those in make_peg */
    size_t bytecode_start = size_padded(sizeof(JanetPeg), sizeof(uint32_t));
    size_t bytecode_size = bytecode_len * sizeof(uint32_t);
    size_t constants_start = size_padded(bytecode_start + bytecode_size, sizeof(Janet));
    size_t total_size = constants_start + sizeof(Janet) * (size_t) num_constants;

    /* DOS prevention? I.E. we could read bytecode and constants before
     * hand so we don't allocated a ton of memory on bad, short input */

    /* Allocate PEG */
    char *mem = janet_unmarshal_abstract(ctx, total_size);
    JanetPeg *peg = (JanetPeg *)mem;
    uint32_t *bytecode = (uint32_t *)(mem + bytecode_start);
    Janet *constants = (Janet *)(mem + constants_start);
    peg->bytecode = NULL;
    peg->constants = NULL;
    peg->bytecode_len = bytecode_len;
    peg->num_constants = num_constants;

    for (size_t i = 0; i < peg->bytecode_len; i++)
        bytecode[i] = (uint32_t) janet_unmarshal_int(ctx);
    for (uint32_t j = 0; j < peg->num_constants; j++)
        constants[j] = janet_unmarshal_janet(ctx);

    /* After here, no panics except for the bad: label. */

    /* Keep track at each index if an instruction was
     * reference (0x01) or is in a main bytecode position
     * (0x02). This lets us do a linear scan and not
     * need to a depth first traversal. It is stricter
     * than a dfs by not allowing certain kinds of unused
     * bytecode. */
    uint32_t blen = (int32_t) peg->bytecode_len;
    uint32_t clen = peg->num_constants;
    uint8_t *op_flags = calloc(1, blen);
    if (NULL == op_flags) {
        JANET_OUT_OF_MEMORY;
    }

    /* verify peg bytecode */
    uint32_t i = 0;
    while (i < blen) {
        uint32_t instr = bytecode[i];
        uint32_t *rule = bytecode + i;
        op_flags[i] |= 0x02;
        switch (instr & 0x1F) {
            case RULE_LITERAL:
                i += 2 + ((rule[1] + 3) >> 2);
                break;
            case RULE_NCHAR:
            case RULE_NOTNCHAR:
            case RULE_RANGE:
            case RULE_POSITION:
            case RULE_BACKMATCH:
                /* [1 word] */
                i += 2;
                break;
            case RULE_SET:
                /* [8 words] */
                i += 9;
                break;
            case RULE_LOOK:
                /* [offset, rule] */
                if (rule[2] >= blen) goto bad;
                op_flags[rule[2]] |= 0x1;
                i += 3;
                break;
            case RULE_CHOICE:
            case RULE_SEQUENCE:
                /* [len, rules...] */
            {
                uint32_t len = rule[1];
                for (uint32_t j = 0; j < len; j++) {
                    if (rule[2 + j] >= blen) goto bad;
                    op_flags[rule[2 + j]] |= 0x1;
                }
                i += 2 + len;
            }
            break;
            case RULE_IF:
            case RULE_IFNOT:
            case RULE_LENPREFIX:
                /* [rule_a, rule_b (b if not a)] */
                if (rule[1] >= blen) goto bad;
                if (rule[2] >= blen) goto bad;
                op_flags[rule[1]] |= 0x01;
                op_flags[rule[2]] |= 0x01;
                i += 3;
                break;
            case RULE_BETWEEN:
                /* [lo, hi, rule] */
                if (rule[3] >= blen) goto bad;
                op_flags[rule[3]] |= 0x01;
                i += 4;
                break;
            case RULE_ARGUMENT:
            case RULE_GETTAG:
                /* [searchtag, tag] */
                i += 3;
                break;
            case RULE_CONSTANT:
                /* [constant, tag] */
                if (rule[1] >= clen) goto bad;
                i += 3;
                break;
            case RULE_ACCUMULATE:
            case RULE_GROUP:
            case RULE_CAPTURE:
                /* [rule, tag] */
                if (rule[1] >= blen) goto bad;
                op_flags[rule[1]] |= 0x01;
                i += 3;
                break;
            case RULE_REPLACE:
            case RULE_MATCHTIME:
                /* [rule, constant, tag] */
                if (rule[1] >= blen) goto bad;
                if (rule[2] >= clen) goto bad;
                op_flags[rule[1]] |= 0x01;
                i += 4;
                break;
            case RULE_ERROR:
            case RULE_DROP:
            case RULE_NOT:
            case RULE_TO:
            case RULE_THRU:
                /* [rule] */
                if (rule[1] >= blen) goto bad;
                op_flags[rule[1]] |= 0x01;
                i += 2;
                break;
            default:
                goto bad;
        }
    }

    /* last instruction cannot overflow */
    if (i != blen) goto bad;

    /* Make sure all referenced instructions are actually
     * in instruction positions. */
    for (i = 0; i < blen; i++)
        if (op_flags[i] == 0x01) goto bad;

    /* Good return */
    peg->bytecode = bytecode;
    peg->constants = constants;
    free(op_flags);
    return peg;

bad:
    free(op_flags);
    janet_panic("invalid peg bytecode");
}

static int cfun_peg_getter(JanetAbstract a, Janet key, Janet *out);

const JanetAbstractType janet_peg_type = {
    "core/peg",
    NULL,
    peg_mark,
    cfun_peg_getter,
    NULL,
    peg_marshal,
    peg_unmarshal,
    JANET_ATEND_UNMARSHAL
};

/* Convert Builder to JanetPeg (Janet Abstract Value) */
static JanetPeg *make_peg(Builder *b) {
    size_t bytecode_start = size_padded(sizeof(JanetPeg), sizeof(uint32_t));
    size_t bytecode_size = janet_v_count(b->bytecode) * sizeof(uint32_t);
    size_t constants_start = size_padded(bytecode_start + bytecode_size, sizeof(Janet));
    size_t constants_size = janet_v_count(b->constants) * sizeof(Janet);
    size_t total_size = constants_start + constants_size;
    char *mem = janet_abstract(&janet_peg_type, total_size);
    JanetPeg *peg = (JanetPeg *)mem;
    peg->bytecode = (uint32_t *)(mem + bytecode_start);
    peg->constants = (Janet *)(mem + constants_start);
    peg->num_constants = janet_v_count(b->constants);
    safe_memcpy(peg->bytecode, b->bytecode, bytecode_size);
    safe_memcpy(peg->constants, b->constants, constants_size);
    peg->bytecode_len = janet_v_count(b->bytecode);
    return peg;
}

/* Compiler entry point */
static JanetPeg *compile_peg(Janet x) {
    Builder builder;
    builder.grammar = janet_table(0);
    builder.default_grammar = janet_get_core_table("default-peg-grammar");
    builder.tags = janet_table(0);
    builder.constants = NULL;
    builder.bytecode = NULL;
    builder.nexttag = 1;
    builder.form = x;
    builder.depth = JANET_RECURSION_GUARD;
    peg_compile1(&builder, x);
    JanetPeg *peg = make_peg(&builder);
    builder_cleanup(&builder);
    return peg;
}

/*
 * C Functions
 */

static Janet cfun_peg_compile(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    JanetPeg *peg = compile_peg(argv[0]);
    return janet_wrap_abstract(peg);
}

static Janet cfun_peg_match(int32_t argc, Janet *argv) {
    janet_arity(argc, 2, -1);
    JanetPeg *peg;
    if (janet_checktype(argv[0], JANET_ABSTRACT) &&
            janet_abstract_type(janet_unwrap_abstract(argv[0])) == &janet_peg_type) {
        peg = janet_unwrap_abstract(argv[0]);
    } else {
        peg = compile_peg(argv[0]);
    }
    JanetByteView bytes = janet_getbytes(argv, 1);
    int32_t start;
    PegState s;
    if (argc > 2) {
        start = janet_gethalfrange(argv, 2, bytes.len, "offset");
        s.extrac = argc - 3;
        s.extrav = janet_tuple_n(argv + 3, argc - 3);
    } else {
        start = 0;
        s.extrac = 0;
        s.extrav = NULL;
    }
    s.mode = PEG_MODE_NORMAL;
    s.text_start = bytes.bytes;
    s.text_end = bytes.bytes + bytes.len;
    s.depth = JANET_RECURSION_GUARD;
    s.captures = janet_array(0);
    s.scratch = janet_buffer(10);
    s.tags = janet_buffer(10);
    s.constants = peg->constants;
    s.bytecode = peg->bytecode;
    const uint8_t *result = peg_rule(&s, s.bytecode, bytes.bytes + start);
    return result ? janet_wrap_array(s.captures) : janet_wrap_nil();
}

static int cfun_peg_getter(JanetAbstract a, Janet key, Janet *out) {
    (void) a;
    if (janet_keyeq(key, "match")) {
        *out = janet_wrap_cfunction(cfun_peg_match);
        return 1;
    }
    return 0;
}

static const JanetReg peg_cfuns[] = {
    {
        "peg/compile", cfun_peg_compile,
        JDOC("(peg/compile peg)\n\n"
             "Compiles a peg source data structure into a <core/peg>. This will speed up matching "
             "if the same peg will be used multiple times.")
    },
    {
        "peg/match", cfun_peg_match,
        JDOC("(peg/match peg text &opt start & args)\n\n"
             "Match a Parsing Expression Grammar to a byte string and return an array of captured values. "
             "Returns nil if text does not match the language defined by peg. The syntax of PEGs is documented on the Janet website.")
    },
    {NULL, NULL, NULL}
};

/* Load the peg module */
void janet_lib_peg(JanetTable *env) {
    janet_core_cfuns(env, NULL, peg_cfuns);
    janet_register_abstract_type(&janet_peg_type);
}

#endif /* ifdef JANET_PEG */


/* src/core/pp.c */
#line 0 "src/core/pp.c"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "util.h"
#include "state.h"
#include <math.h>
#endif

#include <string.h>
#include <ctype.h>

/* Implements a pretty printer for Janet. The pretty printer
 * is simple and not that flexible, but fast. */

/* Temporary buffer size */
#define BUFSIZE 64

static void number_to_string_b(JanetBuffer *buffer, double x) {
    janet_buffer_ensure(buffer, buffer->count + BUFSIZE, 2);
    /* Use int32_t range for valid integers because that is the
     * range most integer-expecting functions in the C api use. */
    const char *fmt = (x == floor(x) &&
                       x <= ((double) INT32_MAX) &&
                       x >= ((double) INT32_MIN)) ? "%.0f" : "%g";
    int count = snprintf((char *) buffer->data + buffer->count, BUFSIZE, fmt, x);
    buffer->count += count;
}

/* expects non positive x */
static int count_dig10(int32_t x) {
    int result = 1;
    for (;;) {
        if (x > -10) return result;
        if (x > -100) return result + 1;
        if (x > -1000) return result + 2;
        if (x > -10000) return result + 3;
        x /= 10000;
        result += 4;
    }
}

static void integer_to_string_b(JanetBuffer *buffer, int32_t x) {
    janet_buffer_extra(buffer, BUFSIZE);
    uint8_t *buf = buffer->data + buffer->count;
    int32_t neg = 0;
    int32_t len = 0;
    if (x == 0) {
        buf[0] = '0';
        buffer->count++;
        return;
    }
    if (x > 0) {
        x = -x;
    } else {
        neg = 1;
        *buf++ = '-';
    }
    len = count_dig10(x);
    buf += len;
    while (x) {
        uint8_t digit = (uint8_t) - (x % 10);
        *(--buf) = '0' + digit;
        x /= 10;
    }
    buffer->count += len + neg;
}

#define HEX(i) (((uint8_t *) janet_base64)[(i)])

/* Returns a string description for a pointer. Truncates
 * title to 32 characters */
static void string_description_b(JanetBuffer *buffer, const char *title, void *pointer) {
    janet_buffer_ensure(buffer, buffer->count + BUFSIZE, 2);
    uint8_t *c = buffer->data + buffer->count;
    int32_t i;
    union {
        uint8_t bytes[sizeof(void *)];
        void *p;
    } pbuf;

    pbuf.p = pointer;
    *c++ = '<';
    /* Maximum of 32 bytes for abstract type name */
    for (i = 0; title[i] && i < 32; ++i)
        *c++ = ((uint8_t *)title) [i];
    *c++ = ' ';
    *c++ = '0';
    *c++ = 'x';
#if defined(JANET_64)
#define POINTSIZE 6
#else
#define POINTSIZE (sizeof(void *))
#endif
    for (i = POINTSIZE; i > 0; --i) {
        uint8_t byte = pbuf.bytes[i - 1];
        *c++ = HEX(byte >> 4);
        *c++ = HEX(byte & 0xF);
    }
    *c++ = '>';
    buffer->count = (int32_t)(c - buffer->data);
#undef POINTSIZE
}

#undef HEX
#undef BUFSIZE

static void janet_escape_string_impl(JanetBuffer *buffer, const uint8_t *str, int32_t len) {
    janet_buffer_push_u8(buffer, '"');
    for (int32_t i = 0; i < len; ++i) {
        uint8_t c = str[i];
        switch (c) {
            case '"':
                janet_buffer_push_bytes(buffer, (const uint8_t *)"\\\"", 2);
                break;
            case '\n':
                janet_buffer_push_bytes(buffer, (const uint8_t *)"\\n", 2);
                break;
            case '\r':
                janet_buffer_push_bytes(buffer, (const uint8_t *)"\\r", 2);
                break;
            case '\0':
                janet_buffer_push_bytes(buffer, (const uint8_t *)"\\0", 2);
                break;
            case '\f':
                janet_buffer_push_bytes(buffer, (const uint8_t *)"\\f", 2);
                break;
            case '\v':
                janet_buffer_push_bytes(buffer, (const uint8_t *)"\\v", 2);
                break;
            case 27:
                janet_buffer_push_bytes(buffer, (const uint8_t *)"\\e", 2);
                break;
            case '\\':
                janet_buffer_push_bytes(buffer, (const uint8_t *)"\\\\", 2);
                break;
            case '\t':
                janet_buffer_push_bytes(buffer, (const uint8_t *)"\\t", 2);
                break;
            default:
                if (c < 32 || c > 126) {
                    uint8_t buf[4];
                    buf[0] = '\\';
                    buf[1] = 'x';
                    buf[2] = janet_base64[(c >> 4) & 0xF];
                    buf[3] = janet_base64[c & 0xF];
                    janet_buffer_push_bytes(buffer, buf, 4);
                } else {
                    janet_buffer_push_u8(buffer, c);
                }
                break;
        }
    }
    janet_buffer_push_u8(buffer, '"');
}

static void janet_escape_string_b(JanetBuffer *buffer, const uint8_t *str) {
    janet_escape_string_impl(buffer, str, janet_string_length(str));
}

static void janet_escape_buffer_b(JanetBuffer *buffer, JanetBuffer *bx) {
    if (bx == buffer) {
        /* Ensures buffer won't resize while escaping */
        janet_buffer_ensure(bx, bx->count + 5 * bx->count + 3, 1);
    }
    janet_buffer_push_u8(buffer, '@');
    janet_escape_string_impl(buffer, bx->data, bx->count);
}

void janet_to_string_b(JanetBuffer *buffer, Janet x) {
    switch (janet_type(x)) {
        case JANET_NIL:
            janet_buffer_push_cstring(buffer, "nil");
            break;
        case JANET_BOOLEAN:
            janet_buffer_push_cstring(buffer,
                                      janet_unwrap_boolean(x) ? "true" : "false");
            break;
        case JANET_NUMBER:
            number_to_string_b(buffer, janet_unwrap_number(x));
            break;
        case JANET_STRING:
        case JANET_SYMBOL:
        case JANET_KEYWORD:
            janet_buffer_push_bytes(buffer,
                                    janet_unwrap_string(x),
                                    janet_string_length(janet_unwrap_string(x)));
            break;
        case JANET_BUFFER: {
            JanetBuffer *to = janet_unwrap_buffer(x);
            /* Prevent resizing buffer while appending */
            if (buffer == to) janet_buffer_extra(buffer, to->count);
            janet_buffer_push_bytes(buffer, to->data, to->count);
            break;
        }
        case JANET_ABSTRACT: {
            JanetAbstract p = janet_unwrap_abstract(x);
            const JanetAbstractType *t = janet_abstract_type(p);
            if (t->tostring != NULL) {
                t->tostring(p, buffer);
            } else {
                string_description_b(buffer, t->name, p);
            }
        }
        return;
        case JANET_CFUNCTION: {
            Janet check = janet_table_get(janet_vm_registry, x);
            if (janet_checktype(check, JANET_SYMBOL)) {
                janet_buffer_push_cstring(buffer, "<cfunction ");
                janet_buffer_push_bytes(buffer,
                                        janet_unwrap_symbol(check),
                                        janet_string_length(janet_unwrap_symbol(check)));
                janet_buffer_push_u8(buffer, '>');
                break;
            }
            goto fallthrough;
        }
        case JANET_FUNCTION: {
            JanetFunction *fun = janet_unwrap_function(x);
            JanetFuncDef *def = fun->def;
            if (def->name) {
                const uint8_t *n = def->name;
                janet_buffer_push_cstring(buffer, "<function ");
                janet_buffer_push_bytes(buffer, n, janet_string_length(n));
                janet_buffer_push_u8(buffer, '>');
                break;
            }
            goto fallthrough;
        }
    fallthrough:
        default:
            string_description_b(buffer, janet_type_names[janet_type(x)], janet_unwrap_pointer(x));
            break;
    }
}

/* See parse.c for full table */

static const uint32_t pp_symchars[8] = {
    0x00000000, 0xf7ffec72, 0xc7ffffff, 0x07fffffe,
    0x00000000, 0x00000000, 0x00000000, 0x00000000
};

static int pp_is_symbol_char(uint8_t c) {
    return pp_symchars[c >> 5] & ((uint32_t)1 << (c & 0x1F));
}

/* Check if a symbol or keyword contains no symbol characters */
static int contains_bad_chars(const uint8_t *sym, int issym) {
    int32_t len = janet_string_length(sym);
    if (len && issym && sym[0] >= '0' && sym[0] <= '9') return 1;
    for (int32_t i = 0; i < len; i++) {
        if (!pp_is_symbol_char(sym[i])) return 1;
    }
    return 0;
}

void janet_description_b(JanetBuffer *buffer, Janet x) {
    switch (janet_type(x)) {
        default:
            break;
        case JANET_KEYWORD:
            janet_buffer_push_u8(buffer, ':');
            break;
        case JANET_STRING:
            janet_escape_string_b(buffer, janet_unwrap_string(x));
            return;
        case JANET_BUFFER: {
            JanetBuffer *b = janet_unwrap_buffer(x);
            janet_escape_buffer_b(buffer, b);
            return;
        }
        case JANET_ABSTRACT: {
            JanetAbstract p = janet_unwrap_abstract(x);
            const JanetAbstractType *t = janet_abstract_type(p);
            if (t->tostring != NULL) {
                janet_buffer_push_cstring(buffer, "<");
                janet_buffer_push_cstring(buffer, t->name);
                janet_buffer_push_cstring(buffer, " ");
                t->tostring(p, buffer);
                janet_buffer_push_cstring(buffer, ">");
            } else {
                string_description_b(buffer, t->name, p);
            }
            return;
        }
    }
    janet_to_string_b(buffer, x);
}

const uint8_t *janet_description(Janet x) {
    JanetBuffer b;
    janet_buffer_init(&b, 10);
    janet_description_b(&b, x);
    const uint8_t *ret = janet_string(b.data, b.count);
    janet_buffer_deinit(&b);
    return ret;
}

/* Convert any value to a janet string. Similar to description, but
 * strings, symbols, and buffers will return their content. */
const uint8_t *janet_to_string(Janet x) {
    switch (janet_type(x)) {
        default: {
            JanetBuffer b;
            janet_buffer_init(&b, 10);
            janet_to_string_b(&b, x);
            const uint8_t *ret = janet_string(b.data, b.count);
            janet_buffer_deinit(&b);
            return ret;
        }
        case JANET_BUFFER:
            return janet_string(janet_unwrap_buffer(x)->data, janet_unwrap_buffer(x)->count);
        case JANET_STRING:
        case JANET_SYMBOL:
        case JANET_KEYWORD:
            return janet_unwrap_string(x);
    }
}

/* Hold state for pretty printer. */
struct pretty {
    JanetBuffer *buffer;
    int depth;
    int indent;
    int flags;
    int32_t bufstartlen;
    JanetTable seen;
};

/* Print jdn format */
static int print_jdn_one(struct pretty *S, Janet x, int depth) {
    if (depth == 0) return 1;
    switch (janet_type(x)) {
        case JANET_NIL:
        case JANET_NUMBER:
        case JANET_BOOLEAN:
        case JANET_BUFFER:
        case JANET_STRING:
            janet_description_b(S->buffer, x);
            break;
        case JANET_SYMBOL:
        case JANET_KEYWORD:
            if (contains_bad_chars(janet_unwrap_keyword(x), janet_type(x) == JANET_SYMBOL)) return 1;
            janet_description_b(S->buffer, x);
            break;
        case JANET_TUPLE: {
            JanetTuple t = janet_unwrap_tuple(x);
            int isb = janet_tuple_flag(t) & JANET_TUPLE_FLAG_BRACKETCTOR;
            janet_buffer_push_u8(S->buffer, isb ? '[' : '(');
            for (int32_t i = 0; i < janet_tuple_length(t); i++) {
                if (i) janet_buffer_push_u8(S->buffer, ' ');
                if (print_jdn_one(S, t[i], depth - 1)) return 1;
            }
            janet_buffer_push_u8(S->buffer, isb ? ']' : ')');
        }
        break;
        case JANET_ARRAY: {
            janet_table_put(&S->seen, x, janet_wrap_true());
            JanetArray *a = janet_unwrap_array(x);
            janet_buffer_push_cstring(S->buffer, "@[");
            for (int32_t i = 0; i < a->count; i++) {
                if (i) janet_buffer_push_u8(S->buffer, ' ');
                if (print_jdn_one(S, a->data[i], depth - 1)) return 1;
            }
            janet_buffer_push_u8(S->buffer, ']');
        }
        break;
        case JANET_TABLE: {
            janet_table_put(&S->seen, x, janet_wrap_true());
            JanetTable *tab = janet_unwrap_table(x);
            janet_buffer_push_cstring(S->buffer, "@{");
            int isFirst = 1;
            for (int32_t i = 0; i < tab->capacity; i++) {
                const JanetKV *kv = tab->data + i;
                if (janet_checktype(kv->key, JANET_NIL)) continue;
                if (!isFirst) janet_buffer_push_u8(S->buffer, ' ');
                isFirst = 0;
                if (print_jdn_one(S, kv->key, depth - 1)) return 1;
                janet_buffer_push_u8(S->buffer, ' ');
                if (print_jdn_one(S, kv->value, depth - 1)) return 1;
            }
            janet_buffer_push_u8(S->buffer, '}');
        }
        break;
        case JANET_STRUCT: {
            JanetStruct st = janet_unwrap_struct(x);
            janet_buffer_push_u8(S->buffer, '{');
            int isFirst = 1;
            for (int32_t i = 0; i < janet_struct_capacity(st); i++) {
                const JanetKV *kv = st + i;
                if (janet_checktype(kv->key, JANET_NIL)) continue;
                if (!isFirst) janet_buffer_push_u8(S->buffer, ' ');
                isFirst = 0;
                if (print_jdn_one(S, kv->key, depth - 1)) return 1;
                janet_buffer_push_u8(S->buffer, ' ');
                if (print_jdn_one(S, kv->value, depth - 1)) return 1;
            }
            janet_buffer_push_u8(S->buffer, '}');
        }
        break;
        default:
            return 1;
    }
    return 0;
}

static void print_newline(struct pretty *S, int just_a_space) {
    int i;
    if (just_a_space || (S->flags & JANET_PRETTY_ONELINE)) {
        janet_buffer_push_u8(S->buffer, ' ');
        return;
    }
    janet_buffer_push_u8(S->buffer, '\n');
    for (i = 0; i < S->indent; i++) {
        janet_buffer_push_u8(S->buffer, ' ');
    }
}

/* Color coding for types */
static const char janet_cycle_color[] = "\x1B[36m";
static const char janet_class_color[] = "\x1B[34m";
static const char *janet_pretty_colors[] = {
    "\x1B[32m",
    "\x1B[36m",
    "\x1B[36m",
    "\x1B[36m",
    "\x1B[35m",
    "\x1B[34m",
    "\x1B[33m",
    "\x1B[36m",
    "\x1B[36m",
    "\x1B[36m",
    "\x1B[36m"
    "\x1B[35m",
    "\x1B[36m",
    "\x1B[36m",
    "\x1B[36m",
    "\x1B[36m"
};

#define JANET_PRETTY_DICT_ONELINE 4
#define JANET_PRETTY_IND_ONELINE 10
#define JANET_PRETTY_DICT_LIMIT 30
#define JANET_PRETTY_ARRAY_LIMIT 160

/* Helper for pretty printing */
static void janet_pretty_one(struct pretty *S, Janet x, int is_dict_value) {
    /* Add to seen */
    switch (janet_type(x)) {
        case JANET_NIL:
        case JANET_NUMBER:
        case JANET_SYMBOL:
        case JANET_BOOLEAN:
            break;
        default: {
            Janet seenid = janet_table_get(&S->seen, x);
            if (janet_checktype(seenid, JANET_NUMBER)) {
                if (S->flags & JANET_PRETTY_COLOR) {
                    janet_buffer_push_cstring(S->buffer, janet_cycle_color);
                }
                janet_buffer_push_cstring(S->buffer, "<cycle ");
                integer_to_string_b(S->buffer, janet_unwrap_integer(seenid));
                janet_buffer_push_u8(S->buffer, '>');
                if (S->flags & JANET_PRETTY_COLOR) {
                    janet_buffer_push_cstring(S->buffer, "\x1B[0m");
                }
                return;
            } else {
                janet_table_put(&S->seen, x, janet_wrap_integer(S->seen.count));
                break;
            }
        }
    }

    switch (janet_type(x)) {
        default: {
            const char *color = janet_pretty_colors[janet_type(x)];
            if (color && (S->flags & JANET_PRETTY_COLOR)) {
                janet_buffer_push_cstring(S->buffer, color);
            }
            if (janet_checktype(x, JANET_BUFFER) && janet_unwrap_buffer(x) == S->buffer) {
                janet_buffer_ensure(S->buffer, S->buffer->count + S->bufstartlen * 4 + 3, 1);
                janet_buffer_push_u8(S->buffer, '@');
                janet_escape_string_impl(S->buffer, S->buffer->data, S->bufstartlen);
            } else {
                janet_description_b(S->buffer, x);
            }
            if (color && (S->flags & JANET_PRETTY_COLOR)) {
                janet_buffer_push_cstring(S->buffer, "\x1B[0m");
            }
            break;
        }
        case JANET_ARRAY:
        case JANET_TUPLE: {
            int32_t i = 0, len = 0;
            const Janet *arr = NULL;
            int isarray = janet_checktype(x, JANET_ARRAY);
            janet_indexed_view(x, &arr, &len);
            int hasbrackets = !isarray && (janet_tuple_flag(arr) & JANET_TUPLE_FLAG_BRACKETCTOR);
            const char *startstr = isarray ? "@[" : hasbrackets ? "[" : "(";
            const char endchar = isarray ? ']' : hasbrackets ? ']' : ')';
            janet_buffer_push_cstring(S->buffer, startstr);
            S->depth--;
            S->indent += 2;
            if (S->depth == 0) {
                janet_buffer_push_cstring(S->buffer, "...");
            } else {
                if (!isarray && !(S->flags & JANET_PRETTY_ONELINE) && len >= JANET_PRETTY_IND_ONELINE)
                    janet_buffer_push_u8(S->buffer, ' ');
                if (is_dict_value && len >= JANET_PRETTY_IND_ONELINE) print_newline(S, 0);
                if (len > JANET_PRETTY_ARRAY_LIMIT && !(S->flags & JANET_PRETTY_NOTRUNC)) {
                    for (i = 0; i < 3; i++) {
                        if (i) print_newline(S, 0);
                        janet_pretty_one(S, arr[i], 0);
                    }
                    print_newline(S, 0);
                    janet_buffer_push_cstring(S->buffer, "...");
                    for (i = 0; i < 3; i++) {
                        print_newline(S, 0);
                        janet_pretty_one(S, arr[len - 3 + i], 0);
                    }
                } else {
                    for (i = 0; i < len; i++) {
                        if (i) print_newline(S, len < JANET_PRETTY_IND_ONELINE);
                        janet_pretty_one(S, arr[i], 0);
                    }
                }
            }
            S->indent -= 2;
            S->depth++;
            janet_buffer_push_u8(S->buffer, endchar);
            break;
        }
        case JANET_STRUCT:
        case JANET_TABLE: {
            int istable = janet_checktype(x, JANET_TABLE);
            janet_buffer_push_cstring(S->buffer, istable ? "@" : "{");

            /* For object-like tables, print class name */
            if (istable) {
                JanetTable *t = janet_unwrap_table(x);
                JanetTable *proto = t->proto;
                if (NULL != proto) {
                    Janet name = janet_table_get(proto, janet_ckeywordv("name"));
                    const uint8_t *n;
                    int32_t len;
                    if (janet_bytes_view(name, &n, &len)) {
                        if (S->flags & JANET_PRETTY_COLOR) {
                            janet_buffer_push_cstring(S->buffer, janet_class_color);
                        }
                        janet_buffer_push_bytes(S->buffer, n, len);
                        if (S->flags & JANET_PRETTY_COLOR) {
                            janet_buffer_push_cstring(S->buffer, "\x1B[0m");
                        }
                    }
                }
                janet_buffer_push_cstring(S->buffer, "{");
            }

            S->depth--;
            S->indent += 2;
            if (S->depth == 0) {
                janet_buffer_push_cstring(S->buffer, "...");
            } else {
                int32_t i = 0, len = 0, cap = 0;
                int first_kv_pair = 1;
                const JanetKV *kvs = NULL;
                int counter = 0;
                janet_dictionary_view(x, &kvs, &len, &cap);
                if (!istable && !(S->flags & JANET_PRETTY_ONELINE) && len >= JANET_PRETTY_DICT_ONELINE)
                    janet_buffer_push_u8(S->buffer, ' ');
                if (is_dict_value && len >= JANET_PRETTY_DICT_ONELINE) print_newline(S, 0);
                for (i = 0; i < cap; i++) {
                    if (!janet_checktype(kvs[i].key, JANET_NIL)) {
                        if (counter == JANET_PRETTY_DICT_LIMIT && !(S->flags & JANET_PRETTY_NOTRUNC)) {
                            print_newline(S, 0);
                            janet_buffer_push_cstring(S->buffer, "...");
                            break;
                        }
                        if (first_kv_pair) {
                            first_kv_pair = 0;
                        } else {
                            print_newline(S, len < JANET_PRETTY_DICT_ONELINE);
                        }
                        janet_pretty_one(S, kvs[i].key, 0);
                        janet_buffer_push_u8(S->buffer, ' ');
                        janet_pretty_one(S, kvs[i].value, 1);
                        counter++;
                    }
                }
            }
            S->indent -= 2;
            S->depth++;
            janet_buffer_push_u8(S->buffer, '}');
            break;
        }
    }
    /* Remove from seen */
    janet_table_remove(&S->seen, x);
    return;
}

static JanetBuffer *janet_pretty_(JanetBuffer *buffer, int depth, int flags, Janet x, int32_t startlen) {
    struct pretty S;
    if (NULL == buffer) {
        buffer = janet_buffer(0);
    }
    S.buffer = buffer;
    S.depth = depth;
    S.indent = 0;
    S.flags = flags;
    S.bufstartlen = startlen;
    janet_table_init(&S.seen, 10);
    janet_pretty_one(&S, x, 0);
    janet_table_deinit(&S.seen);
    return S.buffer;
}

/* Helper for printing a janet value in a pretty form. Not meant to be used
 * for serialization or anything like that. */
JanetBuffer *janet_pretty(JanetBuffer *buffer, int depth, int flags, Janet x) {
    return janet_pretty_(buffer, depth, flags, x, buffer ? buffer->count : 0);
}

static JanetBuffer *janet_jdn_(JanetBuffer *buffer, int depth, Janet x, int32_t startlen) {
    struct pretty S;
    if (NULL == buffer) {
        buffer = janet_buffer(0);
    }
    S.buffer = buffer;
    S.depth = depth;
    S.indent = 0;
    S.flags = 0;
    S.bufstartlen = startlen;
    janet_table_init(&S.seen, 10);
    int res = print_jdn_one(&S, x, depth);
    janet_table_deinit(&S.seen);
    if (res) {
        janet_panic("could not print to jdn format");
    }
    return S.buffer;
}

JanetBuffer *janet_jdn(JanetBuffer *buffer, int depth, Janet x) {
    return janet_jdn_(buffer, depth, x, buffer ? buffer->count : 0);
}

static const char *typestr(Janet x) {
    JanetType t = janet_type(x);
    return (t == JANET_ABSTRACT)
           ? janet_abstract_type(janet_unwrap_abstract(x))->name
           : janet_type_names[t];
}

static void pushtypes(JanetBuffer *buffer, int types) {
    int first = 1;
    int i = 0;
    while (types) {
        if (1 & types) {
            if (first) {
                first = 0;
            } else {
                janet_buffer_push_u8(buffer, '|');
            }
            janet_buffer_push_cstring(buffer, janet_type_names[i]);
        }
        i++;
        types >>= 1;
    }
}

/*
 * code adapted from lua/lstrlib.c http://lua.org
 */

#define MAX_ITEM  256
#define FMT_FLAGS "-+ #0"
#define MAX_FORMAT 32

static const char *scanformat(
    const char *strfrmt,
    char *form,
    char width[3],
    char precision[3]) {
    const char *p = strfrmt;
    memset(width, '\0', 3);
    memset(precision, '\0', 3);
    while (*p != '\0' && strchr(FMT_FLAGS, *p) != NULL)
        p++; /* skip flags */
    if ((size_t)(p - strfrmt) >= sizeof(FMT_FLAGS) / sizeof(char))
        janet_panic("invalid format (repeated flags)");
    if (isdigit((int)(*p)))
        width[0] = *p++; /* skip width */
    if (isdigit((int)(*p)))
        width[1] = *p++; /* (2 digits at most) */
    if (*p == '.') {
        p++;
        if (isdigit((int)(*p)))
            precision[0] = *p++; /* skip precision */
        if (isdigit((int)(*p)))
            precision[1] = *p++; /* (2 digits at most) */
    }
    if (isdigit((int)(*p)))
        janet_panic("invalid format (width or precision too long)");
    *(form++) = '%';
    memcpy(form, strfrmt, ((p - strfrmt) + 1) * sizeof(char));
    form += (p - strfrmt) + 1;
    *form = '\0';
    return p;
}

void janet_formatbv(JanetBuffer *b, const char *format, va_list args) {
    const char *format_end = format + strlen(format);
    const char *c = format;
    int32_t startlen = b->count;
    while (c < format_end) {
        if (*c != '%') {
            janet_buffer_push_u8(b, (uint8_t) *c++);
        } else if (*++c == '%') {
            janet_buffer_push_u8(b, (uint8_t) *c++);
        } else {
            char form[MAX_FORMAT], item[MAX_ITEM];
            char width[3], precision[3];
            int nb = 0; /* number of bytes in added item */
            c = scanformat(c, form, width, precision);
            switch (*c++) {
                case 'c': {
                    int n = va_arg(args, long);
                    nb = snprintf(item, MAX_ITEM, form, n);
                    break;
                }
                case 'd':
                case 'i':
                case 'o':
                case 'x':
                case 'X': {
                    int32_t n = va_arg(args, long);
                    nb = snprintf(item, MAX_ITEM, form, n);
                    break;
                }
                case 'a':
                case 'A':
                case 'e':
                case 'E':
                case 'f':
                case 'g':
                case 'G': {
                    double d = va_arg(args, double);
                    nb = snprintf(item, MAX_ITEM, form, d);
                    break;
                }
                case 's':
                case 'S': {
                    const char *str = va_arg(args, const char *);
                    int32_t len = c[-1] == 's'
                                  ? (int32_t) strlen(str)
                                  : janet_string_length((JanetString) str);
                    if (form[2] == '\0')
                        janet_buffer_push_bytes(b, (const uint8_t *) str, len);
                    else {
                        if (len != (int32_t) strlen((const char *) str))
                            janet_panic("string contains zeros");
                        if (!strchr(form, '.') && len >= 100) {
                            janet_panic("no precision and string is too long to be formatted");
                        } else {
                            nb = snprintf(item, MAX_ITEM, form, str);
                        }
                    }
                    break;
                }
                case 'V':
                    janet_to_string_b(b, va_arg(args, Janet));
                    break;
                case 'v':
                    janet_description_b(b, va_arg(args, Janet));
                    break;
                case 't':
                    janet_buffer_push_cstring(b, typestr(va_arg(args, Janet)));
                    break;
                case 'T': {
                    int types = va_arg(args, long);
                    pushtypes(b, types);
                    break;
                }
                case 'M':
                case 'm':
                case 'N':
                case 'n':
                case 'Q':
                case 'q':
                case 'P':
                case 'p': { /* janet pretty , precision = depth */
                    int depth = atoi(precision);
                    if (depth < 1) depth = 4;
                    char d = c[-1];
                    int has_color = (d == 'P') || (d == 'Q') || (d == 'M') || (d == 'N');
                    int has_oneline = (d == 'Q') || (d == 'q') || (d == 'N') || (d == 'n');
                    int has_notrunc = (d == 'M') || (d == 'm') || (d == 'N') || (d == 'n');
                    int flags = 0;
                    flags |= has_color ? JANET_PRETTY_COLOR : 0;
                    flags |= has_oneline ? JANET_PRETTY_ONELINE : 0;
                    flags |= has_notrunc ? JANET_PRETTY_NOTRUNC : 0;
                    janet_pretty_(b, depth, flags, va_arg(args, Janet), startlen);
                    break;
                }
                case 'j': {
                    int depth = atoi(precision);
                    if (depth < 1)
                        depth = JANET_RECURSION_GUARD;
                    janet_jdn_(b, depth, va_arg(args, Janet), startlen);
                    break;
                }
                default: {
                    /* also treat cases 'nLlh' */
                    janet_panicf("invalid conversion '%s' to 'format'",
                                 form);
                }
            }
            if (nb >= MAX_ITEM)
                janet_panicf("format buffer overflow", form);
            if (nb > 0)
                janet_buffer_push_bytes(b, (uint8_t *) item, nb);
        }

    }
}

/* Helper function for formatting strings. Useful for generating error messages and the like.
 * Similar to printf, but specialized for operating with janet. */
const uint8_t *janet_formatc(const char *format, ...) {
    va_list args;
    const uint8_t *ret;
    JanetBuffer buffer;
    int32_t len = 0;

    /* Calculate length, init buffer and args */
    while (format[len]) len++;
    janet_buffer_init(&buffer, len);
    va_start(args, format);

    /* Run format */
    janet_formatbv(&buffer, format, args);

    /* Iterate length */
    va_end(args);

    ret = janet_string(buffer.data, buffer.count);
    janet_buffer_deinit(&buffer);
    return ret;
}

JanetBuffer *janet_formatb(JanetBuffer *buffer, const char *format, ...) {
    va_list args;
    va_start(args, format);
    janet_formatbv(buffer, format, args);
    va_end(args);
    return buffer;
}

/* Shared implementation between string/format and
 * buffer/format */
void janet_buffer_format(
    JanetBuffer *b,
    const char *strfrmt,
    int32_t argstart,
    int32_t argc,
    Janet *argv) {
    size_t sfl = strlen(strfrmt);
    const char *strfrmt_end = strfrmt + sfl;
    int32_t arg = argstart;
    int32_t startlen = b->count;
    while (strfrmt < strfrmt_end) {
        if (*strfrmt != '%')
            janet_buffer_push_u8(b, (uint8_t) * strfrmt++);
        else if (*++strfrmt == '%')
            janet_buffer_push_u8(b, (uint8_t) * strfrmt++); /* %% */
        else { /* format item */
            char form[MAX_FORMAT], item[MAX_ITEM];
            char width[3], precision[3];
            int nb = 0; /* number of bytes in added item */
            if (++arg >= argc)
                janet_panic("not enough values for format");
            strfrmt = scanformat(strfrmt, form, width, precision);
            switch (*strfrmt++) {
                case 'c': {
                    nb = snprintf(item, MAX_ITEM, form, (int)
                                  janet_getinteger(argv, arg));
                    break;
                }
                case 'd':
                case 'i':
                case 'o':
                case 'x':
                case 'X': {
                    int32_t n = janet_getinteger(argv, arg);
                    nb = snprintf(item, MAX_ITEM, form, n);
                    break;
                }
                case 'a':
                case 'A':
                case 'e':
                case 'E':
                case 'f':
                case 'g':
                case 'G': {
                    double d = janet_getnumber(argv, arg);
                    nb = snprintf(item, MAX_ITEM, form, d);
                    break;
                }
                case 's': {
                    const uint8_t *s = janet_getstring(argv, arg);
                    int32_t l = janet_string_length(s);
                    if (form[2] == '\0')
                        janet_buffer_push_bytes(b, s, l);
                    else {
                        if (l != (int32_t) strlen((const char *) s))
                            janet_panic("string contains zeros");
                        if (!strchr(form, '.') && l >= 100) {
                            janet_panic("no precision and string is too long to be formatted");
                        } else {
                            nb = snprintf(item, MAX_ITEM, form, s);
                        }
                    }
                    break;
                }
                case 'V': {
                    janet_to_string_b(b, argv[arg]);
                    break;
                }
                case 'v': {
                    janet_description_b(b, argv[arg]);
                    break;
                }
                case 'M':
                case 'm':
                case 'N':
                case 'n':
                case 'Q':
                case 'q':
                case 'P':
                case 'p': { /* janet pretty , precision = depth */
                    int depth = atoi(precision);
                    if (depth < 1) depth = 4;
                    char d = strfrmt[-1];
                    int has_color = (d == 'P') || (d == 'Q') || (d == 'M') || (d == 'N');
                    int has_oneline = (d == 'Q') || (d == 'q') || (d == 'N') || (d == 'n');
                    int has_notrunc = (d == 'M') || (d == 'm') || (d == 'N') || (d == 'n');
                    int flags = 0;
                    flags |= has_color ? JANET_PRETTY_COLOR : 0;
                    flags |= has_oneline ? JANET_PRETTY_ONELINE : 0;
                    flags |= has_notrunc ? JANET_PRETTY_NOTRUNC : 0;
                    janet_pretty_(b, depth, flags, argv[arg], startlen);
                    break;
                }
                case 'j': {
                    int depth = atoi(precision);
                    if (depth < 1)
                        depth = JANET_RECURSION_GUARD;
                    janet_jdn_(b, depth, argv[arg], startlen);
                    break;
                }
                default: {
                    /* also treat cases 'nLlh' */
                    janet_panicf("invalid conversion '%s' to 'format'",
                                 form);
                }
            }
            if (nb >= MAX_ITEM)
                janet_panicf("format buffer overflow", form);
            if (nb > 0)
                janet_buffer_push_bytes(b, (uint8_t *) item, nb);
        }
    }
}


/* src/core/regalloc.c */
#line 0 "src/core/regalloc.c"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "regalloc.h"
#include "util.h"
#endif

void janetc_regalloc_init(JanetcRegisterAllocator *ra) {
    ra->chunks = NULL;
    ra->count = 0;
    ra->capacity = 0;
    ra->max = 0;
    ra->regtemps = 0;
}

void janetc_regalloc_deinit(JanetcRegisterAllocator *ra) {
    free(ra->chunks);
}

/* Fallbacks for when ctz not available */
#ifdef __GNUC__
#define count_trailing_zeros(x) __builtin_ctz(x)
#define count_trailing_ones(x) __builtin_ctz(~(x))
#else
static int32_t count_trailing_ones(uint32_t x) {
    int32_t ret = 0;
    while (x & 1) {
        ret++;
        x >>= 1;
    }
    return ret;
}
#define count_trailing_zeros(x) count_trailing_ones(~(x))
#endif

/* Get ith bit */
#define ithbit(I) ((uint32_t)1 << (I))

/* Get N bits */
#define nbits(N) (ithbit(N) - 1)

/* Copy a register allocator */
void janetc_regalloc_clone(JanetcRegisterAllocator *dest, JanetcRegisterAllocator *src) {
    size_t size;
    dest->count = src->count;
    dest->capacity = src->capacity;
    dest->max = src->max;
    size = sizeof(uint32_t) * (size_t) dest->capacity;
    dest->regtemps = 0;
    if (size) {
        dest->chunks = malloc(size);
        if (!dest->chunks) {
            JANET_OUT_OF_MEMORY;
        }
        memcpy(dest->chunks, src->chunks, size);
    } else {
        dest->chunks = NULL;
    }
}

/* Allocate one more chunk in chunks */
static void pushchunk(JanetcRegisterAllocator *ra) {
    /* Registers 240-255 are always allocated (reserved) */
    uint32_t chunk = ra->count == 7 ? 0xFFFF0000 : 0;
    int32_t newcount = ra->count + 1;
    if (newcount > ra->capacity) {
        int32_t newcapacity = newcount * 2;
        ra->chunks = realloc(ra->chunks, (size_t) newcapacity * sizeof(uint32_t));
        if (!ra->chunks) {
            JANET_OUT_OF_MEMORY;
        }
        ra->capacity = newcapacity;
    }
    ra->chunks[ra->count] = chunk;
    ra->count = newcount;
}

/* Reallocate a given register */
void janetc_regalloc_touch(JanetcRegisterAllocator *ra, int32_t reg) {
    int32_t chunk = reg >> 5;
    int32_t bit = reg & 0x1F;
    while (chunk >= ra->count) pushchunk(ra);
    ra->chunks[chunk] |= ithbit(bit);
}

/* Allocate one register. */
int32_t janetc_regalloc_1(JanetcRegisterAllocator *ra) {
    /* Get the nth bit in the array */
    int32_t bit, chunk, nchunks, reg;
    bit = -1;
    nchunks = ra->count;
    for (chunk = 0; chunk < nchunks; chunk++) {
        uint32_t block = ra->chunks[chunk];
        if (block == 0xFFFFFFFF) continue;
        bit = count_trailing_ones(block);
        break;
    }
    /* No reg found */
    if (bit == -1) {
        pushchunk(ra);
        bit = 0;
        chunk = nchunks;
    }
    /* set the bit at index bit in chunk */
    ra->chunks[chunk] |= ithbit(bit);
    reg = (chunk << 5) + bit;
    if (reg > ra->max)
        ra->max = reg;
    return reg;
}

/* Free a register. The register must have been previously allocated
 * without being freed. */
void janetc_regalloc_free(JanetcRegisterAllocator *ra, int32_t reg) {
    int32_t chunk = reg >> 5;
    int32_t bit = reg & 0x1F;
    ra->chunks[chunk] &= ~ithbit(bit);
}

/* Get a register that will fit in 8 bits (< 256). Do not call this
 * twice with the same value of nth without calling janetc_regalloc_free
 * on the returned register before. */
int32_t janetc_regalloc_temp(JanetcRegisterAllocator *ra, JanetcRegisterTemp nth) {
    int32_t oldmax = ra->max;
    if (ra->regtemps & (1 << nth)) {
        JANET_EXIT("regtemp already allocated");
    }
    ra->regtemps |= 1 << nth;
    int32_t reg = janetc_regalloc_1(ra);
    if (reg > 0xFF) {
        reg = 0xF0 + nth;
        ra->max = (reg > oldmax) ? reg : oldmax;
    }
    return reg;
}

void janetc_regalloc_freetemp(JanetcRegisterAllocator *ra, int32_t reg, JanetcRegisterTemp nth) {
    ra->regtemps &= ~(1 << nth);
    if (reg < 0xF0)
        janetc_regalloc_free(ra, reg);
}


/* src/core/run.c */
#line 0 "src/core/run.c"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "state.h"
#endif

/* Run a string */
int janet_dobytes(JanetTable *env, const uint8_t *bytes, int32_t len, const char *sourcePath, Janet *out) {
    JanetParser parser;
    int errflags = 0, done = 0;
    int32_t index = 0;
    Janet ret = janet_wrap_nil();
    const uint8_t *where = sourcePath ? janet_cstring(sourcePath) : NULL;

    if (where) janet_gcroot(janet_wrap_string(where));
    if (NULL == sourcePath) sourcePath = "<unknown>";
    janet_parser_init(&parser);

    /* While we haven't seen an error */
    while (!done) {

        /* Evaluate parsed values */
        while (janet_parser_has_more(&parser)) {
            Janet form = janet_parser_produce(&parser);
            JanetCompileResult cres = janet_compile(form, env, where);
            if (cres.status == JANET_COMPILE_OK) {
                JanetFunction *f = janet_thunk(cres.funcdef);
                JanetFiber *fiber = janet_fiber(f, 64, 0, NULL);
                fiber->env = env;
                JanetSignal status = janet_continue(fiber, janet_wrap_nil(), &ret);
                if (status != JANET_SIGNAL_OK && status != JANET_SIGNAL_EVENT) {
                    janet_stacktrace(fiber, ret);
                    errflags |= 0x01;
                    done = 1;
                }
            } else {
                if (cres.macrofiber) {
                    janet_eprintf("compile error in %s: ", sourcePath);
                    janet_stacktrace(cres.macrofiber, janet_wrap_string(cres.error));
                } else {
                    janet_eprintf("compile error in %s: %s\n", sourcePath,
                                  (const char *)cres.error);
                }
                errflags |= 0x02;
                done = 1;
            }
        }

        /* Dispatch based on parse state */
        switch (janet_parser_status(&parser)) {
            case JANET_PARSE_DEAD:
                done = 1;
                break;
            case JANET_PARSE_ERROR:
                errflags |= 0x04;
                janet_eprintf("parse error in %s: %s\n",
                              sourcePath, janet_parser_error(&parser));
                done = 1;
                break;
            case JANET_PARSE_PENDING:
                if (index == len) {
                    janet_parser_eof(&parser);
                } else {
                    janet_parser_consume(&parser, bytes[index++]);
                }
                break;
            case JANET_PARSE_ROOT:
                if (index >= len) {
                    janet_parser_eof(&parser);
                } else {
                    janet_parser_consume(&parser, bytes[index++]);
                }
                break;
        }

    }

    /* Clean up and return errors */
    janet_parser_deinit(&parser);
    if (where) janet_gcunroot(janet_wrap_string(where));
    if (out) *out = ret;
    return errflags;
}

int janet_dostring(JanetTable *env, const char *str, const char *sourcePath, Janet *out) {
    int32_t len = 0;
    while (str[len]) ++len;
    return janet_dobytes(env, (const uint8_t *)str, len, sourcePath, out);
}



/* src/core/specials.c */
#line 0 "src/core/specials.c"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "compile.h"
#include "util.h"
#include "vector.h"
#include "emit.h"
#endif

static JanetSlot janetc_quote(JanetFopts opts, int32_t argn, const Janet *argv) {
    if (argn != 1) {
        janetc_cerror(opts.compiler, "expected 1 argument");
        return janetc_cslot(janet_wrap_nil());
    }
    return janetc_cslot(argv[0]);
}

static JanetSlot janetc_splice(JanetFopts opts, int32_t argn, const Janet *argv) {
    JanetSlot ret;
    if (argn != 1) {
        janetc_cerror(opts.compiler, "expected 1 argument");
        return janetc_cslot(janet_wrap_nil());
    }
    ret = janetc_value(opts, argv[0]);
    ret.flags |= JANET_SLOT_SPLICED;
    return ret;
}

static JanetSlot qq_slots(JanetFopts opts, JanetSlot *slots, int makeop) {
    JanetSlot target = janetc_gettarget(opts);
    janetc_pushslots(opts.compiler, slots);
    janetc_freeslots(opts.compiler, slots);
    janetc_emit_s(opts.compiler, makeop, target, 1);
    return target;
}

static JanetSlot quasiquote(JanetFopts opts, Janet x, int depth, int level) {
    if (depth == 0) {
        janetc_cerror(opts.compiler, "quasiquote too deeply nested");
        return janetc_cslot(janet_wrap_nil());
    }
    JanetSlot *slots = NULL;
    switch (janet_type(x)) {
        default:
            return janetc_cslot(x);
        case JANET_TUPLE: {
            int32_t i, len;
            const Janet *tup = janet_unwrap_tuple(x);
            len = janet_tuple_length(tup);
            if (len > 1 && janet_checktype(tup[0], JANET_SYMBOL)) {
                const uint8_t *head = janet_unwrap_symbol(tup[0]);
                if (!janet_cstrcmp(head, "unquote")) {
                    if (level == 0) {
                        return janetc_value(janetc_fopts_default(opts.compiler), tup[1]);
                    } else {
                        level--;
                    }
                } else if (!janet_cstrcmp(head, "quasiquote")) {
                    level++;
                }
            }
            for (i = 0; i < len; i++)
                janet_v_push(slots, quasiquote(opts, tup[i], depth - 1, level));
            return qq_slots(opts, slots, (janet_tuple_flag(tup) & JANET_TUPLE_FLAG_BRACKETCTOR)
                            ? JOP_MAKE_BRACKET_TUPLE
                            : JOP_MAKE_TUPLE);
        }
        case JANET_ARRAY: {
            int32_t i;
            JanetArray *array = janet_unwrap_array(x);
            for (i = 0; i < array->count; i++)
                janet_v_push(slots, quasiquote(opts, array->data[i], depth - 1, level));
            return qq_slots(opts, slots, JOP_MAKE_ARRAY);
        }
        case JANET_TABLE:
        case JANET_STRUCT: {
            const JanetKV *kv = NULL, *kvs = NULL;
            int32_t len, cap = 0;
            janet_dictionary_view(x, &kvs, &len, &cap);
            while ((kv = janet_dictionary_next(kvs, cap, kv))) {
                JanetSlot key = quasiquote(opts, kv->key, depth - 1, level);
                JanetSlot value =  quasiquote(opts, kv->value, depth - 1, level);
                key.flags &= ~JANET_SLOT_SPLICED;
                value.flags &= ~JANET_SLOT_SPLICED;
                janet_v_push(slots, key);
                janet_v_push(slots, value);
            }
            return qq_slots(opts, slots,
                            janet_checktype(x, JANET_TABLE) ? JOP_MAKE_TABLE : JOP_MAKE_STRUCT);
        }
    }
}

static JanetSlot janetc_quasiquote(JanetFopts opts, int32_t argn, const Janet *argv) {
    if (argn != 1) {
        janetc_cerror(opts.compiler, "expected 1 argument");
        return janetc_cslot(janet_wrap_nil());
    }
    return quasiquote(opts, argv[0], JANET_RECURSION_GUARD, 0);
}

static JanetSlot janetc_unquote(JanetFopts opts, int32_t argn, const Janet *argv) {
    (void) argn;
    (void) argv;
    janetc_cerror(opts.compiler, "cannot use unquote here");
    return janetc_cslot(janet_wrap_nil());
}

/* Perform destructuring. Be careful to
 * keep the order registers are freed.
 * Returns if the slot 'right' can be freed. */
static int destructure(JanetCompiler *c,
                       Janet left,
                       JanetSlot right,
                       int (*leaf)(JanetCompiler *c,
                                   const uint8_t *sym,
                                   JanetSlot s,
                                   JanetTable *attr),
                       JanetTable *attr) {
    switch (janet_type(left)) {
        default:
            janetc_cerror(c, "unexpected type in destructuring");
            return 1;
        case JANET_SYMBOL:
            /* Leaf, assign right to left */
            return leaf(c, janet_unwrap_symbol(left), right, attr);
        case JANET_TUPLE:
        case JANET_ARRAY: {
            int32_t len = 0;
            const Janet *values = NULL;
            janet_indexed_view(left, &values, &len);
            for (int32_t i = 0; i < len; i++) {
                JanetSlot nextright = janetc_farslot(c);
                Janet subval = values[i];
                if (i < 0x100) {
                    janetc_emit_ssu(c, JOP_GET_INDEX, nextright, right, (uint8_t) i, 1);
                } else {
                    JanetSlot k = janetc_cslot(janet_wrap_integer(i));
                    janetc_emit_sss(c, JOP_IN, nextright, right, k, 1);
                }
                if (destructure(c, subval, nextright, leaf, attr))
                    janetc_freeslot(c, nextright);
            }
        }
        return 1;
        case JANET_TABLE:
        case JANET_STRUCT: {
            const JanetKV *kvs = NULL;
            int32_t cap = 0, len = 0;
            janet_dictionary_view(left, &kvs, &len, &cap);
            for (int32_t i = 0; i < cap; i++) {
                if (janet_checktype(kvs[i].key, JANET_NIL)) continue;
                JanetSlot nextright = janetc_farslot(c);
                JanetSlot k = janetc_value(janetc_fopts_default(c), kvs[i].key);
                janetc_emit_sss(c, JOP_IN, nextright, right, k, 1);
                if (destructure(c, kvs[i].value, nextright, leaf, attr))
                    janetc_freeslot(c, nextright);
            }
        }
        return 1;
    }
}

/* Create a source map for definitions. */
static const Janet *janetc_make_sourcemap(JanetCompiler *c) {
    Janet *tup = janet_tuple_begin(3);
    tup[0] = c->source ? janet_wrap_string(c->source) : janet_wrap_nil();
    tup[1] = janet_wrap_integer(c->current_mapping.line);
    tup[2] = janet_wrap_integer(c->current_mapping.column);
    return janet_tuple_end(tup);
}

static JanetSlot janetc_varset(JanetFopts opts, int32_t argn, const Janet *argv) {
    if (argn != 2) {
        janetc_cerror(opts.compiler, "expected 2 arguments");
        return janetc_cslot(janet_wrap_nil());
    }
    JanetFopts subopts = janetc_fopts_default(opts.compiler);
    if (janet_checktype(argv[0], JANET_SYMBOL)) {
        /* Normal var - (set a 1) */
        const uint8_t *sym = janet_unwrap_symbol(argv[0]);
        JanetSlot dest = janetc_resolve(opts.compiler, sym);
        if (!(dest.flags & JANET_SLOT_MUTABLE)) {
            janetc_cerror(opts.compiler, "cannot set constant");
            return janetc_cslot(janet_wrap_nil());
        }
        subopts.flags = JANET_FOPTS_HINT;
        subopts.hint = dest;
        JanetSlot ret = janetc_value(subopts, argv[1]);
        janetc_copy(opts.compiler, dest, ret);
        return ret;
    } else if (janet_checktype(argv[0], JANET_TUPLE)) {
        /* Set a field (setf behavior) - (set (tab :key) 2) */
        const Janet *tup = janet_unwrap_tuple(argv[0]);
        /* Tuple must have 2 elements */
        if (janet_tuple_length(tup) != 2) {
            janetc_cerror(opts.compiler, "expected 2 element tuple for l-value to set");
            return janetc_cslot(janet_wrap_nil());
        }
        JanetSlot ds = janetc_value(subopts, tup[0]);
        JanetSlot key = janetc_value(subopts, tup[1]);
        /* Can't be tail position because we will emit a PUT instruction afterwards */
        /* Also can't drop either */
        opts.flags &= ~(JANET_FOPTS_TAIL | JANET_FOPTS_DROP);
        JanetSlot rvalue = janetc_value(opts, argv[1]);
        /* Emit the PUT instruction */
        janetc_emit_sss(opts.compiler, JOP_PUT, ds, key, rvalue, 0);
        return rvalue;
    } else {
        /* Error */
        janetc_cerror(opts.compiler, "expected symbol or tuple for l-value to set");
        return janetc_cslot(janet_wrap_nil());
    }
}

/* Add attributes to a global def or var table */
static JanetTable *handleattr(JanetCompiler *c, int32_t argn, const Janet *argv) {
    int32_t i;
    JanetTable *tab = janet_table(2);
    for (i = 1; i < argn - 1; i++) {
        Janet attr = argv[i];
        switch (janet_type(attr)) {
            default:
                janetc_cerror(c, "could not add metadata to binding");
                break;
            case JANET_KEYWORD:
                janet_table_put(tab, attr, janet_wrap_true());
                break;
            case JANET_STRING:
                janet_table_put(tab, janet_ckeywordv("doc"), attr);
                break;
        }
    }
    return tab;
}

static JanetSlot dohead(JanetCompiler *c, JanetFopts opts, Janet *head, int32_t argn, const Janet *argv) {
    JanetFopts subopts = janetc_fopts_default(c);
    JanetSlot ret;
    if (argn < 2) {
        janetc_cerror(c, "expected at least 2 arguments");
        return janetc_cslot(janet_wrap_nil());
    }
    *head = argv[0];
    subopts.flags = opts.flags & ~(JANET_FOPTS_TAIL | JANET_FOPTS_DROP);
    subopts.hint = opts.hint;
    ret = janetc_value(subopts, argv[argn - 1]);
    return ret;
}

/* Def or var a symbol in a local scope */
static int namelocal(JanetCompiler *c, const uint8_t *head, int32_t flags, JanetSlot ret) {
    int isUnnamedRegister = !(ret.flags & JANET_SLOT_NAMED) &&
                            ret.index > 0 &&
                            ret.envindex >= 0;
    if (!isUnnamedRegister) {
        /* Slot is not able to be named */
        JanetSlot localslot = janetc_farslot(c);
        janetc_copy(c, localslot, ret);
        ret = localslot;
    }
    ret.flags |= flags;
    janetc_nameslot(c, head, ret);
    return !isUnnamedRegister;
}

static int varleaf(
    JanetCompiler *c,
    const uint8_t *sym,
    JanetSlot s,
    JanetTable *reftab) {
    if (c->scope->flags & JANET_SCOPE_TOP) {
        /* Global var, generate var */
        JanetSlot refslot;
        JanetTable *entry = janet_table_clone(reftab);
        JanetArray *ref = janet_array(1);
        janet_array_push(ref, janet_wrap_nil());
        janet_table_put(entry, janet_ckeywordv("ref"), janet_wrap_array(ref));
        janet_table_put(entry, janet_ckeywordv("source-map"),
                        janet_wrap_tuple(janetc_make_sourcemap(c)));
        janet_table_put(c->env, janet_wrap_symbol(sym), janet_wrap_table(entry));
        refslot = janetc_cslot(janet_wrap_array(ref));
        janetc_emit_ssu(c, JOP_PUT_INDEX, refslot, s, 0, 0);
        return 1;
    } else {
        return namelocal(c, sym, JANET_SLOT_MUTABLE, s);
    }
}

static JanetSlot janetc_var(JanetFopts opts, int32_t argn, const Janet *argv) {
    JanetCompiler *c = opts.compiler;
    Janet head;
    JanetSlot ret = dohead(c, opts, &head, argn, argv);
    if (c->result.status == JANET_COMPILE_ERROR)
        return janetc_cslot(janet_wrap_nil());
    destructure(c, argv[0], ret, varleaf, handleattr(c, argn, argv));
    return ret;
}

static int defleaf(
    JanetCompiler *c,
    const uint8_t *sym,
    JanetSlot s,
    JanetTable *tab) {
    if (c->scope->flags & JANET_SCOPE_TOP) {
        JanetTable *entry = janet_table_clone(tab);
        janet_table_put(entry, janet_ckeywordv("source-map"),
                        janet_wrap_tuple(janetc_make_sourcemap(c)));
        JanetSlot valsym = janetc_cslot(janet_ckeywordv("value"));
        JanetSlot tabslot = janetc_cslot(janet_wrap_table(entry));

        /* Add env entry to env */
        janet_table_put(c->env, janet_wrap_symbol(sym), janet_wrap_table(entry));

        /* Put value in table when evaulated */
        janetc_emit_sss(c, JOP_PUT, tabslot, valsym, s, 0);
        return 1;
    } else {
        return namelocal(c, sym, 0, s);
    }
}

static JanetSlot janetc_def(JanetFopts opts, int32_t argn, const Janet *argv) {
    JanetCompiler *c = opts.compiler;
    Janet head;
    opts.flags &= ~JANET_FOPTS_HINT;
    JanetSlot ret = dohead(c, opts, &head, argn, argv);
    if (c->result.status == JANET_COMPILE_ERROR)
        return janetc_cslot(janet_wrap_nil());
    destructure(c, argv[0], ret, defleaf, handleattr(c, argn, argv));
    return ret;
}

/*
 * :condition
 * ...
 * jump-if-not condition :right
 * :left
 * ...
 * jump done (only if not tail)
 * :right
 * ...
 * :done
 */
static JanetSlot janetc_if(JanetFopts opts, int32_t argn, const Janet *argv) {
    JanetCompiler *c = opts.compiler;
    int32_t labelr, labeljr, labeld, labeljd;
    JanetFopts condopts, bodyopts;
    JanetSlot cond, left, right, target;
    Janet truebody, falsebody;
    JanetScope condscope, tempscope;
    const int tail = opts.flags & JANET_FOPTS_TAIL;
    const int drop = opts.flags & JANET_FOPTS_DROP;

    if (argn < 2 || argn > 3) {
        janetc_cerror(c, "expected 2 or 3 arguments to if");
        return janetc_cslot(janet_wrap_nil());
    }

    /* Get the bodies of the if expression */
    truebody = argv[1];
    falsebody = argn > 2 ? argv[2] : janet_wrap_nil();

    /* Get options */
    condopts = janetc_fopts_default(c);
    bodyopts = opts;

    /* Set target for compilation */
    target = (drop || tail)
             ? janetc_cslot(janet_wrap_nil())
             : janetc_gettarget(opts);

    /* Compile condition */
    janetc_scope(&condscope, c, 0, "if");
    cond = janetc_value(condopts, argv[0]);

    /* Check constant condition. */
    /* TODO: Use type info for more short circuits */
    if (cond.flags & JANET_SLOT_CONSTANT) {
        if (!janet_truthy(cond.constant)) {
            /* Swap the true and false bodies */
            Janet temp = falsebody;
            falsebody = truebody;
            truebody = temp;
        }
        janetc_scope(&tempscope, c, 0, "if-true");
        right = janetc_value(bodyopts, truebody);
        if (!drop && !tail) janetc_copy(c, target, right);
        janetc_popscope(c);
        janetc_throwaway(bodyopts, falsebody);
        janetc_popscope(c);
        return target;
    }

    /* Compile jump to right */
    labeljr = janetc_emit_si(c, JOP_JUMP_IF_NOT, cond, 0, 0);

    /* Condition left body */
    janetc_scope(&tempscope, c, 0, "if-true");
    left = janetc_value(bodyopts, truebody);
    if (!drop && !tail) janetc_copy(c, target, left);
    janetc_popscope(c);

    /* Compile jump to done */
    labeljd = janet_v_count(c->buffer);
    if (!tail) janetc_emit(c, JOP_JUMP);

    /* Compile right body */
    labelr = janet_v_count(c->buffer);
    janetc_scope(&tempscope, c, 0, "if-false");
    right = janetc_value(bodyopts, falsebody);
    if (!drop && !tail) janetc_copy(c, target, right);
    janetc_popscope(c);

    /* Pop main scope */
    janetc_popscope(c);

    /* Write jumps - only add jump lengths if jump actually emitted */
    labeld = janet_v_count(c->buffer);
    c->buffer[labeljr] |= (labelr - labeljr) << 16;
    if (!tail) c->buffer[labeljd] |= (labeld - labeljd) << 8;

    if (tail) target.flags |= JANET_SLOT_RETURNED;
    return target;
}

/* Compile a do form. Do forms execute their body sequentially and
 * evaluate to the last expression in the body. */
static JanetSlot janetc_do(JanetFopts opts, int32_t argn, const Janet *argv) {
    int32_t i;
    JanetSlot ret = janetc_cslot(janet_wrap_nil());
    JanetCompiler *c = opts.compiler;
    JanetFopts subopts = janetc_fopts_default(c);
    JanetScope tempscope;
    janetc_scope(&tempscope, c, 0, "do");
    for (i = 0; i < argn; i++) {
        if (i != argn - 1) {
            subopts.flags = JANET_FOPTS_DROP;
        } else {
            subopts = opts;
        }
        ret = janetc_value(subopts, argv[i]);
        if (i != argn - 1) {
            janetc_freeslot(c, ret);
        }
    }
    janetc_popscope_keepslot(c, ret);
    return ret;
}

/* Add a funcdef to the top most function scope */
static int32_t janetc_addfuncdef(JanetCompiler *c, JanetFuncDef *def) {
    JanetScope *scope = c->scope;
    while (scope) {
        if (scope->flags & JANET_SCOPE_FUNCTION)
            break;
        scope = scope->parent;
    }
    janet_assert(scope, "could not add funcdef");
    janet_v_push(scope->defs, def);
    return janet_v_count(scope->defs) - 1;
}

/*
 * break
 *
 * jump :end or retn if in function
 */
static JanetSlot janetc_break(JanetFopts opts, int32_t argn, const Janet *argv) {
    JanetCompiler *c = opts.compiler;
    JanetScope *scope = c->scope;
    if (argn > 1) {
        janetc_cerror(c, "expected at most 1 argument");
        return janetc_cslot(janet_wrap_nil());
    }

    /* Find scope to break from */
    while (scope) {
        if (scope->flags & (JANET_SCOPE_FUNCTION | JANET_SCOPE_WHILE))
            break;
        scope = scope->parent;
    }
    if (NULL == scope) {
        janetc_cerror(c, "break must occur in while loop or closure");
        return janetc_cslot(janet_wrap_nil());
    }

    /* Emit code to break from that scope */
    JanetFopts subopts = janetc_fopts_default(c);
    if (scope->flags & JANET_SCOPE_FUNCTION) {
        if (!(scope->flags & JANET_SCOPE_WHILE) && argn) {
            /* Closure body with return argument */
            subopts.flags |= JANET_FOPTS_TAIL;
            JanetSlot ret = janetc_value(subopts, argv[0]);
            ret.flags |= JANET_SLOT_RETURNED;
            return ret;
        } else {
            /* while loop IIFE or no argument */
            if (argn) {
                subopts.flags |= JANET_FOPTS_DROP;
                janetc_value(subopts, argv[0]);
            }
            janetc_emit(c, JOP_RETURN_NIL);
            JanetSlot s = janetc_cslot(janet_wrap_nil());
            s.flags |= JANET_SLOT_RETURNED;
            return s;
        }
    } else {
        if (argn) {
            subopts.flags |= JANET_FOPTS_DROP;
            janetc_value(subopts, argv[0]);
        }
        /* Tag the instruction so the while special can turn it into a proper jump */
        janetc_emit(c, 0x80 | JOP_JUMP);
        return janetc_cslot(janet_wrap_nil());
    }
}

/* Check if a form matches the pattern (not= nil _) */
static int janetc_check_notnil_form(Janet x, Janet *capture) {
    if (!janet_checktype(x, JANET_TUPLE)) return 0;
    JanetTuple tup = janet_unwrap_tuple(x);
    if (!janet_checktype(tup[0], JANET_FUNCTION)) return 0;
    if (3 != janet_tuple_length(tup)) return 0;
    JanetFunction *fun = janet_unwrap_function(tup[0]);
    uint32_t tag = fun->def->flags & JANET_FUNCDEF_FLAG_TAG;
    if (tag != JANET_FUN_NEQ) return 0;
    if (!janet_checktype(tup[1], JANET_NIL)) return 0;
    *capture = tup[2];
    return 1;
}

/*
 * :whiletop
 * ...
 * :condition
 * jump-if-not cond :done
 * ...
 * jump :whiletop
 * :done
 */
static JanetSlot janetc_while(JanetFopts opts, int32_t argn, const Janet *argv) {
    JanetCompiler *c = opts.compiler;
    JanetSlot cond;
    JanetFopts subopts = janetc_fopts_default(c);
    JanetScope tempscope;
    int32_t labelwt, labeld, labeljt, labelc, i;
    int infinite = 0;
    int is_notnil_form = 0;
    uint8_t ifjmp = JOP_JUMP_IF;
    uint8_t ifnjmp = JOP_JUMP_IF_NOT;

    if (argn < 2) {
        janetc_cerror(c, "expected at least 2 arguments");
        return janetc_cslot(janet_wrap_nil());
    }

    labelwt = janet_v_count(c->buffer);

    janetc_scope(&tempscope, c, JANET_SCOPE_WHILE, "while");

    /* Check for `(not= nil _)` in condition, and if so, use the
     * jmpnl or jmpnn instructions. This let's us implement `(each ...)`
     * more efficiently. */
    Janet condform = argv[0];
    if (janetc_check_notnil_form(condform, &condform)) {
        is_notnil_form = 1;
        ifjmp = JOP_JUMP_IF_NOT_NIL;
        ifnjmp = JOP_JUMP_IF_NIL;
    }

    /* Compile condition */
    cond = janetc_value(subopts, condform);

    /* Check for constant condition */
    if (cond.flags & JANET_SLOT_CONSTANT) {
        /* Loop never executes */
        int never_executes = is_notnil_form
                             ? janet_checktype(cond.constant, JANET_NIL)
                             : !janet_truthy(cond.constant);
        if (never_executes) {
            janetc_popscope(c);
            return janetc_cslot(janet_wrap_nil());
        }
        /* Infinite loop */
        infinite = 1;
    }

    /* Infinite loop does not need to check condition */
    labelc = infinite
             ? 0
             : janetc_emit_si(c, ifnjmp, cond, 0, 0);

    /* Compile body */
    for (i = 1; i < argn; i++) {
        subopts.flags = JANET_FOPTS_DROP;
        janetc_freeslot(c, janetc_value(subopts, argv[i]));
    }

    /* Check if closure created in while scope. If so,
     * recompile in a function scope. */
    if (tempscope.flags & JANET_SCOPE_CLOSURE) {
        subopts = janetc_fopts_default(c);
        tempscope.flags |= JANET_SCOPE_UNUSED;
        janetc_popscope(c);
        if (c->buffer) janet_v__cnt(c->buffer) = labelwt;
        if (c->mapbuffer) janet_v__cnt(c->mapbuffer) = labelwt;

        janetc_scope(&tempscope, c, JANET_SCOPE_FUNCTION, "while-iife");

        /* Recompile in the function scope */
        cond = janetc_value(subopts, condform);
        if (!(cond.flags & JANET_SLOT_CONSTANT)) {
            /* If not an infinite loop, return nil when condition false */
            janetc_emit_si(c, ifjmp, cond, 2, 0);
            janetc_emit(c, JOP_RETURN_NIL);
        }
        for (i = 1; i < argn; i++) {
            subopts.flags = JANET_FOPTS_DROP;
            janetc_freeslot(c, janetc_value(subopts, argv[i]));
        }
        /* But now add tail recursion */
        int32_t tempself = janetc_regalloc_temp(&tempscope.ra, JANETC_REGTEMP_0);
        janetc_emit(c, JOP_LOAD_SELF | (tempself << 8));
        janetc_emit(c, JOP_TAILCALL | (tempself << 8));
        janetc_regalloc_freetemp(&c->scope->ra, tempself, JANETC_REGTEMP_0);
        /* Compile function */
        JanetFuncDef *def = janetc_pop_funcdef(c);
        def->name = janet_cstring("_while");
        int32_t defindex = janetc_addfuncdef(c, def);
        /* And then load the closure and call it. */
        int32_t cloreg = janetc_regalloc_temp(&c->scope->ra, JANETC_REGTEMP_0);
        janetc_emit(c, JOP_CLOSURE | (cloreg << 8) | (defindex << 16));
        janetc_emit(c, JOP_CALL | (cloreg << 8) | (cloreg << 16));
        janetc_regalloc_freetemp(&c->scope->ra, cloreg, JANETC_REGTEMP_0);
        c->scope->flags |= JANET_SCOPE_CLOSURE;
        return janetc_cslot(janet_wrap_nil());
    }

    /* Compile jump to :whiletop */
    labeljt = janet_v_count(c->buffer);
    janetc_emit(c, JOP_JUMP);

    /* Calculate jumps */
    labeld = janet_v_count(c->buffer);
    if (!infinite) c->buffer[labelc] |= (uint32_t)(labeld - labelc) << 16;
    c->buffer[labeljt] |= (uint32_t)(labelwt - labeljt) << 8;

    /* Calculate breaks */
    for (int32_t i = labelwt; i < labeld; i++) {
        if (c->buffer[i] == (0x80 | JOP_JUMP)) {
            c->buffer[i] = JOP_JUMP | ((labeld - i) << 8);
        }
    }

    /* Pop scope and return nil slot */
    janetc_popscope(c);

    return janetc_cslot(janet_wrap_nil());
}

static JanetSlot janetc_fn(JanetFopts opts, int32_t argn, const Janet *argv) {
    JanetCompiler *c = opts.compiler;
    JanetFuncDef *def;
    JanetSlot ret;
    Janet head;
    JanetScope fnscope;
    int32_t paramcount, argi, parami, arity, min_arity, max_arity, defindex, i;
    JanetFopts subopts = janetc_fopts_default(c);
    const Janet *params;
    const char *errmsg = NULL;

    /* Function flags */
    int vararg = 0;
    int structarg = 0;
    int allow_extra = 0;
    int selfref = 0;
    int seenamp = 0;
    int seenopt = 0;

    /* Begin function */
    c->scope->flags |= JANET_SCOPE_CLOSURE;
    janetc_scope(&fnscope, c, JANET_SCOPE_FUNCTION, "function");

    if (argn == 0) {
        errmsg = "expected at least 1 argument to function literal";
        goto error;
    }

    /* Read function parameters */
    parami = 0;
    head = argv[0];
    if (janet_checktype(head, JANET_SYMBOL)) {
        selfref = 1;
        parami = 1;
    }
    if (parami >= argn || !janet_checktype(argv[parami], JANET_TUPLE)) {
        errmsg = "expected function parameters";
        goto error;
    }

    /* Keep track of destructured parameters */
    JanetSlot *destructed_params = NULL;

    /* Compile function parameters */
    params = janet_unwrap_tuple(argv[parami]);
    paramcount = janet_tuple_length(params);
    arity = paramcount;
    for (i = 0; i < paramcount; i++) {
        Janet param = params[i];
        if (janet_checktype(param, JANET_SYMBOL)) {
            /* Check for varargs and unfixed arity */
            if (!janet_cstrcmp(janet_unwrap_symbol(param), "&")) {
                if (seenamp) {
                    errmsg = "& in unexpected location";
                    goto error;
                } else if (i == paramcount - 1) {
                    allow_extra = 1;
                    arity--;
                } else if (i == paramcount - 2) {
                    vararg = 1;
                    arity -= 2;
                } else {
                    errmsg = "& in unexpected location";
                    goto error;
                }
                seenamp = 1;
            } else if (!janet_cstrcmp(janet_unwrap_symbol(param), "&opt")) {
                if (seenopt) {
                    errmsg = "only one &opt allowed";
                    goto error;
                } else if (i == paramcount - 1) {
                    errmsg = "&opt cannot be last item in parameter list";
                    goto error;
                }
                min_arity = i;
                arity--;
                seenopt = 1;
            } else if (!janet_cstrcmp(janet_unwrap_symbol(param), "&keys")) {
                if (seenamp) {
                    errmsg = "&keys in unexpected location";
                    goto error;
                } else if (i == paramcount - 2) {
                    vararg = 1;
                    structarg = 1;
                    arity -= 2;
                } else {
                    errmsg = "&keys in unexpected location";
                    goto error;
                }
                seenamp = 1;
            } else {
                janetc_nameslot(c, janet_unwrap_symbol(param), janetc_farslot(c));
            }
        } else {
            janet_v_push(destructed_params, janetc_farslot(c));
        }
    }

    /* Compile destructed params */
    int32_t j = 0;
    for (i = 0; i < paramcount; i++) {
        Janet param = params[i];
        if (!janet_checktype(param, JANET_SYMBOL)) {
            JanetSlot reg = destructed_params[j++];
            destructure(c, param, reg, defleaf, NULL);
            janetc_freeslot(c, reg);
        }
    }
    janet_v_free(destructed_params);

    max_arity = (vararg || allow_extra) ? INT32_MAX : arity;
    if (!seenopt) min_arity = arity;

    /* Check for self ref */
    if (selfref) {
        JanetSlot slot = janetc_farslot(c);
        slot.flags = JANET_SLOT_NAMED | JANET_FUNCTION;
        janetc_emit_s(c, JOP_LOAD_SELF, slot, 1);
        janetc_nameslot(c, janet_unwrap_symbol(head), slot);
    }

    /* Compile function body */
    if (parami + 1 == argn) {
        janetc_emit(c, JOP_RETURN_NIL);
    } else {
        for (argi = parami + 1; argi < argn; argi++) {
            subopts.flags = (argi == (argn - 1)) ? JANET_FOPTS_TAIL : JANET_FOPTS_DROP;
            janetc_value(subopts, argv[argi]);
            if (c->result.status == JANET_COMPILE_ERROR)
                goto error2;
        }
    }

    /* Build function */
    def = janetc_pop_funcdef(c);
    def->arity = arity;
    def->min_arity = min_arity;
    def->max_arity = max_arity;
    if (vararg) def->flags |= JANET_FUNCDEF_FLAG_VARARG;
    if (structarg) def->flags |= JANET_FUNCDEF_FLAG_STRUCTARG;

    if (selfref) def->name = janet_unwrap_symbol(head);
    defindex = janetc_addfuncdef(c, def);

    /* Ensure enough slots for vararg function. */
    if (arity + vararg > def->slotcount) def->slotcount = arity + vararg;

    /* Instantiate closure */
    ret = janetc_gettarget(opts);
    janetc_emit_su(c, JOP_CLOSURE, ret, defindex, 1);
    return ret;

error:
    janetc_cerror(c, errmsg);
error2:
    janetc_popscope(c);
    return janetc_cslot(janet_wrap_nil());
}

/* Keep in lexicographic order */
static const JanetSpecial janetc_specials[] = {
    {"break", janetc_break},
    {"def", janetc_def},
    {"do", janetc_do},
    {"fn", janetc_fn},
    {"if", janetc_if},
    {"quasiquote", janetc_quasiquote},
    {"quote", janetc_quote},
    {"set", janetc_varset},
    {"splice", janetc_splice},
    {"unquote", janetc_unquote},
    {"var", janetc_var},
    {"while", janetc_while}
};

/* Find a special */
const JanetSpecial *janetc_special(const uint8_t *name) {
    return janet_strbinsearch(
               &janetc_specials,
               sizeof(janetc_specials) / sizeof(JanetSpecial),
               sizeof(JanetSpecial),
               name);
}



/* src/core/string.c */
#line 0 "src/core/string.c"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "gc.h"
#include "util.h"
#include "state.h"
#endif

#include <string.h>

/* Begin building a string */
uint8_t *janet_string_begin(int32_t length) {
    JanetStringHead *head = janet_gcalloc(JANET_MEMORY_STRING, sizeof(JanetStringHead) + (size_t) length + 1);
    head->length = length;
    uint8_t *data = (uint8_t *)head->data;
    data[length] = 0;
    return data;
}

/* Finish building a string */
const uint8_t *janet_string_end(uint8_t *str) {
    janet_string_hash(str) = janet_string_calchash(str, janet_string_length(str));
    return str;
}

/* Load a buffer as a string */
const uint8_t *janet_string(const uint8_t *buf, int32_t len) {
    JanetStringHead *head = janet_gcalloc(JANET_MEMORY_STRING, sizeof(JanetStringHead) + (size_t) len + 1);
    head->length = len;
    head->hash = janet_string_calchash(buf, len);
    uint8_t *data = (uint8_t *)head->data;
    safe_memcpy(data, buf, len);
    data[len] = 0;
    return data;
}

/* Compare two strings */
int janet_string_compare(const uint8_t *lhs, const uint8_t *rhs) {
    int32_t xlen = janet_string_length(lhs);
    int32_t ylen = janet_string_length(rhs);
    int32_t len = xlen > ylen ? ylen : xlen;
    int res = memcmp(lhs, rhs, len);
    if (res) return res;
    if (xlen == ylen) return 0;
    return xlen < ylen ? -1 : 1;
}

/* Compare a janet string with a piece of memory */
int janet_string_equalconst(const uint8_t *lhs, const uint8_t *rhs, int32_t rlen, int32_t rhash) {
    int32_t lhash = janet_string_hash(lhs);
    int32_t llen = janet_string_length(lhs);
    if (lhs == rhs)
        return 1;
    if (lhash != rhash || llen != rlen)
        return 0;
    return !memcmp(lhs, rhs, rlen);
}

/* Check if two strings are equal */
int janet_string_equal(const uint8_t *lhs, const uint8_t *rhs) {
    return janet_string_equalconst(lhs, rhs,
                                   janet_string_length(rhs), janet_string_hash(rhs));
}

/* Load a c string */
const uint8_t *janet_cstring(const char *str) {
    return janet_string((const uint8_t *)str, (int32_t)strlen(str));
}

/* Knuth Morris Pratt Algorithm */

struct kmp_state {
    int32_t i;
    int32_t j;
    int32_t textlen;
    int32_t patlen;
    int32_t *lookup;
    const uint8_t *text;
    const uint8_t *pat;
};

static void kmp_init(
    struct kmp_state *s,
    const uint8_t *text, int32_t textlen,
    const uint8_t *pat, int32_t patlen) {
    if (patlen == 0) {
        janet_panic("expected non-empty pattern");
    }
    int32_t *lookup = calloc(patlen, sizeof(int32_t));
    if (!lookup) {
        JANET_OUT_OF_MEMORY;
    }
    s->lookup = lookup;
    s->i = 0;
    s->j = 0;
    s->text = text;
    s->pat = pat;
    s->textlen = textlen;
    s->patlen = patlen;
    /* Init state machine */
    {
        int32_t i, j;
        for (i = 1, j = 0; i < patlen; i++) {
            while (j && pat[j] != pat[i]) j = lookup[j - 1];
            if (pat[j] == pat[i]) j++;
            lookup[i] = j;
        }
    }
}

static void kmp_deinit(struct kmp_state *state) {
    free(state->lookup);
}

static void kmp_seti(struct kmp_state *state, int32_t i) {
    state->i = i;
    state->j = 0;
}

static int32_t kmp_next(struct kmp_state *state) {
    int32_t i = state->i;
    int32_t j = state->j;
    int32_t textlen = state->textlen;
    int32_t patlen = state->patlen;
    const uint8_t *text = state->text;
    const uint8_t *pat = state->pat;
    int32_t *lookup = state->lookup;
    while (i < textlen) {
        if (text[i] == pat[j]) {
            if (j == patlen - 1) {
                state->i = i + 1;
                state->j = lookup[j];
                return i - j;
            } else {
                i++;
                j++;
            }
        } else {
            if (j > 0) {
                j = lookup[j - 1];
            } else {
                i++;
            }
        }
    }
    return -1;
}

/* CFuns */

static Janet cfun_string_slice(int32_t argc, Janet *argv) {
    JanetByteView view = janet_getbytes(argv, 0);
    JanetRange range = janet_getslice(argc, argv);
    return janet_stringv(view.bytes + range.start, range.end - range.start);
}

static Janet cfun_string_repeat(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 2);
    JanetByteView view = janet_getbytes(argv, 0);
    int32_t rep = janet_getinteger(argv, 1);
    if (rep < 0) janet_panic("expected non-negative number of repetitions");
    if (rep == 0) return janet_cstringv("");
    int64_t mulres = (int64_t) rep * view.len;
    if (mulres > INT32_MAX) janet_panic("result string is too long");
    uint8_t *newbuf = janet_string_begin((int32_t) mulres);
    uint8_t *end = newbuf + mulres;
    for (uint8_t *p = newbuf; p < end; p += view.len) {
        safe_memcpy(p, view.bytes, view.len);
    }
    return janet_wrap_string(janet_string_end(newbuf));
}

static Janet cfun_string_bytes(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    JanetByteView view = janet_getbytes(argv, 0);
    Janet *tup = janet_tuple_begin(view.len);
    int32_t i;
    for (i = 0; i < view.len; i++) {
        tup[i] = janet_wrap_integer((int32_t) view.bytes[i]);
    }
    return janet_wrap_tuple(janet_tuple_end(tup));
}

static Janet cfun_string_frombytes(int32_t argc, Janet *argv) {
    int32_t i;
    uint8_t *buf = janet_string_begin(argc);
    for (i = 0; i < argc; i++) {
        int32_t c = janet_getinteger(argv, i);
        buf[i] = c & 0xFF;
    }
    return janet_wrap_string(janet_string_end(buf));
}

static Janet cfun_string_asciilower(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    JanetByteView view = janet_getbytes(argv, 0);
    uint8_t *buf = janet_string_begin(view.len);
    for (int32_t i = 0; i < view.len; i++) {
        uint8_t c = view.bytes[i];
        if (c >= 65 && c <= 90) {
            buf[i] = c + 32;
        } else {
            buf[i] = c;
        }
    }
    return janet_wrap_string(janet_string_end(buf));
}

static Janet cfun_string_asciiupper(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    JanetByteView view = janet_getbytes(argv, 0);
    uint8_t *buf = janet_string_begin(view.len);
    for (int32_t i = 0; i < view.len; i++) {
        uint8_t c = view.bytes[i];
        if (c >= 97 && c <= 122) {
            buf[i] = c - 32;
        } else {
            buf[i] = c;
        }
    }
    return janet_wrap_string(janet_string_end(buf));
}

static Janet cfun_string_reverse(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    JanetByteView view = janet_getbytes(argv, 0);
    uint8_t *buf = janet_string_begin(view.len);
    int32_t i, j;
    for (i = 0, j = view.len - 1; i < view.len; i++, j--) {
        buf[i] = view.bytes[j];
    }
    return janet_wrap_string(janet_string_end(buf));
}

static void findsetup(int32_t argc, Janet *argv, struct kmp_state *s, int32_t extra) {
    janet_arity(argc, 2, 3 + extra);
    JanetByteView pat = janet_getbytes(argv, 0);
    JanetByteView text = janet_getbytes(argv, 1);
    int32_t start = 0;
    if (argc >= 3) {
        start = janet_getinteger(argv, 2);
        if (start < 0) janet_panic("expected non-negative start index");
    }
    kmp_init(s, text.bytes, text.len, pat.bytes, pat.len);
    s->i = start;
}

static Janet cfun_string_find(int32_t argc, Janet *argv) {
    int32_t result;
    struct kmp_state state;
    findsetup(argc, argv, &state, 0);
    result = kmp_next(&state);
    kmp_deinit(&state);
    return result < 0
           ? janet_wrap_nil()
           : janet_wrap_integer(result);
}

static Janet cfun_string_hasprefix(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 2);
    JanetByteView prefix = janet_getbytes(argv, 0);
    JanetByteView str = janet_getbytes(argv, 1);
    return str.len < prefix.len
           ? janet_wrap_false()
           : janet_wrap_boolean(memcmp(prefix.bytes, str.bytes, prefix.len) == 0);
}

static Janet cfun_string_hassuffix(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 2);
    JanetByteView suffix = janet_getbytes(argv, 0);
    JanetByteView str = janet_getbytes(argv, 1);
    return str.len < suffix.len
           ? janet_wrap_false()
           : janet_wrap_boolean(memcmp(suffix.bytes,
                                       str.bytes + str.len - suffix.len,
                                       suffix.len) == 0);
}

static Janet cfun_string_findall(int32_t argc, Janet *argv) {
    int32_t result;
    struct kmp_state state;
    findsetup(argc, argv, &state, 0);
    JanetArray *array = janet_array(0);
    while ((result = kmp_next(&state)) >= 0) {
        janet_array_push(array, janet_wrap_integer(result));
    }
    kmp_deinit(&state);
    return janet_wrap_array(array);
}

struct replace_state {
    struct kmp_state kmp;
    const uint8_t *subst;
    int32_t substlen;
};

static void replacesetup(int32_t argc, Janet *argv, struct replace_state *s) {
    janet_arity(argc, 3, 4);
    JanetByteView pat = janet_getbytes(argv, 0);
    JanetByteView subst = janet_getbytes(argv, 1);
    JanetByteView text = janet_getbytes(argv, 2);
    int32_t start = 0;
    if (argc == 4) {
        start = janet_getinteger(argv, 3);
        if (start < 0) janet_panic("expected non-negative start index");
    }
    kmp_init(&s->kmp, text.bytes, text.len, pat.bytes, pat.len);
    s->kmp.i = start;
    s->subst = subst.bytes;
    s->substlen = subst.len;
}

static Janet cfun_string_replace(int32_t argc, Janet *argv) {
    int32_t result;
    struct replace_state s;
    uint8_t *buf;
    replacesetup(argc, argv, &s);
    result = kmp_next(&s.kmp);
    if (result < 0) {
        kmp_deinit(&s.kmp);
        return janet_stringv(s.kmp.text, s.kmp.textlen);
    }
    buf = janet_string_begin(s.kmp.textlen - s.kmp.patlen + s.substlen);
    safe_memcpy(buf, s.kmp.text, result);
    safe_memcpy(buf + result, s.subst, s.substlen);
    safe_memcpy(buf + result + s.substlen,
                s.kmp.text + result + s.kmp.patlen,
                s.kmp.textlen - result - s.kmp.patlen);
    kmp_deinit(&s.kmp);
    return janet_wrap_string(janet_string_end(buf));
}

static Janet cfun_string_replaceall(int32_t argc, Janet *argv) {
    int32_t result;
    struct replace_state s;
    JanetBuffer b;
    int32_t lastindex = 0;
    replacesetup(argc, argv, &s);
    janet_buffer_init(&b, s.kmp.textlen);
    while ((result = kmp_next(&s.kmp)) >= 0) {
        janet_buffer_push_bytes(&b, s.kmp.text + lastindex, result - lastindex);
        janet_buffer_push_bytes(&b, s.subst, s.substlen);
        lastindex = result + s.kmp.patlen;
        kmp_seti(&s.kmp, lastindex);
    }
    janet_buffer_push_bytes(&b, s.kmp.text + lastindex, s.kmp.textlen - lastindex);
    const uint8_t *ret = janet_string(b.data, b.count);
    janet_buffer_deinit(&b);
    kmp_deinit(&s.kmp);
    return janet_wrap_string(ret);
}

static Janet cfun_string_split(int32_t argc, Janet *argv) {
    int32_t result;
    JanetArray *array;
    struct kmp_state state;
    int32_t limit = -1, lastindex = 0;
    if (argc == 4) {
        limit = janet_getinteger(argv, 3);
    }
    findsetup(argc, argv, &state, 1);
    array = janet_array(0);
    while ((result = kmp_next(&state)) >= 0 && --limit) {
        const uint8_t *slice = janet_string(state.text + lastindex, result - lastindex);
        janet_array_push(array, janet_wrap_string(slice));
        lastindex = result + state.patlen;
    }
    const uint8_t *slice = janet_string(state.text + lastindex, state.textlen - lastindex);
    janet_array_push(array, janet_wrap_string(slice));
    kmp_deinit(&state);
    return janet_wrap_array(array);
}

static Janet cfun_string_checkset(int32_t argc, Janet *argv) {
    uint32_t bitset[8] = {0, 0, 0, 0, 0, 0, 0, 0};
    janet_fixarity(argc, 2);
    JanetByteView set = janet_getbytes(argv, 0);
    JanetByteView str = janet_getbytes(argv, 1);
    /* Populate set */
    for (int32_t i = 0; i < set.len; i++) {
        int index = set.bytes[i] >> 5;
        uint32_t mask = 1 << (set.bytes[i] & 0x1F);
        bitset[index] |= mask;
    }
    /* Check set */
    for (int32_t i = 0; i < str.len; i++) {
        int index = str.bytes[i] >> 5;
        uint32_t mask = 1 << (str.bytes[i] & 0x1F);
        if (!(bitset[index] & mask)) {
            return janet_wrap_false();
        }
    }
    return janet_wrap_true();
}

static Janet cfun_string_join(int32_t argc, Janet *argv) {
    janet_arity(argc, 1, 2);
    JanetView parts = janet_getindexed(argv, 0);
    JanetByteView joiner;
    if (argc == 2) {
        joiner = janet_getbytes(argv, 1);
    } else {
        joiner.bytes = NULL;
        joiner.len = 0;
    }
    /* Check args */
    int32_t i;
    int64_t finallen = 0;
    for (i = 0; i < parts.len; i++) {
        const uint8_t *chunk;
        int32_t chunklen = 0;
        if (!janet_bytes_view(parts.items[i], &chunk, &chunklen)) {
            janet_panicf("item %d of parts is not a byte sequence, got %v", i, parts.items[i]);
        }
        if (i) finallen += joiner.len;
        finallen += chunklen;
        if (finallen > INT32_MAX)
            janet_panic("result string too long");
    }
    uint8_t *buf, *out;
    out = buf = janet_string_begin((int32_t) finallen);
    for (i = 0; i < parts.len; i++) {
        const uint8_t *chunk = NULL;
        int32_t chunklen = 0;
        if (i) {
            safe_memcpy(out, joiner.bytes, joiner.len);
            out += joiner.len;
        }
        janet_bytes_view(parts.items[i], &chunk, &chunklen);
        safe_memcpy(out, chunk, chunklen);
        out += chunklen;
    }
    return janet_wrap_string(janet_string_end(buf));
}

static Janet cfun_string_format(int32_t argc, Janet *argv) {
    janet_arity(argc, 1, -1);
    JanetBuffer *buffer = janet_buffer(0);
    const char *strfrmt = (const char *) janet_getstring(argv, 0);
    janet_buffer_format(buffer, strfrmt, 0, argc, argv);
    return janet_stringv(buffer->data, buffer->count);
}

static int trim_help_checkset(JanetByteView set, uint8_t x) {
    for (int32_t j = 0; j < set.len; j++)
        if (set.bytes[j] == x)
            return 1;
    return 0;
}

static int32_t trim_help_leftedge(JanetByteView str, JanetByteView set) {
    for (int32_t i = 0; i < str.len; i++)
        if (!trim_help_checkset(set, str.bytes[i]))
            return i;
    return str.len;
}

static int32_t trim_help_rightedge(JanetByteView str, JanetByteView set) {
    for (int32_t i = str.len - 1; i >= 0; i--)
        if (!trim_help_checkset(set, str.bytes[i]))
            return i + 1;
    return 0;
}

static void trim_help_args(int32_t argc, Janet *argv, JanetByteView *str, JanetByteView *set) {
    janet_arity(argc, 1, 2);
    *str = janet_getbytes(argv, 0);
    if (argc >= 2) {
        *set = janet_getbytes(argv, 1);
    } else {
        set->bytes = (const uint8_t *)(" \t\r\n\v\f");
        set->len = 6;
    }
}

static Janet cfun_string_trim(int32_t argc, Janet *argv) {
    JanetByteView str, set;
    trim_help_args(argc, argv, &str, &set);
    int32_t left_edge = trim_help_leftedge(str, set);
    int32_t right_edge = trim_help_rightedge(str, set);
    if (right_edge < left_edge)
        return janet_stringv(NULL, 0);
    return janet_stringv(str.bytes + left_edge, right_edge - left_edge);
}

static Janet cfun_string_triml(int32_t argc, Janet *argv) {
    JanetByteView str, set;
    trim_help_args(argc, argv, &str, &set);
    int32_t left_edge = trim_help_leftedge(str, set);
    return janet_stringv(str.bytes + left_edge, str.len - left_edge);
}

static Janet cfun_string_trimr(int32_t argc, Janet *argv) {
    JanetByteView str, set;
    trim_help_args(argc, argv, &str, &set);
    int32_t right_edge = trim_help_rightedge(str, set);
    return janet_stringv(str.bytes, right_edge);
}

static const JanetReg string_cfuns[] = {
    {
        "string/slice", cfun_string_slice,
        JDOC("(string/slice bytes &opt start end)\n\n"
             "Returns a substring from a byte sequence. The substring is from "
             "index start inclusive to index end exclusive. All indexing "
             "is from 0. 'start' and 'end' can also be negative to indicate indexing "
             "from the end of the string. Note that index -1 is synonymous with "
             "index (length bytes) to allow a full negative slice range. ")
    },
    {
        "string/repeat", cfun_string_repeat,
        JDOC("(string/repeat bytes n)\n\n"
             "Returns a string that is n copies of bytes concatenated.")
    },
    {
        "string/bytes", cfun_string_bytes,
        JDOC("(string/bytes str)\n\n"
             "Returns an array of integers that are the byte values of the string.")
    },
    {
        "string/from-bytes", cfun_string_frombytes,
        JDOC("(string/from-bytes & byte-vals)\n\n"
             "Creates a string from integer parameters with byte values. All integers "
             "will be coerced to the range of 1 byte 0-255.")
    },
    {
        "string/ascii-lower", cfun_string_asciilower,
        JDOC("(string/ascii-lower str)\n\n"
             "Returns a new string where all bytes are replaced with the "
             "lowercase version of themselves in ASCII. Does only a very simple "
             "case check, meaning no unicode support.")
    },
    {
        "string/ascii-upper", cfun_string_asciiupper,
        JDOC("(string/ascii-upper str)\n\n"
             "Returns a new string where all bytes are replaced with the "
             "uppercase version of themselves in ASCII. Does only a very simple "
             "case check, meaning no unicode support.")
    },
    {
        "string/reverse", cfun_string_reverse,
        JDOC("(string/reverse str)\n\n"
             "Returns a string that is the reversed version of str.")
    },
    {
        "string/find", cfun_string_find,
        JDOC("(string/find patt str)\n\n"
             "Searches for the first instance of pattern patt in string "
             "str. Returns the index of the first character in patt if found, "
             "otherwise returns nil.")
    },
    {
        "string/find-all", cfun_string_findall,
        JDOC("(string/find-all patt str)\n\n"
             "Searches for all instances of pattern patt in string "
             "str. Returns an array of all indices of found patterns. Overlapping "
             "instances of the pattern are not counted, meaning a byte in string "
             "will only contribute to finding at most on occurrence of pattern. If no "
             "occurrences are found, will return an empty array.")
    },
    {
        "string/has-prefix?", cfun_string_hasprefix,
        JDOC("(string/has-prefix? pfx str)\n\n"
             "Tests whether str starts with pfx.")
    },
    {
        "string/has-suffix?", cfun_string_hassuffix,
        JDOC("(string/has-suffix? sfx str)\n\n"
             "Tests whether str ends with sfx.")
    },
    {
        "string/replace", cfun_string_replace,
        JDOC("(string/replace patt subst str)\n\n"
             "Replace the first occurrence of patt with subst in the string str. "
             "Will return the new string if patt is found, otherwise returns str.")
    },
    {
        "string/replace-all", cfun_string_replaceall,
        JDOC("(string/replace-all patt subst str)\n\n"
             "Replace all instances of patt with subst in the string str. "
             "Will return the new string if patt is found, otherwise returns str.")
    },
    {
        "string/split", cfun_string_split,
        JDOC("(string/split delim str &opt start limit)\n\n"
             "Splits a string str with delimiter delim and returns an array of "
             "substrings. The substrings will not contain the delimiter delim. If delim "
             "is not found, the returned array will have one element. Will start searching "
             "for delim at the index start (if provided), and return up to a maximum "
             "of limit results (if provided).")
    },
    {
        "string/check-set", cfun_string_checkset,
        JDOC("(string/check-set set str)\n\n"
             "Checks that the string str only contains bytes that appear in the string set. "
             "Returns true if all bytes in str appear in set, false if some bytes in str do "
             "not appear in set.")
    },
    {
        "string/join", cfun_string_join,
        JDOC("(string/join parts &opt sep)\n\n"
             "Joins an array of strings into one string, optionally separated by "
             "a separator string sep.")
    },
    {
        "string/format", cfun_string_format,
        JDOC("(string/format format & values)\n\n"
             "Similar to snprintf, but specialized for operating with Janet values. Returns "
             "a new string.")
    },
    {
        "string/trim", cfun_string_trim,
        JDOC("(string/trim str &opt set)\n\n"
             "Trim leading and trailing whitespace from a byte sequence. If the argument "
             "set is provided, consider only characters in set to be whitespace.")
    },
    {
        "string/triml", cfun_string_triml,
        JDOC("(string/triml str &opt set)\n\n"
             "Trim leading whitespace from a byte sequence. If the argument "
             "set is provided, consider only characters in set to be whitespace.")
    },
    {
        "string/trimr", cfun_string_trimr,
        JDOC("(string/trimr str &opt set)\n\n"
             "Trim trailing whitespace from a byte sequence. If the argument "
             "set is provided, consider only characters in set to be whitespace.")
    },
    {NULL, NULL, NULL}
};

/* Module entry point */
void janet_lib_string(JanetTable *env) {
    janet_core_cfuns(env, NULL, string_cfuns);
}


/* src/core/strtod.c */
#line 0 "src/core/strtod.c"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

/* Use a custom double parser instead of libc's strtod for better portability
 * and control.
 *
 * This version has been modified for much greater flexibility in parsing, such
 * as choosing the radix and supporting scientific notation with any radix.
 *
 * Numbers are of the form [-+]R[rR]I.F[eE&][-+]X in pseudo-regex form, where R
 * is the radix, I is the integer part, F is the fractional part, and X is the
 * exponent. All signs, radix, decimal point, fractional part, and exponent can
 * be omitted.  The radix is assumed to be 10 if omitted, and the E or e
 * separator for the exponent can only be used when the radix is 10. This is
 * because E is a valid digit in bases 15 or greater. For bases greater than
 * 10, the letters are used as digits. A through Z correspond to the digits 10
 * through 35, and the lowercase letters have the same values. The radix number
 * is always in base 10. For example, a hexidecimal number could be written
 * '16rdeadbeef'. janet_scan_number also supports some c style syntax for
 * hexidecimal literals. The previous number could also be written
 * '0xdeadbeef'.
 */

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "util.h"
#endif

#include <math.h>
#include <string.h>

/* Lookup table for getting values of characters when parsing numbers. Handles
 * digits 0-9 and a-z (and A-Z). A-Z have values of 10 to 35. */
static uint8_t digit_lookup[128] = {
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
    25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
    25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 0xff, 0xff, 0xff, 0xff, 0xff
};

#define BIGNAT_NBIT 31
#define BIGNAT_BASE 0x80000000U

/* Allow for large mantissa. BigNat is a natural number. */
struct BigNat {
    uint32_t first_digit; /* First digit so we don't need to allocate when not needed. */
    int32_t n; /* n digits */
    int32_t cap; /* allocated digit capacity */
    uint32_t *digits; /* Each digit is base (2 ^ 31). Digits are least significant first. */
};

/* Initialize a bignat to 0 */
static void bignat_zero(struct BigNat *x) {
    x->first_digit = 0;
    x->n = 0;
    x->cap = 0;
    x->digits = NULL;
}

/* Allocate n more digits for mant. Return a pointer to these digits. */
static uint32_t *bignat_extra(struct BigNat *mant, int32_t n) {
    int32_t oldn = mant->n;
    int32_t newn = oldn + n;
    if (mant->cap < newn) {
        int32_t newcap = 2 * newn;
        uint32_t *mem = realloc(mant->digits, (size_t) newcap * sizeof(uint32_t));
        if (NULL == mem) {
            JANET_OUT_OF_MEMORY;
        }
        mant->cap = newcap;
        mant->digits = mem;
    }
    mant->n = newn;
    return mant->digits + oldn;
}

/* Append a digit */
static void bignat_append(struct BigNat *mant, uint32_t dig) {
    bignat_extra(mant, 1)[0] = dig;
}

/* Multiply the mantissa mant by a factor and the add a term
 * in one operation. factor will be between 2 and 36^4,
 * term will be between 0 and 36. */
static void bignat_muladd(struct BigNat *mant, uint32_t factor, uint32_t term) {
    int32_t i;
    uint64_t carry = ((uint64_t) mant->first_digit) * factor + term;
    mant->first_digit = carry % BIGNAT_BASE;
    carry /= BIGNAT_BASE;
    for (i = 0; i < mant->n; i++) {
        carry += ((uint64_t) mant->digits[i]) * factor;
        mant->digits[i] = carry % BIGNAT_BASE;
        carry /= BIGNAT_BASE;
    }
    if (carry) bignat_append(mant, (uint32_t) carry);
}

/* Divide the mantissa mant by a factor. Drop the remainder. */
static void bignat_div(struct BigNat *mant, uint32_t divisor) {
    int32_t i;
    uint32_t quotient, remainder;
    uint64_t dividend;
    remainder = 0, quotient = 0;
    for (i = mant->n - 1; i >= 0; i--) {
        dividend = ((uint64_t)remainder * BIGNAT_BASE) + mant->digits[i];
        if (i < mant->n - 1) mant->digits[i + 1] = quotient;
        quotient = (uint32_t)(dividend / divisor);
        remainder = (uint32_t)(dividend % divisor);
        mant->digits[i] = remainder;
    }
    dividend = ((uint64_t)remainder * BIGNAT_BASE) + mant->first_digit;
    if (mant->n && mant->digits[mant->n - 1] == 0) mant->n--;
    mant->first_digit = (uint32_t)(dividend / divisor);
}

/* Shift left by a multiple of BIGNAT_NBIT */
static void bignat_lshift_n(struct BigNat *mant, int n) {
    if (!n) return;
    int32_t oldn = mant->n;
    bignat_extra(mant, n);
    memmove(mant->digits + n, mant->digits, sizeof(uint32_t) * oldn);
    memset(mant->digits, 0, sizeof(uint32_t) * (n - 1));
    mant->digits[n - 1] = mant->first_digit;
    mant->first_digit = 0;
}

#ifdef __GNUC__
#define clz(x) __builtin_clz(x)
#else
static int clz(uint32_t x) {
    int n = 0;
    if (x <= 0x0000ffff) n += 16, x <<= 16;
    if (x <= 0x00ffffff) n += 8, x <<= 8;
    if (x <= 0x0fffffff) n += 4, x <<= 4;
    if (x <= 0x3fffffff) n += 2, x <<= 2;
    if (x <= 0x7fffffff) n ++;
    return n;
}
#endif

/* Extract double value from mantissa */
static double bignat_extract(struct BigNat *mant, int32_t exponent2) {
    uint64_t top53;
    int32_t n = mant->n;
    /* Get most significant 53 bits from mant. Bit 52 (0 indexed) should
     * always be 1. This is essentially a large right shift on mant.*/
    if (n) {
        /* Two or more digits */
        uint64_t d1 = mant->digits[n - 1]; /* MSD (non-zero) */
        uint64_t d2 = (n == 1) ? mant->first_digit : mant->digits[n - 2];
        uint64_t d3 = (n > 2) ? mant->digits[n - 3] : (n == 2) ? mant->first_digit : 0;
        int lz = clz((uint32_t) d1);
        int nbits = 32 - lz;
        /* First get 54 bits */
        top53 = (d2 << (54 - BIGNAT_NBIT)) + (d3 >> (2 * BIGNAT_NBIT - 54));
        top53 >>= nbits;
        top53 |= (d1 << (54 - nbits));
        /* Rounding based on lowest bit of 54 */
        if (top53 & 1) top53++;
        top53 >>= 1;
        if (top53 > 0x1FffffFFFFffffUL) {
            top53 >>= 1;
            exponent2++;
        }
        /* Correct exponent - to correct for large right shift to mantissa. */
        exponent2 += (nbits - 53) + BIGNAT_NBIT * n;
    } else {
        /* One digit */
        top53 = mant->first_digit;
    }
    return ldexp((double)top53, exponent2);
}

/* Read in a mantissa and exponent of a certain base, and give
 * back the double value. Should properly handle 0s, infinities, and
 * denormalized numbers. (When the exponent values are too large or small) */
static double convert(
    int negative,
    struct BigNat *mant,
    int32_t base,
    int32_t exponent) {

    int32_t exponent2 = 0;

    /* Approximate exponent in base 2 of mant and exponent. This should get us a good estimate of the final size of the
     * number, within * 2^32 or so. */
    int64_t mant_exp2_approx = mant->n * 32 + 16;
    int64_t exp_exp2_approx = (int64_t)(floor(log2(base) * exponent));
    int64_t exp2_approx = mant_exp2_approx + exp_exp2_approx;

    /* Short circuit zero, huge, and small numbers. We use the exponent range of valid IEEE754 doubles (-1022, 1023)
     * with a healthy buffer to allow for inaccuracies in the approximation and denormailzed numbers. */
    if (mant->n == 0 && mant->first_digit == 0)
        return negative ? -0.0 : 0.0;
    if (exp2_approx > 1176)
        return negative ? -INFINITY : INFINITY;
    if (exp2_approx < -1175)
        return negative ? -0.0 : 0.0;

    /* Final value is X = mant * base ^ exponent * 2 ^ exponent2
     * Get exponent to zero while holding X constant. */

    /* Positive exponents are simple */
    for (; exponent > 3; exponent -= 4) bignat_muladd(mant, base * base * base * base, 0);
    for (; exponent > 1; exponent -= 2) bignat_muladd(mant, base * base, 0);
    for (; exponent > 0; exponent -= 1) bignat_muladd(mant, base, 0);

    /* Negative exponents are tricky - we don't want to loose bits
     * from integer division, so we need to premultiply. */
    if (exponent < 0) {
        int32_t shamt = 5 - exponent / 4;
        bignat_lshift_n(mant, shamt);
        exponent2 -= shamt * BIGNAT_NBIT;
        for (; exponent < -3; exponent += 4) bignat_div(mant, base * base * base * base);
        for (; exponent < -1; exponent += 2) bignat_div(mant, base * base);
        for (; exponent <  0; exponent += 1) bignat_div(mant, base);
    }

    return negative
           ? -bignat_extract(mant, exponent2)
           : bignat_extract(mant, exponent2);
}

/* Scan a real (double) from a string. If the string cannot be converted into
 * and integer, set *err to 1 and return 0. */
int janet_scan_number(
    const uint8_t *str,
    int32_t len,
    double *out) {
    const uint8_t *end = str + len;
    int seenadigit = 0;
    int ex = 0;
    int base = 10;
    int seenpoint = 0;
    int foundexp = 0;
    int neg = 0;
    struct BigNat mant;
    bignat_zero(&mant);

    /* Prevent some kinds of overflow bugs relating to the exponent
     * overflowing.  For example, if a string was passed 2GB worth of 0s after
     * the decimal point, exponent could wrap around and become positive. It's
     * easier to reject ridiculously large inputs than to check for overflows.
     * */
    if (len > INT32_MAX / 40) goto error;

    /* Get sign */
    if (str >= end) goto error;
    if (*str == '-') {
        neg = 1;
        str++;
    } else if (*str == '+') {
        str++;
    }

    /* Check for leading 0x or digit digit r */
    if (str + 1 < end && str[0] == '0' && str[1] == 'x') {
        base = 16;
        str += 2;
    } else if (str + 1 < end  &&
               str[0] >= '0' && str[0] <= '9' &&
               str[1] == 'r') {
        base = str[0] - '0';
        str += 2;
    } else if (str + 2 < end  &&
               str[0] >= '0' && str[0] <= '9' &&
               str[1] >= '0' && str[1] <= '9' &&
               str[2] == 'r') {
        base = 10 * (str[0] - '0') + (str[1] - '0');
        if (base < 2 || base > 36) goto error;
        str += 3;
    }

    /* Skip leading zeros */
    while (str < end && (*str == '0' || *str == '.')) {
        if (seenpoint) ex--;
        if (*str == '.') {
            if (seenpoint) goto error;
            seenpoint = 1;
        } else {
            seenadigit = 1;
        }
        str++;
    }

    /* Parse significant digits */
    while (str < end) {
        if (*str == '.') {
            if (seenpoint) goto error;
            seenpoint = 1;
        } else if (*str == '&') {
            foundexp = 1;
            break;
        } else if (base == 10 && (*str == 'E' || *str == 'e')) {
            foundexp = 1;
            break;
        } else if (*str == '_') {
            if (!seenadigit) goto error;
        } else {
            int digit = digit_lookup[*str & 0x7F];
            if (*str > 127 || digit >= base) goto error;
            if (seenpoint) ex--;
            bignat_muladd(&mant, base, digit);
            seenadigit = 1;
        }
        str++;
    }

    if (!seenadigit)
        goto error;

    /* Read exponent */
    if (str < end && foundexp) {
        int eneg = 0;
        int32_t ee = 0;
        seenadigit = 0;
        str++;
        if (str >= end) goto error;
        if (*str == '-') {
            eneg = 1;
            str++;
        } else if (*str == '+') {
            str++;
        }
        /* Skip leading 0s in exponent */
        while (str < end && *str == '0') {
            str++;
            seenadigit = 1;
        }
        while (str < end) {
            int digit = digit_lookup[*str & 0x7F];
            if (*str > 127 || digit >= base) goto error;
            if (ee < (INT32_MAX / 40)) {
                ee = base * ee + digit;
            }
            str++;
            seenadigit = 1;
        }
        if (eneg) ex -= ee;
        else ex += ee;
    }

    if (!seenadigit)
        goto error;

    *out = convert(neg, &mant, base, ex);
    free(mant.digits);
    return 0;

error:
    free(mant.digits);
    return 1;
}

#ifdef JANET_INT_TYPES

static int scan_uint64(
    const uint8_t *str,
    int32_t len,
    uint64_t *out,
    int *neg) {
    const uint8_t *end = str + len;
    int seenadigit = 0;
    int base = 10;
    *neg = 0;
    *out = 0;
    uint64_t accum = 0;
    /* len max is INT64_MAX in base 2 with _ between each bits */
    /* '2r' + 64 bits + 63 _  + sign = 130 => 150 for some leading  */
    /* zeros */
    if (len > 150) return 0;
    /* Get sign */
    if (str >= end) return 0;
    if (*str == '-') {
        *neg = 1;
        str++;
    } else if (*str == '+') {
        str++;
    }
    /* Check for leading 0x or digit digit r */
    if (str + 1 < end && str[0] == '0' && str[1] == 'x') {
        base = 16;
        str += 2;
    } else if (str + 1 < end  &&
               str[0] >= '0' && str[0] <= '9' &&
               str[1] == 'r') {
        base = str[0] - '0';
        str += 2;
    } else if (str + 2 < end  &&
               str[0] >= '0' && str[0] <= '9' &&
               str[1] >= '0' && str[1] <= '9' &&
               str[2] == 'r') {
        base = 10 * (str[0] - '0') + (str[1] - '0');
        if (base < 2 || base > 36) return 0;
        str += 3;
    }

    /* Skip leading zeros */
    while (str < end && *str == '0') {
        seenadigit = 1;
        str++;
    }
    /* Parse significant digits */
    while (str < end) {
        if (*str == '_') {
            if (!seenadigit) return 0;
        } else {
            int digit = digit_lookup[*str & 0x7F];
            if (*str > 127 || digit >= base) return 0;
            if (accum > (UINT64_MAX - digit) / base) return 0;
            accum = accum * base + digit;
            seenadigit = 1;
        }
        str++;
    }

    if (!seenadigit) return 0;
    *out = accum;
    return 1;
}

int janet_scan_int64(const uint8_t *str, int32_t len, int64_t *out) {
    int neg;
    uint64_t bi;
    if (scan_uint64(str, len, &bi, &neg)) {
        if (neg && bi <= (UINT64_MAX / 2)) {
            if (bi > INT64_MAX) {
                *out = INT64_MIN;
            } else {
                *out = -((int64_t) bi);
            }
            return 1;
        }
        if (!neg && bi <= INT64_MAX) {
            *out = (int64_t) bi;
            return 1;
        }
    }
    return 0;
}

int janet_scan_uint64(const uint8_t *str, int32_t len, uint64_t *out) {
    int neg;
    uint64_t bi;
    if (scan_uint64(str, len, &bi, &neg)) {
        if (!neg) {
            *out = bi;
            return 1;
        }
    }
    return 0;
}

#endif


/* src/core/struct.c */
#line 0 "src/core/struct.c"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "gc.h"
#include "util.h"
#include <math.h>
#endif

/* Begin creation of a struct */
JanetKV *janet_struct_begin(int32_t count) {
    /* Calculate capacity as power of 2 after 2 * count. */
    int32_t capacity = janet_tablen(2 * count);
    if (capacity < 0) capacity = janet_tablen(count + 1);

    size_t size = sizeof(JanetStructHead) + (size_t) capacity * sizeof(JanetKV);
    JanetStructHead *head = janet_gcalloc(JANET_MEMORY_STRUCT, size);
    head->length = count;
    head->capacity = capacity;
    head->hash = 0;

    JanetKV *st = (JanetKV *)(head->data);
    janet_memempty(st, capacity);
    return st;
}

/* Find an item in a struct. Should be similar to janet_dict_find, but
 * specialized to structs (slightly more compact). */
const JanetKV *janet_struct_find(const JanetKV *st, Janet key) {
    int32_t cap = janet_struct_capacity(st);
    int32_t index = janet_maphash(cap, janet_hash(key));
    int32_t i;
    for (i = index; i < cap; i++)
        if (janet_checktype(st[i].key, JANET_NIL) || janet_equals(st[i].key, key))
            return st + i;
    for (i = 0; i < index; i++)
        if (janet_checktype(st[i].key, JANET_NIL) || janet_equals(st[i].key, key))
            return st + i;
    return NULL;
}

/* Put a kv pair into a struct that has not yet been fully constructed.
 * Nil keys and values are ignored, extra keys are ignore, and duplicate keys are
 * ignored.
 *
 * Runs will be in sorted order, as the collisions resolver essentially
 * preforms an in-place insertion sort. This ensures the internal structure of the
 * hash map is independent of insertion order.
 */
void janet_struct_put(JanetKV *st, Janet key, Janet value) {
    int32_t cap = janet_struct_capacity(st);
    int32_t hash = janet_hash(key);
    int32_t index = janet_maphash(cap, hash);
    int32_t i, j, dist;
    int32_t bounds[4] = {index, cap, 0, index};
    if (janet_checktype(key, JANET_NIL) || janet_checktype(value, JANET_NIL)) return;
    if (janet_checktype(key, JANET_NUMBER) && isnan(janet_unwrap_number(key))) return;
    /* Avoid extra items */
    if (janet_struct_hash(st) == janet_struct_length(st)) return;
    for (dist = 0, j = 0; j < 4; j += 2)
        for (i = bounds[j]; i < bounds[j + 1]; i++, dist++) {
            int status;
            int32_t otherhash;
            int32_t otherindex, otherdist;
            JanetKV *kv = st + i;
            /* We found an empty slot, so just add key and value */
            if (janet_checktype(kv->key, JANET_NIL)) {
                kv->key = key;
                kv->value = value;
                /* Update the temporary count */
                janet_struct_hash(st)++;
                return;
            }
            /* Robinhood hashing - check if colliding kv pair
             * is closer to their source than current. We use robinhood
             * hashing to ensure that equivalent structs that are constructed
             * with different order have the same internal layout, and therefor
             * will compare properly - i.e., {1 2 3 4} should equal {3 4 1 2}.
             * Collisions are resolved via an insertion sort insertion. */
            otherhash = janet_hash(kv->key);
            otherindex = janet_maphash(cap, otherhash);
            otherdist = (i + cap - otherindex) & (cap - 1);
            if (dist < otherdist)
                status = -1;
            else if (otherdist < dist)
                status = 1;
            else if (hash < otherhash)
                status = -1;
            else if (otherhash < hash)
                status = 1;
            else
                status = janet_compare(key, kv->key);
            /* If other is closer to their ideal slot */
            if (status == 1) {
                /* Swap current kv pair with pair in slot */
                JanetKV temp = *kv;
                kv->key = key;
                kv->value = value;
                key = temp.key;
                value = temp.value;
                /* Save dist and hash of new kv pair */
                dist = otherdist;
                hash = otherhash;
            } else if (status == 0) {
                /* A key was added to the struct more than once - replace old value */
                kv->value = value;
                return;
            }
        }
}

/* Finish building a struct */
const JanetKV *janet_struct_end(JanetKV *st) {
    if (janet_struct_hash(st) != janet_struct_length(st)) {
        /* Error building struct, probably duplicate values. We need to rebuild
         * the struct using only the values that went in. The second creation should always
         * succeed. */
        JanetKV *newst = janet_struct_begin(janet_struct_hash(st));
        for (int32_t i = 0; i < janet_struct_capacity(st); i++) {
            JanetKV *kv = st + i;
            if (!janet_checktype(kv->key, JANET_NIL)) {
                janet_struct_put(newst, kv->key, kv->value);
            }
        }
        st = newst;
    }
    janet_struct_hash(st) = janet_kv_calchash(st, janet_struct_capacity(st));
    return (const JanetKV *)st;
}

/* Get an item from a struct */
Janet janet_struct_get(const JanetKV *st, Janet key) {
    const JanetKV *kv = janet_struct_find(st, key);
    return kv ? kv->value : janet_wrap_nil();
}

/* Convert struct to table */
JanetTable *janet_struct_to_table(const JanetKV *st) {
    JanetTable *table = janet_table(janet_struct_capacity(st));
    int32_t i;
    for (i = 0; i < janet_struct_capacity(st); i++) {
        const JanetKV *kv = st + i;
        if (!janet_checktype(kv->key, JANET_NIL)) {
            janet_table_put(table, kv->key, kv->value);
        }
    }
    return table;
}


/* src/core/symcache.c */
#line 0 "src/core/symcache.c"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

/* The symbol cache is an open hashtable with all active symbols in the program
 * stored in it. As the primary use of symbols is table lookups and equality
 * checks, all symbols are interned so that there is a single copy of it in the
 * whole program. Equality is then just a pointer check. */

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "state.h"
#include "gc.h"
#include "util.h"
#include "symcache.h"
#endif

#include <string.h>

/* Cache state */
JANET_THREAD_LOCAL const uint8_t **janet_vm_cache = NULL;
JANET_THREAD_LOCAL uint32_t janet_vm_cache_capacity = 0;
JANET_THREAD_LOCAL uint32_t janet_vm_cache_count = 0;
JANET_THREAD_LOCAL uint32_t janet_vm_cache_deleted = 0;

/* Initialize the cache (allocate cache memory) */
void janet_symcache_init() {
    janet_vm_cache_capacity = 1024;
    janet_vm_cache = calloc(1, (size_t) janet_vm_cache_capacity * sizeof(const uint8_t *));
    if (NULL == janet_vm_cache) {
        JANET_OUT_OF_MEMORY;
    }
    janet_vm_cache_count = 0;
    janet_vm_cache_deleted = 0;
}

/* Deinitialize the cache (free the cache memory) */
void janet_symcache_deinit() {
    free((void *)janet_vm_cache);
    janet_vm_cache = NULL;
    janet_vm_cache_capacity = 0;
    janet_vm_cache_count = 0;
    janet_vm_cache_deleted = 0;
}

/* Mark an entry in the table as deleted. */
static const uint8_t JANET_SYMCACHE_DELETED[1] = {0};

/* Find an item in the cache and return its location.
 * If the item is not found, return the location
 * where one would put it. */
static const uint8_t **janet_symcache_findmem(
    const uint8_t *str,
    int32_t len,
    int32_t hash,
    int *success) {
    uint32_t bounds[4];
    uint32_t i, j, index;
    const uint8_t **firstEmpty = NULL;

    /* We will search two ranges - index to the end,
     * and 0 to the index. */
    index = (uint32_t)hash & (janet_vm_cache_capacity - 1);
    bounds[0] = index;
    bounds[1] = janet_vm_cache_capacity;
    bounds[2] = 0;
    bounds[3] = index;
    for (j = 0; j < 4; j += 2)
        for (i = bounds[j]; i < bounds[j + 1]; ++i) {
            const uint8_t *test = janet_vm_cache[i];
            /* Check empty spots */
            if (NULL == test) {
                if (NULL == firstEmpty)
                    firstEmpty = janet_vm_cache + i;
                goto notfound;
            }
            /* Check for marked deleted */
            if (JANET_SYMCACHE_DELETED == test) {
                if (firstEmpty == NULL)
                    firstEmpty = janet_vm_cache + i;
                continue;
            }
            if (janet_string_equalconst(test, str, len, hash)) {
                /* Replace first deleted */
                *success = 1;
                if (firstEmpty != NULL) {
                    *firstEmpty = test;
                    janet_vm_cache[i] = JANET_SYMCACHE_DELETED;
                    return firstEmpty;
                }
                return janet_vm_cache + i;
            }
        }
notfound:
    *success = 0;
    return firstEmpty;
}

#define janet_symcache_find(str, success) \
    janet_symcache_findmem((str), janet_string_length(str), janet_string_hash(str), (success))

/* Resize the cache. */
static void janet_cache_resize(uint32_t newCapacity) {
    uint32_t i, oldCapacity;
    const uint8_t **oldCache = janet_vm_cache;
    const uint8_t **newCache = calloc(1, (size_t) newCapacity * sizeof(const uint8_t *));
    if (newCache == NULL) {
        JANET_OUT_OF_MEMORY;
    }
    oldCapacity = janet_vm_cache_capacity;
    janet_vm_cache = newCache;
    janet_vm_cache_capacity = newCapacity;
    janet_vm_cache_deleted = 0;
    /* Add all of the old cache entries back */
    for (i = 0; i < oldCapacity; ++i) {
        int status;
        const uint8_t **bucket;
        const uint8_t *x = oldCache[i];
        if (x != NULL && x != JANET_SYMCACHE_DELETED) {
            bucket = janet_symcache_find(x, &status);
            if (status || bucket == NULL) {
                /* there was a problem with the algorithm. */
                break;
            }
            *bucket = x;
        }
    }
    /* Free the old cache */
    free((void *)oldCache);
}

/* Add an item to the cache */
static void janet_symcache_put(const uint8_t *x, const uint8_t **bucket) {
    if ((janet_vm_cache_count + janet_vm_cache_deleted) * 2 > janet_vm_cache_capacity) {
        int status;
        janet_cache_resize(janet_tablen((2 * janet_vm_cache_count + 1)));
        bucket = janet_symcache_find(x, &status);
    }
    /* Add x to the cache */
    janet_vm_cache_count++;
    *bucket = x;
}

/* Remove a symbol from the symcache */
void janet_symbol_deinit(const uint8_t *sym) {
    int status = 0;
    const uint8_t **bucket = janet_symcache_find(sym, &status);
    if (status) {
        janet_vm_cache_count--;
        janet_vm_cache_deleted++;
        *bucket = JANET_SYMCACHE_DELETED;
    }
}

/* Create a symbol from a byte string */
const uint8_t *janet_symbol(const uint8_t *str, int32_t len) {
    int32_t hash = janet_string_calchash(str, len);
    uint8_t *newstr;
    int success = 0;
    const uint8_t **bucket = janet_symcache_findmem(str, len, hash, &success);
    if (success)
        return *bucket;
    JanetStringHead *head = janet_gcalloc(JANET_MEMORY_SYMBOL, sizeof(JanetStringHead) + (size_t) len + 1);
    head->hash = hash;
    head->length = len;
    newstr = (uint8_t *)(head->data);
    safe_memcpy(newstr, str, len);
    newstr[len] = 0;
    janet_symcache_put((const uint8_t *)newstr, bucket);
    return newstr;
}

/* Get a symbol from a cstring */
const uint8_t *janet_csymbol(const char *cstr) {
    return janet_symbol((const uint8_t *)cstr, (int32_t) strlen(cstr));
}

/* Store counter for genysm to avoid quadratic behavior */
JANET_THREAD_LOCAL uint8_t gensym_counter[8] = {'_', '0', '0', '0', '0', '0', '0', 0};

/* Increment the gensym buffer */
static void inc_gensym(void) {
    for (int i = sizeof(gensym_counter) - 2; i; i--) {
        if (gensym_counter[i] == '9') {
            gensym_counter[i] = 'a';
            break;
        } else if (gensym_counter[i] == 'z') {
            gensym_counter[i] = 'A';
            break;
        } else if (gensym_counter[i] == 'Z') {
            gensym_counter[i] = '0';
        } else {
            gensym_counter[i]++;
            break;
        }
    }
}

/* Generate a unique symbol. This is used in the library function gensym. The
 * symbol will be of the format _XXXXXX, where X is a base64 digit, and
 * prefix is the argument passed. No prefix for speed. */
const uint8_t *janet_symbol_gen(void) {
    const uint8_t **bucket = NULL;
    uint8_t *sym;
    int32_t hash = 0;
    int status;
    /* Leave spaces for 6 base 64 digits and two dashes. That means 64^6 possible suffixes, which
     * is enough for resolving collisions. */
    do {
        hash = janet_string_calchash(
                   gensym_counter,
                   sizeof(gensym_counter) - 1);
        bucket = janet_symcache_findmem(
                     gensym_counter,
                     sizeof(gensym_counter) - 1,
                     hash,
                     &status);
    } while (status && (inc_gensym(), 1));
    JanetStringHead *head = janet_gcalloc(JANET_MEMORY_SYMBOL, sizeof(JanetStringHead) + sizeof(gensym_counter));
    head->length = sizeof(gensym_counter) - 1;
    head->hash = hash;
    sym = (uint8_t *)(head->data);
    memcpy(sym, gensym_counter, sizeof(gensym_counter));
    janet_symcache_put((const uint8_t *)sym, bucket);
    return (const uint8_t *)sym;
}


/* src/core/table.c */
#line 0 "src/core/table.c"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "gc.h"
#include "util.h"
#include <math.h>
#endif

#define JANET_TABLE_FLAG_STACK 0x10000

static void *janet_memalloc_empty_local(int32_t count) {
    int32_t i;
    void *mem = janet_smalloc((size_t) count * sizeof(JanetKV));
    JanetKV *mmem = (JanetKV *)mem;
    for (i = 0; i < count; i++) {
        JanetKV *kv = mmem + i;
        kv->key = janet_wrap_nil();
        kv->value = janet_wrap_nil();
    }
    return mem;
}

static JanetTable *janet_table_init_impl(JanetTable *table, int32_t capacity, int stackalloc) {
    JanetKV *data;
    capacity = janet_tablen(capacity);
    if (stackalloc) table->gc.flags = JANET_TABLE_FLAG_STACK;
    if (capacity) {
        if (stackalloc) {
            data = janet_memalloc_empty_local(capacity);
        } else {
            data = (JanetKV *) janet_memalloc_empty(capacity);
            if (NULL == data) {
                JANET_OUT_OF_MEMORY;
            }
        }
        table->data = data;
        table->capacity = capacity;
    } else {
        table->data = NULL;
        table->capacity = 0;
    }
    table->count = 0;
    table->deleted = 0;
    table->proto = NULL;
    return table;
}

/* Initialize a table */
JanetTable *janet_table_init(JanetTable *table, int32_t capacity) {
    return janet_table_init_impl(table, capacity, 1);
}

/* Deinitialize a table */
void janet_table_deinit(JanetTable *table) {
    janet_sfree(table->data);
}

/* Create a new table */
JanetTable *janet_table(int32_t capacity) {
    JanetTable *table = janet_gcalloc(JANET_MEMORY_TABLE, sizeof(JanetTable));
    return janet_table_init_impl(table, capacity, 0);
}

/* Find the bucket that contains the given key. Will also return
 * bucket where key should go if not in the table. */
JanetKV *janet_table_find(JanetTable *t, Janet key) {
    return (JanetKV *) janet_dict_find(t->data, t->capacity, key);
}

/* Resize the dictionary table. */
static void janet_table_rehash(JanetTable *t, int32_t size) {
    JanetKV *olddata = t->data;
    JanetKV *newdata;
    int islocal = t->gc.flags & JANET_TABLE_FLAG_STACK;
    if (islocal) {
        newdata = (JanetKV *) janet_memalloc_empty_local(size);
    } else {
        newdata = (JanetKV *) janet_memalloc_empty(size);
        if (NULL == newdata) {
            JANET_OUT_OF_MEMORY;
        }
    }
    int32_t i, oldcapacity;
    oldcapacity = t->capacity;
    t->data = newdata;
    t->capacity = size;
    t->deleted = 0;
    for (i = 0; i < oldcapacity; i++) {
        JanetKV *kv = olddata + i;
        if (!janet_checktype(kv->key, JANET_NIL)) {
            JanetKV *newkv = janet_table_find(t, kv->key);
            *newkv = *kv;
        }
    }
    if (islocal) {
        janet_sfree(olddata);
    } else {
        free(olddata);
    }
}

/* Get a value out of the table */
Janet janet_table_get(JanetTable *t, Janet key) {
    JanetKV *bucket = janet_table_find(t, key);
    if (NULL != bucket && !janet_checktype(bucket->key, JANET_NIL))
        return bucket->value;
    /* Check prototypes */
    {
        int i;
        for (i = JANET_MAX_PROTO_DEPTH, t = t->proto; t && i; t = t->proto, --i) {
            bucket = janet_table_find(t, key);
            if (NULL != bucket && !janet_checktype(bucket->key, JANET_NIL))
                return bucket->value;
        }
    }
    return janet_wrap_nil();
}

/* Get a value out of the table, and record which prototype it was from. */
Janet janet_table_get_ex(JanetTable *t, Janet key, JanetTable **which) {
    JanetKV *bucket = janet_table_find(t, key);
    if (NULL != bucket && !janet_checktype(bucket->key, JANET_NIL)) {
        *which = t;
        return bucket->value;
    }
    /* Check prototypes */
    {
        int i;
        for (i = JANET_MAX_PROTO_DEPTH, t = t->proto; t && i; t = t->proto, --i) {
            bucket = janet_table_find(t, key);
            if (NULL != bucket && !janet_checktype(bucket->key, JANET_NIL)) {
                *which = t;
                return bucket->value;
            }
        }
    }
    return janet_wrap_nil();
}

/* Get a value out of the table. Don't check prototype tables. */
Janet janet_table_rawget(JanetTable *t, Janet key) {
    JanetKV *bucket = janet_table_find(t, key);
    if (NULL != bucket && !janet_checktype(bucket->key, JANET_NIL))
        return bucket->value;
    else
        return janet_wrap_nil();
}

/* Remove an entry from the dictionary. Return the value that
 * was removed. */
Janet janet_table_remove(JanetTable *t, Janet key) {
    JanetKV *bucket = janet_table_find(t, key);
    if (NULL != bucket && !janet_checktype(bucket->key, JANET_NIL)) {
        Janet ret = bucket->key;
        t->count--;
        t->deleted++;
        bucket->key = janet_wrap_nil();
        bucket->value = janet_wrap_false();
        return ret;
    } else {
        return janet_wrap_nil();
    }
}

/* Put a value into the object */
void janet_table_put(JanetTable *t, Janet key, Janet value) {
    if (janet_checktype(key, JANET_NIL)) return;
    if (janet_checktype(key, JANET_NUMBER) && isnan(janet_unwrap_number(key))) return;
    if (janet_checktype(value, JANET_NIL)) {
        janet_table_remove(t, key);
    } else {
        JanetKV *bucket = janet_table_find(t, key);
        if (NULL != bucket && !janet_checktype(bucket->key, JANET_NIL)) {
            bucket->value = value;
        } else {
            if (NULL == bucket || 2 * (t->count + t->deleted + 1) > t->capacity) {
                janet_table_rehash(t, janet_tablen(2 * t->count + 2));
            }
            bucket = janet_table_find(t, key);
            if (janet_checktype(bucket->value, JANET_BOOLEAN))
                --t->deleted;
            bucket->key = key;
            bucket->value = value;
            ++t->count;
        }
    }
}

/* Clear a table */
void janet_table_clear(JanetTable *t) {
    int32_t capacity = t->capacity;
    JanetKV *data = t->data;
    janet_memempty(data, capacity);
    t->count = 0;
    t->deleted = 0;
}

/* Convert table to struct */
const JanetKV *janet_table_to_struct(JanetTable *t) {
    JanetKV *st = janet_struct_begin(t->count);
    JanetKV *kv = t->data;
    JanetKV *end = t->data + t->capacity;
    while (kv < end) {
        if (!janet_checktype(kv->key, JANET_NIL))
            janet_struct_put(st, kv->key, kv->value);
        kv++;
    }
    return janet_struct_end(st);
}

/* Clone a table. */
JanetTable *janet_table_clone(JanetTable *table) {
    JanetTable *newTable = janet_gcalloc(JANET_MEMORY_TABLE, sizeof(JanetTable));
    newTable->count = table->count;
    newTable->capacity = table->capacity;
    newTable->deleted = table->deleted;
    newTable->proto = table->proto;
    newTable->data = malloc(newTable->capacity * sizeof(JanetKV));
    if (NULL == newTable->data) {
        JANET_OUT_OF_MEMORY;
    }
    memcpy(newTable->data, table->data, (size_t) table->capacity * sizeof(JanetKV));
    return newTable;
}

/* Merge a table or struct into a table */
static void janet_table_mergekv(JanetTable *table, const JanetKV *kvs, int32_t cap) {
    int32_t i;
    for (i = 0; i < cap; i++) {
        const JanetKV *kv = kvs + i;
        if (!janet_checktype(kv->key, JANET_NIL)) {
            janet_table_put(table, kv->key, kv->value);
        }
    }
}

/* Merge a table other into another table */
void janet_table_merge_table(JanetTable *table, JanetTable *other) {
    janet_table_mergekv(table, other->data, other->capacity);
}

/* Merge a struct into a table */
void janet_table_merge_struct(JanetTable *table, const JanetKV *other) {
    janet_table_mergekv(table, other, janet_struct_capacity(other));
}

/* C Functions */

static Janet cfun_table_new(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    int32_t cap = janet_getinteger(argv, 0);
    return janet_wrap_table(janet_table(cap));
}

static Janet cfun_table_getproto(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    JanetTable *t = janet_gettable(argv, 0);
    return t->proto
           ? janet_wrap_table(t->proto)
           : janet_wrap_nil();
}

static Janet cfun_table_setproto(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 2);
    JanetTable *table = janet_gettable(argv, 0);
    JanetTable *proto = NULL;
    if (!janet_checktype(argv[1], JANET_NIL)) {
        proto = janet_gettable(argv, 1);
    }
    table->proto = proto;
    return argv[0];
}

static Janet cfun_table_tostruct(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    JanetTable *t = janet_gettable(argv, 0);
    return janet_wrap_struct(janet_table_to_struct(t));
}

static Janet cfun_table_rawget(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 2);
    JanetTable *table = janet_gettable(argv, 0);
    return janet_table_rawget(table, argv[1]);
}

static Janet cfun_table_clone(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    JanetTable *table = janet_gettable(argv, 0);
    return janet_wrap_table(janet_table_clone(table));
}

static const JanetReg table_cfuns[] = {
    {
        "table/new", cfun_table_new,
        JDOC("(table/new capacity)\n\n"
             "Creates a new empty table with pre-allocated memory "
             "for capacity entries. This means that if one knows the number of "
             "entries going to go in a table on creation, extra memory allocation "
             "can be avoided. Returns the new table.")
    },
    {
        "table/to-struct", cfun_table_tostruct,
        JDOC("(table/to-struct tab)\n\n"
             "Convert a table to a struct. Returns a new struct. This function "
             "does not take into account prototype tables.")
    },
    {
        "table/getproto", cfun_table_getproto,
        JDOC("(table/getproto tab)\n\n"
             "Get the prototype table of a table. Returns nil if a table "
             "has no prototype, otherwise returns the prototype.")
    },
    {
        "table/setproto", cfun_table_setproto,
        JDOC("(table/setproto tab proto)\n\n"
             "Set the prototype of a table. Returns the original table tab.")
    },
    {
        "table/rawget", cfun_table_rawget,
        JDOC("(table/rawget tab key)\n\n"
             "Gets a value from a table without looking at the prototype table. "
             "If a table tab does not contain t directly, the function will return "
             "nil without checking the prototype. Returns the value in the table.")
    },
    {
        "table/clone", cfun_table_clone,
        JDOC("(table/clone tab)\n\n"
             "Create a copy of a table. Updates to the new table will not change the old table, "
             "and vice versa.")
    },
    {NULL, NULL, NULL}
};

/* Load the table module */
void janet_lib_table(JanetTable *env) {
    janet_core_cfuns(env, NULL, table_cfuns);
}


/* src/core/thread.c */
#line 0 "src/core/thread.c"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "gc.h"
#include "util.h"
#include "state.h"
#endif

#ifdef JANET_THREADS

#include <math.h>
#ifdef JANET_WINDOWS
#include <windows.h>
#else
#include <setjmp.h>
#include <time.h>
#include <pthread.h>
#endif

/* typedefed in janet.h */
struct JanetMailbox {

    /* Synchronization */
#ifdef JANET_WINDOWS
    CRITICAL_SECTION lock;
    CONDITION_VARIABLE cond;
#else
    pthread_mutex_t lock;
    pthread_cond_t cond;
#endif

    /* Memory management - reference counting */
    int refCount;
    int closed;

    /* Store messages */
    uint16_t messageCapacity;
    uint16_t messageCount;
    uint16_t messageFirst;
    uint16_t messageNext;

    /* Buffers to store messages. These buffers are manually allocated, so
     * are not owned by any thread's GC. */
    JanetBuffer messages[];
};

#define JANET_THREAD_HEAVYWEIGHT 0x1
#define JANET_THREAD_ABSTRACTS 0x2
#define JANET_THREAD_CFUNCTIONS 0x4
static const char janet_thread_flags[] = "hac";

typedef struct {
    JanetMailbox *original;
    JanetMailbox *newbox;
    uint64_t flags;
} JanetMailboxPair;

static JANET_THREAD_LOCAL JanetMailbox *janet_vm_mailbox = NULL;
static JANET_THREAD_LOCAL JanetThread *janet_vm_thread_current = NULL;
static JANET_THREAD_LOCAL JanetTable *janet_vm_thread_decode = NULL;

static JanetTable *janet_thread_get_decode(void) {
    if (janet_vm_thread_decode == NULL) {
        janet_vm_thread_decode = janet_get_core_table("load-image-dict");
        janet_gcroot(janet_wrap_table(janet_vm_thread_decode));
    }
    return janet_vm_thread_decode;
}

static JanetMailbox *janet_mailbox_create(int refCount, uint16_t capacity) {
    JanetMailbox *mailbox = malloc(sizeof(JanetMailbox) + sizeof(JanetBuffer) * (size_t) capacity);
    if (NULL == mailbox) {
        JANET_OUT_OF_MEMORY;
    }
#ifdef JANET_WINDOWS
    InitializeCriticalSection(&mailbox->lock);
    InitializeConditionVariable(&mailbox->cond);
#else
    pthread_mutex_init(&mailbox->lock, NULL);
    pthread_cond_init(&mailbox->cond, NULL);
#endif
    mailbox->refCount = refCount;
    mailbox->closed = 0;
    mailbox->messageCount = 0;
    mailbox->messageCapacity = capacity;
    mailbox->messageFirst = 0;
    mailbox->messageNext = 0;
    for (uint16_t i = 0; i < capacity; i++) {
        janet_buffer_init(mailbox->messages + i, 0);
    }
    return mailbox;
}

static void janet_mailbox_destroy(JanetMailbox *mailbox) {
#ifdef JANET_WINDOWS
    DeleteCriticalSection(&mailbox->lock);
#else
    pthread_mutex_destroy(&mailbox->lock);
    pthread_cond_destroy(&mailbox->cond);
#endif
    for (uint16_t i = 0; i < mailbox->messageCapacity; i++) {
        janet_buffer_deinit(mailbox->messages + i);
    }
    free(mailbox);
}

static void janet_mailbox_lock(JanetMailbox *mailbox) {
#ifdef JANET_WINDOWS
    EnterCriticalSection(&mailbox->lock);
#else
    pthread_mutex_lock(&mailbox->lock);
#endif
}

static void janet_mailbox_unlock(JanetMailbox *mailbox) {
#ifdef JANET_WINDOWS
    LeaveCriticalSection(&mailbox->lock);
#else
    pthread_mutex_unlock(&mailbox->lock);
#endif
}

/* Assumes you have the mailbox lock already */
static void janet_mailbox_ref_with_lock(JanetMailbox *mailbox, int delta) {
    mailbox->refCount += delta;
    if (mailbox->refCount <= 0) {
        janet_mailbox_unlock(mailbox);
        janet_mailbox_destroy(mailbox);
    } else {
        janet_mailbox_unlock(mailbox);
    }
}

static void janet_mailbox_ref(JanetMailbox *mailbox, int delta) {
    janet_mailbox_lock(mailbox);
    janet_mailbox_ref_with_lock(mailbox, delta);
}

static void janet_close_thread(JanetThread *thread) {
    if (thread->mailbox) {
        janet_mailbox_ref(thread->mailbox, -1);
        thread->mailbox = NULL;
    }
}

static int thread_gc(void *p, size_t size) {
    (void) size;
    JanetThread *thread = (JanetThread *)p;
    janet_close_thread(thread);
    return 0;
}

static int thread_mark(void *p, size_t size) {
    (void) size;
    JanetThread *thread = (JanetThread *)p;
    if (thread->encode) {
        janet_mark(janet_wrap_table(thread->encode));
    }
    return 0;
}

static JanetMailboxPair *make_mailbox_pair(JanetMailbox *original, uint64_t flags) {
    JanetMailboxPair *pair = malloc(sizeof(JanetMailboxPair));
    if (NULL == pair) {
        JANET_OUT_OF_MEMORY;
    }
    pair->original = original;
    janet_mailbox_ref(original, 1);
    pair->newbox = janet_mailbox_create(1, 16);
    pair->flags = flags;
    return pair;
}

static void destroy_mailbox_pair(JanetMailboxPair *pair) {
    janet_mailbox_ref(pair->original, -1);
    janet_mailbox_ref(pair->newbox, -1);
    free(pair);
}

/* Abstract waiting for timeout across windows/posix */
typedef struct {
    int timedwait;
    int nowait;
#ifdef JANET_WINDOWS
    DWORD interval;
    DWORD ticksLeft;
#else
    struct timespec ts;
#endif
} JanetWaiter;

static void janet_waiter_init(JanetWaiter *waiter, double sec) {
    waiter->timedwait = 0;
    waiter->nowait = 0;

    if (sec <= 0.0 || isnan(sec)) {
        waiter->nowait = 1;
        return;
    }
    waiter->timedwait = sec > 0.0 && !isinf(sec);

    /* Set maximum wait time to 30 days */
    if (sec > (60.0 * 60.0 * 24.0 * 30.0)) {
        sec = 60.0 * 60.0 * 24.0 * 30.0;
    }

#ifdef JANET_WINDOWS
    if (waiter->timedwait) {
        waiter->ticksLeft = waiter->interval = (DWORD) floor(1000.0 * sec);
    }
#else
    if (waiter->timedwait) {
        /* N seconds -> timespec of (now + sec) */
        struct timespec now;
        clock_gettime(CLOCK_REALTIME, &now);
        time_t tvsec = (time_t) floor(sec);
        long tvnsec = (long) floor(1000000000.0 * (sec - ((double) tvsec)));
        tvsec += now.tv_sec;
        tvnsec += now.tv_nsec;
        if (tvnsec >= 1000000000L) {
            tvnsec -= 1000000000L;
            tvsec += 1;
        }
        waiter->ts.tv_sec = tvsec;
        waiter->ts.tv_nsec = tvnsec;
    }
#endif
}

static int janet_waiter_wait(JanetWaiter *wait, JanetMailbox *mailbox) {
    if (wait->nowait) return 1;
#ifdef JANET_WINDOWS
    if (wait->timedwait) {
        if (wait->ticksLeft == 0) return 1;
        DWORD startTime = GetTickCount();
        int status = !SleepConditionVariableCS(&mailbox->cond, &mailbox->lock, wait->ticksLeft);
        DWORD dTick = GetTickCount() - startTime;
        /* Be careful about underflow */
        wait->ticksLeft = dTick > wait->ticksLeft ? 0 : dTick;
        return status;
    } else {
        SleepConditionVariableCS(&mailbox->cond, &mailbox->lock, INFINITE);
        return 0;
    }
#else
    if (wait->timedwait) {
        return pthread_cond_timedwait(&mailbox->cond, &mailbox->lock, &wait->ts);
    } else {
        pthread_cond_wait(&mailbox->cond, &mailbox->lock);
        return 0;
    }
#endif
}

static void janet_mailbox_wakeup(JanetMailbox *mailbox) {
#ifdef JANET_WINDOWS
    WakeConditionVariable(&mailbox->cond);
#else
    pthread_cond_signal(&mailbox->cond);
#endif
}

static int mailbox_at_capacity(JanetMailbox *mailbox) {
    return mailbox->messageCount >= mailbox->messageCapacity;
}

/* Returns 1 if could not send (encode error or timeout), 2 for mailbox closed, and
 * 0 otherwise. Will not panic.  */
int janet_thread_send(JanetThread *thread, Janet msg, double timeout) {

    /* Ensure mailbox is not closed. */
    JanetMailbox *mailbox = thread->mailbox;
    if (NULL == mailbox) return 2;
    janet_mailbox_lock(mailbox);
    if (mailbox->closed) {
        janet_mailbox_ref_with_lock(mailbox, -1);
        thread->mailbox = NULL;
        return 2;
    }

    /* Back pressure */
    if (mailbox_at_capacity(mailbox)) {
        JanetWaiter wait;
        janet_waiter_init(&wait, timeout);

        if (wait.nowait) {
            janet_mailbox_unlock(mailbox);
            return 1;
        }

        /* Retry loop, as there can be multiple writers */
        while (mailbox_at_capacity(mailbox)) {
            if (janet_waiter_wait(&wait, mailbox)) {
                janet_mailbox_unlock(mailbox);
                janet_mailbox_wakeup(mailbox);
                return 1;
            }
        }
    }

    /* Hack to capture all panics from marshalling. This works because
     * we know janet_marshal won't mess with other essential global state. */
    jmp_buf buf;
    jmp_buf *old_buf = janet_vm_jmp_buf;
    janet_vm_jmp_buf = &buf;
    int32_t oldmcount = mailbox->messageCount;

    int ret = 0;
    if (setjmp(buf)) {
        ret = 1;
        mailbox->messageCount = oldmcount;
    } else {
        JanetBuffer *msgbuf = mailbox->messages + mailbox->messageNext;
        msgbuf->count = 0;

        /* Start panic zone */
        janet_marshal(msgbuf, msg, thread->encode, JANET_MARSHAL_UNSAFE);
        /* End panic zone */

        mailbox->messageNext = (mailbox->messageNext + 1) % mailbox->messageCapacity;
        mailbox->messageCount++;
    }

    /* Cleanup */
    janet_vm_jmp_buf = old_buf;
    janet_mailbox_unlock(mailbox);

    /* Potentially wake up a blocked thread */
    janet_mailbox_wakeup(mailbox);

    return ret;
}

/* Returns 0 on successful message. Returns 1 if timedout */
int janet_thread_receive(Janet *msg_out, double timeout) {
    JanetMailbox *mailbox = janet_vm_mailbox;
    janet_mailbox_lock(mailbox);

    /* For timeouts */
    JanetWaiter wait;
    janet_waiter_init(&wait, timeout);

    for (;;) {

        /* Check for messages waiting for us */
        if (mailbox->messageCount > 0) {

            /* Hack to capture all panics from marshalling. This works because
             * we know janet_marshal won't mess with other essential global state. */
            jmp_buf buf;
            jmp_buf *old_buf = janet_vm_jmp_buf;
            janet_vm_jmp_buf = &buf;

            /* Handle errors */
            if (setjmp(buf)) {
                /* Cleanup jmp_buf, keep lock */
                janet_vm_jmp_buf = old_buf;
            } else {
                JanetBuffer *msgbuf = mailbox->messages + mailbox->messageFirst;
                mailbox->messageCount--;
                mailbox->messageFirst = (mailbox->messageFirst + 1) % mailbox->messageCapacity;

                /* Read from beginning of channel */
                const uint8_t *nextItem = NULL;
                Janet item = janet_unmarshal(
                                 msgbuf->data, msgbuf->count,
                                 JANET_MARSHAL_UNSAFE, janet_thread_get_decode(), &nextItem);
                *msg_out = item;

                /* Cleanup */
                janet_vm_jmp_buf = old_buf;
                janet_mailbox_unlock(mailbox);

                /* Potentially wake up pending threads */
                janet_mailbox_wakeup(mailbox);

                return 0;
            }
        }

        if (wait.nowait) {
            janet_mailbox_unlock(mailbox);
            return 1;
        }

        /* Wait for next message */
        if (janet_waiter_wait(&wait, mailbox)) {
            janet_mailbox_unlock(mailbox);
            return 1;
        }
    }

}

static int janet_thread_getter(void *p, Janet key, Janet *out);

const JanetAbstractType janet_thread_type = {
    "core/thread",
    thread_gc,
    thread_mark,
    janet_thread_getter,
    JANET_ATEND_GET
};

static JanetThread *janet_make_thread(JanetMailbox *mailbox, JanetTable *encode) {
    JanetThread *thread = janet_abstract(&janet_thread_type, sizeof(JanetThread));
    janet_mailbox_ref(mailbox, 1);
    thread->mailbox = mailbox;
    thread->encode = encode;
    return thread;
}

JanetThread *janet_getthread(const Janet *argv, int32_t n) {
    return (JanetThread *) janet_getabstract(argv, n, &janet_thread_type);
}

/* Runs in new thread */
static int thread_worker(JanetMailboxPair *pair) {
    JanetFiber *fiber = NULL;
    Janet out;

    /* Use the mailbox we were given */
    janet_vm_mailbox = pair->newbox;
    janet_mailbox_ref(pair->newbox, 1);

    /* Init VM */
    janet_init();

    /* Get dictionaries for default encode/decode */
    JanetTable *encode;
    if (pair->flags & JANET_THREAD_HEAVYWEIGHT) {
        encode = janet_get_core_table("make-image-dict");
    } else {
        encode = NULL;
        janet_vm_thread_decode = janet_table(0);
        janet_gcroot(janet_wrap_table(janet_vm_thread_decode));
    }

    /* Create parent thread */
    JanetThread *parent = janet_make_thread(pair->original, encode);
    Janet parentv = janet_wrap_abstract(parent);

    /* Unmarshal the abstract registry */
    if (pair->flags & JANET_THREAD_ABSTRACTS) {
        Janet reg;
        int status = janet_thread_receive(&reg, INFINITY);
        if (status) goto error;
        if (!janet_checktype(reg, JANET_TABLE)) goto error;
        janet_gcunroot(janet_wrap_table(janet_vm_abstract_registry));
        janet_vm_abstract_registry = janet_unwrap_table(reg);
        janet_gcroot(janet_wrap_table(janet_vm_abstract_registry));
    }

    /* Unmarshal the normal registry */
    if (pair->flags & JANET_THREAD_CFUNCTIONS) {
        Janet reg;
        int status = janet_thread_receive(&reg, INFINITY);
        if (status) goto error;
        if (!janet_checktype(reg, JANET_TABLE)) goto error;
        janet_gcunroot(janet_wrap_table(janet_vm_registry));
        janet_vm_registry = janet_unwrap_table(reg);
        janet_gcroot(janet_wrap_table(janet_vm_registry));
    }

    /* Unmarshal the function */
    Janet funcv;
    int status = janet_thread_receive(&funcv, INFINITY);
    if (status) goto error;
    if (!janet_checktype(funcv, JANET_FUNCTION)) goto error;
    JanetFunction *func = janet_unwrap_function(funcv);

    /* Arity check */
    if (func->def->min_arity > 1 || func->def->max_arity < 1) {
        goto error;
    }

    /* Call function */
    Janet argv[1] = { parentv };
    fiber = janet_fiber(func, 64, 1, argv);
    JanetSignal sig = janet_continue(fiber, janet_wrap_nil(), &out);
    if (sig != JANET_SIGNAL_OK && sig < JANET_SIGNAL_USER0) {
        janet_eprintf("in thread %v: ", janet_wrap_abstract(janet_make_thread(pair->newbox, encode)));
        janet_stacktrace(fiber, out);
    }

#ifdef JANET_NET
    janet_loop();
#endif

    /* Normal exit */
    destroy_mailbox_pair(pair);
    janet_deinit();
    return 0;

    /* Fail to set something up */
error:
    destroy_mailbox_pair(pair);
    janet_eprintf("\nthread failed to start\n");
    janet_deinit();
    return 1;
}

#ifdef JANET_WINDOWS

static DWORD WINAPI janet_create_thread_wrapper(LPVOID param) {
    thread_worker((JanetMailboxPair *)param);
    return 0;
}

static int janet_thread_start_child(JanetMailboxPair *pair) {
    HANDLE handle = CreateThread(NULL, 0, janet_create_thread_wrapper, pair, 0, NULL);
    int ret = NULL == handle;
    /* Does not kill thread, simply detatches */
    if (!ret) CloseHandle(handle);
    return ret;
}

#else

static void *janet_pthread_wrapper(void *param) {
    thread_worker((JanetMailboxPair *)param);
    return NULL;
}

static int janet_thread_start_child(JanetMailboxPair *pair) {
    pthread_t handle;
    int error = pthread_create(&handle, NULL, janet_pthread_wrapper, pair);
    if (error) {
        return 1;
    } else {
        pthread_detach(handle);
        return 0;
    }
}

#endif

/*
 * Setup/Teardown
 */

void janet_threads_init(void) {
    if (NULL == janet_vm_mailbox) {
        janet_vm_mailbox = janet_mailbox_create(1, 10);
    }
    janet_vm_thread_decode = NULL;
    janet_vm_thread_current = NULL;
}

void janet_threads_deinit(void) {
    janet_mailbox_lock(janet_vm_mailbox);
    janet_vm_mailbox->closed = 1;
    janet_mailbox_ref_with_lock(janet_vm_mailbox, -1);
    janet_vm_mailbox = NULL;
    janet_vm_thread_current = NULL;
    janet_vm_thread_decode = NULL;
}

/*
 * Cfuns
 */

static Janet cfun_thread_current(int32_t argc, Janet *argv) {
    (void) argv;
    janet_fixarity(argc, 0);
    if (NULL == janet_vm_thread_current) {
        janet_vm_thread_current = janet_make_thread(janet_vm_mailbox, janet_get_core_table("make-image-dict"));
        janet_gcroot(janet_wrap_abstract(janet_vm_thread_current));
    }
    return janet_wrap_abstract(janet_vm_thread_current);
}

static Janet cfun_thread_new(int32_t argc, Janet *argv) {
    janet_arity(argc, 1, 3);
    /* Just type checking */
    janet_getfunction(argv, 0);
    int32_t cap = janet_optinteger(argv, argc, 1, 10);
    if (cap < 1 || cap > UINT16_MAX) {
        janet_panicf("bad slot #1, expected integer in range [1, 65535], got %d", cap);
    }
    uint64_t flags = argc >= 3 ? janet_getflags(argv, 2, janet_thread_flags) : JANET_THREAD_ABSTRACTS;
    JanetTable *encode;
    if (flags & JANET_THREAD_HEAVYWEIGHT) {
        encode = janet_get_core_table("make-image-dict");
    } else {
        encode = NULL;
    }

    JanetMailboxPair *pair = make_mailbox_pair(janet_vm_mailbox, flags);
    JanetThread *thread = janet_make_thread(pair->newbox, encode);
    if (janet_thread_start_child(pair)) {
        destroy_mailbox_pair(pair);
        janet_panic("could not start thread");
    }

    if (flags & JANET_THREAD_ABSTRACTS) {
        if (janet_thread_send(thread, janet_wrap_table(janet_vm_abstract_registry), INFINITY)) {
            janet_panic("could not send abstract registry to thread");
        }
    }

    if (flags & JANET_THREAD_CFUNCTIONS) {
        if (janet_thread_send(thread, janet_wrap_table(janet_vm_registry), INFINITY)) {
            janet_panic("could not send registry to thread");
        }
    }

    /* If thread started, send the worker function. */
    if (janet_thread_send(thread, argv[0], INFINITY)) {
        janet_panicf("could not send worker function %v to thread", argv[0]);
    }

    return janet_wrap_abstract(thread);
}

static Janet cfun_thread_send(int32_t argc, Janet *argv) {
    janet_arity(argc, 2, 3);
    JanetThread *thread = janet_getthread(argv, 0);
    int status = janet_thread_send(thread, argv[1], janet_optnumber(argv, argc, 2, 1.0));
    switch (status) {
        default:
            break;
        case 1:
            janet_panicf("failed to send message %v", argv[1]);
        case 2:
            janet_panic("thread mailbox is closed");
    }
    return argv[0];
}

static Janet cfun_thread_receive(int32_t argc, Janet *argv) {
    janet_arity(argc, 0, 1);
    double wait = janet_optnumber(argv, argc, 0, 1.0);
    Janet out;
    int status = janet_thread_receive(&out, wait);
    switch (status) {
        default:
            break;
        case 1:
            janet_panicf("timeout after %f seconds", wait);
    }
    return out;
}

static Janet cfun_thread_close(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    JanetThread *thread = janet_getthread(argv, 0);
    janet_close_thread(thread);
    return janet_wrap_nil();
}

static const JanetMethod janet_thread_methods[] = {
    {"send", cfun_thread_send},
    {"close", cfun_thread_close},
    {NULL, NULL}
};

static int janet_thread_getter(void *p, Janet key, Janet *out) {
    (void) p;
    if (!janet_checktype(key, JANET_KEYWORD)) return 0;
    return janet_getmethod(janet_unwrap_keyword(key), janet_thread_methods, out);
}

static const JanetReg threadlib_cfuns[] = {
    {
        "thread/current", cfun_thread_current,
        JDOC("(thread/current)\n\n"
             "Get the current running thread.")
    },
    {
        "thread/new", cfun_thread_new,
        JDOC("(thread/new func &opt capacity flags)\n\n"
             "Start a new thread that will start immediately. "
             "If capacity is provided, that is how many messages can be stored in the thread's mailbox before blocking senders. "
             "The capacity must be between 1 and 65535 inclusive, and defaults to 10. "
             "Can optionally provide flags to the new thread - supported flags are:\n"
             "\t:h - Start a heavyweight thread. This loads the core environment by default, so may use more memory initially. Messages may compress better, though.\n"
             "\t:a - Allow sending over registered abstract types to the new thread\n"
             "\t:c - Send over cfunction information to the new thread.\n"
             "Returns a handle to the new thread.")
    },
    {
        "thread/send", cfun_thread_send,
        JDOC("(thread/send thread msg)\n\n"
             "Send a message to the thread. This will never block and returns thread immediately. "
             "Will throw an error if there is a problem sending the message.")
    },
    {
        "thread/receive", cfun_thread_receive,
        JDOC("(thread/receive &opt timeout)\n\n"
             "Get a message sent to this thread. If timeout is provided, an error will be thrown after the timeout has elapsed but "
             "no messages are received.")
    },
    {
        "thread/close", cfun_thread_close,
        JDOC("(thread/close thread)\n\n"
             "Close a thread, unblocking it and ending communication with it. Note that closing "
             "a thread is idempotent and does not cancel the thread's operation. Returns nil.")
    },
    {NULL, NULL, NULL}
};

/* Module entry point */
void janet_lib_thread(JanetTable *env) {
    janet_core_cfuns(env, NULL, threadlib_cfuns);
    janet_register_abstract_type(&janet_thread_type);
}

#endif


/* src/core/tuple.c */
#line 0 "src/core/tuple.c"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "symcache.h"
#include "gc.h"
#include "util.h"
#endif

/* Create a new empty tuple of the given size. This will return memory
 * which should be filled with Janets. The memory will not be collected until
 * janet_tuple_end is called. */
Janet *janet_tuple_begin(int32_t length) {
    size_t size = sizeof(JanetTupleHead) + ((size_t) length * sizeof(Janet));
    JanetTupleHead *head = janet_gcalloc(JANET_MEMORY_TUPLE, size);
    head->sm_line = -1;
    head->sm_column = -1;
    head->length = length;
    return (Janet *)(head->data);
}

/* Finish building a tuple */
const Janet *janet_tuple_end(Janet *tuple) {
    janet_tuple_hash(tuple) = janet_array_calchash(tuple, janet_tuple_length(tuple));
    return (const Janet *)tuple;
}

/* Build a tuple with n values */
const Janet *janet_tuple_n(const Janet *values, int32_t n) {
    Janet *t = janet_tuple_begin(n);
    safe_memcpy(t, values, sizeof(Janet) * n);
    return janet_tuple_end(t);
}

/* C Functions */

static Janet cfun_tuple_brackets(int32_t argc, Janet *argv) {
    const Janet *tup = janet_tuple_n(argv, argc);
    janet_tuple_flag(tup) |= JANET_TUPLE_FLAG_BRACKETCTOR;
    return janet_wrap_tuple(tup);
}

static Janet cfun_tuple_slice(int32_t argc, Janet *argv) {
    JanetView view = janet_getindexed(argv, 0);
    JanetRange range = janet_getslice(argc, argv);
    return janet_wrap_tuple(janet_tuple_n(view.items + range.start, range.end - range.start));
}

static Janet cfun_tuple_type(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    const Janet *tup = janet_gettuple(argv, 0);
    if (janet_tuple_flag(tup) & JANET_TUPLE_FLAG_BRACKETCTOR) {
        return janet_ckeywordv("brackets");
    } else {
        return janet_ckeywordv("parens");
    }
}

static Janet cfun_tuple_sourcemap(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    const Janet *tup = janet_gettuple(argv, 0);
    Janet contents[2];
    contents[0] = janet_wrap_integer(janet_tuple_head(tup)->sm_line);
    contents[1] = janet_wrap_integer(janet_tuple_head(tup)->sm_column);
    return janet_wrap_tuple(janet_tuple_n(contents, 2));
}

static Janet cfun_tuple_setmap(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 3);
    const Janet *tup = janet_gettuple(argv, 0);
    janet_tuple_head(tup)->sm_line = janet_getinteger(argv, 1);
    janet_tuple_head(tup)->sm_column = janet_getinteger(argv, 2);
    return argv[0];
}

static const JanetReg tuple_cfuns[] = {
    {
        "tuple/brackets", cfun_tuple_brackets,
        JDOC("(tuple/brackets & xs)\n\n"
             "Creates a new bracketed tuple containing the elements xs.")
    },
    {
        "tuple/slice", cfun_tuple_slice,
        JDOC("(tuple/slice arrtup [,start=0 [,end=(length arrtup)]])\n\n"
             "Take a sub sequence of an array or tuple from index start "
             "inclusive to index end exclusive. If start or end are not provided, "
             "they default to 0 and the length of arrtup respectively. "
             "'start' and 'end' can also be negative to indicate indexing "
             "from the end of the input. Note that index -1 is synonymous with "
             "index '(length arrtup)' to allow a full negative slice range. "
             "Returns the new tuple.")
    },
    {
        "tuple/type", cfun_tuple_type,
        JDOC("(tuple/type tup)\n\n"
             "Checks how the tuple was constructed. Will return the keyword "
             ":brackets if the tuple was parsed with brackets, and :parens "
             "otherwise. The two types of tuples will behave the same most of "
             "the time, but will print differently and be treated differently by "
             "the compiler.")
    },
    {
        "tuple/sourcemap", cfun_tuple_sourcemap,
        JDOC("(tuple/sourcemap tup)\n\n"
             "Returns the sourcemap metadata attached to a tuple, "
             " which is another tuple (line, column).")
    },
    {
        "tuple/setmap", cfun_tuple_setmap,
        JDOC("(tuple/setmap tup line column)\n\n"
             "Set the sourcemap metadata on a tuple. line and column indicate "
             "should be integers.")
    },
    {NULL, NULL, NULL}
};

/* Load the tuple module */
void janet_lib_tuple(JanetTable *env) {
    janet_core_cfuns(env, NULL, tuple_cfuns);
}


/* src/core/typedarray.c */
#line 0 "src/core/typedarray.c"

/*
* Copyright (c) 2020 Calvin Rose & contributors
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "util.h"
#endif

#ifdef JANET_TYPED_ARRAY

static char *ta_type_names[] = {
    "uint8",
    "int8",
    "uint16",
    "int16",
    "uint32",
    "int32",
    "uint64",
    "int64",
    "float32",
    "float64",
    "?"
};

static size_t ta_type_sizes[] = {
    sizeof(uint8_t),
    sizeof(int8_t),
    sizeof(uint16_t),
    sizeof(int16_t),
    sizeof(uint32_t),
    sizeof(int32_t),
    sizeof(uint64_t),
    sizeof(int64_t),
    sizeof(float),
    sizeof(double),
    0
};

#define TA_COUNT_TYPES (JANET_TARRAY_TYPE_F64 + 1)
#define TA_ATOM_MAXSIZE 8
#define TA_FLAG_BIG_ENDIAN 1

static JanetTArrayType get_ta_type_by_name(const uint8_t *name) {
    for (int i = 0; i < TA_COUNT_TYPES; i++) {
        if (!janet_cstrcmp(name, ta_type_names[i]))
            return i;
    }
    janet_panicf("invalid typed array type %S", name);
    return 0;
}

static JanetTArrayBuffer *ta_buffer_init(JanetTArrayBuffer *buf, size_t size) {
    buf->data = NULL;
    if (size > 0) {
        buf->data = (uint8_t *)calloc(size, sizeof(uint8_t));
        if (buf->data == NULL) {
            JANET_OUT_OF_MEMORY;
        }
    }
    buf->size = size;
#ifdef JANET_BIG_ENDIAN
    buf->flags = TA_FLAG_BIG_ENDIAN;
#else
    buf->flags = 0;
#endif
    return buf;
}

static int ta_buffer_gc(void *p, size_t s) {
    (void) s;
    JanetTArrayBuffer *buf = (JanetTArrayBuffer *)p;
    free(buf->data);
    return 0;
}

static void ta_buffer_marshal(void *p, JanetMarshalContext *ctx) {
    JanetTArrayBuffer *buf = (JanetTArrayBuffer *)p;
    janet_marshal_abstract(ctx, p);
    janet_marshal_size(ctx, buf->size);
    janet_marshal_int(ctx, buf->flags);
    janet_marshal_bytes(ctx, buf->data, buf->size);
}

static void *ta_buffer_unmarshal(JanetMarshalContext *ctx) {
    JanetTArrayBuffer *buf = janet_unmarshal_abstract(ctx, sizeof(JanetTArrayBuffer));
    size_t size = janet_unmarshal_size(ctx);
    int32_t flags = janet_unmarshal_int(ctx);
    ta_buffer_init(buf, size);
    buf->flags = flags;
    janet_unmarshal_bytes(ctx, buf->data, size);
    return buf;
}

const JanetAbstractType janet_ta_buffer_type = {
    "ta/buffer",
    ta_buffer_gc,
    NULL,
    NULL,
    NULL,
    ta_buffer_marshal,
    ta_buffer_unmarshal,
    JANET_ATEND_UNMARSHAL
};

static int ta_mark(void *p, size_t s) {
    (void) s;
    JanetTArrayView *view = (JanetTArrayView *)p;
    janet_mark(janet_wrap_abstract(view->buffer));
    return 0;
}

static void ta_view_marshal(void *p, JanetMarshalContext *ctx) {
    JanetTArrayView *view = (JanetTArrayView *)p;
    size_t offset = (view->buffer->data - view->as.u8);
    janet_marshal_abstract(ctx, p);
    janet_marshal_size(ctx, view->size);
    janet_marshal_size(ctx, view->stride);
    janet_marshal_int(ctx, view->type);
    janet_marshal_size(ctx, offset);
    janet_marshal_janet(ctx, janet_wrap_abstract(view->buffer));
}

static void *ta_view_unmarshal(JanetMarshalContext *ctx) {
    size_t offset;
    int32_t atype;
    Janet buffer;
    JanetTArrayView *view = janet_unmarshal_abstract(ctx, sizeof(JanetTArrayView));
    view->size = janet_unmarshal_size(ctx);
    view->stride = janet_unmarshal_size(ctx);
    atype = janet_unmarshal_int(ctx);
    if (atype < 0 || atype >= TA_COUNT_TYPES)
        janet_panic("bad typed array type");
    view->type = atype;
    offset = janet_unmarshal_size(ctx);
    buffer = janet_unmarshal_janet(ctx);
    if (!janet_checktype(buffer, JANET_ABSTRACT) ||
            (janet_abstract_type(janet_unwrap_abstract(buffer)) != &janet_ta_buffer_type)) {
        janet_panicf("expected typed array buffer");
    }
    view->buffer = (JanetTArrayBuffer *)janet_unwrap_abstract(buffer);
    size_t buf_need_size = offset + (ta_type_sizes[view->type]) * ((view->size - 1) * view->stride + 1);
    if (view->buffer->size < buf_need_size)
        janet_panic("bad typed array offset in marshalled data");
    view->as.u8 = view->buffer->data + offset;
    return view;
}

static JanetMethod tarray_view_methods[6];

static int ta_getter(void *p, Janet key, Janet *out) {
    size_t index, i;
    JanetTArrayView *array = p;
    if (janet_checktype(key, JANET_KEYWORD)) {
        return janet_getmethod(janet_unwrap_keyword(key), tarray_view_methods, out);
    }
    if (!janet_checksize(key)) janet_panic("expected size as key");
    index = (size_t) janet_unwrap_number(key);
    i = index * array->stride;
    if (index >= array->size) {
        return 0;
    } else {
        switch (array->type) {
            case JANET_TARRAY_TYPE_U8:
                *out = janet_wrap_number(array->as.u8[i]);
                break;
            case JANET_TARRAY_TYPE_S8:
                *out = janet_wrap_number(array->as.s8[i]);
                break;
            case JANET_TARRAY_TYPE_U16:
                *out = janet_wrap_number(array->as.u16[i]);
                break;
            case JANET_TARRAY_TYPE_S16:
                *out = janet_wrap_number(array->as.s16[i]);
                break;
            case JANET_TARRAY_TYPE_U32:
                *out = janet_wrap_number(array->as.u32[i]);
                break;
            case JANET_TARRAY_TYPE_S32:
                *out = janet_wrap_number(array->as.s32[i]);
                break;
#ifdef JANET_INT_TYPES
            case JANET_TARRAY_TYPE_U64:
                *out = janet_wrap_u64(array->as.u64[i]);
                break;
            case JANET_TARRAY_TYPE_S64:
                *out = janet_wrap_s64(array->as.s64[i]);
                break;
#endif
            case JANET_TARRAY_TYPE_F32:
                *out = janet_wrap_number_safe(array->as.f32[i]);
                break;
            case JANET_TARRAY_TYPE_F64:
                *out = janet_wrap_number_safe(array->as.f64[i]);
                break;
            default:
                janet_panicf("cannot get from typed array of type %s",
                             ta_type_names[array->type]);
                break;
        }
    }
    return 1;
}

static void ta_setter(void *p, Janet key, Janet value) {
    size_t index, i;
    if (!janet_checksize(key)) janet_panic("expected size as key");
    index = (size_t) janet_unwrap_number(key);
    JanetTArrayView *array = p;
    i = index * array->stride;
    if (index >= array->size) {
        janet_panic("index out of bounds");
    }
    if (!janet_checktype(value, JANET_NUMBER) &&
            array->type != JANET_TARRAY_TYPE_U64 &&
            array->type != JANET_TARRAY_TYPE_S64) {
        janet_panic("expected number value");
    }
    switch (array->type) {
        case JANET_TARRAY_TYPE_U8:
            array->as.u8[i] = (uint8_t) janet_unwrap_number(value);
            break;
        case JANET_TARRAY_TYPE_S8:
            array->as.s8[i] = (int8_t) janet_unwrap_number(value);
            break;
        case JANET_TARRAY_TYPE_U16:
            array->as.u16[i] = (uint16_t) janet_unwrap_number(value);
            break;
        case JANET_TARRAY_TYPE_S16:
            array->as.s16[i] = (int16_t) janet_unwrap_number(value);
            break;
        case JANET_TARRAY_TYPE_U32:
            array->as.u32[i] = (uint32_t) janet_unwrap_number(value);
            break;
        case JANET_TARRAY_TYPE_S32:
            array->as.s32[i] = (int32_t) janet_unwrap_number(value);
            break;
#ifdef JANET_INT_TYPES
        case JANET_TARRAY_TYPE_U64:
            array->as.u64[i] = janet_unwrap_u64(value);
            break;
        case JANET_TARRAY_TYPE_S64:
            array->as.s64[i] = janet_unwrap_s64(value);
            break;
#endif
        case JANET_TARRAY_TYPE_F32:
            array->as.f32[i] = (float) janet_unwrap_number(value);
            break;
        case JANET_TARRAY_TYPE_F64:
            array->as.f64[i] = janet_unwrap_number(value);
            break;
        default:
            janet_panicf("cannot set typed array of type %s",
                         ta_type_names[array->type]);
            break;
    }
}

static Janet ta_view_next(void *p, Janet key) {
    JanetTArrayView *view = p;
    if (janet_checktype(key, JANET_NIL)) {
        if (view->size > 0) {
            return janet_wrap_number(0);
        } else {
            return janet_wrap_nil();
        }
    }
    if (!janet_checksize(key)) janet_panic("expected size as key");
    size_t index = (size_t) janet_unwrap_number(key);
    index++;
    if (index < view->size) {
        return janet_wrap_number((double) index);
    }
    return janet_wrap_nil();
}

const JanetAbstractType janet_ta_view_type = {
    "ta/view",
    NULL,
    ta_mark,
    ta_getter,
    ta_setter,
    ta_view_marshal,
    ta_view_unmarshal,
    NULL,
    NULL,
    NULL,
    ta_view_next,
    JANET_ATEND_NEXT
};

JanetTArrayBuffer *janet_tarray_buffer(size_t size) {
    JanetTArrayBuffer *buf = janet_abstract(&janet_ta_buffer_type, sizeof(JanetTArrayBuffer));
    ta_buffer_init(buf, size);
    return buf;
}

JanetTArrayView *janet_tarray_view(
    JanetTArrayType type,
    size_t size,
    size_t stride,
    size_t offset,
    JanetTArrayBuffer *buffer) {

    JanetTArrayView *view = janet_abstract(&janet_ta_view_type, sizeof(JanetTArrayView));

    if ((stride < 1) || (size < 1)) janet_panic("stride and size should be > 0");
    size_t buf_size = offset + ta_type_sizes[type] * ((size - 1) * stride + 1);

    if (NULL == buffer) {
        buffer = janet_abstract(&janet_ta_buffer_type, sizeof(JanetTArrayBuffer));
        ta_buffer_init(buffer, buf_size);
    }

    if (buffer->size < buf_size) {
        janet_panicf("bad buffer size, %i bytes allocated < %i required",
                     buffer->size,
                     buf_size);
    }

    view->buffer = buffer;
    view->stride = stride;
    view->size = size;
    view->as.u8 = buffer->data + offset;
    view->type = type;

    return view;
}

JanetTArrayBuffer *janet_gettarray_buffer(const Janet *argv, int32_t n) {
    return janet_getabstract(argv, n, &janet_ta_buffer_type);
}

JanetTArrayView *janet_gettarray_any(const Janet *argv, int32_t n) {
    return janet_getabstract(argv, n, &janet_ta_view_type);
}

JanetTArrayView *janet_gettarray_view(const Janet *argv, int32_t n, JanetTArrayType type) {
    JanetTArrayView *view = janet_getabstract(argv, n, &janet_ta_view_type);
    if (view->type != type) {
        janet_panicf("bad slot #%d, expected typed array of type %s, got %v",
                     n, ta_type_names[type], argv[n]);
    }
    return view;
}

static Janet cfun_typed_array_new(int32_t argc, Janet *argv) {
    janet_arity(argc, 2, 5);
    size_t offset = 0;
    size_t stride = 1;
    JanetTArrayBuffer *buffer = NULL;
    const uint8_t *keyw = janet_getkeyword(argv, 0);
    JanetTArrayType type = get_ta_type_by_name(keyw);
    size_t size = janet_getsize(argv, 1);
    if (argc > 2)
        stride = janet_getsize(argv, 2);
    if (argc > 3)
        offset = janet_getsize(argv, 3);
    if (argc > 4) {
        if (!janet_checktype(argv[4], JANET_ABSTRACT)) {
            janet_panicf("bad slot #%d, expected ta/view|ta/buffer, got %v",
                         4, argv[4]);
        }
        void *p = janet_unwrap_abstract(argv[4]);
        if (janet_abstract_type(p) == &janet_ta_view_type) {
            JanetTArrayView *view = (JanetTArrayView *)p;
            offset = (view->buffer->data - view->as.u8) + offset * ta_type_sizes[view->type];
            stride *= view->stride;
            buffer = view->buffer;
        } else if (janet_abstract_type(p) == &janet_ta_buffer_type) {
            buffer = p;
        } else {
            janet_panicf("bad slot #%d, expected ta/view|ta/buffer, got %v",
                         4, argv[4]);
        }
    }
    JanetTArrayView *view = janet_tarray_view(type, size, stride, offset, buffer);
    return janet_wrap_abstract(view);
}

static JanetTArrayView *ta_is_view(Janet x) {
    if (!janet_checktype(x, JANET_ABSTRACT)) return NULL;
    void *abst = janet_unwrap_abstract(x);
    if (janet_abstract_type(abst) != &janet_ta_view_type) return NULL;
    return (JanetTArrayView *)abst;
}

static Janet cfun_typed_array_buffer(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    JanetTArrayView *view;
    if ((view = ta_is_view(argv[0]))) {
        return janet_wrap_abstract(view->buffer);
    }
    size_t size = janet_getsize(argv, 0);
    JanetTArrayBuffer *buf = janet_tarray_buffer(size);
    return janet_wrap_abstract(buf);
}

static Janet cfun_typed_array_size(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    JanetTArrayView *view;
    if ((view = ta_is_view(argv[0]))) {
        return janet_wrap_number((double) view->size);
    }
    JanetTArrayBuffer *buf = (JanetTArrayBuffer *)janet_getabstract(argv, 0, &janet_ta_buffer_type);
    return janet_wrap_number((double) buf->size);
}

static Janet cfun_typed_array_properties(int32_t argc, Janet *argv) {
    janet_fixarity(argc, 1);
    JanetTArrayView *view;
    if ((view = ta_is_view(argv[0]))) {
        JanetTArrayView *view = janet_unwrap_abstract(argv[0]);
        JanetKV *props = janet_struct_begin(6);
        ptrdiff_t boffset = view->as.u8 - view->buffer->data;
        janet_struct_put(props, janet_ckeywordv("size"),
                         janet_wrap_number((double) view->size));
        janet_struct_put(props, janet_ckeywordv("byte-offset"),
                         janet_wrap_number((double) boffset));
        janet_struct_put(props, janet_ckeywordv("stride"),
                         janet_wrap_number((double) view->stride));
        janet_struct_put(props, janet_ckeywordv("type"),
                         janet_ckeywordv(ta_type_names[view->type]));
        janet_struct_put(props, janet_ckeywordv("type-size"),
                         janet_wrap_number((double) ta_type_sizes[view->type]));
        janet_struct_put(props, janet_ckeywordv("buffer"),
                         janet_wrap_abstract(view->buffer));
        return janet_wrap_struct(janet_struct_end(props));
    } else {
        JanetTArrayBuffer *buffer = janet_gettarray_buffer(argv, 0);
        JanetKV *props = janet_struct_begin(2);
        janet_struct_put(props, janet_ckeywordv("size"),
                         janet_wrap_number((double) buffer->size));
        janet_struct_put(props, janet_ckeywordv("big-endian"),
                         janet_wrap_boolean(buffer->flags & TA_FLAG_BIG_ENDIAN));
        return janet_wrap_struct(janet_struct_end(props));
    }
}

static Janet cfun_typed_array_slice(int32_t argc, Janet *argv) {
    janet_arity(argc, 1, 3);
    JanetTArrayView *src = janet_getabstract(argv, 0, &janet_ta_view_type);
    JanetRange range;
    int32_t length = (int32_t)src->size;
    if (argc == 1) {
        range.start = 0;
        range.end = length;
    } else if (argc == 2) {
        range.start = janet_gethalfrange(argv, 1, length, "start");
        range.end = length;
    } else {
        range.start = janet_gethalfrange(argv, 1, length, "start");
        range.end = janet_gethalfrange(argv, 2, length, "end");
        if (range.end < range.start)
            range.end = range.start;
    }
    JanetArray *array = janet_array(range.end - range.start);
    if (array->data) {
        for (int32_t i = range.start; i < range.end; i++) {
            if (!ta_getter(src, janet_wrap_number(i), &array->data[i - range.start]))
                array->data[i - range.start] = janet_wrap_nil();
        }
    }
    array->count = range.end - range.start;
    return janet_wrap_array(array);
}

static Janet cfun_typed_array_copy_bytes(int32_t argc, Janet *argv) {
    janet_arity(argc, 4, 5);
    JanetTArrayView *src = janet_getabstract(argv, 0, &janet_ta_view_type);
    size_t index_src = janet_getsize(argv, 1);
    JanetTArrayView *dst = janet_getabstract(argv, 2, &janet_ta_view_type);
    size_t index_dst = janet_getsize(argv, 3);
    size_t count = (argc == 5) ? janet_getsize(argv, 4) : 1;
    size_t src_atom_size = ta_type_sizes[src->type];
    size_t dst_atom_size = ta_type_sizes[dst->type];
    size_t step_src = src->stride * src_atom_size;
    size_t step_dst = dst->stride * dst_atom_size;
    size_t pos_src = (src->as.u8 - src->buffer->data) + (index_src * step_src);
    size_t pos_dst = (dst->as.u8 - dst->buffer->data) + (index_dst * step_dst);
    uint8_t *ps = src->buffer->data + pos_src, * pd = dst->buffer->data + pos_dst;
    if ((pos_dst + (count - 1)*step_dst + src_atom_size <= dst->buffer->size) &&
            (pos_src + (count - 1)*step_src + src_atom_size <= src->buffer->size)) {
        for (size_t i = 0; i < count; i++) {
            memmove(pd, ps, src_atom_size);
            pd += step_dst;
            ps += step_src;
        }
    } else {
        janet_panic("typed array copy out of bounds");
    }
    return janet_wrap_nil();
}

static Janet cfun_typed_array_swap_bytes(int32_t argc, Janet *argv) {
    janet_arity(argc, 4, 5);
    JanetTArrayView *src = janet_getabstract(argv, 0, &janet_ta_view_type);
    size_t index_src = janet_getsize(argv, 1);
    JanetTArrayView *dst = janet_getabstract(argv, 2, &janet_ta_view_type);
    size_t index_dst = janet_getsize(argv, 3);
    size_t count = (argc == 5) ? janet_getsize(argv, 4) : 1;
    size_t src_atom_size = ta_type_sizes[src->type];
    size_t dst_atom_size = ta_type_sizes[dst->type];
    size_t step_src = src->stride * src_atom_size;
    size_t step_dst = dst->stride * dst_atom_size;
    size_t pos_src = (src->as.u8 - src->buffer->data) + (index_src * step_src);
    size_t pos_dst = (dst->as.u8 - dst->buffer->data) + (index_dst * step_dst);
    uint8_t *ps = src->buffer->data + pos_src, * pd = dst->buffer->data + pos_dst;
    uint8_t temp[TA_ATOM_MAXSIZE];
    if ((pos_dst + (count - 1)*step_dst + src_atom_size <= dst->buffer->size) &&
            (pos_src + (count - 1)*step_src + src_atom_size <= src->buffer->size)) {
        for (size_t i = 0; i < count; i++) {
            memcpy(temp, ps, src_atom_size);
            memcpy(ps, pd, src_atom_size);
            memcpy(pd, temp, src_atom_size);
            pd += step_dst;
            ps += step_src;
        }
    } else {
        janet_panic("typed array swap out of bounds");
    }
    return janet_wrap_nil();
}

static const JanetReg ta_cfuns[] = {
    {
        "tarray/new", cfun_typed_array_new,
        JDOC("(tarray/new type size &opt stride offset tarray|buffer)\n\n"
             "Create new typed array.")
    },
    {
        "tarray/buffer", cfun_typed_array_buffer,
        JDOC("(tarray/buffer array|size)\n\n"
             "Return typed array buffer or create a new buffer.")
    },
    {
        "tarray/length", cfun_typed_array_size,
        JDOC("(tarray/length array|buffer)\n\n"
             "Return typed array or buffer size.")
    },
    {
        "tarray/properties", cfun_typed_array_properties,
        JDOC("(tarray/properties array)\n\n"
             "Return typed array properties as a struct.")
    },
    {
        "tarray/copy-bytes", cfun_typed_array_copy_bytes,
        JDOC("(tarray/copy-bytes src sindex dst dindex &opt count)\n\n"
             "Copy count elements (default 1) of src array from index sindex "
             "to dst array at position dindex "
             "memory can overlap.")
    },
    {
        "tarray/swap-bytes", cfun_typed_array_swap_bytes,
        JDOC("(tarray/swap-bytes src sindex dst dindex &opt count)\n\n"
             "Swap count elements (default 1) between src array from index sindex "
             "and dst array at position dindex "
             "memory can overlap.")
    },
    {
        "tarray/slice", cfun_typed_array_slice,
        JDOC("(tarray/slice tarr &opt start end)\n\n"
             "Takes a slice of a typed array from start to end. The range is half "
             "open, [start, end). Indexes can also be negative, indicating indexing "
             "from the end of the end of the typed array. By default, start is 0 and end is "
             "the size of the typed array. Returns a new janet array.")
    },
    {NULL, NULL, NULL}
};

static JanetMethod tarray_view_methods[] = {
    {"length", cfun_typed_array_size},
    {"properties", cfun_typed_array_properties},
    {"copy-bytes", cfun_typed_array_copy_bytes},
    {"swap-bytes", cfun_typed_array_swap_bytes},
    {"slice", cfun_typed_array_slice},
    {NULL, NULL}
};

/* Module entry point */
void janet_lib_typed_array(JanetTable *env) {
    janet_core_cfuns(env, NULL, ta_cfuns);
    janet_register_abstract_type(&janet_ta_buffer_type);
    janet_register_abstract_type(&janet_ta_view_type);
}

#endif


/* src/core/util.c */
#line 0 "src/core/util.c"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "util.h"
#include "state.h"
#include "gc.h"
#endif

#include <inttypes.h>

/* Base 64 lookup table for digits */
const char janet_base64[65] =
    "0123456789"
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    "abcdefghijklmnopqrstuvwxyz"
    "_=";

/* The JANET value types in order. These types can be used as
 * mnemonics instead of a bit pattern for type checking */
const char *const janet_type_names[16] = {
    "number",
    "nil",
    "boolean",
    "fiber",
    "string",
    "symbol",
    "keyword",
    "array",
    "tuple",
    "table",
    "struct",
    "buffer",
    "function",
    "cfunction",
    "abstract",
    "pointer"
};

const char *const janet_signal_names[14] = {
    "ok",
    "error",
    "debug",
    "yield",
    "user0",
    "user1",
    "user2",
    "user3",
    "user4",
    "user5",
    "user6",
    "user7",
    "user8",
    "user9"
};

const char *const janet_status_names[16] = {
    "dead",
    "error",
    "debug",
    "pending",
    "user0",
    "user1",
    "user2",
    "user3",
    "user4",
    "user5",
    "user6",
    "user7",
    "user8",
    "user9",
    "new",
    "alive"
};

#ifdef JANET_NO_PRF

int32_t janet_string_calchash(const uint8_t *str, int32_t len) {
    const uint8_t *end = str + len;
    uint32_t hash = 5381;
    while (str < end)
        hash = (hash << 5) + hash + *str++;
    return (int32_t) hash;
}

#else

/*
  Public domain siphash implementation sourced from:

  https://raw.githubusercontent.com/veorq/SipHash/master/halfsiphash.c

  We have made a few alterations, such as hardcoding the output size
  and then removing dead code.
*/
#define cROUNDS 2
#define dROUNDS 4

#define ROTL(x, b) (uint32_t)(((x) << (b)) | ((x) >> (32 - (b))))

#define U8TO32_LE(p)                                                           \
    (((uint32_t)((p)[0])) | ((uint32_t)((p)[1]) << 8) |                        \
     ((uint32_t)((p)[2]) << 16) | ((uint32_t)((p)[3]) << 24))

#define SIPROUND                                                               \
    do {                                                                       \
        v0 += v1;                                                              \
        v1 = ROTL(v1, 5);                                                      \
        v1 ^= v0;                                                              \
        v0 = ROTL(v0, 16);                                                     \
        v2 += v3;                                                              \
        v3 = ROTL(v3, 8);                                                      \
        v3 ^= v2;                                                              \
        v0 += v3;                                                              \
        v3 = ROTL(v3, 7);                                                      \
        v3 ^= v0;                                                              \
        v2 += v1;                                                              \
        v1 = ROTL(v1, 13);                                                     \
        v1 ^= v2;                                                              \
        v2 = ROTL(v2, 16);                                                     \
    } while (0)

static uint32_t halfsiphash(const uint8_t *in, const size_t inlen, const uint8_t *k) {

    uint32_t v0 = 0;
    uint32_t v1 = 0;
    uint32_t v2 = UINT32_C(0x6c796765);
    uint32_t v3 = UINT32_C(0x74656462);
    uint32_t k0 = U8TO32_LE(k);
    uint32_t k1 = U8TO32_LE(k + 4);
    uint32_t m;
    int i;
    const uint8_t *end = in + inlen - (inlen % sizeof(uint32_t));
    const int left = inlen & 3;
    uint32_t b = ((uint32_t)inlen) << 24;
    v3 ^= k1;
    v2 ^= k0;
    v1 ^= k1;
    v0 ^= k0;

    for (; in != end; in += 4) {
        m = U8TO32_LE(in);
        v3 ^= m;

        for (i = 0; i < cROUNDS; ++i)
            SIPROUND;

        v0 ^= m;
    }

    switch (left) {
        case 3:
            b |= ((uint32_t)in[2]) << 16;
        /* fallthrough */
        case 2:
            b |= ((uint32_t)in[1]) << 8;
        /* fallthrough */
        case 1:
            b |= ((uint32_t)in[0]);
            break;
        case 0:
            break;
    }

    v3 ^= b;

    for (i = 0; i < cROUNDS; ++i)
        SIPROUND;

    v0 ^= b;

    v2 ^= 0xff;

    for (i = 0; i < dROUNDS; ++i)
        SIPROUND;

    b = v1 ^ v3;
    return b;
}
/* end of siphash */

static uint8_t hash_key[JANET_HASH_KEY_SIZE] = {0};

void janet_init_hash_key(uint8_t new_key[JANET_HASH_KEY_SIZE]) {
    memcpy(hash_key, new_key, sizeof(hash_key));
}

/* Calculate hash for string */

int32_t janet_string_calchash(const uint8_t *str, int32_t len) {
    uint32_t hash;
    hash = halfsiphash(str, len, hash_key);
    return (int32_t)hash;
}

#endif

/* Computes hash of an array of values */
int32_t janet_array_calchash(const Janet *array, int32_t len) {
    const Janet *end = array + len;
    uint32_t hash = 5381;
    while (array < end)
        hash = (hash << 5) + hash + janet_hash(*array++);
    return (int32_t) hash;
}

/* Computes hash of an array of values */
int32_t janet_kv_calchash(const JanetKV *kvs, int32_t len) {
    const JanetKV *end = kvs + len;
    uint32_t hash = 5381;
    while (kvs < end) {
        hash = (hash << 5) + hash + janet_hash(kvs->key);
        hash = (hash << 5) + hash + janet_hash(kvs->value);
        kvs++;
    }
    return (int32_t) hash;
}

/* Calculate next power of 2. May overflow. If n is 0,
 * will return 0. */
int32_t janet_tablen(int32_t n) {
    n |= n >> 1;
    n |= n >> 2;
    n |= n >> 4;
    n |= n >> 8;
    n |= n >> 16;
    return n + 1;
}

/* Avoid some undefined behavior that was common in the code base. */
void safe_memcpy(void *dest, const void *src, size_t len) {
    if (!len) return;
    memcpy(dest, src, len);
}

/* Helper to find a value in a Janet struct or table. Returns the bucket
 * containing the key, or the first empty bucket if there is no such key. */
const JanetKV *janet_dict_find(const JanetKV *buckets, int32_t cap, Janet key) {
    int32_t index = janet_maphash(cap, janet_hash(key));
    int32_t i;
    const JanetKV *first_bucket = NULL;
    /* Higher half */
    for (i = index; i < cap; i++) {
        const JanetKV *kv = buckets + i;
        if (janet_checktype(kv->key, JANET_NIL)) {
            if (janet_checktype(kv->value, JANET_NIL)) {
                return kv;
            } else if (NULL == first_bucket) {
                first_bucket = kv;
            }
        } else if (janet_equals(kv->key, key)) {
            return buckets + i;
        }
    }
    /* Lower half */
    for (i = 0; i < index; i++) {
        const JanetKV *kv = buckets + i;
        if (janet_checktype(kv->key, JANET_NIL)) {
            if (janet_checktype(kv->value, JANET_NIL)) {
                return kv;
            } else if (NULL == first_bucket) {
                first_bucket = kv;
            }
        } else if (janet_equals(kv->key, key)) {
            return buckets + i;
        }
    }
    return first_bucket;
}

/* Get a value from a janet struct or table. */
Janet janet_dictionary_get(const JanetKV *data, int32_t cap, Janet key) {
    const JanetKV *kv = janet_dict_find(data, cap, key);
    if (kv && !janet_checktype(kv->key, JANET_NIL)) {
        return kv->value;
    }
    return janet_wrap_nil();
}

/* Iterate through a struct or dictionary generically */
const JanetKV *janet_dictionary_next(const JanetKV *kvs, int32_t cap, const JanetKV *kv) {
    const JanetKV *end = kvs + cap;
    kv = (kv == NULL) ? kvs : kv + 1;
    while (kv < end) {
        if (!janet_checktype(kv->key, JANET_NIL))
            return kv;
        kv++;
    }
    return NULL;
}

/* Compare a janet string with a cstring. More efficient than loading
 * c string as a janet string. */
int janet_cstrcmp(const uint8_t *str, const char *other) {
    int32_t len = janet_string_length(str);
    int32_t index;
    for (index = 0; index < len; index++) {
        uint8_t c = str[index];
        uint8_t k = ((const uint8_t *)other)[index];
        if (c < k) return -1;
        if (c > k) return 1;
        if (k == '\0') break;
    }
    return (other[index] == '\0') ? 0 : -1;
}

/* Do a binary search on a static array of structs. Each struct must
 * have a string as its first element, and the struct must be sorted
 * lexicographically by that element. */
const void *janet_strbinsearch(
    const void *tab,
    size_t tabcount,
    size_t itemsize,
    const uint8_t *key) {
    size_t low = 0;
    size_t hi = tabcount;
    const char *t = (const char *)tab;
    while (low < hi) {
        size_t mid = low + ((hi - low) / 2);
        const char **item = (const char **)(t + mid * itemsize);
        const char *name = *item;
        int comp = janet_cstrcmp(key, name);
        if (comp < 0) {
            hi = mid;
        } else if (comp > 0) {
            low = mid + 1;
        } else {
            return (const void *)item;
        }
    }
    return NULL;
}

/* Register a value in the global registry */
void janet_register(const char *name, JanetCFunction cfun) {
    Janet key = janet_wrap_cfunction(cfun);
    Janet value = janet_csymbolv(name);
    janet_table_put(janet_vm_registry, key, value);
}

/* Add a def to an environment */
void janet_def(JanetTable *env, const char *name, Janet val, const char *doc) {
    JanetTable *subt = janet_table(2);
    janet_table_put(subt, janet_ckeywordv("value"), val);
    if (doc)
        janet_table_put(subt, janet_ckeywordv("doc"), janet_cstringv(doc));
    janet_table_put(env, janet_csymbolv(name), janet_wrap_table(subt));
}

/* Add a var to the environment */
void janet_var(JanetTable *env, const char *name, Janet val, const char *doc) {
    JanetArray *array = janet_array(1);
    JanetTable *subt = janet_table(2);
    janet_array_push(array, val);
    janet_table_put(subt, janet_ckeywordv("ref"), janet_wrap_array(array));
    if (doc)
        janet_table_put(subt, janet_ckeywordv("doc"), janet_cstringv(doc));
    janet_table_put(env, janet_csymbolv(name), janet_wrap_table(subt));
}

/* Load many cfunctions at once */
static void _janet_cfuns_prefix(JanetTable *env, const char *regprefix, const JanetReg *cfuns, int defprefix) {
    uint8_t *longname_buffer = NULL;
    size_t prefixlen = 0;
    size_t bufsize = 0;
    if (NULL != regprefix) {
        prefixlen = strlen(regprefix);
        bufsize = prefixlen + 256;
        longname_buffer = malloc(bufsize);
        if (NULL == longname_buffer) {
            JANET_OUT_OF_MEMORY;
        }
        safe_memcpy(longname_buffer, regprefix, prefixlen);
        longname_buffer[prefixlen] = '/';
        prefixlen++;
    }
    while (cfuns->name) {
        Janet name;
        if (NULL != regprefix) {
            int32_t nmlen = 0;
            while (cfuns->name[nmlen]) nmlen++;
            int32_t totallen = (int32_t) prefixlen + nmlen;
            if ((size_t) totallen > bufsize) {
                bufsize = (size_t)(totallen) + 128;
                longname_buffer = realloc(longname_buffer, bufsize);
                if (NULL == longname_buffer) {
                    JANET_OUT_OF_MEMORY;
                }
            }
            safe_memcpy(longname_buffer + prefixlen, cfuns->name, nmlen);
            name = janet_wrap_symbol(janet_symbol(longname_buffer, totallen));
        } else {
            name = janet_csymbolv(cfuns->name);
        }
        Janet fun = janet_wrap_cfunction(cfuns->cfun);
        if (defprefix) {
            JanetTable *subt = janet_table(2);
            janet_table_put(subt, janet_ckeywordv("value"), fun);
            if (cfuns->documentation)
                janet_table_put(subt, janet_ckeywordv("doc"), janet_cstringv(cfuns->documentation));
            janet_table_put(env, name, janet_wrap_table(subt));
        } else {
            janet_def(env, cfuns->name, fun, cfuns->documentation);
        }
        janet_table_put(janet_vm_registry, fun, name);
        cfuns++;
    }
    free(longname_buffer);
}

void janet_cfuns_prefix(JanetTable *env, const char *regprefix, const JanetReg *cfuns) {
    _janet_cfuns_prefix(env, regprefix, cfuns, 1);
}

void janet_cfuns(JanetTable *env, const char *regprefix, const JanetReg *cfuns) {
    _janet_cfuns_prefix(env, regprefix, cfuns, 0);
}

/* Abstract type introspection */

void janet_register_abstract_type(const JanetAbstractType *at) {
    Janet sym = janet_csymbolv(at->name);
    if (!(janet_checktype(janet_table_get(janet_vm_abstract_registry, sym), JANET_NIL))) {
        janet_panicf("cannot register abstract type %s, "
                     "a type with the same name exists", at->name);
    }
    janet_table_put(janet_vm_abstract_registry, sym, janet_wrap_pointer((void *) at));
}

const JanetAbstractType *janet_get_abstract_type(Janet key) {
    Janet wrapped = janet_table_get(janet_vm_abstract_registry, key);
    if (janet_checktype(wrapped, JANET_NIL)) {
        return NULL;
    }
    return (JanetAbstractType *)(janet_unwrap_pointer(wrapped));
}

#ifndef JANET_BOOTSTRAP
void janet_core_def(JanetTable *env, const char *name, Janet x, const void *p) {
    (void) p;
    Janet key = janet_csymbolv(name);
    janet_table_put(env, key, x);
    if (janet_checktype(x, JANET_CFUNCTION)) {
        janet_table_put(janet_vm_registry, x, key);
    }
}

void janet_core_cfuns(JanetTable *env, const char *regprefix, const JanetReg *cfuns) {
    (void) regprefix;
    while (cfuns->name) {
        Janet fun = janet_wrap_cfunction(cfuns->cfun);
        janet_core_def(env, cfuns->name, fun, cfuns->documentation);
        cfuns++;
    }
}
#endif

/* Resolve a symbol in the environment */
JanetBindingType janet_resolve(JanetTable *env, const uint8_t *sym, Janet *out) {
    Janet ref;
    JanetTable *entry_table;
    Janet entry = janet_table_get(env, janet_wrap_symbol(sym));
    if (!janet_checktype(entry, JANET_TABLE))
        return JANET_BINDING_NONE;
    entry_table = janet_unwrap_table(entry);
    if (!janet_checktype(
                janet_table_get(entry_table, janet_ckeywordv("macro")),
                JANET_NIL)) {
        *out = janet_table_get(entry_table, janet_ckeywordv("value"));
        return JANET_BINDING_MACRO;
    }
    ref = janet_table_get(entry_table, janet_ckeywordv("ref"));
    if (janet_checktype(ref, JANET_ARRAY)) {
        *out = ref;
        return JANET_BINDING_VAR;
    }
    *out = janet_table_get(entry_table, janet_ckeywordv("value"));
    return JANET_BINDING_DEF;
}

/* Resolve a symbol in the core environment. */
Janet janet_resolve_core(const char *name) {
    JanetTable *env = janet_core_env(NULL);
    Janet out = janet_wrap_nil();
    janet_resolve(env, janet_csymbol(name), &out);
    return out;
}

/* Read both tuples and arrays as c pointers + int32_t length. Return 1 if the
 * view can be constructed, 0 if an invalid type. */
int janet_indexed_view(Janet seq, const Janet **data, int32_t *len) {
    if (janet_checktype(seq, JANET_ARRAY)) {
        *data = janet_unwrap_array(seq)->data;
        *len = janet_unwrap_array(seq)->count;
        return 1;
    } else if (janet_checktype(seq, JANET_TUPLE)) {
        *data = janet_unwrap_tuple(seq);
        *len = janet_tuple_length(janet_unwrap_tuple(seq));
        return 1;
    }
    return 0;
}

/* Read both strings and buffer as unsigned character array + int32_t len.
 * Returns 1 if the view can be constructed and 0 if the type is invalid. */
int janet_bytes_view(Janet str, const uint8_t **data, int32_t *len) {
    if (janet_checktype(str, JANET_STRING) || janet_checktype(str, JANET_SYMBOL) ||
            janet_checktype(str, JANET_KEYWORD)) {
        *data = janet_unwrap_string(str);
        *len = janet_string_length(janet_unwrap_string(str));
        return 1;
    } else if (janet_checktype(str, JANET_BUFFER)) {
        *data = janet_unwrap_buffer(str)->data;
        *len = janet_unwrap_buffer(str)->count;
        return 1;
    }
    return 0;
}

/* Read both structs and tables as the entries of a hashtable with
 * identical structure. Returns 1 if the view can be constructed and
 * 0 if the type is invalid. */
int janet_dictionary_view(Janet tab, const JanetKV **data, int32_t *len, int32_t *cap) {
    if (janet_checktype(tab, JANET_TABLE)) {
        *data = janet_unwrap_table(tab)->data;
        *cap = janet_unwrap_table(tab)->capacity;
        *len = janet_unwrap_table(tab)->count;
        return 1;
    } else if (janet_checktype(tab, JANET_STRUCT)) {
        *data = janet_unwrap_struct(tab);
        *cap = janet_struct_capacity(janet_unwrap_struct(tab));
        *len = janet_struct_length(janet_unwrap_struct(tab));
        return 1;
    }
    return 0;
}

int janet_checkint(Janet x) {
    if (!janet_checktype(x, JANET_NUMBER))
        return 0;
    double dval = janet_unwrap_number(x);
    return janet_checkintrange(dval);
}

int janet_checkint64(Janet x) {
    if (!janet_checktype(x, JANET_NUMBER))
        return 0;
    double dval = janet_unwrap_number(x);
    return janet_checkint64range(dval);
}

int janet_checksize(Janet x) {
    if (!janet_checktype(x, JANET_NUMBER))
        return 0;
    double dval = janet_unwrap_number(x);
    return dval == (double)((size_t) dval) &&
           dval <= SIZE_MAX;
}

JanetTable *janet_get_core_table(const char *name) {
    JanetTable *env = janet_core_env(NULL);
    Janet out = janet_wrap_nil();
    JanetBindingType bt = janet_resolve(env, janet_csymbol(name), &out);
    if (bt == JANET_BINDING_NONE) return NULL;
    if (!janet_checktype(out, JANET_TABLE)) return NULL;
    return janet_unwrap_table(out);
}


/* src/core/value.c */
#line 0 "src/core/value.c"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include "util.h"
#include "state.h"
#include "gc.h"
#include <janet.h>
#endif

JANET_THREAD_LOCAL JanetTraversalNode *janet_vm_traversal = NULL;
JANET_THREAD_LOCAL JanetTraversalNode *janet_vm_traversal_top = NULL;
JANET_THREAD_LOCAL JanetTraversalNode *janet_vm_traversal_base = NULL;

static void push_traversal_node(void *lhs, void *rhs, int32_t index2) {
    JanetTraversalNode node;
    node.self = (JanetGCObject *) lhs;
    node.other = (JanetGCObject *) rhs;
    node.index = 0;
    node.index2 = index2;
    if (janet_vm_traversal + 1 >= janet_vm_traversal_top) {
        size_t oldsize = janet_vm_traversal - janet_vm_traversal_base;
        size_t newsize = 2 * oldsize + 1;
        if (newsize < 128) {
            newsize = 128;
        }
        JanetTraversalNode *tn = realloc(janet_vm_traversal_base, newsize * sizeof(JanetTraversalNode));
        if (tn == NULL) {
            JANET_OUT_OF_MEMORY;
        }
        janet_vm_traversal_base = tn;
        janet_vm_traversal_top = janet_vm_traversal_base + newsize;
        janet_vm_traversal = janet_vm_traversal_base + oldsize;
    }
    *(++janet_vm_traversal) = node;
}

/*
 * Used for travsersing structs and tuples without recursion
 * Returns:
 * 0 - next node found
 * 1 - early stop - lhs < rhs
 * 2 - no next node found
 * 3 - early stop - lhs > rhs
 */
static int traversal_next(Janet *x, Janet *y) {
    JanetTraversalNode *t = janet_vm_traversal;
    while (t && t > janet_vm_traversal_base) {
        JanetGCObject *self = t->self;
        JanetTupleHead *tself = (JanetTupleHead *)self;
        JanetStructHead *sself = (JanetStructHead *)self;
        JanetGCObject *other = t->other;
        JanetTupleHead *tother = (JanetTupleHead *)other;
        JanetStructHead *sother = (JanetStructHead *)other;
        if ((self->flags & JANET_MEM_TYPEBITS) == JANET_MEMORY_TUPLE) {
            /* Node is a tuple at index t->index */
            if (t->index < tself->length && t->index < tother->length) {
                int32_t index = t->index++;
                *x = tself->data[index];
                *y = tother->data[index];
                janet_vm_traversal = t;
                return 0;
            }
            if (t->index2 && tself->length != tother->length) {
                return tself->length > tother->length ? 3 : 1;
            }
        } else {
            /* Node is a struct at index t->index: if t->index2 is true, we should return the values. */
            if (t->index2) {
                t->index2 = 0;
                int32_t index = t->index++;
                *x = sself->data[index].value;
                *y = sother->data[index].value;
                janet_vm_traversal = t;
                return 0;
            }
            for (int32_t i = t->index; i < sself->capacity; i++) {
                t->index2 = 1;
                *x = sself->data[t->index].key;
                *y = sother->data[t->index].key;
                janet_vm_traversal = t;
                return 0;
            }
        }
        t--;
    }
    janet_vm_traversal = t;
    return 2;
}

/*
 * Define a number of functions that can be used internally on ANY Janet.
 */

Janet janet_next(Janet ds, Janet key) {
    JanetType t = janet_type(ds);
    switch (t) {
        default:
            janet_panicf("expected iterable type, got %v", ds);
        case JANET_TABLE:
        case JANET_STRUCT: {
            const JanetKV *start;
            int32_t cap;
            if (t == JANET_TABLE) {
                JanetTable *tab = janet_unwrap_table(ds);
                cap = tab->capacity;
                start = tab->data;
            } else {
                JanetStruct st = janet_unwrap_struct(ds);
                cap = janet_struct_capacity(st);
                start = st;
            }
            const JanetKV *end = start + cap;
            const JanetKV *kv = janet_checktype(key, JANET_NIL)
                                ? start
                                : janet_dict_find(start, cap, key) + 1;
            while (kv < end) {
                if (!janet_checktype(kv->key, JANET_NIL)) return kv->key;
                kv++;
            }
            break;
        }
        case JANET_STRING:
        case JANET_KEYWORD:
        case JANET_SYMBOL:
        case JANET_BUFFER:
        case JANET_ARRAY:
        case JANET_TUPLE: {
            int32_t i;
            if (janet_checktype(key, JANET_NIL)) {
                i = 0;
            } else if (janet_checkint(key)) {
                i = janet_unwrap_integer(key) + 1;
            } else {
                break;
            }
            int32_t len;
            if (t == JANET_BUFFER) {
                len = janet_unwrap_buffer(ds)->count;
            } else if (t == JANET_ARRAY) {
                len = janet_unwrap_array(ds)->count;
            } else if (t == JANET_TUPLE) {
                len = janet_tuple_length(janet_unwrap_tuple(ds));
            } else {
                len = janet_string_length(janet_unwrap_string(ds));
            }
            if (i < len && i >= 0) {
                return janet_wrap_integer(i);
            }
            break;
        }
        case JANET_ABSTRACT: {
            JanetAbstract abst = janet_unwrap_abstract(ds);
            const JanetAbstractType *at = janet_abstract_type(abst);
            if (NULL == at->next) break;
            return at->next(abst, key);
        }
    }
    return janet_wrap_nil();
}

/* Compare two abstract values */
static int janet_compare_abstract(JanetAbstract xx, JanetAbstract yy) {
    if (xx == yy) return 0;
    const JanetAbstractType *xt = janet_abstract_type(xx);
    const JanetAbstractType *yt = janet_abstract_type(yy);
    if (xt != yt) {
        return xt > yt ? 1 : -1;
    }
    if (xt->compare == NULL) {
        return xx > yy ? 1 : -1;
    }
    return xt->compare(xx, yy);
}

int janet_equals(Janet x, Janet y) {
    janet_vm_traversal = janet_vm_traversal_base;
    do {
        if (janet_type(x) != janet_type(y)) return 0;
        switch (janet_type(x)) {
            case JANET_NIL:
                break;
            case JANET_BOOLEAN:
                if (janet_unwrap_boolean(x) != janet_unwrap_boolean(y)) return 0;
                break;
            case JANET_NUMBER:
                if (janet_unwrap_number(x) != janet_unwrap_number(y)) return 0;
                break;
            case JANET_STRING:
                if (!janet_string_equal(janet_unwrap_string(x), janet_unwrap_string(y))) return 0;
                break;
            case JANET_ABSTRACT:
                if (janet_compare_abstract(janet_unwrap_abstract(x), janet_unwrap_abstract(y))) return 0;
                break;
            default:
                if (janet_unwrap_pointer(x) != janet_unwrap_pointer(y)) return 0;
                break;
            case JANET_TUPLE: {
                const Janet *t1 = janet_unwrap_tuple(x);
                const Janet *t2 = janet_unwrap_tuple(y);
                if (t1 == t2) break;
                if (janet_tuple_hash(t1) != janet_tuple_hash(t2)) return 0;
                if (janet_tuple_length(t1) != janet_tuple_length(t2)) return 0;
                push_traversal_node(janet_tuple_head(t1), janet_tuple_head(t2), 0);
                break;
            }
            break;
            case JANET_STRUCT: {
                const JanetKV *s1 = janet_unwrap_struct(x);
                const JanetKV *s2 = janet_unwrap_struct(y);
                if (s1 == s2) break;
                if (janet_struct_hash(s1) != janet_struct_hash(s2)) return 0;
                if (janet_struct_length(s1) != janet_struct_length(s2)) return 0;
                push_traversal_node(janet_struct_head(s1), janet_struct_head(s2), 0);
                break;
            }
            break;
        }
    } while (!traversal_next(&x, &y));
    return 1;
}

/* Computes a hash value for a function */
int32_t janet_hash(Janet x) {
    int32_t hash = 0;
    switch (janet_type(x)) {
        case JANET_NIL:
            hash = 0;
            break;
        case JANET_BOOLEAN:
            hash = janet_unwrap_boolean(x);
            break;
        case JANET_STRING:
        case JANET_SYMBOL:
        case JANET_KEYWORD:
            hash = janet_string_hash(janet_unwrap_string(x));
            break;
        case JANET_TUPLE:
            hash = janet_tuple_hash(janet_unwrap_tuple(x));
            break;
        case JANET_STRUCT:
            hash = janet_struct_hash(janet_unwrap_struct(x));
            break;
        case JANET_ABSTRACT: {
            JanetAbstract xx = janet_unwrap_abstract(x);
            const JanetAbstractType *at = janet_abstract_type(xx);
            if (at->hash != NULL) {
                hash = at->hash(xx, janet_abstract_size(xx));
                break;
            }
        }
        /* fallthrough */
        default:
            /* TODO - test performance with different hash functions */
            if (sizeof(double) == sizeof(void *)) {
                /* Assuming 8 byte pointer */
                uint64_t i = janet_u64(x);
                hash = (int32_t)(i & 0xFFFFFFFF);
                /* Get a bit more entropy by shifting the low bits out */
                hash >>= 3;
                hash ^= (int32_t)(i >> 32);
            } else {
                /* Assuming 4 byte pointer (or smaller) */
                hash = (int32_t)((char *)janet_unwrap_pointer(x) - (char *)0);
                hash >>= 2;
            }
            break;
    }
    return hash;
}

/* Compares x to y. If they are equal returns 0. If x is less, returns -1.
 * If y is less, returns 1. All types are comparable
 * and should have strict ordering, excepts NaNs. */
int janet_compare(Janet x, Janet y) {
    janet_vm_traversal = janet_vm_traversal_base;
    int status;
    do {
        JanetType tx = janet_type(x);
        JanetType ty = janet_type(y);
        if (tx != ty) return tx < ty ? -1 : 1;
        switch (tx) {
            case JANET_NIL:
                break;
            case JANET_BOOLEAN: {
                int diff = janet_unwrap_boolean(x) - janet_unwrap_boolean(y);
                if (diff) return diff;
                break;
            }
            case JANET_NUMBER: {
                double xx = janet_unwrap_number(x);
                double yy = janet_unwrap_number(y);
                if (xx == yy) {
                    break;
                } else {
                    return (xx < yy) ? -1 : 1;
                }
            }
            case JANET_STRING:
            case JANET_SYMBOL:
            case JANET_KEYWORD: {
                int diff = janet_string_compare(janet_unwrap_string(x), janet_unwrap_string(y));
                if (diff) return diff;
                break;
            }
            case JANET_ABSTRACT: {
                int diff = janet_compare_abstract(janet_unwrap_abstract(x), janet_unwrap_abstract(y));
                if (diff) return diff;
                break;
            }
            default: {
                if (janet_unwrap_pointer(x) == janet_unwrap_pointer(y)) {
                    break;
                } else {
                    return janet_unwrap_pointer(x) > janet_unwrap_pointer(y) ? 1 : -1;
                }
            }
            case JANET_TUPLE: {
                const Janet *lhs = janet_unwrap_tuple(x);
                const Janet *rhs = janet_unwrap_tuple(y);
                push_traversal_node(janet_tuple_head(lhs), janet_tuple_head(rhs), 1);
                break;
            }
            case JANET_STRUCT: {
                const JanetKV *lhs = janet_unwrap_struct(x);
                const JanetKV *rhs = janet_unwrap_struct(y);
                int32_t llen = janet_struct_capacity(lhs);
                int32_t rlen = janet_struct_capacity(rhs);
                int32_t lhash = janet_struct_hash(lhs);
                int32_t rhash = janet_struct_hash(rhs);
                if (llen < rlen) return -1;
                if (llen > rlen) return 1;
                if (lhash < rhash) return -1;
                if (lhash > rhash) return 1;
                push_traversal_node(janet_struct_head(lhs), janet_struct_head(rhs), 0);
                break;
            }
        }
    } while (!(status = traversal_next(&x, &y)));
    return status - 2;
}

static int32_t getter_checkint(Janet key, int32_t max) {
    if (!janet_checkint(key)) goto bad;
    int32_t ret = janet_unwrap_integer(key);
    if (ret < 0) goto bad;
    if (ret >= max) goto bad;
    return ret;
bad:
    janet_panicf("expected integer key in range [0, %d), got %v", max, key);
}

/* Gets a value and returns. Can panic. */
Janet janet_in(Janet ds, Janet key) {
    Janet value;
    switch (janet_type(ds)) {
        default:
            janet_panicf("expected %T, got %v", JANET_TFLAG_LENGTHABLE, ds);
            break;
        case JANET_STRUCT:
            value = janet_struct_get(janet_unwrap_struct(ds), key);
            break;
        case JANET_TABLE:
            value = janet_table_get(janet_unwrap_table(ds), key);
            break;
        case JANET_ARRAY: {
            JanetArray *array = janet_unwrap_array(ds);
            int32_t index = getter_checkint(key, array->count);
            value = array->data[index];
            break;
        }
        case JANET_TUPLE: {
            const Janet *tuple = janet_unwrap_tuple(ds);
            int32_t len = janet_tuple_length(tuple);
            value = tuple[getter_checkint(key, len)];
            break;
        }
        case JANET_BUFFER: {
            JanetBuffer *buffer = janet_unwrap_buffer(ds);
            int32_t index = getter_checkint(key, buffer->count);
            value = janet_wrap_integer(buffer->data[index]);
            break;
        }
        case JANET_STRING:
        case JANET_SYMBOL:
        case JANET_KEYWORD: {
            const uint8_t *str = janet_unwrap_string(ds);
            int32_t index = getter_checkint(key, janet_string_length(str));
            value = janet_wrap_integer(str[index]);
            break;
        }
        case JANET_ABSTRACT: {
            JanetAbstractType *type = (JanetAbstractType *)janet_abstract_type(janet_unwrap_abstract(ds));
            if (type->get) {
                if (!(type->get)(janet_unwrap_abstract(ds), key, &value))
                    janet_panicf("key %v not found in %v ", key, ds);
            } else {
                janet_panicf("no getter for %v ", ds);
            }
            break;
        }
    }
    return value;
}

Janet janet_get(Janet ds, Janet key) {
    JanetType t = janet_type(ds);
    switch (t) {
        default:
            return janet_wrap_nil();
        case JANET_STRING:
        case JANET_SYMBOL:
        case JANET_KEYWORD: {
            if (!janet_checkint(key)) return janet_wrap_nil();
            int32_t index = janet_unwrap_integer(key);
            if (index < 0) return janet_wrap_nil();
            const uint8_t *str = janet_unwrap_string(ds);
            if (index >= janet_string_length(str)) return janet_wrap_nil();
            return janet_wrap_integer(str[index]);
        }
        case JANET_ABSTRACT: {
            Janet value;
            void *abst = janet_unwrap_abstract(ds);
            JanetAbstractType *type = (JanetAbstractType *)janet_abstract_type(abst);
            if (!type->get) return janet_wrap_nil();
            if ((type->get)(abst, key, &value))
                return value;
            return janet_wrap_nil();
        }
        case JANET_ARRAY:
        case JANET_TUPLE:
        case JANET_BUFFER: {
            if (!janet_checkint(key)) return janet_wrap_nil();
            int32_t index = janet_unwrap_integer(key);
            if (index < 0) return janet_wrap_nil();
            if (t == JANET_ARRAY) {
                JanetArray *a = janet_unwrap_array(ds);
                if (index >= a->count) return janet_wrap_nil();
                return a->data[index];
            } else if (t == JANET_BUFFER) {
                JanetBuffer *b = janet_unwrap_buffer(ds);
                if (index >= b->count) return janet_wrap_nil();
                return janet_wrap_integer(b->data[index]);
            } else {
                const Janet *t = janet_unwrap_tuple(ds);
                if (index >= janet_tuple_length(t)) return janet_wrap_nil();
                return t[index];
            }
        }
        case JANET_TABLE: {
            return janet_table_get(janet_unwrap_table(ds), key);
        }
        case JANET_STRUCT: {
            const JanetKV *st = janet_unwrap_struct(ds);
            return janet_struct_get(st, key);
        }
    }
}

Janet janet_getindex(Janet ds, int32_t index) {
    Janet value;
    if (index < 0) janet_panic("expected non-negative index");
    switch (janet_type(ds)) {
        default:
            janet_panicf("expected %T, got %v", JANET_TFLAG_LENGTHABLE, ds);
            break;
        case JANET_STRING:
        case JANET_SYMBOL:
        case JANET_KEYWORD:
            if (index >= janet_string_length(janet_unwrap_string(ds))) {
                value = janet_wrap_nil();
            } else {
                value = janet_wrap_integer(janet_unwrap_string(ds)[index]);
            }
            break;
        case JANET_ARRAY:
            if (index >= janet_unwrap_array(ds)->count) {
                value = janet_wrap_nil();
            } else {
                value = janet_unwrap_array(ds)->data[index];
            }
            break;
        case JANET_BUFFER:
            if (index >= janet_unwrap_buffer(ds)->count) {
                value = janet_wrap_nil();
            } else {
                value = janet_wrap_integer(janet_unwrap_buffer(ds)->data[index]);
            }
            break;
        case JANET_TUPLE:
            if (index >= janet_tuple_length(janet_unwrap_tuple(ds))) {
                value = janet_wrap_nil();
            } else {
                value = janet_unwrap_tuple(ds)[index];
            }
            break;
        case JANET_TABLE:
            value = janet_table_get(janet_unwrap_table(ds), janet_wrap_integer(index));
            break;
        case JANET_STRUCT:
            value = janet_struct_get(janet_unwrap_struct(ds), janet_wrap_integer(index));
            break;
        case JANET_ABSTRACT: {
            JanetAbstractType *type = (JanetAbstractType *)janet_abstract_type(janet_unwrap_abstract(ds));
            if (type->get) {
                if (!(type->get)(janet_unwrap_abstract(ds), janet_wrap_integer(index), &value))
                    value = janet_wrap_nil();
            } else {
                janet_panicf("no getter for %v ", ds);
            }
            break;
        }
    }
    return value;
}

int32_t janet_length(Janet x) {
    switch (janet_type(x)) {
        default:
            janet_panicf("expected %T, got %v", JANET_TFLAG_LENGTHABLE, x);
        case JANET_STRING:
        case JANET_SYMBOL:
        case JANET_KEYWORD:
            return janet_string_length(janet_unwrap_string(x));
        case JANET_ARRAY:
            return janet_unwrap_array(x)->count;
        case JANET_BUFFER:
            return janet_unwrap_buffer(x)->count;
        case JANET_TUPLE:
            return janet_tuple_length(janet_unwrap_tuple(x));
        case JANET_STRUCT:
            return janet_struct_length(janet_unwrap_struct(x));
        case JANET_TABLE:
            return janet_unwrap_table(x)->count;
        case JANET_ABSTRACT: {
            Janet argv[1] = { x };
            Janet len = janet_mcall("length", 1, argv);
            if (!janet_checkint(len))
                janet_panicf("invalid integer length %v", len);
            return janet_unwrap_integer(len);
        }
    }
}

Janet janet_lengthv(Janet x) {
    switch (janet_type(x)) {
        default:
            janet_panicf("expected %T, got %v", JANET_TFLAG_LENGTHABLE, x);
        case JANET_STRING:
        case JANET_SYMBOL:
        case JANET_KEYWORD:
            return janet_wrap_integer(janet_string_length(janet_unwrap_string(x)));
        case JANET_ARRAY:
            return janet_wrap_integer(janet_unwrap_array(x)->count);
        case JANET_BUFFER:
            return janet_wrap_integer(janet_unwrap_buffer(x)->count);
        case JANET_TUPLE:
            return janet_wrap_integer(janet_tuple_length(janet_unwrap_tuple(x)));
        case JANET_STRUCT:
            return janet_wrap_integer(janet_struct_length(janet_unwrap_struct(x)));
        case JANET_TABLE:
            return janet_wrap_integer(janet_unwrap_table(x)->count);
        case JANET_ABSTRACT: {
            Janet argv[1] = { x };
            return janet_mcall("length", 1, argv);
        }
    }
}

void janet_putindex(Janet ds, int32_t index, Janet value) {
    switch (janet_type(ds)) {
        default:
            janet_panicf("expected %T, got %v",
                         JANET_TFLAG_ARRAY | JANET_TFLAG_BUFFER | JANET_TFLAG_TABLE, ds);
        case JANET_ARRAY: {
            JanetArray *array = janet_unwrap_array(ds);
            if (index >= array->count) {
                janet_array_ensure(array, index + 1, 2);
                array->count = index + 1;
            }
            array->data[index] = value;
            break;
        }
        case JANET_BUFFER: {
            JanetBuffer *buffer = janet_unwrap_buffer(ds);
            if (!janet_checkint(value))
                janet_panicf("can only put integers in buffers, got %v", value);
            if (index >= buffer->count) {
                janet_buffer_ensure(buffer, index + 1, 2);
                buffer->count = index + 1;
            }
            buffer->data[index] = (uint8_t)(janet_unwrap_integer(value) & 0xFF);
            break;
        }
        case JANET_TABLE: {
            JanetTable *table = janet_unwrap_table(ds);
            janet_table_put(table, janet_wrap_integer(index), value);
            break;
        }
        case JANET_ABSTRACT: {
            JanetAbstractType *type = (JanetAbstractType *)janet_abstract_type(janet_unwrap_abstract(ds));
            if (type->put) {
                (type->put)(janet_unwrap_abstract(ds), janet_wrap_integer(index), value);
            } else {
                janet_panicf("no setter for %v ", ds);
            }
            break;
        }
    }
}

void janet_put(Janet ds, Janet key, Janet value) {
    switch (janet_type(ds)) {
        default:
            janet_panicf("expected %T, got %v",
                         JANET_TFLAG_ARRAY | JANET_TFLAG_BUFFER | JANET_TFLAG_TABLE, ds);
        case JANET_ARRAY: {
            JanetArray *array = janet_unwrap_array(ds);
            int32_t index = getter_checkint(key, INT32_MAX - 1);
            if (index >= array->count) {
                janet_array_setcount(array, index + 1);
            }
            array->data[index] = value;
            break;
        }
        case JANET_BUFFER: {
            JanetBuffer *buffer = janet_unwrap_buffer(ds);
            int32_t index = getter_checkint(key, INT32_MAX - 1);
            if (!janet_checkint(value))
                janet_panicf("can only put integers in buffers, got %v", value);
            if (index >= buffer->count) {
                janet_buffer_setcount(buffer, index + 1);
            }
            buffer->data[index] = (uint8_t)(janet_unwrap_integer(value) & 0xFF);
            break;
        }
        case JANET_TABLE:
            janet_table_put(janet_unwrap_table(ds), key, value);
            break;
        case JANET_ABSTRACT: {
            JanetAbstractType *type = (JanetAbstractType *)janet_abstract_type(janet_unwrap_abstract(ds));
            if (type->put) {
                (type->put)(janet_unwrap_abstract(ds), key, value);
            } else {
                janet_panicf("no setter for %v ", ds);
            }
            break;
        }
    }
}


/* src/core/vector.c */
#line 0 "src/core/vector.c"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include "vector.h"
#include "util.h"
#endif

/* Grow the buffer dynamically. Used for push operations. */
void *janet_v_grow(void *v, int32_t increment, int32_t itemsize) {
    int32_t dbl_cur = (NULL != v) ? 2 * janet_v__cap(v) : 0;
    int32_t min_needed = janet_v_count(v) + increment;
    int32_t m = dbl_cur > min_needed ? dbl_cur : min_needed;
    size_t newsize = ((size_t) itemsize) * m + sizeof(int32_t) * 2;
    int32_t *p = (int32_t *) janet_srealloc(v ? janet_v__raw(v) : 0, newsize);
    if (!v) p[1] = 0;
    p[0] = m;
    return p + 2;
}

/* Convert a buffer to normal allocated memory (forget capacity) */
void *janet_v_flattenmem(void *v, int32_t itemsize) {
    int32_t *p;
    if (NULL == v) return NULL;
    size_t size = (size_t) itemsize * janet_v__cnt(v);
    p = malloc(size);
    if (NULL != p) {
        safe_memcpy(p, v, size);
        return p;
    } else {
        JANET_OUT_OF_MEMORY;
    }
}



/* src/core/vm.c */
#line 0 "src/core/vm.c"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include "state.h"
#include "fiber.h"
#include "gc.h"
#include "symcache.h"
#include "util.h"
#endif

#include <math.h>

/* VM state */
JANET_THREAD_LOCAL JanetTable *janet_vm_core_env;
JANET_THREAD_LOCAL JanetTable *janet_vm_registry;
JANET_THREAD_LOCAL JanetTable *janet_vm_abstract_registry;
JANET_THREAD_LOCAL int janet_vm_stackn = 0;
JANET_THREAD_LOCAL JanetFiber *janet_vm_fiber = NULL;
JANET_THREAD_LOCAL JanetFiber *janet_vm_root_fiber = NULL;
JANET_THREAD_LOCAL Janet *janet_vm_return_reg = NULL;
JANET_THREAD_LOCAL jmp_buf *janet_vm_jmp_buf = NULL;

/* Virtual registers
 *
 * One instruction word
 * CC | BB | AA | OP
 * DD | DD | DD | OP
 * EE | EE | AA | OP
 */
#define A ((*pc >> 8)  & 0xFF)
#define B ((*pc >> 16) & 0xFF)
#define C (*pc >> 24)
#define D (*pc >> 8)
#define E (*pc >> 16)

/* Signed interpretations of registers */
#define CS (*((int32_t *)pc) >> 24)
#define DS (*((int32_t *)pc) >> 8)
#define ES (*((int32_t *)pc) >> 16)

/* How we dispatch instructions. By default, we use
 * a switch inside an infinite loop. For GCC/clang, we use
 * computed gotos. */
#if defined(__GNUC__) && !defined(__EMSCRIPTEN__)
#define JANET_USE_COMPUTED_GOTOS
#endif

#ifdef JANET_USE_COMPUTED_GOTOS
#define VM_START() { goto *op_lookup[first_opcode];
#define VM_END() }
#define VM_OP(op) label_##op :
#define VM_DEFAULT() label_unknown_op:
#define vm_next() goto *op_lookup[*pc & 0xFF]
#define opcode (*pc & 0xFF)
#else
#define VM_START() uint8_t opcode = first_opcode; for (;;) {switch(opcode) {
#define VM_END() }}
#define VM_OP(op) case op :
#define VM_DEFAULT() default:
#define vm_next() opcode = *pc & 0xFF; continue
#endif

/* Commit and restore VM state before possible longjmp */
#define vm_commit() do { janet_stack_frame(stack)->pc = pc; } while (0)
#define vm_restore() do { \
    stack = fiber->data + fiber->frame; \
    pc = janet_stack_frame(stack)->pc; \
    func = janet_stack_frame(stack)->func; \
} while (0)
#define vm_return(sig, val) do { \
    janet_vm_return_reg[0] = (val); \
    vm_commit(); \
    return (sig); \
} while (0)

/* Next instruction variations */
#define maybe_collect() do {\
    if (janet_vm_next_collection >= janet_vm_gc_interval) janet_collect(); } while (0)
#define vm_checkgc_next() maybe_collect(); vm_next()
#define vm_pcnext() pc++; vm_next()
#define vm_checkgc_pcnext() maybe_collect(); vm_pcnext()

/* Handle certain errors in main vm loop */
#define vm_throw(e) do { vm_commit(); janet_panic(e); } while (0)
#define vm_assert(cond, e) do {if (!(cond)) vm_throw((e)); } while (0)
#define vm_assert_type(X, T) do { \
    if (!(janet_checktype((X), (T)))) { \
        vm_commit(); \
        janet_panicf("expected %T, got %v", (1 << (T)), (X)); \
    } \
} while (0)
#define vm_assert_types(X, TS) do { \
    if (!(janet_checktypes((X), (TS)))) { \
        vm_commit(); \
        janet_panicf("expected %T, got %v", (TS), (X)); \
    } \
} while (0)

/* Templates for certain patterns in opcodes */
#define vm_binop_immediate(op)\
    {\
        Janet op1 = stack[B];\
        if (!janet_checktype(op1, JANET_NUMBER)) {\
            vm_commit();\
            Janet _argv[2] = { op1, janet_wrap_number(CS) };\
            stack[A] = janet_mcall(#op, 2, _argv);\
            vm_checkgc_pcnext();\
        } else {\
            double x1 = janet_unwrap_number(op1);\
            stack[A] = janet_wrap_number(x1 op CS);\
            vm_pcnext();\
        }\
    }
#define _vm_bitop_immediate(op, type1)\
    {\
        Janet op1 = stack[B];\
        if (!janet_checktype(op1, JANET_NUMBER)) {\
            vm_commit();\
            Janet _argv[2] = { op1, janet_wrap_number(CS) };\
            stack[A] = janet_mcall(#op, 2, _argv);\
            vm_checkgc_pcnext();\
        } else {\
            type1 x1 = (type1) janet_unwrap_integer(op1);\
            stack[A] = janet_wrap_integer(x1 op CS);\
            vm_pcnext();\
        }\
    }
#define vm_bitop_immediate(op) _vm_bitop_immediate(op, int32_t);
#define vm_bitopu_immediate(op) _vm_bitop_immediate(op, uint32_t);
#define _vm_binop(op, wrap)\
    {\
        Janet op1 = stack[B];\
        Janet op2 = stack[C];\
        if (janet_checktype(op1, JANET_NUMBER) && janet_checktype(op2, JANET_NUMBER)) {\
            double x1 = janet_unwrap_number(op1);\
            double x2 = janet_unwrap_number(op2);\
            stack[A] = wrap(x1 op x2);\
            vm_pcnext();\
        } else {\
            vm_commit();\
            stack[A] = janet_binop_call(#op, "r" #op, op1, op2);\
            vm_checkgc_pcnext();\
        }\
    }
#define vm_binop(op) _vm_binop(op, janet_wrap_number)
#define _vm_bitop(op, type1)\
    {\
        Janet op1 = stack[B];\
        Janet op2 = stack[C];\
        if (janet_checktype(op1, JANET_NUMBER) && janet_checktype(op2, JANET_NUMBER)) {\
            type1 x1 = (type1) janet_unwrap_integer(op1);\
            int32_t x2 = janet_unwrap_integer(op2);\
            stack[A] = janet_wrap_integer(x1 op x2);\
            vm_pcnext();\
        } else {\
            vm_commit();\
            stack[A] = janet_binop_call(#op, "r" #op, op1, op2);\
            vm_checkgc_pcnext();\
        }\
    }
#define vm_bitop(op) _vm_bitop(op, int32_t)
#define vm_bitopu(op) _vm_bitop(op, uint32_t)
#define vm_compop(op) \
    {\
        Janet op1 = stack[B];\
        Janet op2 = stack[C];\
        if (janet_checktype(op1, JANET_NUMBER) && janet_checktype(op2, JANET_NUMBER)) {\
            double x1 = janet_unwrap_number(op1);\
            double x2 = janet_unwrap_number(op2);\
            stack[A] = janet_wrap_boolean(x1 op x2);\
            vm_pcnext();\
        } else {\
            vm_commit();\
            stack[A] = janet_wrap_boolean(janet_compare(op1, op2) op 0);\
            vm_checkgc_pcnext();\
        }\
    }

/* Trace a function call */
static void vm_do_trace(JanetFunction *func, int32_t argc, const Janet *argv) {
    if (func->def->name) {
        janet_printf("trace (%S", func->def->name);
    } else {
        janet_printf("trace (%p", janet_wrap_function(func));
    }
    for (int32_t i = 0; i < argc; i++) {
        janet_printf(" %p", argv[i]);
    }
    janet_printf(")\n");
}

/* Invoke a method once we have looked it up */
static Janet janet_method_invoke(Janet method, int32_t argc, Janet *argv) {
    switch (janet_type(method)) {
        case JANET_CFUNCTION:
            return (janet_unwrap_cfunction(method))(argc, argv);
        case JANET_FUNCTION: {
            JanetFunction *fun = janet_unwrap_function(method);
            return janet_call(fun, argc, argv);
        }
        case JANET_ABSTRACT: {
            JanetAbstract abst = janet_unwrap_abstract(method);
            const JanetAbstractType *at = janet_abstract_type(abst);
            if (NULL != at->call) {
                return at->call(abst, argc, argv);
            }
        }
        /* fallthrough */
        case JANET_STRING:
        case JANET_BUFFER:
        case JANET_TABLE:
        case JANET_STRUCT:
        case JANET_ARRAY:
        case JANET_TUPLE: {
            if (argc != 1) {
                janet_panicf("%v called with %d arguments, possibly expected 1", method, argc);
            }
            return janet_in(method, argv[0]);
        }
        default: {
            if (argc != 1) {
                janet_panicf("%v called with %d arguments, possibly expected 1", method, argc);
            }
            return janet_in(argv[0], method);
        }
    }
}

/* Call a non function type from a JOP_CALL or JOP_TAILCALL instruction.
 * Assumes that the arguments are on the fiber stack. */
static Janet call_nonfn(JanetFiber *fiber, Janet callee) {
    int32_t argc = fiber->stacktop - fiber->stackstart;
    fiber->stacktop = fiber->stackstart;
    return janet_method_invoke(callee, argc, fiber->data + fiber->stacktop);
}

/* Get a callable from a keyword method name and ensure that it is valid. */
static Janet resolve_method(Janet name, JanetFiber *fiber) {
    int32_t argc = fiber->stacktop - fiber->stackstart;
    if (argc < 1) janet_panicf("method call (%v) takes at least 1 argument, got 0", name);
    Janet callee = janet_get(fiber->data[fiber->stackstart], name);
    if (janet_checktype(callee, JANET_NIL))
        janet_panicf("unknown method %v invoked on %v", name, fiber->data[fiber->stackstart]);
    return callee;
}

/* Lookup method on value x */
static Janet janet_method_lookup(Janet x, const char *name) {
    Janet kname = janet_ckeywordv(name);
    return janet_get(x, kname);
}

/* Call a method first on the righthand side, and then on the left hand side with a prefix */
static Janet janet_binop_call(const char *lmethod, const char *rmethod, Janet lhs, Janet rhs) {
    Janet lm = janet_method_lookup(lhs, lmethod);
    if (janet_checktype(lm, JANET_NIL)) {
        /* Invert order for rmethod */
        Janet lr = janet_method_lookup(rhs, rmethod);
        Janet argv[2] = { rhs, lhs };
        if (janet_checktype(lr, JANET_NIL)) {
            janet_panicf("could not find method :%s for %v, or :%s for %v",
                         lmethod, lhs,
                         rmethod, rhs);
        }
        return janet_method_invoke(lr, 2, argv);
    } else {
        Janet argv[2] = { lhs, rhs };
        return janet_method_invoke(lm, 2, argv);
    }
}

/* Forward declaration */
static JanetSignal janet_check_can_resume(JanetFiber *fiber, Janet *out);
static JanetSignal janet_continue_no_check(JanetFiber *fiber, Janet in, Janet *out);

/* Interpreter main loop */
static JanetSignal run_vm(JanetFiber *fiber, Janet in) {

    /* opcode -> label lookup if using clang/GCC */
#ifdef JANET_USE_COMPUTED_GOTOS
    static void *op_lookup[255] = {
        &&label_JOP_NOOP,
        &&label_JOP_ERROR,
        &&label_JOP_TYPECHECK,
        &&label_JOP_RETURN,
        &&label_JOP_RETURN_NIL,
        &&label_JOP_ADD_IMMEDIATE,
        &&label_JOP_ADD,
        &&label_JOP_SUBTRACT,
        &&label_JOP_MULTIPLY_IMMEDIATE,
        &&label_JOP_MULTIPLY,
        &&label_JOP_DIVIDE_IMMEDIATE,
        &&label_JOP_DIVIDE,
        &&label_JOP_MODULO,
        &&label_JOP_REMAINDER,
        &&label_JOP_BAND,
        &&label_JOP_BOR,
        &&label_JOP_BXOR,
        &&label_JOP_BNOT,
        &&label_JOP_SHIFT_LEFT,
        &&label_JOP_SHIFT_LEFT_IMMEDIATE,
        &&label_JOP_SHIFT_RIGHT,
        &&label_JOP_SHIFT_RIGHT_IMMEDIATE,
        &&label_JOP_SHIFT_RIGHT_UNSIGNED,
        &&label_JOP_SHIFT_RIGHT_UNSIGNED_IMMEDIATE,
        &&label_JOP_MOVE_FAR,
        &&label_JOP_MOVE_NEAR,
        &&label_JOP_JUMP,
        &&label_JOP_JUMP_IF,
        &&label_JOP_JUMP_IF_NOT,
        &&label_JOP_JUMP_IF_NIL,
        &&label_JOP_JUMP_IF_NOT_NIL,
        &&label_JOP_GREATER_THAN,
        &&label_JOP_GREATER_THAN_IMMEDIATE,
        &&label_JOP_LESS_THAN,
        &&label_JOP_LESS_THAN_IMMEDIATE,
        &&label_JOP_EQUALS,
        &&label_JOP_EQUALS_IMMEDIATE,
        &&label_JOP_COMPARE,
        &&label_JOP_LOAD_NIL,
        &&label_JOP_LOAD_TRUE,
        &&label_JOP_LOAD_FALSE,
        &&label_JOP_LOAD_INTEGER,
        &&label_JOP_LOAD_CONSTANT,
        &&label_JOP_LOAD_UPVALUE,
        &&label_JOP_LOAD_SELF,
        &&label_JOP_SET_UPVALUE,
        &&label_JOP_CLOSURE,
        &&label_JOP_PUSH,
        &&label_JOP_PUSH_2,
        &&label_JOP_PUSH_3,
        &&label_JOP_PUSH_ARRAY,
        &&label_JOP_CALL,
        &&label_JOP_TAILCALL,
        &&label_JOP_RESUME,
        &&label_JOP_SIGNAL,
        &&label_JOP_PROPAGATE,
        &&label_JOP_IN,
        &&label_JOP_GET,
        &&label_JOP_PUT,
        &&label_JOP_GET_INDEX,
        &&label_JOP_PUT_INDEX,
        &&label_JOP_LENGTH,
        &&label_JOP_MAKE_ARRAY,
        &&label_JOP_MAKE_BUFFER,
        &&label_JOP_MAKE_STRING,
        &&label_JOP_MAKE_STRUCT,
        &&label_JOP_MAKE_TABLE,
        &&label_JOP_MAKE_TUPLE,
        &&label_JOP_MAKE_BRACKET_TUPLE,
        &&label_JOP_GREATER_THAN_EQUAL,
        &&label_JOP_LESS_THAN_EQUAL,
        &&label_JOP_NEXT,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op,
        &&label_unknown_op
    };
#endif

    /* Interpreter state */
    register Janet *stack;
    register uint32_t *pc;
    register JanetFunction *func;
    vm_restore();

    if (fiber->flags & JANET_FIBER_DID_LONGJUMP) {
        if (janet_fiber_frame(fiber)->func == NULL) {
            /* Inside a c function */
            janet_fiber_popframe(fiber);
            vm_restore();
        }
        /* Check if we were at a tail call instruction. If so, do implicit return */
        if ((*pc & 0xFF) == JOP_TAILCALL) {
            /* Tail call resume */
            int entrance_frame = janet_stack_frame(stack)->flags & JANET_STACKFRAME_ENTRANCE;
            janet_fiber_popframe(fiber);
            if (entrance_frame) {
                fiber->flags &= ~JANET_FIBER_FLAG_MASK;
                vm_return(JANET_SIGNAL_OK, in);
            }
            vm_restore();
        }
    }

    if (!(fiber->flags & JANET_FIBER_RESUME_NO_USEVAL)) stack[A] = in;
    if (!(fiber->flags & JANET_FIBER_RESUME_NO_SKIP)) pc++;

    uint8_t first_opcode = *pc & ((fiber->flags & JANET_FIBER_BREAKPOINT) ? 0x7F : 0xFF);

    fiber->flags &= ~JANET_FIBER_FLAG_MASK;

    /* Main interpreter loop. Semantically is a switch on
     * (*pc & 0xFF) inside of an infinite loop. */
    VM_START();

    VM_DEFAULT();
    fiber->flags |= JANET_FIBER_BREAKPOINT | JANET_FIBER_RESUME_NO_USEVAL | JANET_FIBER_RESUME_NO_SKIP;
    vm_return(JANET_SIGNAL_DEBUG, janet_wrap_nil());

    VM_OP(JOP_NOOP)
    vm_pcnext();

    VM_OP(JOP_ERROR)
    vm_return(JANET_SIGNAL_ERROR, stack[A]);

    VM_OP(JOP_TYPECHECK)
    vm_assert_types(stack[A], E);
    vm_pcnext();

    VM_OP(JOP_RETURN) {
        Janet retval = stack[D];
        int entrance_frame = janet_stack_frame(stack)->flags & JANET_STACKFRAME_ENTRANCE;
        janet_fiber_popframe(fiber);
        if (entrance_frame) vm_return(JANET_SIGNAL_OK, retval);
        vm_restore();
        stack[A] = retval;
        vm_checkgc_pcnext();
    }

    VM_OP(JOP_RETURN_NIL) {
        Janet retval = janet_wrap_nil();
        int entrance_frame = janet_stack_frame(stack)->flags & JANET_STACKFRAME_ENTRANCE;
        janet_fiber_popframe(fiber);
        if (entrance_frame) vm_return(JANET_SIGNAL_OK, retval);
        vm_restore();
        stack[A] = retval;
        vm_checkgc_pcnext();
    }

    VM_OP(JOP_ADD_IMMEDIATE)
    vm_binop_immediate(+);

    VM_OP(JOP_ADD)
    vm_binop(+);

    VM_OP(JOP_SUBTRACT)
    vm_binop(-);

    VM_OP(JOP_MULTIPLY_IMMEDIATE)
    vm_binop_immediate(*);

    VM_OP(JOP_MULTIPLY)
    vm_binop(*);

    VM_OP(JOP_DIVIDE_IMMEDIATE)
    vm_binop_immediate( /);

    VM_OP(JOP_DIVIDE)
    vm_binop( /);

    VM_OP(JOP_MODULO) {
        Janet op1 = stack[B];
        Janet op2 = stack[C];
        if (janet_checktype(op1, JANET_NUMBER) && janet_checktype(op2, JANET_NUMBER)) {
            double x1 = janet_unwrap_number(op1);
            double x2 = janet_unwrap_number(op2);
            double intres = x2 * floor(x1 / x2);
            stack[A] = janet_wrap_number(x1 - intres);
            vm_pcnext();
        } else {
            vm_commit();
            stack[A] = janet_binop_call("mod", "rmod", op1, op2);
            vm_checkgc_pcnext();
        }
    }

    VM_OP(JOP_REMAINDER) {
        Janet op1 = stack[B];
        Janet op2 = stack[C];
        if (janet_checktype(op1, JANET_NUMBER) && janet_checktype(op2, JANET_NUMBER)) {
            double x1 = janet_unwrap_number(op1);
            double x2 = janet_unwrap_number(op2);
            stack[A] = janet_wrap_number(fmod(x1, x2));
            vm_pcnext();
        } else {
            vm_commit();
            stack[A] = janet_binop_call("%", "r%", op1, op2);
            vm_checkgc_pcnext();
        }
    }

    VM_OP(JOP_BAND)
    vm_bitop(&);

    VM_OP(JOP_BOR)
    vm_bitop( |);

    VM_OP(JOP_BXOR)
    vm_bitop(^);

    VM_OP(JOP_BNOT) {
        Janet op = stack[E];
        vm_assert_type(op, JANET_NUMBER);
        stack[A] = janet_wrap_integer(~janet_unwrap_integer(op));
        vm_pcnext();
    }

    VM_OP(JOP_SHIFT_RIGHT_UNSIGNED)
    vm_bitopu( >>);

    VM_OP(JOP_SHIFT_RIGHT_UNSIGNED_IMMEDIATE)
    vm_bitopu_immediate( >>);

    VM_OP(JOP_SHIFT_RIGHT)
    vm_bitop( >>);

    VM_OP(JOP_SHIFT_RIGHT_IMMEDIATE)
    vm_bitop_immediate( >>);

    VM_OP(JOP_SHIFT_LEFT)
    vm_bitop( <<);

    VM_OP(JOP_SHIFT_LEFT_IMMEDIATE)
    vm_bitop_immediate( <<);

    VM_OP(JOP_MOVE_NEAR)
    stack[A] = stack[E];
    vm_pcnext();

    VM_OP(JOP_MOVE_FAR)
    stack[E] = stack[A];
    vm_pcnext();

    VM_OP(JOP_JUMP)
    pc += DS;
    vm_next();

    VM_OP(JOP_JUMP_IF)
    if (janet_truthy(stack[A])) {
        pc += ES;
    } else {
        pc++;
    }
    vm_next();

    VM_OP(JOP_JUMP_IF_NOT)
    if (janet_truthy(stack[A])) {
        pc++;
    } else {
        pc += ES;
    }
    vm_next();

    VM_OP(JOP_JUMP_IF_NIL)
    if (janet_checktype(stack[A], JANET_NIL)) {
        pc += ES;
    } else {
        pc++;
    }
    vm_next();

    VM_OP(JOP_JUMP_IF_NOT_NIL)
    if (janet_checktype(stack[A], JANET_NIL)) {
        pc++;
    } else {
        pc += ES;
    }
    vm_next();

    VM_OP(JOP_LESS_THAN)
    vm_compop( <);

    VM_OP(JOP_LESS_THAN_EQUAL)
    vm_compop( <=);

    VM_OP(JOP_LESS_THAN_IMMEDIATE)
    stack[A] = janet_wrap_boolean(janet_unwrap_integer(stack[B]) < CS);
    vm_pcnext();

    VM_OP(JOP_GREATER_THAN)
    vm_compop( >);

    VM_OP(JOP_GREATER_THAN_EQUAL)
    vm_compop( >=);

    VM_OP(JOP_GREATER_THAN_IMMEDIATE)
    stack[A] = janet_wrap_boolean(janet_unwrap_integer(stack[B]) > CS);
    vm_pcnext();

    VM_OP(JOP_EQUALS)
    stack[A] = janet_wrap_boolean(janet_equals(stack[B], stack[C]));
    vm_pcnext();

    VM_OP(JOP_EQUALS_IMMEDIATE)
    stack[A] = janet_wrap_boolean(janet_unwrap_integer(stack[B]) == CS);
    vm_pcnext();

    VM_OP(JOP_COMPARE)
    stack[A] = janet_wrap_integer(janet_compare(stack[B], stack[C]));
    vm_pcnext();

    VM_OP(JOP_NEXT)
    stack[A] = janet_next(stack[B], stack[C]);
    vm_pcnext();

    VM_OP(JOP_LOAD_NIL)
    stack[D] = janet_wrap_nil();
    vm_pcnext();

    VM_OP(JOP_LOAD_TRUE)
    stack[D] = janet_wrap_true();
    vm_pcnext();

    VM_OP(JOP_LOAD_FALSE)
    stack[D] = janet_wrap_false();
    vm_pcnext();

    VM_OP(JOP_LOAD_INTEGER)
    stack[A] = janet_wrap_integer(ES);
    vm_pcnext();

    VM_OP(JOP_LOAD_CONSTANT) {
        int32_t cindex = (int32_t)E;
        vm_assert(cindex < func->def->constants_length, "invalid constant");
        stack[A] = func->def->constants[cindex];
        vm_pcnext();
    }

    VM_OP(JOP_LOAD_SELF)
    stack[D] = janet_wrap_function(func);
    vm_pcnext();

    VM_OP(JOP_LOAD_UPVALUE) {
        int32_t eindex = B;
        int32_t vindex = C;
        JanetFuncEnv *env;
        vm_assert(func->def->environments_length > eindex, "invalid upvalue environment");
        env = func->envs[eindex];
        vm_assert(env->length > vindex, "invalid upvalue index");
        vm_assert(janet_env_valid(env), "invalid upvalue environment");
        if (env->offset > 0) {
            /* On stack */
            stack[A] = env->as.fiber->data[env->offset + vindex];
        } else {
            /* Off stack */
            stack[A] = env->as.values[vindex];
        }
        vm_pcnext();
    }

    VM_OP(JOP_SET_UPVALUE) {
        int32_t eindex = B;
        int32_t vindex = C;
        JanetFuncEnv *env;
        vm_assert(func->def->environments_length > eindex, "invalid upvalue environment");
        env = func->envs[eindex];
        vm_assert(env->length > vindex, "invalid upvalue index");
        vm_assert(janet_env_valid(env), "invalid upvalue environment");
        if (env->offset > 0) {
            env->as.fiber->data[env->offset + vindex] = stack[A];
        } else {
            env->as.values[vindex] = stack[A];
        }
        vm_pcnext();
    }

    VM_OP(JOP_CLOSURE) {
        JanetFuncDef *fd;
        JanetFunction *fn;
        int32_t elen;
        int32_t defindex = (int32_t)E;
        vm_assert(defindex < func->def->defs_length, "invalid funcdef");
        fd = func->def->defs[defindex];
        elen = fd->environments_length;
        fn = janet_gcalloc(JANET_MEMORY_FUNCTION, sizeof(JanetFunction) + ((size_t) elen * sizeof(JanetFuncEnv *)));
        fn->def = fd;
        {
            int32_t i;
            for (i = 0; i < elen; ++i) {
                int32_t inherit = fd->environments[i];
                if (inherit == -1) {
                    JanetStackFrame *frame = janet_stack_frame(stack);
                    if (!frame->env) {
                        /* Lazy capture of current stack frame */
                        JanetFuncEnv *env = janet_gcalloc(JANET_MEMORY_FUNCENV, sizeof(JanetFuncEnv));
                        env->offset = fiber->frame;
                        env->as.fiber = fiber;
                        env->length = func->def->slotcount;
                        frame->env = env;
                    }
                    fn->envs[i] = frame->env;
                } else {
                    fn->envs[i] = func->envs[inherit];
                }
            }
        }
        stack[A] = janet_wrap_function(fn);
        vm_checkgc_pcnext();
    }

    VM_OP(JOP_PUSH)
    janet_fiber_push(fiber, stack[D]);
    stack = fiber->data + fiber->frame;
    vm_checkgc_pcnext();

    VM_OP(JOP_PUSH_2)
    janet_fiber_push2(fiber, stack[A], stack[E]);
    stack = fiber->data + fiber->frame;
    vm_checkgc_pcnext();

    VM_OP(JOP_PUSH_3)
    janet_fiber_push3(fiber, stack[A], stack[B], stack[C]);
    stack = fiber->data + fiber->frame;
    vm_checkgc_pcnext();

    VM_OP(JOP_PUSH_ARRAY) {
        const Janet *vals;
        int32_t len;
        if (janet_indexed_view(stack[D], &vals, &len)) {
            janet_fiber_pushn(fiber, vals, len);
        } else {
            janet_panicf("expected %T, got %v", JANET_TFLAG_INDEXED, stack[D]);
        }
    }
    stack = fiber->data + fiber->frame;
    vm_checkgc_pcnext();

    VM_OP(JOP_CALL) {
        Janet callee = stack[E];
        if (fiber->stacktop > fiber->maxstack) {
            vm_throw("stack overflow");
        }
        if (janet_checktype(callee, JANET_KEYWORD)) {
            vm_commit();
            callee = resolve_method(callee, fiber);
        }
        if (janet_checktype(callee, JANET_FUNCTION)) {
            func = janet_unwrap_function(callee);
            if (func->gc.flags & JANET_FUNCFLAG_TRACE) {
                vm_do_trace(func, fiber->stacktop - fiber->stackstart, fiber->data + fiber->stackstart);
            }
            janet_stack_frame(stack)->pc = pc;
            if (janet_fiber_funcframe(fiber, func)) {
                int32_t n = fiber->stacktop - fiber->stackstart;
                janet_panicf("%v called with %d argument%s, expected %d",
                             callee, n, n == 1 ? "" : "s", func->def->arity);
            }
            stack = fiber->data + fiber->frame;
            pc = func->def->bytecode;
            vm_checkgc_next();
        } else if (janet_checktype(callee, JANET_CFUNCTION)) {
            vm_commit();
            int32_t argc = fiber->stacktop - fiber->stackstart;
            janet_fiber_cframe(fiber, janet_unwrap_cfunction(callee));
            Janet ret = janet_unwrap_cfunction(callee)(argc, fiber->data + fiber->frame);
            janet_fiber_popframe(fiber);
            stack = fiber->data + fiber->frame;
            stack[A] = ret;
            vm_checkgc_pcnext();
        } else {
            vm_commit();
            stack[A] = call_nonfn(fiber, callee);
            vm_pcnext();
        }
    }

    VM_OP(JOP_TAILCALL) {
        Janet callee = stack[D];
        if (fiber->stacktop > fiber->maxstack) {
            vm_throw("stack overflow");
        }
        if (janet_checktype(callee, JANET_KEYWORD)) {
            vm_commit();
            callee = resolve_method(callee, fiber);
        }
        if (janet_checktype(callee, JANET_FUNCTION)) {
            func = janet_unwrap_function(callee);
            if (func->gc.flags & JANET_FUNCFLAG_TRACE) {
                vm_do_trace(func, fiber->stacktop - fiber->stackstart, fiber->data + fiber->stackstart);
            }
            if (janet_fiber_funcframe_tail(fiber, func)) {
                janet_stack_frame(fiber->data + fiber->frame)->pc = pc;
                int32_t n = fiber->stacktop - fiber->stackstart;
                janet_panicf("%v called with %d argument%s, expected %d",
                             callee, n, n == 1 ? "" : "s", func->def->arity);
            }
            stack = fiber->data + fiber->frame;
            pc = func->def->bytecode;
            vm_checkgc_next();
        } else {
            Janet retreg;
            int entrance_frame = janet_stack_frame(stack)->flags & JANET_STACKFRAME_ENTRANCE;
            vm_commit();
            if (janet_checktype(callee, JANET_CFUNCTION)) {
                int32_t argc = fiber->stacktop - fiber->stackstart;
                janet_fiber_cframe(fiber, janet_unwrap_cfunction(callee));
                retreg = janet_unwrap_cfunction(callee)(argc, fiber->data + fiber->frame);
                janet_fiber_popframe(fiber);
            } else {
                retreg = call_nonfn(fiber, callee);
            }
            janet_fiber_popframe(fiber);
            if (entrance_frame)
                vm_return(JANET_SIGNAL_OK, retreg);
            vm_restore();
            stack[A] = retreg;
            vm_checkgc_pcnext();
        }
    }

    VM_OP(JOP_RESUME) {
        Janet retreg;
        vm_assert_type(stack[B], JANET_FIBER);
        JanetFiber *child = janet_unwrap_fiber(stack[B]);
        if (janet_check_can_resume(child, &retreg)) {
            vm_commit();
            janet_panicv(retreg);
        }
        fiber->child = child;
        JanetSignal sig = janet_continue_no_check(child, stack[C], &retreg);
        if (sig != JANET_SIGNAL_OK && !(child->flags & (1 << sig))) {
            vm_return(sig, retreg);
        }
        fiber->child = NULL;
        stack = fiber->data + fiber->frame;
        stack[A] = retreg;
        vm_checkgc_pcnext();
    }

    VM_OP(JOP_SIGNAL) {
        int32_t s = C;
        if (s > JANET_SIGNAL_USER9) s = JANET_SIGNAL_USER9;
        if (s < 0) s = 0;
        vm_return(s, stack[B]);
    }

    VM_OP(JOP_PROPAGATE) {
        Janet fv = stack[C];
        vm_assert_type(fv, JANET_FIBER);
        JanetFiber *f = janet_unwrap_fiber(fv);
        JanetFiberStatus sub_status = janet_fiber_status(f);
        if (sub_status > JANET_STATUS_USER9) {
            vm_commit();
            janet_panicf("cannot propagate from fiber with status :%s",
                         janet_status_names[sub_status]);
        }
        fiber->child = f;
        vm_return((int) sub_status, stack[B]);
    }

    VM_OP(JOP_PUT)
    vm_commit();
    fiber->flags |= JANET_FIBER_RESUME_NO_USEVAL;
    janet_put(stack[A], stack[B], stack[C]);
    fiber->flags &= ~JANET_FIBER_RESUME_NO_USEVAL;
    vm_checkgc_pcnext();

    VM_OP(JOP_PUT_INDEX)
    vm_commit();
    fiber->flags |= JANET_FIBER_RESUME_NO_USEVAL;
    janet_putindex(stack[A], C, stack[B]);
    fiber->flags &= ~JANET_FIBER_RESUME_NO_USEVAL;
    vm_checkgc_pcnext();

    VM_OP(JOP_IN)
    vm_commit();
    stack[A] = janet_in(stack[B], stack[C]);
    vm_pcnext();

    VM_OP(JOP_GET)
    vm_commit();
    stack[A] = janet_get(stack[B], stack[C]);
    vm_pcnext();

    VM_OP(JOP_GET_INDEX)
    vm_commit();
    stack[A] = janet_getindex(stack[B], C);
    vm_pcnext();

    VM_OP(JOP_LENGTH)
    vm_commit();
    stack[A] = janet_lengthv(stack[E]);
    vm_pcnext();

    VM_OP(JOP_MAKE_ARRAY) {
        int32_t count = fiber->stacktop - fiber->stackstart;
        Janet *mem = fiber->data + fiber->stackstart;
        stack[D] = janet_wrap_array(janet_array_n(mem, count));
        fiber->stacktop = fiber->stackstart;
        vm_checkgc_pcnext();
    }

    VM_OP(JOP_MAKE_TUPLE)
    /* fallthrough */
    VM_OP(JOP_MAKE_BRACKET_TUPLE) {
        int32_t count = fiber->stacktop - fiber->stackstart;
        Janet *mem = fiber->data + fiber->stackstart;
        const Janet *tup = janet_tuple_n(mem, count);
        if (opcode == JOP_MAKE_BRACKET_TUPLE)
            janet_tuple_flag(tup) |= JANET_TUPLE_FLAG_BRACKETCTOR;
        stack[D] = janet_wrap_tuple(tup);
        fiber->stacktop = fiber->stackstart;
        vm_checkgc_pcnext();
    }

    VM_OP(JOP_MAKE_TABLE) {
        int32_t count = fiber->stacktop - fiber->stackstart;
        Janet *mem = fiber->data + fiber->stackstart;
        if (count & 1) {
            vm_commit();
            janet_panicf("expected even number of arguments to table constructor, got %d", count);
        }
        JanetTable *table = janet_table(count / 2);
        for (int32_t i = 0; i < count; i += 2)
            janet_table_put(table, mem[i], mem[i + 1]);
        stack[D] = janet_wrap_table(table);
        fiber->stacktop = fiber->stackstart;
        vm_checkgc_pcnext();
    }

    VM_OP(JOP_MAKE_STRUCT) {
        int32_t count = fiber->stacktop - fiber->stackstart;
        Janet *mem = fiber->data + fiber->stackstart;
        if (count & 1) {
            vm_commit();
            janet_panicf("expected even number of arguments to struct constructor, got %d", count);
        }
        JanetKV *st = janet_struct_begin(count / 2);
        for (int32_t i = 0; i < count; i += 2)
            janet_struct_put(st, mem[i], mem[i + 1]);
        stack[D] = janet_wrap_struct(janet_struct_end(st));
        fiber->stacktop = fiber->stackstart;
        vm_checkgc_pcnext();
    }

    VM_OP(JOP_MAKE_STRING) {
        int32_t count = fiber->stacktop - fiber->stackstart;
        Janet *mem = fiber->data + fiber->stackstart;
        JanetBuffer buffer;
        janet_buffer_init(&buffer, 10 * count);
        for (int32_t i = 0; i < count; i++)
            janet_to_string_b(&buffer, mem[i]);
        stack[D] = janet_stringv(buffer.data, buffer.count);
        janet_buffer_deinit(&buffer);
        fiber->stacktop = fiber->stackstart;
        vm_checkgc_pcnext();
    }

    VM_OP(JOP_MAKE_BUFFER) {
        int32_t count = fiber->stacktop - fiber->stackstart;
        Janet *mem = fiber->data + fiber->stackstart;
        JanetBuffer *buffer = janet_buffer(10 * count);
        for (int32_t i = 0; i < count; i++)
            janet_to_string_b(buffer, mem[i]);
        stack[D] = janet_wrap_buffer(buffer);
        fiber->stacktop = fiber->stackstart;
        vm_checkgc_pcnext();
    }

    VM_END()
}

/*
 * Execute a single instruction in the fiber. Does this by inspecting
 * the fiber, setting a breakpoint at the next instruction, executing, and
 * reseting breakpoints to how they were prior. Yes, it's a bit hacky.
 */
JanetSignal janet_step(JanetFiber *fiber, Janet in, Janet *out) {
    /* No finished or currently alive fibers. */
    JanetFiberStatus status = janet_fiber_status(fiber);
    if (status == JANET_STATUS_ALIVE ||
            status == JANET_STATUS_DEAD ||
            status == JANET_STATUS_ERROR) {
        janet_panicf("cannot step fiber with status :%s", janet_status_names[status]);
    }

    /* Get PC for setting breakpoints */
    uint32_t *pc = janet_stack_frame(fiber->data + fiber->frame)->pc;

    /* Check current opcode (sans debug flag). This tells us where the next or next two candidate
     * instructions will be. Usually it's the next instruction in memory,
     * but for branching instructions it is also the target of the branch. */
    uint32_t *nexta = NULL, *nextb = NULL, olda = 0, oldb = 0;

    /* Set temporary breakpoints */
    switch (*pc & 0x7F) {
        default:
            nexta = pc + 1;
            break;
        /* These we just ignore for now. Supporting them means
         * we could step into and out of functions (including JOP_CALL). */
        case JOP_RETURN_NIL:
        case JOP_RETURN:
        case JOP_ERROR:
        case JOP_TAILCALL:
            break;
        case JOP_JUMP:
            nexta = pc + DS;
            break;
        case JOP_JUMP_IF:
        case JOP_JUMP_IF_NOT:
            nexta = pc + 1;
            nextb = pc + ES;
            break;
    }
    if (nexta) {
        olda = *nexta;
        *nexta |= 0x80;
    }
    if (nextb) {
        oldb = *nextb;
        *nextb |= 0x80;
    }

    /* Go */
    JanetSignal signal = janet_continue(fiber, in, out);

    /* Restore */
    if (nexta) *nexta = olda;
    if (nextb) *nextb = oldb;

    return signal;
}

Janet janet_call(JanetFunction *fun, int32_t argc, const Janet *argv) {
    /* Check entry conditions */
    if (!janet_vm_fiber)
        janet_panic("janet_call failed because there is no current fiber");
    if (janet_vm_stackn >= JANET_RECURSION_GUARD)
        janet_panic("C stack recursed too deeply");

    /* Tracing */
    if (fun->gc.flags & JANET_FUNCFLAG_TRACE) {
        vm_do_trace(fun, argc, argv);
    }

    /* Push frame */
    janet_fiber_pushn(janet_vm_fiber, argv, argc);
    if (janet_fiber_funcframe(janet_vm_fiber, fun)) {
        janet_panicf("arity mismatch in %v", janet_wrap_function(fun));
    }
    janet_fiber_frame(janet_vm_fiber)->flags |= JANET_STACKFRAME_ENTRANCE;

    /* Set up */
    int32_t oldn = janet_vm_stackn++;
    int handle = janet_gclock();

    /* Run vm */
    janet_vm_fiber->flags |= JANET_FIBER_RESUME_NO_USEVAL | JANET_FIBER_RESUME_NO_SKIP;
    JanetSignal signal = run_vm(janet_vm_fiber, janet_wrap_nil());

    /* Teardown */
    janet_vm_stackn = oldn;
    janet_gcunlock(handle);

    if (signal != JANET_SIGNAL_OK) {
        janet_panicv(*janet_vm_return_reg);
    }

    return *janet_vm_return_reg;
}

static JanetSignal janet_check_can_resume(JanetFiber *fiber, Janet *out) {
    /* Check conditions */
    JanetFiberStatus old_status = janet_fiber_status(fiber);
    if (janet_vm_stackn >= JANET_RECURSION_GUARD) {
        janet_fiber_set_status(fiber, JANET_STATUS_ERROR);
        *out = janet_cstringv("C stack recursed too deeply");
        return JANET_SIGNAL_ERROR;
    }
    if (old_status == JANET_STATUS_ALIVE ||
            old_status == JANET_STATUS_DEAD ||
            (old_status >= JANET_STATUS_USER0 && old_status <= JANET_STATUS_USER4) ||
            old_status == JANET_STATUS_ERROR) {
        const uint8_t *str = janet_formatc("cannot resume fiber with status :%s",
                                           janet_status_names[old_status]);
        *out = janet_wrap_string(str);
        return JANET_SIGNAL_ERROR;
    }
    return JANET_SIGNAL_OK;
}

static JanetSignal janet_continue_no_check(JanetFiber *fiber, Janet in, Janet *out) {
    jmp_buf buf;

    JanetFiberStatus old_status = janet_fiber_status(fiber);

    /* Continue child fiber if it exists */
    if (fiber->child) {
        if (janet_vm_root_fiber == NULL) janet_vm_root_fiber = fiber;
        JanetFiber *child = fiber->child;
        janet_vm_stackn++;
        JanetSignal sig = janet_continue(child, in, &in);
        janet_vm_stackn--;
        if (janet_vm_root_fiber == fiber) janet_vm_root_fiber = NULL;
        if (sig != JANET_SIGNAL_OK && !(child->flags & (1 << sig))) {
            *out = in;
            return sig;
        }
        fiber->child = NULL;
    }

    /* Handle new fibers being resumed with a non-nil value */
    if (old_status == JANET_STATUS_NEW && !janet_checktype(in, JANET_NIL)) {
        Janet *stack = fiber->data + fiber->frame;
        JanetFunction *func = janet_stack_frame(stack)->func;
        if (func) {
            if (func->def->arity > 0) {
                stack[0] = in;
            } else if (func->def->flags & JANET_FUNCDEF_FLAG_VARARG) {
                stack[0] = janet_wrap_tuple(janet_tuple_n(&in, 1));
            }
        }
    }

    /* Save global state */
    int32_t oldn = janet_vm_stackn++;
    int handle = janet_vm_gc_suspend;
    JanetFiber *old_vm_fiber = janet_vm_fiber;
    jmp_buf *old_vm_jmp_buf = janet_vm_jmp_buf;
    Janet *old_vm_return_reg = janet_vm_return_reg;

    /* Setup fiber */
    if (janet_vm_root_fiber == NULL) janet_vm_root_fiber = fiber;
    janet_vm_fiber = fiber;
    janet_gcroot(janet_wrap_fiber(fiber));
    janet_fiber_set_status(fiber, JANET_STATUS_ALIVE);
    janet_vm_return_reg = out;
    janet_vm_jmp_buf = &buf;

    /* Run loop */
    JanetSignal signal;
    int jmpsig;
#if defined(JANET_BSD) || defined(JANET_APPLE)
    jmpsig = _setjmp(buf);
#else
    jmpsig = setjmp(buf);
#endif
    if (jmpsig) {
        signal = (JanetSignal) jmpsig;
    } else {
        signal = run_vm(fiber, in);
    }

    /* Tear down fiber */
    janet_fiber_set_status(fiber, signal);
    janet_gcunroot(janet_wrap_fiber(fiber));

    /* Restore global state */
    if (janet_vm_root_fiber == fiber) janet_vm_root_fiber = NULL;
    janet_vm_gc_suspend = handle;
    janet_vm_fiber = old_vm_fiber;
    janet_vm_stackn = oldn;
    janet_vm_return_reg = old_vm_return_reg;
    janet_vm_jmp_buf = old_vm_jmp_buf;

    return signal;
}

/* Enter the main vm loop */
JanetSignal janet_continue(JanetFiber *fiber, Janet in, Janet *out) {
    /* Check conditions */
    JanetSignal tmp_signal = janet_check_can_resume(fiber, out);
    if (tmp_signal) return tmp_signal;
    return janet_continue_no_check(fiber, in, out);
}

JanetSignal janet_pcall(
    JanetFunction *fun,
    int32_t argc,
    const Janet *argv,
    Janet *out,
    JanetFiber **f) {
    JanetFiber *fiber;
    if (f && *f) {
        fiber = janet_fiber_reset(*f, fun, argc, argv);
    } else {
        fiber = janet_fiber(fun, 64, argc, argv);
    }
    if (f) *f = fiber;
    if (!fiber) {
        *out = janet_cstringv("arity mismatch");
        return JANET_SIGNAL_ERROR;
    }
    return janet_continue(fiber, janet_wrap_nil(), out);
}

Janet janet_mcall(const char *name, int32_t argc, Janet *argv) {
    /* At least 1 argument */
    if (argc < 1) janet_panicf("method :%s expected at least 1 argument");
    /* Find method */
    Janet method = janet_method_lookup(argv[0], name);
    if (janet_checktype(method, JANET_NIL)) {
        janet_panicf("could not find method :%s for %v", name, argv[0]);
    }
    /* Invoke method */
    return janet_method_invoke(method, argc, argv);
}

/* Setup VM */
int janet_init(void) {
    /* Garbage collection */
    janet_vm_blocks = NULL;
    janet_vm_next_collection = 0;
    /* Setting memoryInterval to zero forces
     * a collection pretty much every cycle, which is
     * incredibly horrible for performance, but can help ensure
     * there are no memory bugs during development */
    janet_vm_gc_interval = 0x10000;
    janet_symcache_init();
    /* Initialize gc roots */
    janet_vm_roots = NULL;
    janet_vm_root_count = 0;
    janet_vm_root_capacity = 0;
    /* Scratch memory */
    janet_scratch_mem = NULL;
    janet_scratch_len = 0;
    janet_scratch_cap = 0;
    /* Initialize registry */
    janet_vm_registry = janet_table(0);
    janet_vm_abstract_registry = janet_table(0);
    janet_gcroot(janet_wrap_table(janet_vm_registry));
    janet_gcroot(janet_wrap_table(janet_vm_abstract_registry));
    /* Traversal */
    janet_vm_traversal = NULL;
    janet_vm_traversal_base = NULL;
    janet_vm_traversal_top = NULL;
    /* Core env */
    janet_vm_core_env = NULL;
    /* Seed RNG */
    janet_rng_seed(janet_default_rng(), 0);
    /* Fibers */
    janet_vm_fiber = NULL;
    janet_vm_root_fiber = NULL;
    janet_vm_stackn = 0;
    /* Threads */
#ifdef JANET_THREADS
    janet_threads_init();
#endif
    return 0;
}

/* Clear all memory associated with the VM */
void janet_deinit(void) {
    janet_clear_memory();
    janet_symcache_deinit();
    free(janet_vm_roots);
    janet_vm_roots = NULL;
    janet_vm_root_count = 0;
    janet_vm_root_capacity = 0;
    janet_vm_registry = NULL;
    janet_vm_abstract_registry = NULL;
    janet_vm_core_env = NULL;
    free(janet_vm_traversal_base);
    janet_vm_fiber = NULL;
    janet_vm_root_fiber = NULL;
#ifdef JANET_THREADS
    janet_threads_deinit();
#endif
#ifdef JANET_NET
    janet_net_deinit();
#endif
}


/* src/core/wrap.c */
#line 0 "src/core/wrap.c"

/*
* Copyright (c) 2020 Calvin Rose
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*/

#ifndef JANET_AMALG
#include "features.h"
#include <janet.h>
#include <math.h>
#include "util.h"
#include "state.h"
#endif

/* Macro fills */

JanetType(janet_type)(Janet x) {
    return janet_type(x);
}
int (janet_checktype)(Janet x, JanetType type) {
    return janet_checktype(x, type);
}
int (janet_checktypes)(Janet x, int typeflags) {
    return janet_checktypes(x, typeflags);
}
int (janet_truthy)(Janet x) {
    return janet_truthy(x);
}

const JanetKV *(janet_unwrap_struct)(Janet x) {
    return janet_unwrap_struct(x);
}
const Janet *(janet_unwrap_tuple)(Janet x) {
    return janet_unwrap_tuple(x);
}
JanetFiber *(janet_unwrap_fiber)(Janet x) {
    return janet_unwrap_fiber(x);
}
JanetArray *(janet_unwrap_array)(Janet x) {
    return janet_unwrap_array(x);
}
JanetTable *(janet_unwrap_table)(Janet x) {
    return janet_unwrap_table(x);
}
JanetBuffer *(janet_unwrap_buffer)(Janet x) {
    return janet_unwrap_buffer(x);
}
const uint8_t *(janet_unwrap_string)(Janet x) {
    return janet_unwrap_string(x);
}
const uint8_t *(janet_unwrap_symbol)(Janet x) {
    return janet_unwrap_symbol(x);
}
const uint8_t *(janet_unwrap_keyword)(Janet x) {
    return janet_unwrap_keyword(x);
}
void *(janet_unwrap_abstract)(Janet x) {
    return janet_unwrap_abstract(x);
}
void *(janet_unwrap_pointer)(Janet x) {
    return janet_unwrap_pointer(x);
}
JanetFunction *(janet_unwrap_function)(Janet x) {
    return janet_unwrap_function(x);
}
JanetCFunction(janet_unwrap_cfunction)(Janet x) {
    return janet_unwrap_cfunction(x);
}
int (janet_unwrap_boolean)(Janet x) {
    return janet_unwrap_boolean(x);
}
int32_t (janet_unwrap_integer)(Janet x) {
    return janet_unwrap_integer(x);
}

#if defined(JANET_NANBOX_32) || defined(JANET_NANBOX_64)
Janet(janet_wrap_nil)(void) {
    return janet_wrap_nil();
}
Janet(janet_wrap_true)(void) {
    return janet_wrap_true();
}
Janet(janet_wrap_false)(void) {
    return janet_wrap_false();
}
Janet(janet_wrap_boolean)(int x) {
    return janet_wrap_boolean(x);
}
Janet(janet_wrap_string)(const uint8_t *x) {
    return janet_wrap_string(x);
}
Janet(janet_wrap_symbol)(const uint8_t *x) {
    return janet_wrap_symbol(x);
}
Janet(janet_wrap_keyword)(const uint8_t *x) {
    return janet_wrap_keyword(x);
}
Janet(janet_wrap_array)(JanetArray *x) {
    return janet_wrap_array(x);
}
Janet(janet_wrap_tuple)(const Janet *x) {
    return janet_wrap_tuple(x);
}
Janet(janet_wrap_struct)(const JanetKV *x) {
    return janet_wrap_struct(x);
}
Janet(janet_wrap_fiber)(JanetFiber *x) {
    return janet_wrap_fiber(x);
}
Janet(janet_wrap_buffer)(JanetBuffer *x) {
    return janet_wrap_buffer(x);
}
Janet(janet_wrap_function)(JanetFunction *x) {
    return janet_wrap_function(x);
}
Janet(janet_wrap_cfunction)(JanetCFunction x) {
    return janet_wrap_cfunction(x);
}
Janet(janet_wrap_table)(JanetTable *x) {
    return janet_wrap_table(x);
}
Janet(janet_wrap_abstract)(void *x) {
    return janet_wrap_abstract(x);
}
Janet(janet_wrap_pointer)(void *x) {
    return janet_wrap_pointer(x);
}
Janet(janet_wrap_integer)(int32_t x) {
    return janet_wrap_integer(x);
}
#endif

#ifndef JANET_NANBOX_32
double (janet_unwrap_number)(Janet x) {
    return janet_unwrap_number(x);
}
#endif

#ifdef JANET_NANBOX_64
Janet(janet_wrap_number)(double x) {
    return janet_wrap_number(x);
}
#endif

/*****/

void *janet_memalloc_empty(int32_t count) {
    int32_t i;
    void *mem = malloc((size_t) count * sizeof(JanetKV));
    janet_vm_next_collection += (size_t) count * sizeof(JanetKV);
    if (NULL == mem) {
        JANET_OUT_OF_MEMORY;
    }
    JanetKV *mmem = (JanetKV *)mem;
    for (i = 0; i < count; i++) {
        JanetKV *kv = mmem + i;
        kv->key = janet_wrap_nil();
        kv->value = janet_wrap_nil();
    }
    return mem;
}

void janet_memempty(JanetKV *mem, int32_t count) {
    int32_t i;
    for (i = 0; i < count; i++) {
        mem[i].key = janet_wrap_nil();
        mem[i].value = janet_wrap_nil();
    }
}

#ifdef JANET_NANBOX_64

Janet janet_wrap_number_safe(double d) {
    Janet ret;
    ret.number = isnan(d) ? NAN : d;
    return ret;
}

void *janet_nanbox_to_pointer(Janet x) {
    x.i64 &= JANET_NANBOX_PAYLOADBITS;
    return x.pointer;
}

Janet janet_nanbox_from_pointer(void *p, uint64_t tagmask) {
    Janet ret;
    ret.pointer = p;
    ret.u64 |= tagmask;
    return ret;
}

Janet janet_nanbox_from_cpointer(const void *p, uint64_t tagmask) {
    Janet ret;
    ret.pointer = (void *)p;
    ret.u64 |= tagmask;
    return ret;
}

Janet janet_nanbox_from_double(double d) {
    Janet ret;
    ret.number = d;
    return ret;
}

Janet janet_nanbox_from_bits(uint64_t bits) {
    Janet ret;
    ret.u64 = bits;
    return ret;
}

#elif defined(JANET_NANBOX_32)

Janet janet_wrap_number(double x) {
    Janet ret;
    ret.number = x;
    ret.tagged.type += JANET_DOUBLE_OFFSET;
    return ret;
}

Janet janet_wrap_number_safe(double d) {
    double x = isnan(d) ? NAN : d;
    return janet_wrap_number(x);
}

Janet janet_nanbox32_from_tagi(uint32_t tag, int32_t integer) {
    Janet ret;
    ret.tagged.type = tag;
    ret.tagged.payload.integer = integer;
    return ret;
}

Janet janet_nanbox32_from_tagp(uint32_t tag, void *pointer) {
    Janet ret;
    ret.tagged.type = tag;
    ret.tagged.payload.pointer = pointer;
    return ret;
}

double janet_unwrap_number(Janet x) {
    x.tagged.type -= JANET_DOUBLE_OFFSET;
    return x.number;
}

#else

Janet janet_wrap_number_safe(double d) {
    return janet_wrap_number(d);
}

Janet janet_wrap_nil(void) {
    Janet y;
    y.type = JANET_NIL;
    y.as.u64 = 0;
    return y;
}

Janet janet_wrap_true(void) {
    Janet y;
    y.type = JANET_BOOLEAN;
    y.as.u64 = 1;
    return y;
}

Janet janet_wrap_false(void) {
    Janet y;
    y.type = JANET_BOOLEAN;
    y.as.u64 = 0;
    return y;
}

Janet janet_wrap_boolean(int x) {
    Janet y;
    y.type = JANET_BOOLEAN;
    y.as.u64 = !!x;
    return y;
}

#define JANET_WRAP_DEFINE(NAME, TYPE, DTYPE, UM)\
Janet janet_wrap_##NAME(TYPE x) {\
    Janet y;\
    y.type = DTYPE;\
    y.as.u64 = 0; /* zero other bits in case of 32 bit integer */ \
    y.as.UM = x;\
    return y;\
}

JANET_WRAP_DEFINE(number, double, JANET_NUMBER, number)
JANET_WRAP_DEFINE(string, const uint8_t *, JANET_STRING, cpointer)
JANET_WRAP_DEFINE(symbol, const uint8_t *, JANET_SYMBOL, cpointer)
JANET_WRAP_DEFINE(keyword, const uint8_t *, JANET_KEYWORD, cpointer)
JANET_WRAP_DEFINE(array, JanetArray *, JANET_ARRAY, pointer)
JANET_WRAP_DEFINE(tuple, const Janet *, JANET_TUPLE, cpointer)
JANET_WRAP_DEFINE(struct, const JanetKV *, JANET_STRUCT, cpointer)
JANET_WRAP_DEFINE(fiber, JanetFiber *, JANET_FIBER, pointer)
JANET_WRAP_DEFINE(buffer, JanetBuffer *, JANET_BUFFER, pointer)
JANET_WRAP_DEFINE(function, JanetFunction *, JANET_FUNCTION, pointer)
JANET_WRAP_DEFINE(cfunction, JanetCFunction, JANET_CFUNCTION, pointer)
JANET_WRAP_DEFINE(table, JanetTable *, JANET_TABLE, pointer)
JANET_WRAP_DEFINE(abstract, void *, JANET_ABSTRACT, pointer)
JANET_WRAP_DEFINE(pointer, void *, JANET_POINTER, pointer)

#undef JANET_WRAP_DEFINE

#endif


static const unsigned char janet_core_image_bytes[] = {
  0xD3, 0x81, 0xDF, 0xCF, 0x06, 0x70, 0x75, 0x74, 0x2D, 0x69, 0x6E, 0xD3, 0x03, 0xD0, 0x05, 0x76, 
  0x61, 0x6C, 0x75, 0x65, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x10, 0x03, 0x03, 0x03, 0x02, 0x28, 
  0xCE, 0x06, 0x70, 0x75, 0x74, 0x2D, 0x69, 0x6E, 0xCE, 0x0A, 0x62, 0x6F, 0x6F, 0x74, 0x2E, 0x6A, 
  0x61, 0x6E, 0x65, 0x74, 0xCE, 0x1D, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x61, 
  0x74, 0x20, 0x6C, 0x65, 0x61, 0x73, 0x74, 0x20, 0x31, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x69, 0x6E, 
  0x20, 0x6B, 0x73, 0xD8, 0x05, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2C, 0x03, 0x00, 0x00, 0x19, 0x04, 
  0x00, 0x00, 0x3D, 0x05, 0x01, 0x00, 0x29, 0x07, 0x01, 0x00, 0x07, 0x06, 0x05, 0x07, 0x19, 0x05, 
  0x06, 0x00, 0x29, 0x08, 0x00, 0x00, 0x21, 0x07, 0x05, 0x08, 0x1C, 0x07, 0x04, 0x00, 0x2A, 0x08, 
  0x00, 0x00, 0x01, 0x08, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x29, 0x07, 0x00, 0x00, 0x19, 0x08, 
  0x05, 0x00, 0x21, 0x09, 0x07, 0x08, 0x1C, 0x09, 0x13, 0x00, 0x19, 0x0A, 0x07, 0x00, 0x39, 0x0B, 
  0x01, 0x0A, 0x19, 0x0C, 0x0B, 0x00, 0x39, 0x0B, 0x04, 0x0C, 0x19, 0x0D, 0x0B, 0x00, 0x26, 0x0E, 
  0x00, 0x00, 0x23, 0x0B, 0x0E, 0x0D, 0x1C, 0x0B, 0x07, 0x00, 0x2A, 0x0F, 0x01, 0x00, 0x33, 0x0E, 
  0x0F, 0x00, 0x19, 0x0F, 0x0E, 0x00, 0x3A, 0x04, 0x0C, 0x0F, 0x19, 0x04, 0x0F, 0x00, 0x1A, 0x02, 
  0x00, 0x00, 0x19, 0x04, 0x0D, 0x00, 0x29, 0x0B, 0x01, 0x00, 0x06, 0x07, 0x07, 0x0B, 0x1A, 0xED, 
  0xFF, 0xFF, 0x39, 0x07, 0x01, 0x05, 0x19, 0x08, 0x07, 0x00, 0x39, 0x09, 0x04, 0x08, 0x19, 0x0A, 
  0x09, 0x00, 0x3A, 0x04, 0x08, 0x02, 0x03, 0x00, 0x00, 0x00, 0x84, 0xE7, 0x01, 0x06, 0x03, 0x01, 
  0x11, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x03, 0x01, 0x07, 0x00, 0x07, 0x00, 0x03, 0x00, 0x13, 0x00, 
  0x13, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x0C, 0x00, 
  0x05, 0x01, 0x0C, 0x00, 0x05, 0x01, 0x09, 0x00, 0x09, 0x00, 0x05, 0x01, 0x12, 0x00, 0x12, 0x00, 
  0x07, 0x01, 0x09, 0x01, 0x09, 0xBF, 0xFD, 0x05, 0x04, 0x07, 0xBF, 0xF9, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x08, 0x11, 0x00, 0x03, 0x01, 0x11, 0x00, 0x03, 0x01, 0x03, 0xBF, 0xED, 0x01, 0xD0, 0x03, 
  0x64, 0x6F, 0x63, 0xCE, 0x80, 0xD9, 0x28, 0x70, 0x75, 0x74, 0x2D, 0x69, 0x6E, 0x20, 0x64, 0x73, 
  0x20, 0x6B, 0x73, 0x20, 0x76, 0x29, 0x0A, 0x0A, 0x50, 0x75, 0x74, 0x20, 0x61, 0x20, 0x76, 0x61, 
  0x6C, 0x75, 0x65, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x73, 0x74, 0x65, 
  0x64, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 
  0x2E, 0x20, 0x20, 0x4C, 0x6F, 0x6F, 0x6B, 0x73, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 
  0x20, 0x76, 0x69, 0x61, 0x20, 0x20, 0x61, 0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6E, 0x63, 0x65, 
  0x20, 0x6F, 0x66, 0x20, 0x6B, 0x65, 0x79, 0x73, 0x2E, 0x20, 0x4D, 0x69, 0x73, 0x73, 0x69, 0x6E, 
  0x67, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 
  0x73, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x72, 0x65, 0x70, 0x6C, 0x61, 0x63, 
  0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x73, 0x2E, 0x20, 
  0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x6F, 0x64, 
  0x69, 0x66, 0x69, 0x65, 0x64, 0x2C, 0x20, 0x6F, 0x72, 0x69, 0x67, 0x69, 0x6E, 0x61, 0x6C, 0x20, 
  0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x2E, 0xD0, 
  0x0A, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x2D, 0x6D, 0x61, 0x70, 0xD2, 0x03, 0x00, 0xDA, 0x05, 
  0x84, 0xE7, 0x01, 0xCF, 0x0F, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x2F, 0x73, 0x6F, 0x75, 0x72, 0x63, 
  0x65, 0x6D, 0x61, 0x70, 0xD3, 0x02, 0xDA, 0x03, 0xD8, 0x0F, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x2F, 
  0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x6D, 0x61, 0x70, 0xDA, 0x09, 0xCE, 0x72, 0x28, 0x74, 0x75, 
  0x70, 0x6C, 0x65, 0x2F, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x6D, 0x61, 0x70, 0x20, 0x74, 0x75, 
  0x70, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x6D, 0x61, 0x70, 0x20, 0x6D, 0x65, 0x74, 0x61, 0x64, 0x61, 
  0x74, 0x61, 0x20, 0x61, 0x74, 0x74, 0x61, 0x63, 0x68, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x61, 
  0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x2C, 0x20, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x69, 
  0x73, 0x20, 0x61, 0x6E, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x20, 
  0x28, 0x6C, 0x69, 0x6E, 0x65, 0x2C, 0x20, 0x63, 0x6F, 0x6C, 0x75, 0x6D, 0x6E, 0x29, 0x2E, 0xCF, 
  0x0B, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x66, 0x69, 0x6C, 0x6C, 0xD3, 0x02, 0xDA, 0x03, 
  0xD8, 0x0B, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x66, 0x69, 0x6C, 0x6C, 0xDA, 0x09, 0xCE, 
  0x80, 0x90, 0x28, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x66, 0x69, 0x6C, 0x6C, 0x20, 0x62, 
  0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x62, 0x79, 0x74, 0x65, 0x29, 
  0x0A, 0x0A, 0x46, 0x69, 0x6C, 0x6C, 0x20, 0x75, 0x70, 0x20, 0x61, 0x20, 0x62, 0x75, 0x66, 0x66, 
  0x65, 0x72, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x2C, 0x20, 0x64, 
  0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x6F, 0x20, 0x30, 0x73, 0x2E, 
  0x20, 0x44, 0x6F, 0x65, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x63, 0x68, 0x61, 0x6E, 0x67, 0x65, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x27, 0x73, 0x20, 0x6C, 0x65, 
  0x6E, 0x67, 0x74, 0x68, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 
  0x72, 0x2E, 0xCF, 0x0B, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2F, 0x63, 0x6C, 0x6F, 0x6E, 0x65, 0xD3, 
  0x02, 0xDA, 0x03, 0xD8, 0x0B, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2F, 0x63, 0x6C, 0x6F, 0x6E, 0x65, 
  0xDA, 0x09, 0xCE, 0x74, 0x28, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2F, 0x63, 0x6C, 0x6F, 0x6E, 0x65, 
  0x20, 0x74, 0x61, 0x62, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 
  0x63, 0x6F, 0x70, 0x79, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2E, 
  0x20, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x6E, 0x65, 0x77, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x6E, 
  0x6F, 0x74, 0x20, 0x63, 0x68, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6F, 0x6C, 
  0x64, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x76, 0x69, 0x63, 
  0x65, 0x20, 0x76, 0x65, 0x72, 0x73, 0x61, 0x2E, 0xCF, 0x09, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x65, 
  0x72, 0x66, 0x63, 0xD3, 0x02, 0xDA, 0x03, 0xD8, 0x09, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x65, 0x72, 
  0x66, 0x63, 0xDA, 0x09, 0xCE, 0x3D, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x65, 0x72, 0x66, 0x63, 
  0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x63, 0x6F, 0x6D, 0x70, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x61, 0x72, 0x79, 0x20, 0x65, 
  0x72, 0x72, 0x6F, 0x72, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x6F, 0x66, 
  0x20, 0x78, 0x2E, 0xCF, 0x09, 0x77, 0x68, 0x65, 0x6E, 0x2D, 0x77, 0x69, 0x74, 0x68, 0xD3, 0x04, 
  0xDA, 0x03, 0xD7, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x09, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 
  0x03, 0x17, 0xCE, 0x09, 0x77, 0x68, 0x65, 0x6E, 0x2D, 0x77, 0x69, 0x74, 0x68, 0xDA, 0x05, 0xD0, 
  0x05, 0x63, 0x6C, 0x6F, 0x73, 0x65, 0xD7, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x0B, 0x01, 0x01, 0xCD, 
  0x7F, 0xFF, 0xFF, 0xFF, 0x0C, 0x2C, 0xCE, 0x05, 0x64, 0x65, 0x66, 0x65, 0x72, 0xDA, 0x05, 0xD8, 
  0x06, 0x67, 0x65, 0x6E, 0x73, 0x79, 0x6D, 0xCF, 0x02, 0x66, 0x6E, 0xD8, 0x09, 0x66, 0x69, 0x62, 
  0x65, 0x72, 0x2F, 0x6E, 0x65, 0x77, 0xD0, 0x02, 0x74, 0x69, 0xCF, 0x03, 0x64, 0x65, 0x66, 0xD7, 
  0xCD, 0x00, 0x08, 0x00, 0x05, 0x02, 0x02, 0x01, 0x02, 0x00, 0x02, 0xCE, 0x06, 0x72, 0x65, 0x73, 
  0x75, 0x6D, 0x65, 0x35, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, 0xD8, 0x0C, 0x66, 0x69, 0x62, 
  0x65, 0x72, 0x2F, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0xCF, 0x01, 0x3D, 0xD0, 0x04, 0x64, 0x65, 
  0x61, 0x64, 0xD7, 0xCD, 0x00, 0x08, 0x00, 0x1A, 0x02, 0x02, 0x02, 0x02, 0x00, 0x02, 0xCE, 0x09, 
  0x70, 0x72, 0x6F, 0x70, 0x61, 0x67, 0x61, 0x74, 0x65, 0x37, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 
  0x00, 0xCF, 0x02, 0x69, 0x66, 0xCF, 0x02, 0x64, 0x6F, 0x2C, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x00, 
  0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x04, 0x03, 0x00, 0x2A, 0x05, 0x00, 0x00, 0x33, 0x03, 0x05, 
  0x00, 0x19, 0x05, 0x03, 0x00, 0x44, 0x03, 0x00, 0x00, 0x2A, 0x07, 0x01, 0x00, 0x30, 0x07, 0x03, 
  0x00, 0x32, 0x01, 0x00, 0x00, 0x43, 0x06, 0x00, 0x00, 0x2A, 0x07, 0x02, 0x00, 0x2A, 0x08, 0x03, 
  0x00, 0x31, 0x07, 0x06, 0x08, 0x43, 0x03, 0x00, 0x00, 0x2A, 0x07, 0x04, 0x00, 0x31, 0x07, 0x04, 
  0x03, 0x43, 0x06, 0x00, 0x00, 0x2A, 0x07, 0x05, 0x00, 0x30, 0x07, 0x04, 0x00, 0x43, 0x03, 0x00, 
  0x00, 0x2A, 0x08, 0x04, 0x00, 0x31, 0x08, 0x05, 0x03, 0x43, 0x07, 0x00, 0x00, 0x2A, 0x08, 0x06, 
  0x00, 0x30, 0x08, 0x04, 0x00, 0x43, 0x03, 0x00, 0x00, 0x2A, 0x09, 0x07, 0x00, 0x2A, 0x0A, 0x08, 
  0x00, 0x31, 0x09, 0x03, 0x0A, 0x43, 0x08, 0x00, 0x00, 0x2A, 0x09, 0x09, 0x00, 0x31, 0x09, 0x05, 
  0x04, 0x43, 0x03, 0x00, 0x00, 0x2A, 0x0A, 0x0A, 0x00, 0x31, 0x0A, 0x08, 0x05, 0x2F, 0x03, 0x00, 
  0x00, 0x43, 0x09, 0x00, 0x00, 0x2A, 0x08, 0x0B, 0x00, 0x31, 0x08, 0x06, 0x07, 0x30, 0x00, 0x09, 
  0x00, 0x43, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x81, 0x2A, 0x01, 0x04, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0xCF, 0x06, 0x69, 0x66, 0x2D, 0x6C, 0x65, 0x74, 0x3B, 0x02, 0x00, 0x00, 0x19, 0x03, 
  0x02, 0x00, 0x3B, 0x02, 0x00, 0x01, 0x19, 0x04, 0x02, 0x00, 0x3B, 0x02, 0x00, 0x02, 0x19, 0x05, 
  0x02, 0x00, 0x2C, 0x00, 0x00, 0x00, 0x30, 0x03, 0x04, 0x00, 0x44, 0x02, 0x00, 0x00, 0x1C, 0x05, 
  0x03, 0x00, 0x19, 0x06, 0x05, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x2A, 0x06, 0x00, 0x00, 0x30, 0x06, 
  0x03, 0x00, 0x43, 0x06, 0x00, 0x00, 0x2F, 0x06, 0x00, 0x00, 0x32, 0x01, 0x00, 0x00, 0x2A, 0x08, 
  0x01, 0x00, 0x33, 0x07, 0x08, 0x00, 0x2A, 0x08, 0x02, 0x00, 0x31, 0x08, 0x02, 0x07, 0x43, 0x06, 
  0x00, 0x00, 0x03, 0x06, 0x00, 0x00, 0x81, 0x6E, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 
  0x01, 0x00, 0x01, 0x00, 0x01, 0x04, 0x03, 0x00, 0x03, 0x01, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 
  0x15, 0x00, 0x14, 0x00, 0x14, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xFF, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xDA, 0x09, 0xCE, 0x80, 0x9F, 0x28, 0x77, 0x68, 0x65, 0x6E, 
  0x2D, 0x77, 0x69, 0x74, 0x68, 0x20, 0x5B, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x63, 
  0x74, 0x6F, 0x72, 0x20, 0x64, 0x74, 0x6F, 0x72, 0x5D, 0x20, 0x26, 0x20, 0x62, 0x6F, 0x64, 0x79, 
  0x29, 0x0A, 0x0A, 0x53, 0x69, 0x6D, 0x69, 0x6C, 0x61, 0x72, 0x20, 0x74, 0x6F, 0x20, 0x77, 0x69, 
  0x74, 0x68, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x69, 0x66, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 
  0x6E, 0x67, 0x20, 0x69, 0x73, 0x20, 0x66, 0x61, 0x6C, 0x73, 0x65, 0x20, 0x6F, 0x72, 0x20, 0x6E, 
  0x69, 0x6C, 0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x20, 0x6E, 0x69, 0x6C, 
  0x20, 0x77, 0x69, 0x74, 0x68, 0x6F, 0x75, 0x74, 0x20, 0x65, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 
  0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x2E, 0x20, 0x4F, 0x74, 
  0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x2C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6D, 
  0x65, 0x20, 0x61, 0x73, 0x20, 0x77, 0x69, 0x74, 0x68, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 
  0x05, 0x81, 0x6E, 0x01, 0xD0, 0x05, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0xCB, 0xCF, 0x06, 0x74, 0x61, 
  0x62, 0x6C, 0x65, 0x3F, 0xD3, 0x03, 0xDA, 0x03, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x01, 
  0x01, 0x01, 0x02, 0x07, 0xCE, 0x06, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x3F, 0xDA, 0x05, 0xD8, 0x04, 
  0x74, 0x79, 0x70, 0x65, 0xD0, 0x05, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2C, 0x01, 0x00, 0x00, 0x2F, 
  0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x23, 
  0x03, 0x02, 0x04, 0x03, 0x03, 0x00, 0x00, 0x61, 0x01, 0x00, 0x2B, 0x00, 0x2B, 0x00, 0x2B, 0x00, 
  0x28, 0x00, 0x28, 0x00, 0x28, 0xDA, 0x09, 0xCE, 0x1F, 0x28, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x3F, 
  0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 
  0x61, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x61, 
  0x01, 0xCF, 0x0A, 0x6D, 0x61, 0x6B, 0x65, 0x2D, 0x69, 0x6D, 0x61, 0x67, 0x65, 0xD3, 0x03, 0xDA, 
  0x03, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x03, 0x01, 0x01, 0x01, 0x02, 0x05, 0xCE, 0x0A, 0x6D, 
  0x61, 0x6B, 0x65, 0x2D, 0x69, 0x6D, 0x61, 0x67, 0x65, 0xDA, 0x05, 0xD3, 0x81, 0xE0, 0xC8, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x7F, 0xCF, 0x08, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x69, 0x6E, 
  0x66, 0x01, 0xCF, 0x11, 0x6A, 0x61, 0x6E, 0x65, 0x74, 0x2F, 0x63, 0x6F, 0x6E, 0x66, 0x69, 0x67, 
  0x2D, 0x62, 0x69, 0x74, 0x73, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x06, 0x03, 0x02, 0x03, 0x01, 
  0x06, 0xCE, 0x06, 0x69, 0x66, 0x2D, 0x6E, 0x6F, 0x74, 0xDA, 0x05, 0xDA, 0x2E, 0x2C, 0x03, 0x00, 
  0x00, 0x2A, 0x05, 0x00, 0x00, 0x31, 0x05, 0x00, 0x02, 0x2F, 0x01, 0x00, 0x00, 0x43, 0x04, 0x00, 
  0x00, 0x03, 0x04, 0x00, 0x00, 0x80, 0x9F, 0x01, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0xCF, 0x06, 0x69, 0x66, 0x2D, 0x6E, 0x6F, 0x74, 0xD7, 0xCD, 0x00, 0x09, 0x00, 0x0E, 
  0x06, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x13, 0xCE, 0x03, 0x62, 0x6F, 0x72, 0x3D, 
  0x01, 0x00, 0x00, 0x24, 0x02, 0x01, 0x00, 0x1C, 0x02, 0x03, 0x00, 0x29, 0x03, 0x00, 0x00, 0x03, 
  0x03, 0x00, 0x00, 0x24, 0x02, 0x01, 0x01, 0x1C, 0x02, 0x05, 0x00, 0x29, 0x03, 0x00, 0x00, 0x3B, 
  0x04, 0x00, 0x00, 0x0F, 0x03, 0x03, 0x04, 0x03, 0x03, 0x00, 0x00, 0x3B, 0x03, 0x00, 0x00, 0x29, 
  0x05, 0x01, 0x00, 0x38, 0x04, 0x00, 0x05, 0x0F, 0x03, 0x03, 0x04, 0x05, 0x05, 0x05, 0x01, 0x23, 
  0x02, 0x05, 0x01, 0x1C, 0x02, 0xFC, 0xFF, 0x03, 0x03, 0x00, 0x00, 0xCF, 0x03, 0x62, 0x6F, 0x72, 
  0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x04, 0x02, 0x00, 0x02, 0x02, 0x05, 0xCE, 0x0C, 0x61, 0x6C, 
  0x6C, 0x2D, 0x64, 0x79, 0x6E, 0x61, 0x6D, 0x69, 0x63, 0x73, 0xDA, 0x05, 0xD7, 0xCD, 0x00, 0x98, 
  0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 0x02, 0x07, 0xCE, 0x08, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 
  0x64, 0x3F, 0xDA, 0x05, 0xDA, 0x39, 0xD0, 0x07, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 0x2C, 
  0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2A, 
  0x04, 0x01, 0x00, 0x23, 0x03, 0x02, 0x04, 0x03, 0x03, 0x00, 0x00, 0x5C, 0x01, 0x00, 0x32, 0x00, 
  0x32, 0x00, 0x32, 0x00, 0x2F, 0x00, 0x2F, 0x00, 0x2F, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x10, 
  0x03, 0x01, 0x03, 0x06, 0x38, 0xCE, 0x08, 0x65, 0x6E, 0x76, 0x2D, 0x77, 0x61, 0x6C, 0x6B, 0xDA, 
  0x05, 0xD8, 0x0D, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2F, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 
  0xD8, 0x0C, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2F, 0x67, 0x65, 0x74, 0x65, 0x6E, 0x76, 0xD8, 0x0A, 
  0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x70, 0x75, 0x73, 0x68, 0xD8, 0x0E, 0x74, 0x61, 0x62, 0x6C, 
  0x65, 0x2F, 0x67, 0x65, 0x74, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 
  0x09, 0x01, 0x01, 0x01, 0x02, 0x16, 0xCE, 0x04, 0x6B, 0x65, 0x79, 0x73, 0xDA, 0x05, 0xD8, 0x09, 
  0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x6E, 0x65, 0x77, 0xDA, 0x52, 0x2C, 0x01, 0x00, 0x00, 0x3D, 
  0x02, 0x00, 0x00, 0x2F, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 
  0x02, 0x03, 0x00, 0x26, 0x05, 0x00, 0x00, 0x47, 0x04, 0x00, 0x05, 0x19, 0x05, 0x04, 0x00, 0x26, 
  0x07, 0x00, 0x00, 0x23, 0x06, 0x07, 0x05, 0x1B, 0x06, 0x03, 0x00, 0x27, 0x06, 0x00, 0x00, 0x1A, 
  0x02, 0x00, 0x00, 0x28, 0x06, 0x00, 0x00, 0x1C, 0x06, 0x06, 0x00, 0x30, 0x02, 0x05, 0x00, 0x2A, 
  0x08, 0x01, 0x00, 0x33, 0x07, 0x08, 0x00, 0x47, 0x05, 0x00, 0x05, 0x1A, 0xF5, 0xFF, 0xFF, 0x03, 
  0x02, 0x00, 0x00, 0x85, 0x1A, 0x01, 0x03, 0x17, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x03, 
  0x01, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 
  0x00, 0x0A, 0x00, 0x03, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x0C, 0xBF, 0xFE, 0x03, 0xBF, 
  0xFB, 0x01, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x06, 0x02, 0x01, 0x02, 0x02, 0x0D, 0xCE, 0x04, 
  0x73, 0x6F, 0x72, 0x74, 0xDA, 0x05, 0xD7, 0xCD, 0x00, 0x09, 0x00, 0x15, 0x06, 0x00, 0x00, 0xCD, 
  0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x10, 0xCE, 0x01, 0x3C, 0x3D, 0x01, 0x00, 0x00, 0x22, 0x02, 0x01, 
  0x02, 0x1B, 0x02, 0x0A, 0x00, 0x3B, 0x03, 0x00, 0x00, 0x29, 0x05, 0x01, 0x00, 0x38, 0x04, 0x00, 
  0x05, 0x21, 0x02, 0x03, 0x04, 0x1C, 0x02, 0x07, 0x00, 0x05, 0x05, 0x05, 0x01, 0x19, 0x03, 0x04, 
  0x00, 0x23, 0x02, 0x05, 0x01, 0x1C, 0x02, 0xFA, 0xFF, 0x27, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 
  0x00, 0x28, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x09, 
  0x04, 0x04, 0x04, 0x01, 0x14, 0xCE, 0x09, 0x73, 0x6F, 0x72, 0x74, 0x2D, 0x68, 0x65, 0x6C, 0x70, 
  0xDA, 0x05, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x10, 0x04, 0x04, 0x04, 0x00, 0x1C, 0xCE, 0x09, 
  0x73, 0x6F, 0x72, 0x74, 0x2D, 0x70, 0x61, 0x72, 0x74, 0xDA, 0x05, 0x2C, 0x04, 0x00, 0x00, 0x38, 
  0x05, 0x00, 0x02, 0x19, 0x06, 0x05, 0x00, 0x19, 0x07, 0x01, 0x00, 0x19, 0x08, 0x01, 0x00, 0x19, 
  0x09, 0x02, 0x00, 0x21, 0x0A, 0x08, 0x09, 0x1C, 0x0A, 0x11, 0x00, 0x19, 0x0B, 0x08, 0x00, 0x38, 
  0x0C, 0x00, 0x0B, 0x19, 0x0D, 0x0C, 0x00, 0x30, 0x0D, 0x06, 0x00, 0x33, 0x0C, 0x03, 0x00, 0x1C, 
  0x0C, 0x08, 0x00, 0x38, 0x0E, 0x00, 0x07, 0x19, 0x0F, 0x0E, 0x00, 0x3A, 0x00, 0x07, 0x0D, 0x3A, 
  0x00, 0x0B, 0x0F, 0x29, 0x0E, 0x01, 0x00, 0x06, 0x07, 0x07, 0x0E, 0x1A, 0x01, 0x00, 0x00, 0x29, 
  0x0C, 0x01, 0x00, 0x06, 0x08, 0x08, 0x0C, 0x1A, 0xEF, 0xFF, 0xFF, 0x38, 0x08, 0x00, 0x07, 0x3A, 
  0x00, 0x02, 0x08, 0x3A, 0x00, 0x07, 0x06, 0x03, 0x07, 0x00, 0x00, 0x82, 0xE2, 0x01, 0x02, 0x0E, 
  0x00, 0x03, 0x01, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x0D, 
  0x00, 0x05, 0x01, 0x0B, 0x00, 0x0B, 0x00, 0x05, 0x01, 0x0F, 0x00, 0x07, 0x01, 0x07, 0x01, 0x07, 
  0x01, 0x07, 0x00, 0x07, 0xBF, 0xFC, 0x05, 0xBF, 0xFE, 0x03, 0x00, 0x03, 0x00, 0x03, 0x07, 0x0F, 
  0x00, 0x03, 0x01, 0x03, 0xBF, 0xF4, 0x01, 0x2C, 0x04, 0x00, 0x00, 0x1F, 0x05, 0x02, 0x01, 0x1C, 
  0x05, 0x11, 0x00, 0x31, 0x00, 0x01, 0x02, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x07, 0x00, 0x00, 0x33, 
  0x06, 0x07, 0x00, 0x19, 0x07, 0x06, 0x00, 0x29, 0x08, 0x01, 0x00, 0x07, 0x06, 0x07, 0x08, 0x31, 
  0x00, 0x01, 0x06, 0x2F, 0x03, 0x00, 0x00, 0x33, 0x08, 0x04, 0x00, 0x29, 0x08, 0x01, 0x00, 0x06, 
  0x06, 0x07, 0x08, 0x31, 0x00, 0x06, 0x02, 0x2F, 0x03, 0x00, 0x00, 0x33, 0x08, 0x04, 0x00, 0x1A, 
  0x01, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x82, 0xF1, 0x01, 0x02, 0x09, 0x00, 0x03, 0x01, 0x0E, 
  0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x05, 0x01, 0x15, 0x00, 0x15, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x01, 0x12, 0x00, 0x12, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xBF, 0xFD, 0x03, 0xBF, 
  0xFE, 0x01, 0x2C, 0x02, 0x00, 0x00, 0x3D, 0x03, 0x00, 0x00, 0x29, 0x05, 0x01, 0x00, 0x07, 0x04, 
  0x03, 0x05, 0x1C, 0x01, 0x03, 0x00, 0x19, 0x03, 0x01, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x2A, 0x03, 
  0x00, 0x00, 0x29, 0x05, 0x00, 0x00, 0x31, 0x00, 0x05, 0x04, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x05, 
  0x01, 0x00, 0x34, 0x05, 0x00, 0x00, 0x82, 0xF9, 0x01, 0x03, 0x15, 0x00, 0x12, 0x00, 0x12, 0x00, 
  0x23, 0x00, 0x23, 0x00, 0x23, 0x00, 0x23, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x2C, 0x03, 0x00, 0x00, 0x26, 0x06, 0x00, 0x00, 0x23, 0x05, 0x06, 0x01, 0x1C, 0x05, 0x08, 
  0x00, 0x2A, 0x07, 0x00, 0x00, 0x33, 0x06, 0x07, 0x00, 0x2F, 0x06, 0x00, 0x00, 0x2A, 0x08, 0x01, 
  0x00, 0x33, 0x07, 0x08, 0x00, 0x19, 0x04, 0x07, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x04, 0x01, 
  0x00, 0x19, 0x05, 0x04, 0x00, 0x3E, 0x06, 0x00, 0x00, 0x19, 0x07, 0x06, 0x00, 0x19, 0x08, 0x05, 
  0x00, 0x1C, 0x08, 0x0B, 0x00, 0x30, 0x07, 0x08, 0x00, 0x2A, 0x0A, 0x02, 0x00, 0x33, 0x09, 0x0A, 
  0x00, 0x2F, 0x08, 0x00, 0x00, 0x2A, 0x09, 0x03, 0x00, 0x33, 0x08, 0x09, 0x00, 0x1C, 0x02, 0x03, 
  0x00, 0x1A, 0x03, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x1A, 0xF6, 0xFF, 0xFF, 0x42, 0x08, 0x00, 
  0x00, 0x19, 0x09, 0x08, 0x00, 0x26, 0x0B, 0x00, 0x00, 0x47, 0x0A, 0x07, 0x0B, 0x19, 0x0B, 0x0A, 
  0x00, 0x1D, 0x0B, 0x12, 0x00, 0x38, 0x0A, 0x07, 0x0B, 0x19, 0x0C, 0x0A, 0x00, 0x26, 0x0D, 0x00, 
  0x00, 0x47, 0x0A, 0x0C, 0x0D, 0x19, 0x0D, 0x0A, 0x00, 0x1D, 0x0D, 0x0A, 0x00, 0x19, 0x0A, 0x0D, 
  0x00, 0x2F, 0x0A, 0x00, 0x00, 0x33, 0x0E, 0x00, 0x00, 0x1C, 0x0E, 0x04, 0x00, 0x27, 0x0F, 0x00, 
  0x00, 0x3A, 0x09, 0x0A, 0x0F, 0x1A, 0x01, 0x00, 0x00, 0x47, 0x0D, 0x0C, 0x0D, 0x1A, 0xF7, 0xFF, 
  0xFF, 0x47, 0x0B, 0x07, 0x0B, 0x1A, 0xEF, 0xFF, 0xFF, 0x2F, 0x09, 0x00, 0x00, 0x2A, 0x0B, 0x04, 
  0x00, 0x33, 0x0A, 0x0B, 0x00, 0x2F, 0x0A, 0x00, 0x00, 0x2A, 0x0B, 0x05, 0x00, 0x34, 0x0B, 0x00, 
  0x00, 0x86, 0x1F, 0x01, 0x02, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x1E, 0x00, 0x1E, 0x00, 0x10, 
  0x00, 0x10, 0x00, 0x10, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 
  0x01, 0x07, 0x00, 0x13, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0x37, 0x00, 0x37, 0x00, 0x37, 
  0x00, 0x4B, 0x00, 0x55, 0x00, 0x4B, 0x00, 0x13, 0x01, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x02, 0x10, 0x00, 0x10, 0xBF, 0xFE, 0x03, 0x03, 0x05, 0x00, 0x05, 0xBF, 0xFD, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x04, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x2C, 0x02, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x31, 0x03, 0x00, 0x01, 
  0x2A, 0x03, 0x01, 0x00, 0x34, 0x03, 0x00, 0x00, 0x86, 0x32, 0x01, 0x05, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0xCF, 0x0C, 0x61, 0x6C, 0x6C, 0x2D, 0x64, 0x79, 0x6E, 0x61, 0x6D, 0x69, 0x63, 
  0x73, 0xC8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xFF, 0xCF, 0x09, 0x6D, 0x61, 0x74, 0x68, 
  0x2F, 0x2D, 0x69, 0x6E, 0x66, 0xD7, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x05, 0x01, 0x01, 0xCD, 0x7F, 
  0xFF, 0xFF, 0xFF, 0x03, 0x07, 0xCE, 0x09, 0x64, 0x65, 0x66, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x2D, 
  0xDA, 0x05, 0xDA, 0x35, 0xD0, 0x07, 0x70, 0x72, 0x69, 0x76, 0x61, 0x74, 0x65, 0xD7, 0xCD, 0x02, 
  0xBB, 0x00, 0x00, 0x17, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x0D, 0x38, 0x01, 0xCE, 0x04, 
  0x64, 0x65, 0x66, 0x6E, 0xDA, 0x05, 0xCE, 0x00, 0xCE, 0x01, 0x28, 0xD8, 0x06, 0x62, 0x75, 0x66, 
  0x66, 0x65, 0x72, 0xCE, 0x01, 0x20, 0xD8, 0x12, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x70, 
  0x75, 0x73, 0x68, 0x2D, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0xCE, 0x02, 0x25, 0x6A, 0xD8, 0x0D, 
  0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0xCE, 0x03, 0x29, 
  0x0A, 0x0A, 0xD8, 0x06, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0xDA, 0x52, 0xD8, 0x0B, 0x74, 0x75, 
  0x70, 0x6C, 0x65, 0x2F, 0x73, 0x6C, 0x69, 0x63, 0x65, 0xDA, 0x23, 0xDA, 0x26, 0x2C, 0x02, 0x00, 
  0x00, 0x3D, 0x03, 0x01, 0x00, 0x19, 0x04, 0x03, 0x00, 0x3E, 0x05, 0x00, 0x00, 0x19, 0x06, 0x05, 
  0x00, 0x2A, 0x07, 0x00, 0x00, 0x2E, 0x08, 0x00, 0x00, 0x19, 0x09, 0x08, 0x00, 0x29, 0x0A, 0x00, 
  0x00, 0x2F, 0x0A, 0x00, 0x00, 0x33, 0x0A, 0x09, 0x00, 0x19, 0x0B, 0x0A, 0x00, 0x38, 0x0C, 0x01, 
  0x0B, 0x19, 0x0D, 0x0C, 0x00, 0x29, 0x0E, 0x00, 0x00, 0x3D, 0x0F, 0x0D, 0x00, 0x19, 0x10, 0x0F, 
  0x00, 0x2A, 0x11, 0x01, 0x00, 0x30, 0x11, 0x00, 0x00, 0x2A, 0x12, 0x02, 0x00, 0x33, 0x11, 0x12, 
  0x00, 0x19, 0x12, 0x11, 0x00, 0x21, 0x13, 0x0E, 0x10, 0x1C, 0x13, 0x0D, 0x00, 0x2A, 0x14, 0x03, 
  0x00, 0x30, 0x12, 0x14, 0x00, 0x2A, 0x15, 0x04, 0x00, 0x33, 0x14, 0x15, 0x00, 0x38, 0x14, 0x0D, 
  0x0E, 0x2A, 0x15, 0x05, 0x00, 0x31, 0x12, 0x15, 0x14, 0x2A, 0x16, 0x06, 0x00, 0x33, 0x15, 0x16, 
  0x00, 0x29, 0x14, 0x01, 0x00, 0x06, 0x0E, 0x0E, 0x14, 0x1A, 0xF3, 0xFF, 0xFF, 0x2A, 0x13, 0x07, 
  0x00, 0x31, 0x12, 0x13, 0x07, 0x2A, 0x14, 0x08, 0x00, 0x33, 0x13, 0x14, 0x00, 0x30, 0x06, 0x13, 
  0x00, 0x2A, 0x15, 0x09, 0x00, 0x33, 0x14, 0x15, 0x00, 0x30, 0x01, 0x0B, 0x00, 0x2A, 0x15, 0x0A, 
  0x00, 0x33, 0x13, 0x15, 0x00, 0x2A, 0x16, 0x0B, 0x00, 0x30, 0x16, 0x00, 0x00, 0x32, 0x13, 0x00, 
  0x00, 0x43, 0x15, 0x00, 0x00, 0x2A, 0x16, 0x0C, 0x00, 0x30, 0x16, 0x00, 0x00, 0x32, 0x06, 0x00, 
  0x00, 0x2F, 0x15, 0x00, 0x00, 0x43, 0x13, 0x00, 0x00, 0x03, 0x13, 0x00, 0x00, 0xCD, 0x00, 0xD8, 
  0x00, 0x00, 0x09, 0x01, 0x01, 0x01, 0x04, 0x1D, 0x01, 0xCE, 0x05, 0x72, 0x65, 0x63, 0x75, 0x72, 
  0xDA, 0x05, 0xDA, 0x39, 0xD0, 0x05, 0x74, 0x75, 0x70, 0x6C, 0x65, 0xD0, 0x06, 0x73, 0x74, 0x72, 
  0x69, 0x6E, 0x67, 0xDA, 0x52, 0x2C, 0x01, 0x00, 0x00, 0x2B, 0x03, 0x00, 0x01, 0x38, 0x02, 0x03, 
  0x00, 0x19, 0x03, 0x02, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x02, 0x04, 
  0x00, 0x19, 0x04, 0x02, 0x00, 0x2A, 0x06, 0x01, 0x00, 0x23, 0x05, 0x04, 0x06, 0x1C, 0x05, 0x02, 
  0x00, 0x03, 0x00, 0x00, 0x00, 0x2A, 0x07, 0x02, 0x00, 0x23, 0x06, 0x04, 0x07, 0x1C, 0x06, 0x03, 
  0x00, 0x2D, 0x03, 0x00, 0x07, 0x1A, 0x05, 0x00, 0x00, 0x2B, 0x07, 0x00, 0x06, 0x30, 0x07, 0x03, 
  0x00, 0x2A, 0x08, 0x03, 0x00, 0x33, 0x07, 0x08, 0x00, 0x2B, 0x07, 0x00, 0x04, 0x21, 0x06, 0x00, 
  0x07, 0x1C, 0x06, 0x05, 0x00, 0x29, 0x08, 0x01, 0x00, 0x06, 0x07, 0x00, 0x08, 0x2F, 0x07, 0x00, 
  0x00, 0x34, 0x01, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xBF, 0xFF, 0x11, 0x07, 0x01, 0x09, 0x00, 
  0x09, 0x00, 0x09, 0x01, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x09, 0x01, 0x0D, 0x00, 0x0D, 0x00, 
  0x09, 0x00, 0x09, 0x03, 0x11, 0x00, 0x11, 0x00, 0x0D, 0x01, 0x0F, 0xBF, 0xFF, 0x0D, 0x02, 0x0F, 
  0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x01, 0x11, 0x00, 0x11, 0x00, 0x0D, 0x00, 0x22, 0x00, 0x22, 
  0x00, 0x1B, 0x00, 0x1B, 0x00, 0x0D, 0x0C, 0x03, 0x01, 0x0E, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 
  0x01, 0x05, 0x02, 0x07, 0xBF, 0xFF, 0x05, 0x0B, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x05, 0x01, 
  0x0F, 0x00, 0x05, 0x02, 0x05, 0x01, 0x11, 0x00, 0x05, 0x01, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 
  0x0E, 0x00, 0x05, 0x01, 0x0C, 0x00, 0x05, 0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x01, 
  0x1F, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x01, 0x12, 0x00, 0x12, 0xBF, 0xFD, 0x05, 
  0x04, 0x1B, 0x00, 0x1B, 0x00, 0x1B, 0x00, 0x1B, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x02, 0x29, 
  0x00, 0x29, 0x00, 0x29, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xD2, 0x00, 0x00, 0x00, 0x2C, 0x02, 0x00, 0x00, 
  0x2A, 0x03, 0x00, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x31, 0x00, 0x03, 0x04, 0x32, 0x01, 0x00, 0x00, 
  0x2A, 0x03, 0x02, 0x00, 0x34, 0x03, 0x00, 0x00, 0x2E, 0x01, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x09, 0x64, 0x65, 0x66, 0x6D, 0x61, 0x63, 0x72, 0x6F, 
  0x2D, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 0x02, 0x07, 0xCE, 0x09, 0x66, 
  0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x3F, 0xDA, 0x05, 0xDA, 0x39, 0xD0, 0x08, 0x66, 0x75, 
  0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 
  0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x23, 0x03, 0x02, 0x04, 0x03, 0x03, 
  0x00, 0x00, 0x5E, 0x01, 0x01, 0x06, 0x00, 0x06, 0x00, 0x06, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0xCF, 0x09, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x3F, 0xD7, 0xCD, 0x00, 0x98, 0x00, 
  0x00, 0x0A, 0x03, 0x03, 0x03, 0x0B, 0x1F, 0xCE, 0x0B, 0x62, 0x61, 0x64, 0x2D, 0x63, 0x6F, 0x6D, 
  0x70, 0x69, 0x6C, 0x65, 0xDA, 0x05, 0xD0, 0x09, 0x65, 0x72, 0x72, 0x2D, 0x63, 0x6F, 0x6C, 0x6F, 
  0x72, 0xD8, 0x03, 0x64, 0x79, 0x6E, 0xCE, 0x11, 0x20, 0x77, 0x68, 0x69, 0x6C, 0x65, 0x20, 0x63, 
  0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x69, 0x6E, 0x67, 0x20, 0xDA, 0x6F, 0xD8, 0x10, 0x64, 0x65, 0x62, 
  0x75, 0x67, 0x2F, 0x73, 0x74, 0x61, 0x63, 0x6B, 0x74, 0x72, 0x61, 0x63, 0x65, 0xCE, 0x05, 0x1B, 
  0x5B, 0x33, 0x31, 0x6D, 0xDA, 0x67, 0xCE, 0x04, 0x1B, 0x5B, 0x30, 0x6D, 0xCE, 0x0F, 0x63, 0x6F, 
  0x6D, 0x70, 0x69, 0x6C, 0x65, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x3A, 0x20, 0xD8, 0x06, 0x65, 
  0x70, 0x72, 0x69, 0x6E, 0x74, 0xD8, 0x06, 0x65, 0x66, 0x6C, 0x75, 0x73, 0x68, 0x2C, 0x03, 0x00, 
  0x00, 0x2A, 0x04, 0x00, 0x00, 0x2F, 0x04, 0x00, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x33, 0x04, 0x05, 
  0x00, 0x19, 0x05, 0x04, 0x00, 0x1C, 0x01, 0x09, 0x00, 0x2A, 0x06, 0x02, 0x00, 0x31, 0x00, 0x06, 
  0x02, 0x2A, 0x07, 0x03, 0x00, 0x33, 0x06, 0x07, 0x00, 0x30, 0x01, 0x06, 0x00, 0x2A, 0x08, 0x04, 
  0x00, 0x33, 0x07, 0x08, 0x00, 0x1A, 0x0F, 0x00, 0x00, 0x1C, 0x05, 0x03, 0x00, 0x2A, 0x06, 0x05, 
  0x00, 0x1A, 0x02, 0x00, 0x00, 0x2A, 0x06, 0x06, 0x00, 0x1C, 0x05, 0x03, 0x00, 0x2A, 0x07, 0x07, 
  0x00, 0x1A, 0x02, 0x00, 0x00, 0x2A, 0x07, 0x06, 0x00, 0x2A, 0x08, 0x08, 0x00, 0x31, 0x06, 0x08, 
  0x00, 0x2A, 0x08, 0x02, 0x00, 0x31, 0x08, 0x02, 0x07, 0x2A, 0x09, 0x09, 0x00, 0x33, 0x08, 0x09, 
  0x00, 0x2A, 0x06, 0x0A, 0x00, 0x34, 0x06, 0x00, 0x00, 0x87, 0xC6, 0x01, 0x03, 0x0B, 0x00, 0x0B, 
  0x00, 0x0B, 0x00, 0x0B, 0x00, 0x03, 0x01, 0x03, 0x01, 0x1E, 0x00, 0x1E, 0x00, 0x1E, 0x00, 0x1E, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xBF, 0xFF, 0x03, 0x03, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 
  0x07, 0x05, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xFA, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x07, 0x03, 0x00, 0x03, 0xCF, 0x0B, 0x62, 0x61, 0x64, 0x2D, 
  0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x07, 0x01, 0x01, 
  0x01, 0x03, 0x0D, 0xCE, 0x0B, 0x64, 0x69, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x72, 0x79, 0x3F, 
  0xDA, 0x05, 0xDA, 0x39, 0xDA, 0x3A, 0xD0, 0x06, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x2C, 0x01, 
  0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x19, 0x03, 
  0x02, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x23, 0x04, 0x03, 0x05, 0x1C, 0x04, 0x03, 0x00, 0x27, 0x05, 
  0x00, 0x00, 0x03, 0x05, 0x00, 0x00, 0x2A, 0x06, 0x02, 0x00, 0x23, 0x05, 0x03, 0x06, 0x03, 0x05, 
  0x00, 0x00, 0x69, 0x01, 0x01, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x07, 0x00, 0x07, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x19, 0x00, 0x19, 0x00, 0x19, 0xCF, 0x0B, 0x64, 0x69, 
  0x63, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x72, 0x79, 0x3F, 0xD3, 0x00, 0xCF, 0x0C, 0x6D, 0x6F, 0x64, 
  0x75, 0x6C, 0x65, 0x2F, 0x63, 0x61, 0x63, 0x68, 0x65, 0xD7, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x05, 
  0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x02, 0x07, 0xCE, 0x07, 0x72, 0x65, 0x71, 0x75, 0x69, 
  0x72, 0x65, 0xDA, 0x05, 0xD8, 0x06, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0xD7, 0xCD, 0x00, 0x98, 
  0x00, 0x00, 0x0D, 0x03, 0x03, 0x03, 0x0B, 0x3B, 0xCE, 0x09, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 
  0x65, 0x2D, 0x31, 0xDA, 0x05, 0xD7, 0xCD, 0x02, 0xBA, 0x00, 0x00, 0x0C, 0x01, 0x01, 0x01, 0x0D, 
  0x4F, 0x01, 0xCE, 0x0B, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2F, 0x66, 0x69, 0x6E, 0x64, 0xDA, 
  0x05, 0xD1, 0x0C, 0xD2, 0x03, 0x00, 0xCE, 0x12, 0x3A, 0x63, 0x75, 0x72, 0x3A, 0x2F, 0x3A, 0x61, 
  0x6C, 0x6C, 0x3A, 0x2E, 0x6A, 0x69, 0x6D, 0x61, 0x67, 0x65, 0xD0, 0x05, 0x69, 0x6D, 0x61, 0x67, 
  0x65, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x04, 0x01, 0x01, 0x01, 0x02, 0x08, 0xCE, 0x07, 0x63, 
  0x68, 0x65, 0x63, 0x6B, 0x2D, 0x2E, 0xDA, 0x05, 0xCE, 0x01, 0x2E, 0xD8, 0x12, 0x73, 0x74, 0x72, 
  0x69, 0x6E, 0x67, 0x2F, 0x68, 0x61, 0x73, 0x2D, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x3F, 0x2C, 
  0x01, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x30, 0x02, 0x00, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x33, 
  0x02, 0x03, 0x00, 0x1C, 0x02, 0x02, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x88, 
  0x90, 0x01, 0x00, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 
  0xD2, 0x03, 0x00, 0xCE, 0x11, 0x3A, 0x63, 0x75, 0x72, 0x3A, 0x2F, 0x3A, 0x61, 0x6C, 0x6C, 0x3A, 
  0x2E, 0x6A, 0x61, 0x6E, 0x65, 0x74, 0xD0, 0x06, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0xDA, 0x80, 
  0x97, 0xD2, 0x03, 0x00, 0xCE, 0x16, 0x3A, 0x63, 0x75, 0x72, 0x3A, 0x2F, 0x3A, 0x61, 0x6C, 0x6C, 
  0x3A, 0x2F, 0x69, 0x6E, 0x69, 0x74, 0x2E, 0x6A, 0x61, 0x6E, 0x65, 0x74, 0xDA, 0x80, 0x9A, 0xDA, 
  0x80, 0x97, 0xD2, 0x03, 0x00, 0xCE, 0x13, 0x3A, 0x63, 0x75, 0x72, 0x3A, 0x2F, 0x3A, 0x61, 0x6C, 
  0x6C, 0x3A, 0x3A, 0x6E, 0x61, 0x74, 0x69, 0x76, 0x65, 0x3A, 0xD0, 0x06, 0x6E, 0x61, 0x74, 0x69, 
  0x76, 0x65, 0xDA, 0x80, 0x97, 0xD2, 0x03, 0x00, 0xCE, 0x12, 0x3A, 0x73, 0x79, 0x73, 0x3A, 0x2F, 
  0x3A, 0x61, 0x6C, 0x6C, 0x3A, 0x2E, 0x6A, 0x69, 0x6D, 0x61, 0x67, 0x65, 0xDA, 0x80, 0x93, 0xD7, 
  0xCD, 0x00, 0x98, 0x00, 0x00, 0x04, 0x01, 0x01, 0x01, 0x02, 0x08, 0xCE, 0x0B, 0x6E, 0x6F, 0x74, 
  0x2D, 0x63, 0x68, 0x65, 0x63, 0x6B, 0x2D, 0x2E, 0xDA, 0x05, 0xDA, 0x80, 0x95, 0xDA, 0x80, 0x96, 
  0x2C, 0x01, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x30, 0x02, 0x00, 0x00, 0x2A, 0x03, 0x01, 0x00, 
  0x33, 0x02, 0x03, 0x00, 0x1C, 0x02, 0x02, 0x00, 0x04, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
  0x88, 0x91, 0x01, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x18, 0x00, 0x18, 0x00, 
  0x18, 0xD2, 0x03, 0x00, 0xCE, 0x11, 0x3A, 0x73, 0x79, 0x73, 0x3A, 0x2F, 0x3A, 0x61, 0x6C, 0x6C, 
  0x3A, 0x2E, 0x6A, 0x61, 0x6E, 0x65, 0x74, 0xDA, 0x80, 0x9A, 0xDA, 0x80, 0xA3, 0xD2, 0x03, 0x00, 
  0xCE, 0x16, 0x3A, 0x73, 0x79, 0x73, 0x3A, 0x2F, 0x3A, 0x61, 0x6C, 0x6C, 0x3A, 0x2F, 0x69, 0x6E, 
  0x69, 0x74, 0x2E, 0x6A, 0x61, 0x6E, 0x65, 0x74, 0xDA, 0x80, 0x9A, 0xDA, 0x80, 0xA3, 0xD2, 0x03, 
  0x00, 0xCE, 0x13, 0x3A, 0x73, 0x79, 0x73, 0x3A, 0x2F, 0x3A, 0x61, 0x6C, 0x6C, 0x3A, 0x3A, 0x6E, 
  0x61, 0x74, 0x69, 0x76, 0x65, 0x3A, 0xDA, 0x80, 0x9F, 0xDA, 0x80, 0xA3, 0xD2, 0x03, 0x00, 0xCE, 
  0x0C, 0x3A, 0x61, 0x6C, 0x6C, 0x3A, 0x2E, 0x6A, 0x69, 0x6D, 0x61, 0x67, 0x65, 0xDA, 0x80, 0x93, 
  0xDA, 0x80, 0xA3, 0xD2, 0x03, 0x00, 0xCE, 0x0B, 0x3A, 0x61, 0x6C, 0x6C, 0x3A, 0x2E, 0x6A, 0x61, 
  0x6E, 0x65, 0x74, 0xDA, 0x80, 0x9A, 0xDA, 0x80, 0xA3, 0xD2, 0x03, 0x00, 0xCE, 0x10, 0x3A, 0x61, 
  0x6C, 0x6C, 0x3A, 0x2F, 0x69, 0x6E, 0x69, 0x74, 0x2E, 0x6A, 0x61, 0x6E, 0x65, 0x74, 0xDA, 0x80, 
  0x9A, 0xDA, 0x80, 0xA3, 0xD2, 0x03, 0x00, 0xCE, 0x0D, 0x3A, 0x61, 0x6C, 0x6C, 0x3A, 0x3A, 0x6E, 
  0x61, 0x74, 0x69, 0x76, 0x65, 0x3A, 0xDA, 0x80, 0x9F, 0xDA, 0x80, 0xA3, 0xD7, 0xCD, 0x00, 0x98, 
  0x00, 0x00, 0x07, 0x02, 0x02, 0x02, 0x04, 0x11, 0xCE, 0x0A, 0x6D, 0x6F, 0x64, 0x2D, 0x66, 0x69, 
  0x6C, 0x74, 0x65, 0x72, 0xDA, 0x05, 0xDA, 0x39, 0xD0, 0x03, 0x6E, 0x69, 0x6C, 0xDA, 0x73, 0xD8, 
  0x12, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x68, 0x61, 0x73, 0x2D, 0x73, 0x75, 0x66, 0x66, 
  0x69, 0x78, 0x3F, 0x2C, 0x02, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 
  0x03, 0x04, 0x00, 0x19, 0x04, 0x03, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x23, 0x03, 0x04, 0x05, 0x1C, 
  0x03, 0x02, 0x00, 0x03, 0x01, 0x00, 0x00, 0x2A, 0x06, 0x02, 0x00, 0x23, 0x05, 0x04, 0x06, 0x1C, 
  0x05, 0x04, 0x00, 0x30, 0x00, 0x01, 0x00, 0x2A, 0x06, 0x03, 0x00, 0x34, 0x06, 0x00, 0x00, 0x2F, 
  0x01, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x88, 0xC6, 0x01, 0x02, 0x09, 0x00, 0x09, 0x00, 0x09, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x02, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x01, 0x05, 0x00, 0x05, 0xDA, 0x79, 0xD8, 0x12, 0x6D, 0x6F, 
  0x64, 0x75, 0x6C, 0x65, 0x2F, 0x65, 0x78, 0x70, 0x61, 0x6E, 0x64, 0x2D, 0x70, 0x61, 0x74, 0x68, 
  0xDA, 0x6F, 0xD7, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 0x02, 0x08, 0x01, 0xCE, 
  0x07, 0x66, 0x65, 0x78, 0x69, 0x73, 0x74, 0x73, 0xDA, 0x05, 0xD0, 0x04, 0x6D, 0x6F, 0x64, 0x65, 
  0xD0, 0x04, 0x66, 0x69, 0x6C, 0x65, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x30, 0x00, 
  0x02, 0x00, 0x2B, 0x03, 0x00, 0x02, 0x33, 0x02, 0x03, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x23, 0x03, 
  0x04, 0x02, 0x03, 0x03, 0x00, 0x00, 0xBF, 0xFF, 0x88, 0xBB, 0x1A, 0x00, 0x36, 0x00, 0x36, 0x00, 
  0x36, 0x00, 0x36, 0x00, 0x2D, 0x00, 0x2D, 0x00, 0x2D, 0x00, 0x04, 0xC9, 0xC9, 0xD8, 0x07, 0x6F, 
  0x73, 0x2F, 0x73, 0x74, 0x61, 0x74, 0xC9, 0xD7, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x1C, 0x01, 0x01, 
  0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x02, 0x80, 0x8A, 0xCE, 0x03, 0x6D, 0x61, 0x70, 0xDA, 0x05, 0xCE, 
  0x26, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x61, 0x74, 0x20, 0x6C, 0x65, 0x61, 
  0x73, 0x74, 0x20, 0x31, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x65, 0x64, 0x20, 0x63, 0x6F, 0x6C, 
  0x6C, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0xDA, 0x55, 0x2C, 0x02, 0x00, 0x00, 0x3D, 0x03, 0x01, 
  0x00, 0x19, 0x04, 0x03, 0x00, 0x29, 0x06, 0x00, 0x00, 0x23, 0x05, 0x06, 0x04, 0x1C, 0x05, 0x04, 
  0x00, 0x2A, 0x06, 0x00, 0x00, 0x01, 0x06, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x29, 0x06, 0x00, 
  0x00, 0x38, 0x05, 0x01, 0x06, 0x3D, 0x06, 0x05, 0x00, 0x19, 0x05, 0x06, 0x00, 0x29, 0x07, 0x00, 
  0x00, 0x19, 0x08, 0x04, 0x00, 0x21, 0x09, 0x07, 0x08, 0x1C, 0x09, 0x0C, 0x00, 0x19, 0x0A, 0x07, 
  0x00, 0x38, 0x0B, 0x01, 0x0A, 0x3D, 0x0C, 0x0B, 0x00, 0x19, 0x0B, 0x0C, 0x00, 0x21, 0x0C, 0x0B, 
  0x05, 0x1C, 0x0C, 0x03, 0x00, 0x19, 0x05, 0x0B, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x29, 0x0C, 0x01, 
  0x00, 0x06, 0x07, 0x07, 0x0C, 0x1A, 0xF4, 0xFF, 0xFF, 0x3B, 0x07, 0x01, 0x00, 0x19, 0x08, 0x07, 
  0x00, 0x3B, 0x07, 0x01, 0x01, 0x19, 0x09, 0x07, 0x00, 0x3B, 0x07, 0x01, 0x02, 0x19, 0x0A, 0x07, 
  0x00, 0x3B, 0x07, 0x01, 0x03, 0x19, 0x0B, 0x07, 0x00, 0x2F, 0x05, 0x00, 0x00, 0x2A, 0x0C, 0x01, 
  0x00, 0x33, 0x07, 0x0C, 0x00, 0x19, 0x0C, 0x07, 0x00, 0x29, 0x0E, 0x01, 0x00, 0x23, 0x0D, 0x04, 
  0x0E, 0x1C, 0x0D, 0x0E, 0x00, 0x29, 0x0E, 0x00, 0x00, 0x19, 0x0F, 0x05, 0x00, 0x21, 0x10, 0x0E, 
  0x0F, 0x1C, 0x10, 0x09, 0x00, 0x19, 0x11, 0x0E, 0x00, 0x38, 0x12, 0x08, 0x11, 0x2F, 0x12, 0x00, 
  0x00, 0x33, 0x13, 0x00, 0x00, 0x3A, 0x0C, 0x11, 0x13, 0x29, 0x12, 0x01, 0x00, 0x06, 0x0E, 0x0E, 
  0x12, 0x1A, 0xF7, 0xFF, 0xFF, 0x1A, 0x52, 0x00, 0x00, 0x29, 0x0F, 0x02, 0x00, 0x23, 0x0E, 0x04, 
  0x0F, 0x1C, 0x0E, 0x0F, 0x00, 0x29, 0x0F, 0x00, 0x00, 0x19, 0x10, 0x05, 0x00, 0x21, 0x11, 0x0F, 
  0x10, 0x1C, 0x11, 0x0A, 0x00, 0x19, 0x12, 0x0F, 0x00, 0x38, 0x13, 0x08, 0x12, 0x38, 0x14, 0x09, 
  0x12, 0x30, 0x13, 0x14, 0x00, 0x33, 0x15, 0x00, 0x00, 0x3A, 0x0C, 0x12, 0x15, 0x29, 0x13, 0x01, 
  0x00, 0x06, 0x0F, 0x0F, 0x13, 0x1A, 0xF6, 0xFF, 0xFF, 0x1A, 0x41, 0x00, 0x00, 0x29, 0x10, 0x03, 
  0x00, 0x23, 0x0F, 0x04, 0x10, 0x1C, 0x0F, 0x10, 0x00, 0x29, 0x10, 0x00, 0x00, 0x19, 0x11, 0x05, 
  0x00, 0x21, 0x12, 0x10, 0x11, 0x1C, 0x12, 0x0B, 0x00, 0x19, 0x13, 0x10, 0x00, 0x38, 0x14, 0x08, 
  0x13, 0x38, 0x15, 0x09, 0x13, 0x38, 0x16, 0x0A, 0x13, 0x31, 0x14, 0x15, 0x16, 0x33, 0x17, 0x00, 
  0x00, 0x3A, 0x0C, 0x13, 0x17, 0x29, 0x14, 0x01, 0x00, 0x06, 0x10, 0x10, 0x14, 0x1A, 0xF5, 0xFF, 
  0xFF, 0x1A, 0x2F, 0x00, 0x00, 0x29, 0x11, 0x04, 0x00, 0x23, 0x10, 0x04, 0x11, 0x1C, 0x10, 0x12, 
  0x00, 0x29, 0x11, 0x00, 0x00, 0x19, 0x12, 0x05, 0x00, 0x21, 0x13, 0x11, 0x12, 0x1C, 0x13, 0x0D, 
  0x00, 0x19, 0x14, 0x11, 0x00, 0x38, 0x15, 0x08, 0x14, 0x38, 0x16, 0x09, 0x14, 0x38, 0x17, 0x0A, 
  0x14, 0x38, 0x18, 0x0B, 0x14, 0x31, 0x15, 0x16, 0x17, 0x2F, 0x18, 0x00, 0x00, 0x33, 0x19, 0x00, 
  0x00, 0x3A, 0x0C, 0x14, 0x19, 0x29, 0x15, 0x01, 0x00, 0x06, 0x11, 0x11, 0x15, 0x1A, 0xF3, 0xFF, 
  0xFF, 0x1A, 0x1B, 0x00, 0x00, 0x29, 0x11, 0x00, 0x00, 0x19, 0x12, 0x05, 0x00, 0x21, 0x13, 0x11, 
  0x12, 0x1C, 0x13, 0x17, 0x00, 0x19, 0x14, 0x11, 0x00, 0x2F, 0x04, 0x00, 0x00, 0x2A, 0x16, 0x01, 
  0x00, 0x33, 0x15, 0x16, 0x00, 0x19, 0x16, 0x15, 0x00, 0x29, 0x15, 0x00, 0x00, 0x19, 0x17, 0x04, 
  0x00, 0x21, 0x18, 0x15, 0x17, 0x1C, 0x18, 0x08, 0x00, 0x19, 0x19, 0x15, 0x00, 0x38, 0x1A, 0x01, 
  0x19, 0x38, 0x1B, 0x1A, 0x14, 0x3A, 0x16, 0x19, 0x1B, 0x29, 0x1A, 0x01, 0x00, 0x06, 0x15, 0x15, 
  0x1A, 0x1A, 0xF8, 0xFF, 0xFF, 0x32, 0x16, 0x00, 0x00, 0x33, 0x15, 0x00, 0x00, 0x3A, 0x0C, 0x14, 
  0x15, 0x29, 0x15, 0x01, 0x00, 0x06, 0x11, 0x11, 0x15, 0x1A, 0xE9, 0xFF, 0xFF, 0x03, 0x0C, 0x00, 
  0x00, 0x83, 0x41, 0x01, 0x04, 0x0E, 0x00, 0x03, 0x01, 0x07, 0x00, 0x07, 0x00, 0x03, 0x00, 0x13, 
  0x00, 0x13, 0x00, 0x03, 0x01, 0x16, 0x00, 0x16, 0x00, 0x0E, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x14, 0x00, 0x0C, 0x00, 0x05, 0x01, 0x09, 0x00, 0x05, 
  0x00, 0x15, 0x00, 0x05, 0xBF, 0xFE, 0x03, 0x00, 0x03, 0x00, 0x03, 0x03, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x0C, 0x00, 0x0C, 0x00, 
  0x0C, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 
  0x07, 0x00, 0x07, 0x00, 0x26, 0x00, 0x23, 0x00, 0x23, 0x00, 0x16, 0x00, 0x07, 0x00, 0x07, 0x00, 
  0x07, 0xBF, 0xFF, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x02, 0x07, 0x00, 0x07, 0x00, 0x07, 
  0x00, 0x07, 0x00, 0x07, 0x00, 0x26, 0x00, 0x30, 0x00, 0x23, 0x00, 0x23, 0x00, 0x16, 0x00, 0x07, 
  0x00, 0x07, 0x00, 0x07, 0xBF, 0xFE, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x03, 0x07, 0x00, 
  0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x26, 0x00, 0x30, 0x00, 0x3A, 0x00, 0x23, 0x00, 
  0x23, 0x00, 0x16, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xFD, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x04, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x26, 0x00, 0x30, 
  0x00, 0x3A, 0x00, 0x44, 0x00, 0x23, 0x00, 0x23, 0x00, 0x23, 0x00, 0x16, 0x00, 0x07, 0x00, 0x07, 
  0x00, 0x07, 0xBF, 0xFC, 0x03, 0x05, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 
  0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x07, 0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 
  0x07, 0x00, 0x28, 0x00, 0x24, 0x00, 0x16, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x01, 0x14, 0x00, 
  0x14, 0x00, 0x07, 0xBF, 0xFD, 0x05, 0x00, 0x05, 0x00, 0x05, 0xBF, 0xEF, 0x01, 0xD7, 0xCD, 0x00, 
  0x98, 0x00, 0x00, 0x02, 0x01, 0x01, 0x01, 0x00, 0x02, 0xCE, 0x08, 0x69, 0x64, 0x65, 0x6E, 0x74, 
  0x69, 0x74, 0x79, 0xDA, 0x05, 0x2C, 0x01, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x82, 0x79, 0x01, 
  0x00, 0x01, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0A, 0x02, 0x02, 0x02, 0x01, 0x13, 0xCE, 0x06, 
  0x66, 0x69, 0x6C, 0x74, 0x65, 0x72, 0xDA, 0x05, 0xDA, 0x52, 0x2C, 0x02, 0x00, 0x00, 0x3E, 0x03, 
  0x00, 0x00, 0x19, 0x04, 0x03, 0x00, 0x26, 0x06, 0x00, 0x00, 0x47, 0x05, 0x01, 0x06, 0x19, 0x06, 
  0x05, 0x00, 0x1D, 0x06, 0x0C, 0x00, 0x38, 0x05, 0x01, 0x06, 0x19, 0x07, 0x05, 0x00, 0x2F, 0x07, 
  0x00, 0x00, 0x33, 0x05, 0x00, 0x00, 0x1C, 0x05, 0x05, 0x00, 0x30, 0x04, 0x07, 0x00, 0x2A, 0x09, 
  0x00, 0x00, 0x33, 0x08, 0x09, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x47, 0x06, 0x01, 0x06, 0x1A, 0xF5, 
  0xFF, 0xFF, 0x03, 0x04, 0x00, 0x00, 0x83, 0x61, 0x01, 0x04, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x09, 0x00, 0x09, 0x00, 0x05, 0x01, 
  0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xFF, 0x05, 0xBF, 0xFF, 0x03, 0x00, 0x03, 0xBF, 0xFB, 0x01, 
  0xCE, 0x05, 0x0A, 0x20, 0x20, 0x20, 0x20, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0C, 0x02, 0x02, 
  0x02, 0x02, 0x1E, 0xCE, 0x09, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x70, 0x6F, 0x73, 0x65, 0xDA, 0x05, 
  0xDA, 0x55, 0xDA, 0x52, 0x2C, 0x02, 0x00, 0x00, 0x3D, 0x03, 0x01, 0x00, 0x19, 0x04, 0x03, 0x00, 
  0x29, 0x06, 0x02, 0x00, 0x09, 0x05, 0x06, 0x04, 0x29, 0x07, 0x01, 0x00, 0x07, 0x06, 0x05, 0x07, 
  0x2F, 0x06, 0x00, 0x00, 0x2A, 0x07, 0x00, 0x00, 0x33, 0x05, 0x07, 0x00, 0x19, 0x06, 0x05, 0x00, 
  0x29, 0x08, 0x00, 0x00, 0x1F, 0x07, 0x04, 0x08, 0x1C, 0x07, 0x06, 0x00, 0x29, 0x09, 0x00, 0x00, 
  0x38, 0x08, 0x01, 0x09, 0x29, 0x09, 0x00, 0x00, 0x3A, 0x06, 0x09, 0x08, 0x1A, 0x01, 0x00, 0x00, 
  0x29, 0x07, 0x01, 0x00, 0x21, 0x08, 0x07, 0x04, 0x1C, 0x08, 0x08, 0x00, 0x38, 0x09, 0x01, 0x07, 
  0x31, 0x06, 0x00, 0x09, 0x2A, 0x0B, 0x01, 0x00, 0x33, 0x0A, 0x0B, 0x00, 0x29, 0x09, 0x01, 0x00, 
  0x06, 0x07, 0x07, 0x09, 0x1A, 0xF8, 0xFF, 0xFF, 0x03, 0x06, 0x00, 0x00, 0x85, 0x6E, 0x01, 0x04, 
  0x0C, 0x00, 0x03, 0x01, 0x1A, 0x00, 0x1A, 0x00, 0x17, 0x00, 0x17, 0x00, 0x0C, 0x00, 0x0C, 0x00, 
  0x0C, 0x00, 0x03, 0x01, 0x07, 0x00, 0x07, 0x00, 0x03, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0x11, 0x00, 
  0x11, 0x00, 0x03, 0x01, 0x03, 0x01, 0x0A, 0x00, 0x03, 0x01, 0x19, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x01, 0x05, 0x00, 0x05, 0xBF, 0xFE, 0x03, 0xBF, 0xF8, 0x01, 0xCE, 0x16, 0x63, 0x6F, 0x75, 
  0x6C, 0x64, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x66, 0x69, 0x6E, 0x64, 0x20, 0x6D, 0x6F, 0x64, 0x75, 
  0x6C, 0x65, 0x20, 0xCE, 0x06, 0x3A, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x2C, 0x01, 0x00, 0x00, 0x26, 
  0x02, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x26, 0x05, 0x00, 0x00, 0x47, 0x03, 0x04, 0x05, 0x19, 
  0x04, 0x03, 0x00, 0x1D, 0x04, 0x2D, 0x00, 0x2A, 0x05, 0x00, 0x00, 0x38, 0x03, 0x05, 0x04, 0x3B, 
  0x05, 0x03, 0x00, 0x19, 0x06, 0x05, 0x00, 0x3B, 0x05, 0x03, 0x01, 0x19, 0x07, 0x05, 0x00, 0x3B, 
  0x05, 0x03, 0x02, 0x19, 0x08, 0x05, 0x00, 0x30, 0x08, 0x00, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x33, 
  0x03, 0x05, 0x00, 0x1C, 0x03, 0x1E, 0x00, 0x2F, 0x06, 0x00, 0x00, 0x2A, 0x09, 0x02, 0x00, 0x33, 
  0x05, 0x09, 0x00, 0x1C, 0x05, 0x0A, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x33, 0x09, 0x06, 0x00, 0x19, 
  0x0A, 0x09, 0x00, 0x1C, 0x0A, 0x05, 0x00, 0x30, 0x0A, 0x07, 0x00, 0x43, 0x02, 0x00, 0x00, 0x1A, 
  0x16, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x1A, 0x10, 0x00, 0x00, 0x30, 0x00, 0x06, 0x00, 0x2A, 
  0x0A, 0x03, 0x00, 0x33, 0x09, 0x0A, 0x00, 0x2F, 0x09, 0x00, 0x00, 0x2A, 0x0B, 0x04, 0x00, 0x33, 
  0x0A, 0x0B, 0x00, 0x19, 0x09, 0x0A, 0x00, 0x2F, 0x09, 0x00, 0x00, 0x2A, 0x0B, 0x05, 0x00, 0x33, 
  0x0A, 0x0B, 0x00, 0x1C, 0x0A, 0x05, 0x00, 0x30, 0x09, 0x07, 0x00, 0x43, 0x02, 0x00, 0x00, 0x1A, 
  0x06, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x47, 
  0x04, 0x03, 0x04, 0x1A, 0xD4, 0xFF, 0xFF, 0x1C, 0x02, 0x02, 0x00, 0x03, 0x02, 0x00, 0x00, 0x2E, 
  0x03, 0x00, 0x00, 0x19, 0x04, 0x03, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x30, 0x04, 0x03, 0x00, 0x2A, 
  0x05, 0x06, 0x00, 0x33, 0x03, 0x05, 0x00, 0x2A, 0x05, 0x07, 0x00, 0x30, 0x05, 0x03, 0x00, 0x2A, 
  0x06, 0x08, 0x00, 0x33, 0x05, 0x06, 0x00, 0x19, 0x03, 0x05, 0x00, 0x2A, 0x05, 0x09, 0x00, 0x30, 
  0x05, 0x03, 0x00, 0x2A, 0x06, 0x0A, 0x00, 0x33, 0x05, 0x06, 0x00, 0x19, 0x06, 0x05, 0x00, 0x2A, 
  0x05, 0x0B, 0x00, 0x2A, 0x07, 0x0C, 0x00, 0x31, 0x05, 0x00, 0x07, 0x32, 0x06, 0x00, 0x00, 0x2A, 
  0x07, 0x04, 0x00, 0x33, 0x05, 0x07, 0x00, 0x26, 0x07, 0x00, 0x00, 0x30, 0x07, 0x05, 0x00, 0x43, 
  0x05, 0x00, 0x00, 0x03, 0x05, 0x00, 0x00, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x06, 0x01, 0x01, 0x01, 
  0x03, 0x15, 0x01, 0xDA, 0x05, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 0x02, 
  0x07, 0xCE, 0x07, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x3F, 0xDA, 0x05, 0xDA, 0x39, 0xDA, 0x73, 
  0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 
  0x2A, 0x04, 0x01, 0x00, 0x23, 0x03, 0x02, 0x04, 0x03, 0x03, 0x00, 0x00, 0x5A, 0x01, 0x00, 0x30, 
  0x00, 0x30, 0x00, 0x30, 0x00, 0x2D, 0x00, 0x2D, 0x00, 0x2D, 0xDA, 0x80, 0xB6, 0xDA, 0x80, 0xB7, 
  0x3B, 0x01, 0x00, 0x00, 0x19, 0x02, 0x01, 0x00, 0x3B, 0x01, 0x00, 0x01, 0x19, 0x03, 0x01, 0x00, 
  0x3B, 0x01, 0x00, 0x02, 0x19, 0x04, 0x01, 0x00, 0x2F, 0x02, 0x00, 0x00, 0x2A, 0x01, 0x00, 0x00, 
  0x33, 0x00, 0x01, 0x00, 0x1C, 0x00, 0x0B, 0x00, 0x2B, 0x01, 0x00, 0x00, 0x30, 0x04, 0x01, 0x00, 
  0x2A, 0x05, 0x01, 0x00, 0x33, 0x01, 0x05, 0x00, 0x1C, 0x01, 0x05, 0x00, 0x2B, 0x05, 0x00, 0x00, 
  0x30, 0x05, 0x02, 0x00, 0x2A, 0x05, 0x02, 0x00, 0x34, 0x05, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
  0x04, 0x00, 0x00, 0x00, 0xBF, 0xFF, 0x88, 0xE0, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 
  0x14, 0x00, 0x14, 0x01, 0x1C, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0x16, 0x01, 0x1E, 0x00, 0x1E, 0x00, 
  0x1E, 0x00, 0x1E, 0x00, 0x18, 0x01, 0x1A, 0x00, 0x1A, 0x00, 0x1A, 0x00, 0x1A, 0xBF, 0xFF, 0x18, 
  0xBF, 0xFF, 0x16, 0x88, 0xCD, 0x01, 0x06, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x01, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x05, 0x01, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 
  0x00, 0x07, 0x01, 0x18, 0x00, 0x18, 0x00, 0x09, 0x00, 0x09, 0x01, 0x14, 0x00, 0x14, 0x01, 0x0B, 
  0xBF, 0xFE, 0x09, 0xBF, 0xFF, 0x07, 0x05, 0x21, 0x00, 0x21, 0x00, 0x21, 0x00, 0x19, 0x00, 0x19, 
  0x00, 0x19, 0x00, 0x0B, 0x01, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x0B, 0x01, 0x16, 0x00, 0x16, 
  0x01, 0x0D, 0xBF, 0xFE, 0x0B, 0xBF, 0xF9, 0x05, 0xBF, 0xFF, 0x03, 0x00, 0x03, 0x00, 0x03, 0x0B, 
  0x03, 0x00, 0x03, 0x01, 0x14, 0x00, 0x05, 0x04, 0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 
  0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0xBF, 0xFC, 0x05, 0x05, 0x15, 0x00, 0x15, 0x00, 0x15, 
  0x00, 0x15, 0xBF, 0xFB, 0x05, 0x06, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 
  0x0C, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x01, 0x00, 0x00, 0x00, 0xD0, 0x05, 0x66, 
  0x72, 0x65, 0x73, 0x68, 0xDA, 0x80, 0x8B, 0xD3, 0x00, 0xCE, 0x14, 0x63, 0x69, 0x72, 0x63, 0x75, 
  0x6C, 0x61, 0x72, 0x20, 0x64, 0x65, 0x70, 0x65, 0x6E, 0x64, 0x65, 0x6E, 0x63, 0x79, 0x20, 0xCE, 
  0x09, 0x20, 0x64, 0x65, 0x74, 0x65, 0x63, 0x74, 0x65, 0x64, 0xDA, 0x6F, 0xDA, 0x4E, 0xD3, 0x03, 
  0xDA, 0x80, 0x9A, 0xD7, 0xCD, 0x00, 0x90, 0x00, 0x00, 0x06, 0x02, 0x02, 0x02, 0x02, 0x0C, 0xDA, 
  0x05, 0xDA, 0x80, 0xCD, 0xD7, 0xCD, 0x03, 0xBB, 0x00, 0x00, 0x19, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 
  0xFF, 0xFF, 0x14, 0x70, 0x04, 0xCE, 0x06, 0x64, 0x6F, 0x66, 0x69, 0x6C, 0x65, 0xDA, 0x05, 0xD0, 
  0x08, 0x65, 0x78, 0x70, 0x61, 0x6E, 0x64, 0x65, 0x72, 0xD0, 0x03, 0x65, 0x6E, 0x76, 0xD0, 0x04, 
  0x65, 0x78, 0x69, 0x74, 0xDA, 0x80, 0x9A, 0xD0, 0x09, 0x65, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 
  0x6F, 0x72, 0xDA, 0x39, 0xD0, 0x09, 0x63, 0x6F, 0x72, 0x65, 0x2F, 0x66, 0x69, 0x6C, 0x65, 0xD0, 
  0x02, 0x72, 0x62, 0xD8, 0x09, 0x66, 0x69, 0x6C, 0x65, 0x2F, 0x6F, 0x70, 0x65, 0x6E, 0xD7, 0xCD, 
  0x00, 0x98, 0x00, 0x00, 0x07, 0x01, 0x00, 0x01, 0x02, 0x0C, 0xCE, 0x08, 0x6D, 0x61, 0x6B, 0x65, 
  0x2D, 0x65, 0x6E, 0x76, 0xDA, 0x05, 0xDA, 0x00, 0xD8, 0x0E, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2F, 
  0x73, 0x65, 0x74, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0x2C, 0x01, 0x00, 0x00, 0x1C, 0x00, 0x03, 0x00, 
  0x19, 0x02, 0x00, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x19, 0x03, 0x02, 0x00, 
  0x42, 0x04, 0x00, 0x00, 0x30, 0x04, 0x03, 0x00, 0x2A, 0x06, 0x01, 0x00, 0x33, 0x05, 0x06, 0x00, 
  0x19, 0x04, 0x05, 0x00, 0x03, 0x04, 0x00, 0x00, 0x87, 0xAB, 0x01, 0x05, 0x0F, 0x00, 0x0F, 0x00, 
  0x0F, 0x00, 0x0F, 0x00, 0x03, 0x01, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x03, 0xBF, 
  0xFA, 0x01, 0xDA, 0x6F, 0xD0, 0x0C, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x2D, 0x66, 0x69, 
  0x6C, 0x65, 0xCE, 0x14, 0x63, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x66, 0x69, 
  0x6E, 0x64, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0xCE, 0x0B, 0x3C, 0x61, 0x6E, 0x6F, 0x6E, 0x79, 
  0x6D, 0x6F, 0x75, 0x73, 0x3E, 0xD0, 0x09, 0x6F, 0x6E, 0x2D, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 
  0xD0, 0x06, 0x63, 0x68, 0x75, 0x6E, 0x6B, 0x73, 0xD0, 0x0E, 0x6F, 0x6E, 0x2D, 0x70, 0x61, 0x72, 
  0x73, 0x65, 0x2D, 0x65, 0x72, 0x72, 0x6F, 0x72, 0xD0, 0x10, 0x6F, 0x6E, 0x2D, 0x63, 0x6F, 0x6D, 
  0x70, 0x69, 0x6C, 0x65, 0x2D, 0x65, 0x72, 0x72, 0x6F, 0x72, 0xD7, 0xCD, 0x02, 0xBA, 0x00, 0x00, 
  0x2C, 0x01, 0x01, 0x01, 0x1E, 0x80, 0xBB, 0x04, 0xCE, 0x0B, 0x72, 0x75, 0x6E, 0x2D, 0x63, 0x6F, 
  0x6E, 0x74, 0x65, 0x78, 0x74, 0xDA, 0x05, 0xDA, 0x80, 0xD3, 0xD0, 0x0B, 0x66, 0x69, 0x62, 0x65, 
  0x72, 0x2D, 0x66, 0x6C, 0x61, 0x67, 0x73, 0xDA, 0x80, 0xDF, 0xDA, 0x80, 0xD2, 0xDA, 0x80, 0xE0, 
  0xDA, 0x80, 0xE1, 0xDA, 0x80, 0x9A, 0xDA, 0x80, 0xE2, 0xDA, 0x80, 0xD5, 0xDA, 0x50, 0xDA, 0x51, 
  0xDA, 0x7F, 0xDA, 0x80, 0x85, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0F, 0x02, 0x02, 0x02, 0x0E, 
  0x2A, 0xCE, 0x09, 0x62, 0x61, 0x64, 0x2D, 0x70, 0x61, 0x72, 0x73, 0x65, 0xDA, 0x05, 0xDA, 0x7C, 
  0xDA, 0x7D, 0xD8, 0x0C, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x77, 0x68, 0x65, 0x72, 0x65, 
  0xDA, 0x80, 0x80, 0xDA, 0x67, 0xDA, 0x6F, 0xD8, 0x0C, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 
  0x65, 0x72, 0x72, 0x6F, 0x72, 0xDA, 0x80, 0x81, 0xCE, 0x0F, 0x70, 0x61, 0x72, 0x73, 0x65, 0x20, 
  0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x69, 0x6E, 0x20, 0xCE, 0x0D, 0x20, 0x61, 0x72, 0x6F, 0x75, 
  0x6E, 0x64, 0x20, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0xCE, 0x09, 0x2C, 0x20, 0x63, 0x6F, 0x6C, 0x75, 
  0x6D, 0x6E, 0x20, 0xCE, 0x02, 0x3A, 0x20, 0xDA, 0x80, 0x83, 0xDA, 0x80, 0x84, 0x2C, 0x02, 0x00, 
  0x00, 0x2A, 0x03, 0x00, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x33, 0x03, 0x04, 
  0x00, 0x19, 0x04, 0x03, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x06, 0x02, 0x00, 0x33, 0x05, 0x06, 
  0x00, 0x3B, 0x06, 0x05, 0x00, 0x19, 0x07, 0x06, 0x00, 0x3B, 0x06, 0x05, 0x01, 0x19, 0x08, 0x06, 
  0x00, 0x1C, 0x04, 0x03, 0x00, 0x2A, 0x06, 0x03, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x2A, 0x06, 0x04, 
  0x00, 0x2F, 0x07, 0x00, 0x00, 0x2A, 0x0A, 0x05, 0x00, 0x33, 0x09, 0x0A, 0x00, 0x2F, 0x08, 0x00, 
  0x00, 0x2A, 0x0B, 0x05, 0x00, 0x33, 0x0A, 0x0B, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x0C, 0x06, 
  0x00, 0x33, 0x0B, 0x0C, 0x00, 0x1C, 0x04, 0x03, 0x00, 0x2A, 0x0C, 0x07, 0x00, 0x1A, 0x02, 0x00, 
  0x00, 0x2A, 0x0C, 0x04, 0x00, 0x2A, 0x0D, 0x08, 0x00, 0x31, 0x06, 0x0D, 0x01, 0x2A, 0x0D, 0x09, 
  0x00, 0x2A, 0x0E, 0x0A, 0x00, 0x31, 0x0D, 0x09, 0x0E, 0x2A, 0x0D, 0x0B, 0x00, 0x31, 0x0A, 0x0D, 
  0x0B, 0x2F, 0x0C, 0x00, 0x00, 0x2A, 0x0E, 0x0C, 0x00, 0x33, 0x0D, 0x0E, 0x00, 0x2A, 0x06, 0x0D, 
  0x00, 0x34, 0x06, 0x00, 0x00, 0x87, 0xB4, 0x01, 0x03, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 
  0x00, 0x03, 0x01, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x02, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x04, 0x05, 0x00, 0x05, 0x00, 0x05, 0x02, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x02, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0xBF, 0xF6, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x0B, 0x03, 0x00, 0x03, 0xDA, 0x80, 0xDE, 0xD0, 0x03, 
  0x79, 0x64, 0x74, 0xD8, 0x0A, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x6E, 0x65, 0x77, 0xDA, 
  0x67, 0xDA, 0x80, 0xD4, 0xD8, 0x0C, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x63, 0x6C, 0x65, 
  0x61, 0x72, 0xD0, 0x06, 0x63, 0x61, 0x6E, 0x63, 0x65, 0x6C, 0xD8, 0x0C, 0x70, 0x61, 0x72, 0x73, 
  0x65, 0x72, 0x2F, 0x66, 0x6C, 0x75, 0x73, 0x68, 0xD8, 0x0A, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 
  0x2F, 0x65, 0x6F, 0x66, 0xD8, 0x0E, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x63, 0x6F, 0x6E, 
  0x73, 0x75, 0x6D, 0x65, 0xD8, 0x0F, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x68, 0x61, 0x73, 
  0x2D, 0x6D, 0x6F, 0x72, 0x65, 0xD8, 0x0E, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x70, 0x72, 
  0x6F, 0x64, 0x75, 0x63, 0x65, 0xD8, 0x0D, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x73, 0x74, 
  0x61, 0x74, 0x75, 0x73, 0xD0, 0x05, 0x65, 0x72, 0x72, 0x6F, 0x72, 0xD0, 0x0A, 0x65, 0x78, 0x69, 
  0x74, 0x2D, 0x76, 0x61, 0x6C, 0x75, 0x65, 0xD7, 0xCD, 0x00, 0x08, 0x00, 0x06, 0x04, 0x03, 0x02, 
  0x03, 0x00, 0x06, 0xCE, 0x02, 0x69, 0x6E, 0x38, 0x00, 0x00, 0x01, 0x26, 0x03, 0x00, 0x00, 0x23, 
  0x03, 0x00, 0x03, 0x1B, 0x03, 0x02, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x02, 0x00, 0x00, 0x2C, 
  0x01, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x38, 0x02, 0x00, 0x03, 0x19, 0x03, 0x02, 0x00, 0x2A, 
  0x04, 0x01, 0x00, 0x38, 0x02, 0x00, 0x04, 0x19, 0x04, 0x02, 0x00, 0x2A, 0x05, 0x02, 0x00, 0x38, 
  0x02, 0x00, 0x05, 0x19, 0x05, 0x02, 0x00, 0x2A, 0x06, 0x03, 0x00, 0x38, 0x02, 0x00, 0x06, 0x19, 
  0x06, 0x02, 0x00, 0x2A, 0x07, 0x04, 0x00, 0x38, 0x02, 0x00, 0x07, 0x19, 0x07, 0x02, 0x00, 0x2A, 
  0x08, 0x05, 0x00, 0x38, 0x02, 0x00, 0x08, 0x19, 0x08, 0x02, 0x00, 0x2A, 0x09, 0x06, 0x00, 0x38, 
  0x02, 0x00, 0x09, 0x19, 0x09, 0x02, 0x00, 0x2A, 0x0A, 0x07, 0x00, 0x38, 0x02, 0x00, 0x0A, 0x19, 
  0x0A, 0x02, 0x00, 0x2A, 0x0B, 0x08, 0x00, 0x38, 0x02, 0x00, 0x0B, 0x19, 0x0B, 0x02, 0x00, 0x26, 
  0x0D, 0x00, 0x00, 0x23, 0x0C, 0x0D, 0x03, 0x1C, 0x0C, 0x08, 0x00, 0x2A, 0x0E, 0x09, 0x00, 0x33, 
  0x0D, 0x0E, 0x00, 0x2F, 0x0D, 0x00, 0x00, 0x2A, 0x0F, 0x0A, 0x00, 0x33, 0x0E, 0x0F, 0x00, 0x19, 
  0x02, 0x0E, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x02, 0x03, 0x00, 0x19, 0x0C, 0x02, 0x00, 0x26, 
  0x0F, 0x00, 0x00, 0x23, 0x0E, 0x0F, 0x07, 0x1C, 0x0E, 0x04, 0x00, 0x2E, 0x0F, 0x00, 0x00, 0x19, 
  0x0D, 0x0F, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x0D, 0x07, 0x00, 0x19, 0x0E, 0x0D, 0x00, 0x26, 
  0x11, 0x00, 0x00, 0x23, 0x10, 0x11, 0x05, 0x1C, 0x10, 0x03, 0x00, 0x2A, 0x0F, 0x0B, 0x00, 0x1A, 
  0x02, 0x00, 0x00, 0x19, 0x0F, 0x05, 0x00, 0x19, 0x10, 0x0F, 0x00, 0x26, 0x13, 0x00, 0x00, 0x23, 
  0x12, 0x13, 0x0A, 0x1C, 0x12, 0x03, 0x00, 0x2A, 0x11, 0x0C, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 
  0x11, 0x0A, 0x00, 0x19, 0x12, 0x11, 0x00, 0x26, 0x15, 0x00, 0x00, 0x23, 0x14, 0x15, 0x08, 0x1C, 
  0x14, 0x03, 0x00, 0x2A, 0x13, 0x0D, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x13, 0x08, 0x00, 0x19, 
  0x14, 0x13, 0x00, 0x26, 0x17, 0x00, 0x00, 0x23, 0x16, 0x17, 0x0B, 0x1C, 0x16, 0x04, 0x00, 0x2E, 
  0x17, 0x01, 0x00, 0x19, 0x15, 0x17, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x15, 0x0B, 0x00, 0x19, 
  0x16, 0x15, 0x00, 0x26, 0x19, 0x00, 0x00, 0x23, 0x18, 0x19, 0x09, 0x1C, 0x18, 0x03, 0x00, 0x2A, 
  0x17, 0x0E, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x17, 0x09, 0x00, 0x19, 0x18, 0x17, 0x00, 0x26, 
  0x1B, 0x00, 0x00, 0x23, 0x1A, 0x1B, 0x04, 0x1C, 0x1A, 0x03, 0x00, 0x2A, 0x19, 0x0F, 0x00, 0x1A, 
  0x02, 0x00, 0x00, 0x19, 0x19, 0x04, 0x00, 0x19, 0x1A, 0x19, 0x00, 0x27, 0x1B, 0x00, 0x00, 0x2A, 
  0x1D, 0x10, 0x00, 0x33, 0x1C, 0x1D, 0x00, 0x19, 0x1D, 0x1C, 0x00, 0x2E, 0x1E, 0x02, 0x00, 0x19, 
  0x1F, 0x1E, 0x00, 0x2E, 0x20, 0x03, 0x00, 0x19, 0x21, 0x20, 0x00, 0x2A, 0x22, 0x11, 0x00, 0x2F, 
  0x22, 0x00, 0x00, 0x3F, 0x22, 0x00, 0x00, 0x19, 0x23, 0x22, 0x00, 0x1C, 0x1B, 0x3D, 0x00, 0x2A, 
  0x24, 0x12, 0x00, 0x2F, 0x24, 0x00, 0x00, 0x33, 0x24, 0x0C, 0x00, 0x1C, 0x24, 0x03, 0x00, 0x1A, 
  0x38, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x2F, 0x23, 0x00, 0x00, 0x2A, 0x25, 0x13, 0x00, 0x33, 
  0x24, 0x25, 0x00, 0x30, 0x23, 0x1D, 0x00, 0x33, 0x24, 0x0E, 0x00, 0x2A, 0x26, 0x14, 0x00, 0x23, 
  0x25, 0x24, 0x26, 0x1C, 0x25, 0x08, 0x00, 0x2F, 0x1D, 0x00, 0x00, 0x2A, 0x26, 0x15, 0x00, 0x33, 
  0x24, 0x26, 0x00, 0x2F, 0x23, 0x00, 0x00, 0x2A, 0x26, 0x13, 0x00, 0x33, 0x24, 0x26, 0x00, 0x1A, 
  0x27, 0x00, 0x00, 0x29, 0x24, 0x00, 0x00, 0x26, 0x26, 0x00, 0x00, 0x3D, 0x27, 0x23, 0x00, 0x19, 
  0x28, 0x27, 0x00, 0x29, 0x29, 0x00, 0x00, 0x23, 0x27, 0x28, 0x29, 0x1C, 0x27, 0x06, 0x00, 0x2F, 
  0x1D, 0x00, 0x00, 0x2A, 0x2A, 0x16, 0x00, 0x33, 0x29, 0x2A, 0x00, 0x28, 0x1B, 0x00, 0x00, 0x1A, 
  0x01, 0x00, 0x00, 0x1F, 0x27, 0x28, 0x24, 0x1C, 0x27, 0x19, 0x00, 0x31, 0x1D, 0x23, 0x24, 0x2A, 
  0x2A, 0x17, 0x00, 0x33, 0x29, 0x2A, 0x00, 0x06, 0x24, 0x24, 0x29, 0x2F, 0x1D, 0x00, 0x00, 0x2A, 
  0x2A, 0x18, 0x00, 0x33, 0x29, 0x2A, 0x00, 0x1C, 0x29, 0x07, 0x00, 0x2F, 0x1D, 0x00, 0x00, 0x2A, 
  0x2B, 0x19, 0x00, 0x33, 0x2A, 0x2B, 0x00, 0x2F, 0x2A, 0x00, 0x00, 0x33, 0x2B, 0x1F, 0x00, 0x1A, 
  0xF7, 0xFF, 0xFF, 0x2F, 0x1D, 0x00, 0x00, 0x2A, 0x2A, 0x1A, 0x00, 0x33, 0x29, 0x2A, 0x00, 0x2A, 
  0x2B, 0x1B, 0x00, 0x23, 0x2A, 0x29, 0x2B, 0x1C, 0x2A, 0x04, 0x00, 0x30, 0x1D, 0x18, 0x00, 0x33, 
  0x29, 0x21, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x1A, 0xE7, 0xFF, 0xFF, 0x1A, 0xC4, 0xFF, 0xFF, 0x2F, 
  0x1D, 0x00, 0x00, 0x2A, 0x25, 0x18, 0x00, 0x33, 0x24, 0x25, 0x00, 0x1C, 0x24, 0x07, 0x00, 0x2F, 
  0x1D, 0x00, 0x00, 0x2A, 0x26, 0x19, 0x00, 0x33, 0x25, 0x26, 0x00, 0x2F, 0x25, 0x00, 0x00, 0x33, 
  0x26, 0x1F, 0x00, 0x1A, 0xF7, 0xFF, 0xFF, 0x2F, 0x1D, 0x00, 0x00, 0x2A, 0x25, 0x1A, 0x00, 0x33, 
  0x24, 0x25, 0x00, 0x2A, 0x26, 0x1B, 0x00, 0x23, 0x25, 0x24, 0x26, 0x1C, 0x25, 0x04, 0x00, 0x30, 
  0x1D, 0x18, 0x00, 0x33, 0x24, 0x21, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x2A, 0x24, 0x1C, 0x00, 0x31, 
  0x0C, 0x24, 0x0C, 0x2A, 0x24, 0x1D, 0x00, 0x34, 0x24, 0x00, 0x00, 0xCD, 0x00, 0xD0, 0x00, 0x00, 
  0x04, 0x02, 0x02, 0x02, 0x02, 0x05, 0x01, 0xDA, 0x05, 0xDA, 0x67, 0xD8, 0x07, 0x67, 0x65, 0x74, 
  0x6C, 0x69, 0x6E, 0x65, 0x2A, 0x02, 0x00, 0x00, 0x2B, 0x03, 0x00, 0x0C, 0x31, 0x02, 0x00, 0x03, 
  0x2A, 0x02, 0x01, 0x00, 0x34, 0x02, 0x00, 0x00, 0xBF, 0xFF, 0x87, 0xEF, 0x1F, 0x00, 0x1F, 0x00, 
  0x1F, 0x00, 0x1F, 0x00, 0x1F, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x02, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 
  0xFF, 0xFF, 0x00, 0x02, 0xCE, 0x08, 0x65, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0xDA, 0x05, 
  0x2C, 0x01, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x87, 0xF3, 0x16, 0x00, 0x29, 0xCD, 0x02, 0xFA, 
  0x00, 0x00, 0x0C, 0x01, 0x01, 0x01, 0x03, 0x26, 0x01, 0x01, 0xCE, 0x05, 0x65, 0x76, 0x61, 0x6C, 
  0x31, 0xDA, 0x05, 0xDA, 0x24, 0xD8, 0x0C, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2F, 0x73, 0x65, 0x74, 
  0x65, 0x6E, 0x76, 0xD8, 0x11, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2F, 0x63, 0x61, 0x6E, 0x2D, 0x72, 
  0x65, 0x73, 0x75, 0x6D, 0x65, 0x3F, 0x2C, 0x01, 0x00, 0x00, 0x2B, 0x03, 0x00, 0x06, 0x1C, 0x03, 
  0x06, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2B, 0x04, 0x00, 0x06, 0x33, 0x03, 0x04, 0x00, 0x19, 0x02, 
  0x03, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x02, 0x00, 0x00, 0x19, 0x03, 0x02, 0x00, 0x27, 0x04, 
  0x00, 0x00, 0x26, 0x05, 0x00, 0x00, 0x2E, 0x06, 0x00, 0x00, 0x2B, 0x07, 0x00, 0x1A, 0x30, 0x06, 
  0x07, 0x00, 0x2A, 0x08, 0x00, 0x00, 0x33, 0x07, 0x08, 0x00, 0x19, 0x06, 0x07, 0x00, 0x2B, 0x08, 
  0x00, 0x0C, 0x30, 0x06, 0x08, 0x00, 0x2A, 0x09, 0x01, 0x00, 0x33, 0x08, 0x09, 0x00, 0x2F, 0x06, 
  0x00, 0x00, 0x2A, 0x0A, 0x02, 0x00, 0x33, 0x09, 0x0A, 0x00, 0x1C, 0x09, 0x0C, 0x00, 0x35, 0x0A, 
  0x06, 0x05, 0x19, 0x0B, 0x0A, 0x00, 0x1C, 0x04, 0x08, 0x00, 0x2B, 0x0A, 0x00, 0x1B, 0x1C, 0x0A, 
  0x05, 0x00, 0x30, 0x06, 0x0B, 0x00, 0x2B, 0x0A, 0x00, 0x10, 0x33, 0x05, 0x0A, 0x00, 0x1A, 0x01, 
  0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x1A, 0xF2, 0xFF, 0xFF, 0x04, 0x00, 0x00, 0x00, 0xBF, 0xFF, 
  0xCD, 0x00, 0xD0, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x0A, 0x33, 0x02, 0xDA, 0x05, 0xD8, 0x07, 
  0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0xDA, 0x39, 0xDA, 0x78, 0xD0, 0x04, 0x6C, 0x69, 0x6E, 
  0x65, 0xD0, 0x05, 0x66, 0x69, 0x62, 0x65, 0x72, 0xDA, 0x80, 0xF7, 0xD0, 0x06, 0x63, 0x6F, 0x6C, 
  0x75, 0x6D, 0x6E, 0xCE, 0x09, 0x20, 0x6F, 0x6E, 0x20, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0xDA, 0x80, 
  0xEA, 0xDA, 0x6F, 0x2B, 0x00, 0x00, 0x03, 0x2B, 0x01, 0x01, 0x0C, 0x2B, 0x02, 0x01, 0x18, 0x31, 
  0x00, 0x01, 0x02, 0x2A, 0x01, 0x00, 0x00, 0x33, 0x00, 0x01, 0x00, 0x19, 0x01, 0x00, 0x00, 0x2F, 
  0x01, 0x00, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2A, 0x04, 0x02, 0x00, 0x23, 
  0x03, 0x02, 0x04, 0x1C, 0x03, 0x08, 0x00, 0x2B, 0x02, 0x00, 0x03, 0x2B, 0x04, 0x01, 0x0C, 0x31, 
  0x01, 0x02, 0x04, 0x2B, 0x02, 0x01, 0x18, 0x2F, 0x02, 0x00, 0x00, 0x2B, 0x02, 0x01, 0x16, 0x34, 
  0x02, 0x00, 0x00, 0x28, 0x02, 0x00, 0x00, 0x2D, 0x02, 0x00, 0x04, 0x2A, 0x04, 0x03, 0x00, 0x38, 
  0x02, 0x01, 0x04, 0x19, 0x04, 0x02, 0x00, 0x2A, 0x05, 0x04, 0x00, 0x38, 0x02, 0x01, 0x05, 0x19, 
  0x05, 0x02, 0x00, 0x2A, 0x06, 0x05, 0x00, 0x38, 0x02, 0x01, 0x06, 0x19, 0x06, 0x02, 0x00, 0x2A, 
  0x07, 0x06, 0x00, 0x38, 0x02, 0x01, 0x07, 0x19, 0x07, 0x02, 0x00, 0x29, 0x09, 0x00, 0x00, 0x46, 
  0x08, 0x09, 0x04, 0x1C, 0x08, 0x09, 0x00, 0x2A, 0x09, 0x07, 0x00, 0x31, 0x06, 0x09, 0x04, 0x2A, 
  0x09, 0x08, 0x00, 0x30, 0x09, 0x07, 0x00, 0x2A, 0x0A, 0x09, 0x00, 0x33, 0x09, 0x0A, 0x00, 0x19, 
  0x02, 0x09, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x02, 0x06, 0x00, 0x19, 0x08, 0x02, 0x00, 0x2B, 
  0x02, 0x01, 0x18, 0x31, 0x08, 0x05, 0x02, 0x2B, 0x02, 0x01, 0x12, 0x34, 0x02, 0x00, 0x00, 0xBF, 
  0xFF, 0x00, 0x88, 0x05, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 
  0x0B, 0x01, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0B, 0x01, 0x0D, 0x00, 
  0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x02, 0x0F, 0x00, 0x0F, 0x01, 
  0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 
  0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x02, 0x15, 0x00, 0x15, 0x00, 0x11, 0x01, 0x13, 0x00, 
  0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0xBF, 0xFF, 0x11, 0x00, 0x11, 0x00, 0x11, 
  0xBF, 0xFF, 0x0F, 0x04, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x87, 0xFE, 0x03, 0x01, 0x11, 
  0x00, 0x11, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x05, 
  0x01, 0x05, 0x01, 0x05, 0x03, 0x09, 0xBF, 0xFF, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 
  0xFF, 0x05, 0x0F, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 
  0x00, 0x05, 0x01, 0x10, 0x00, 0x07, 0x01, 0x07, 0x00, 0x12, 0x00, 0x12, 0x00, 0x2D, 0x00, 0x2D, 
  0x00, 0x2D, 0x00, 0x12, 0x00, 0x07, 0xBF, 0xFE, 0x05, 0x00, 0x05, 0x18, 0x00, 0x00, 0x00, 0xCD, 
  0x02, 0xFA, 0x00, 0x00, 0x08, 0x02, 0x02, 0x02, 0x03, 0x0E, 0x01, 0x01, 0xCE, 0x09, 0x70, 0x61, 
  0x72, 0x73, 0x65, 0x2D, 0x65, 0x72, 0x72, 0xDA, 0x05, 0xD0, 0x02, 0x79, 0x69, 0xDA, 0x24, 0xDA, 
  0x80, 0xFE, 0x2C, 0x02, 0x00, 0x00, 0x2E, 0x03, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x30, 0x03, 
  0x04, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x33, 0x04, 0x05, 0x00, 0x19, 0x03, 0x04, 0x00, 0x2B, 0x05, 
  0x00, 0x0C, 0x30, 0x03, 0x05, 0x00, 0x2A, 0x06, 0x02, 0x00, 0x33, 0x05, 0x06, 0x00, 0x26, 0x07, 
  0x00, 0x00, 0x35, 0x06, 0x03, 0x07, 0x03, 0x06, 0x00, 0x00, 0xBF, 0xFF, 0xCD, 0x00, 0xD0, 0x00, 
  0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x05, 0x02, 0xDA, 0x05, 0x2B, 0x00, 0x01, 0x00, 0x2B, 0x01, 
  0x01, 0x01, 0x30, 0x00, 0x01, 0x00, 0x2B, 0x00, 0x00, 0x14, 0x34, 0x00, 0x00, 0x00, 0x00, 0xBF, 
  0xFF, 0x88, 0x19, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x88, 0x16, 0x03, 0x03, 
  0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x03, 0x00, 0x00, 0x00, 0x87, 0xD5, 0x01, 
  0x10, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x09, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x1E, 0x00, 0x1E, 
  0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x13, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x16, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x03, 0x03, 0x03, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x03, 0x03, 0x00, 0x03, 
  0x18, 0x03, 0x00, 0x03, 0x08, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x03, 0x01, 0x09, 
  0x00, 0x09, 0x00, 0x09, 0x00, 0x05, 0x00, 0x15, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x01, 0x0C, 0x00, 0x0C, 0x00, 0x09, 0x00, 0x09, 0x00, 0x05, 0x04, 0x09, 0x00, 0x09, 0x00, 0x09, 
  0x01, 0x09, 0x00, 0x09, 0x00, 0x09, 0xBF, 0xFB, 0x05, 0x07, 0x09, 0x01, 0x09, 0x01, 0x12, 0x00, 
  0x09, 0x01, 0x0F, 0x00, 0x0F, 0x00, 0x09, 0x01, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x01, 0x0B, 0xBF, 
  0xFE, 0x09, 0x03, 0x10, 0x00, 0x09, 0x01, 0x16, 0x00, 0x16, 0x00, 0x16, 0x00, 0x0B, 0x01, 0x12, 
  0x00, 0x12, 0x00, 0x12, 0x00, 0x0B, 0x01, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x0D, 0x00, 0x0D, 
  0xBF, 0xFF, 0x0B, 0x02, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x11, 0x00, 0x11, 0x00, 0x0B, 0x01, 
  0x0D, 0x00, 0x0D, 0xBF, 0xFF, 0x0B, 0xBF, 0xFC, 0x09, 0xBF, 0xF0, 0x03, 0x18, 0x0A, 0x00, 0x0A, 
  0x00, 0x0A, 0x00, 0x03, 0x01, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x05, 0x00, 0x05, 0xBF, 0xFF, 
  0x03, 0x02, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x09, 0x00, 0x09, 0x00, 0x03, 0x01, 0x05, 0x00, 
  0x05, 0xBF, 0xFF, 0x03, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x40, 0x10, 0x55, 0x0D, 
  0x00, 0x00, 0x00, 0x00, 0xD8, 0x0A, 0x66, 0x69, 0x6C, 0x65, 0x2F, 0x63, 0x6C, 0x6F, 0x73, 0x65, 
  0x2A, 0x03, 0x00, 0x00, 0x38, 0x02, 0x01, 0x03, 0x19, 0x03, 0x02, 0x00, 0x2A, 0x04, 0x01, 0x00, 
  0x38, 0x02, 0x01, 0x04, 0x19, 0x04, 0x02, 0x00, 0x2A, 0x05, 0x02, 0x00, 0x38, 0x02, 0x01, 0x05, 
  0x19, 0x05, 0x02, 0x00, 0x2A, 0x06, 0x03, 0x00, 0x38, 0x02, 0x01, 0x06, 0x19, 0x06, 0x02, 0x00, 
  0x2A, 0x07, 0x04, 0x00, 0x38, 0x02, 0x01, 0x07, 0x19, 0x07, 0x02, 0x00, 0x2C, 0x01, 0x00, 0x00, 
  0x2F, 0x00, 0x00, 0x00, 0x2A, 0x09, 0x05, 0x00, 0x33, 0x08, 0x09, 0x00, 0x2A, 0x0A, 0x06, 0x00, 
  0x23, 0x09, 0x08, 0x0A, 0x1C, 0x09, 0x03, 0x00, 0x19, 0x02, 0x00, 0x00, 0x1A, 0x06, 0x00, 0x00, 
  0x2A, 0x08, 0x07, 0x00, 0x30, 0x00, 0x08, 0x00, 0x2A, 0x0A, 0x08, 0x00, 0x33, 0x08, 0x0A, 0x00, 
  0x19, 0x02, 0x08, 0x00, 0x19, 0x08, 0x02, 0x00, 0x23, 0x09, 0x08, 0x00, 0x19, 0x0A, 0x09, 0x00, 
  0x26, 0x0D, 0x00, 0x00, 0x23, 0x0C, 0x0D, 0x04, 0x1C, 0x0C, 0x05, 0x00, 0x2A, 0x0E, 0x09, 0x00, 
  0x33, 0x0D, 0x0E, 0x00, 0x19, 0x0B, 0x0D, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x0B, 0x04, 0x00, 
  0x19, 0x0C, 0x0B, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x0E, 0x0A, 0x00, 0x33, 0x0D, 0x0E, 0x00, 
  0x19, 0x0E, 0x0D, 0x00, 0x1C, 0x06, 0x03, 0x00, 0x19, 0x0F, 0x06, 0x00, 0x1A, 0x06, 0x00, 0x00, 
  0x1C, 0x0A, 0x03, 0x00, 0x26, 0x10, 0x00, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x10, 0x0E, 0x00, 
  0x19, 0x0F, 0x10, 0x00, 0x2A, 0x10, 0x0B, 0x00, 0x3A, 0x0C, 0x10, 0x0F, 0x1C, 0x06, 0x03, 0x00, 
  0x19, 0x0F, 0x06, 0x00, 0x1A, 0x06, 0x00, 0x00, 0x1C, 0x0A, 0x03, 0x00, 0x19, 0x10, 0x00, 0x00, 
  0x1A, 0x02, 0x00, 0x00, 0x19, 0x10, 0x0E, 0x00, 0x19, 0x0F, 0x10, 0x00, 0x2A, 0x10, 0x03, 0x00, 
  0x3A, 0x0C, 0x10, 0x0F, 0x2E, 0x0F, 0x00, 0x00, 0x19, 0x10, 0x0F, 0x00, 0x2E, 0x11, 0x01, 0x00, 
  0x19, 0x12, 0x11, 0x00, 0x2E, 0x13, 0x02, 0x00, 0x19, 0x14, 0x13, 0x00, 0x1C, 0x08, 0x02, 0x00, 
  0x1A, 0x06, 0x00, 0x00, 0x2A, 0x15, 0x0C, 0x00, 0x30, 0x15, 0x00, 0x00, 0x2A, 0x16, 0x0A, 0x00, 
  0x33, 0x15, 0x16, 0x00, 0x01, 0x15, 0x00, 0x00, 0x2E, 0x15, 0x03, 0x00, 0x1C, 0x06, 0x03, 0x00, 
  0x19, 0x16, 0x06, 0x00, 0x1A, 0x06, 0x00, 0x00, 0x1C, 0x0A, 0x03, 0x00, 0x2A, 0x17, 0x0D, 0x00, 
  0x1A, 0x02, 0x00, 0x00, 0x19, 0x17, 0x0E, 0x00, 0x19, 0x16, 0x17, 0x00, 0x2A, 0x17, 0x01, 0x00, 
  0x2A, 0x18, 0x0E, 0x00, 0x31, 0x17, 0x0C, 0x18, 0x2A, 0x17, 0x00, 0x00, 0x31, 0x15, 0x17, 0x03, 
  0x2A, 0x17, 0x0F, 0x00, 0x2A, 0x18, 0x10, 0x00, 0x31, 0x17, 0x10, 0x18, 0x2A, 0x17, 0x03, 0x00, 
  0x31, 0x12, 0x17, 0x16, 0x2A, 0x17, 0x11, 0x00, 0x2A, 0x18, 0x04, 0x00, 0x31, 0x17, 0x14, 0x18, 
  0x2F, 0x07, 0x00, 0x00, 0x41, 0x15, 0x00, 0x00, 0x2F, 0x15, 0x00, 0x00, 0x2A, 0x17, 0x12, 0x00, 
  0x33, 0x16, 0x17, 0x00, 0x19, 0x15, 0x16, 0x00, 0x1C, 0x0A, 0x02, 0x00, 0x1A, 0x04, 0x00, 0x00, 
  0x2F, 0x08, 0x00, 0x00, 0x2A, 0x18, 0x13, 0x00, 0x33, 0x17, 0x18, 0x00, 0x03, 0x15, 0x00, 0x00, 
  0xCD, 0x00, 0xD8, 0x00, 0x00, 0x05, 0x02, 0x02, 0x02, 0x01, 0x06, 0x01, 0xCE, 0x06, 0x63, 0x68, 
  0x75, 0x6E, 0x6B, 0x73, 0xDA, 0x05, 0xD8, 0x09, 0x66, 0x69, 0x6C, 0x65, 0x2F, 0x72, 0x65, 0x61, 
  0x64, 0x2C, 0x02, 0x00, 0x00, 0x2B, 0x03, 0x00, 0x08, 0x29, 0x04, 0x00, 0x08, 0x31, 0x03, 0x04, 
  0x00, 0x2A, 0x03, 0x00, 0x00, 0x34, 0x03, 0x00, 0x00, 0xBF, 0xFF, 0x89, 0x09, 0x03, 0x00, 0x18, 
  0x00, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x18, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x07, 0x02, 0x00, 
  0x02, 0x02, 0x0D, 0x01, 0xCE, 0x02, 0x62, 0x70, 0xDA, 0x05, 0xDA, 0x80, 0xEC, 0xD8, 0x07, 0x6F, 
  0x73, 0x2F, 0x65, 0x78, 0x69, 0x74, 0x2C, 0x02, 0x00, 0x00, 0x30, 0x00, 0x01, 0x00, 0x2A, 0x04, 
  0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x04, 0x03, 0x00, 0x2B, 0x05, 0x00, 0x05, 0x1C, 0x05, 
  0x06, 0x00, 0x29, 0x05, 0x01, 0x00, 0x2F, 0x05, 0x00, 0x00, 0x2A, 0x06, 0x01, 0x00, 0x33, 0x05, 
  0x06, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x03, 0x04, 0x00, 0x00, 0xBF, 0xFF, 0x89, 0x0A, 0x03, 0x01, 
  0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 0x00, 0x0E, 0x00, 0x0E, 0x00, 
  0x0E, 0x00, 0x0E, 0x00, 0x05, 0xBF, 0xFE, 0x03, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x08, 0x03, 0x00, 
  0x03, 0x02, 0x0D, 0x01, 0xCE, 0x02, 0x62, 0x63, 0xDA, 0x05, 0xDA, 0x80, 0x85, 0xDA, 0x81, 0x0C, 
  0x2C, 0x03, 0x00, 0x00, 0x31, 0x00, 0x01, 0x02, 0x2A, 0x05, 0x00, 0x00, 0x33, 0x04, 0x05, 0x00, 
  0x19, 0x05, 0x04, 0x00, 0x2B, 0x06, 0x00, 0x05, 0x1C, 0x06, 0x06, 0x00, 0x29, 0x06, 0x01, 0x00, 
  0x2F, 0x06, 0x00, 0x00, 0x2A, 0x07, 0x01, 0x00, 0x33, 0x06, 0x07, 0x00, 0x1A, 0x01, 0x00, 0x00, 
  0x03, 0x05, 0x00, 0x00, 0xBF, 0xFF, 0x89, 0x0E, 0x03, 0x01, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 
  0x05, 0x01, 0x05, 0x00, 0x05, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x05, 0xBF, 
  0xFE, 0x03, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x05, 0x02, 0x02, 0x02, 0x05, 0x16, 0x01, 0xDA, 0x05, 
  0xDA, 0x29, 0xDA, 0x2B, 0xDA, 0x7F, 0xDA, 0x81, 0x0C, 0xDA, 0x80, 0x84, 0x2F, 0x00, 0x00, 0x00, 
  0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x23, 0x03, 0x02, 0x04, 
  0x1B, 0x03, 0x03, 0x00, 0x27, 0x03, 0x00, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x28, 0x03, 0x00, 0x00, 
  0x1C, 0x03, 0x0C, 0x00, 0x30, 0x00, 0x01, 0x00, 0x2A, 0x04, 0x02, 0x00, 0x33, 0x02, 0x04, 0x00, 
  0x2B, 0x02, 0x00, 0x05, 0x1C, 0x02, 0x05, 0x00, 0x29, 0x02, 0x01, 0x00, 0x2F, 0x02, 0x00, 0x00, 
  0x2A, 0x02, 0x03, 0x00, 0x34, 0x02, 0x00, 0x00, 0x2A, 0x02, 0x04, 0x00, 0x34, 0x02, 0x00, 0x00, 
  0x04, 0x00, 0x00, 0x00, 0xBF, 0xFF, 0x89, 0x1A, 0x2C, 0x00, 0x2C, 0x00, 0x2C, 0x00, 0x26, 0x00, 
  0x26, 0x00, 0x26, 0x00, 0x26, 0x00, 0x26, 0x00, 0x26, 0x00, 0x20, 0x01, 0x22, 0x00, 0x22, 0x00, 
  0x22, 0x01, 0x22, 0x00, 0x22, 0x00, 0x2B, 0x00, 0x2B, 0x00, 0x2B, 0x00, 0x2B, 0x00, 0x37, 0x00, 
  0x37, 0xBF, 0xFE, 0x20, 0x88, 0xF6, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 
  0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 
  0x01, 0x00, 0x01, 0x00, 0x01, 0x0B, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x0E, 0x00, 0x0E, 0x00, 
  0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x02, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0xBF, 0xFE, 0x0A, 
  0x00, 0x03, 0x03, 0x15, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x10, 0x00, 0x10, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x03, 
  0x01, 0x1A, 0x00, 0x1A, 0x00, 0x1A, 0x00, 0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x1A, 
  0x00, 0x03, 0x00, 0x03, 0x01, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0x1C, 
  0x00, 0x1C, 0x00, 0x14, 0x00, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 
  0x04, 0x03, 0x00, 0x03, 0x04, 0x03, 0x00, 0x03, 0x01, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 
  0x00, 0x05, 0x06, 0x1E, 0x06, 0x1B, 0x00, 0x1B, 0x00, 0x1B, 0x00, 0x23, 0x00, 0x23, 0x00, 0x23, 
  0x00, 0x23, 0x00, 0x1B, 0xBF, 0xF6, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xBF, 0xFF, 0x03, 0x0C, 0x03, 0x00, 0x03, 
  0x00, 0x18, 0x00, 0x18, 0x00, 0x18, 0xBF, 0xD6, 0x01, 0x20, 0x01, 0x00, 0x00, 0x2A, 0x02, 0x00, 
  0x00, 0x27, 0x03, 0x00, 0x00, 0x3A, 0x02, 0x00, 0x03, 0x2F, 0x00, 0x00, 0x00, 0x32, 0x01, 0x00, 
  0x00, 0x2A, 0x03, 0x01, 0x00, 0x33, 0x02, 0x03, 0x00, 0x19, 0x03, 0x02, 0x00, 0x2A, 0x04, 0x00, 
  0x00, 0x26, 0x05, 0x00, 0x00, 0x3A, 0x04, 0x00, 0x05, 0x03, 0x03, 0x00, 0x00, 0x89, 0x29, 0x0F, 
  0x00, 0x0F, 0x00, 0x0F, 0x01, 0x1B, 0x00, 0x1B, 0x00, 0x1B, 0x00, 0x1B, 0x00, 0x0F, 0x01, 0x0F, 
  0x00, 0x0F, 0x00, 0x0F, 0xBF, 0xFD, 0x0D, 0xDA, 0x80, 0x9F, 0xD7, 0xCD, 0x00, 0x90, 0x00, 0x00, 
  0x03, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x02, 0x05, 0xDA, 0x05, 0xDA, 0x80, 0xDB, 0xD8, 
  0x06, 0x6E, 0x61, 0x74, 0x69, 0x76, 0x65, 0x2A, 0x02, 0x00, 0x00, 0x33, 0x01, 0x02, 0x00, 0x30, 
  0x00, 0x01, 0x00, 0x2A, 0x02, 0x01, 0x00, 0x34, 0x02, 0x00, 0x00, 0x89, 0x27, 0x27, 0x00, 0x27, 
  0x00, 0x1A, 0x00, 0x1A, 0x00, 0x1A, 0xDA, 0x80, 0x93, 0xD7, 0xCD, 0x00, 0x90, 0x00, 0x00, 0x03, 
  0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x02, 0x06, 0xDA, 0x05, 0xD7, 0xCD, 0x00, 0x98, 0x00, 
  0x00, 0x08, 0x01, 0x01, 0x01, 0x07, 0x16, 0xCE, 0x05, 0x73, 0x6C, 0x75, 0x72, 0x70, 0xDA, 0x05, 
  0xDA, 0x80, 0xD7, 0xDA, 0x80, 0xD8, 0xCE, 0x14, 0x63, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x6E, 0x6F, 
  0x74, 0x20, 0x6F, 0x70, 0x65, 0x6E, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0xDA, 0x6F, 0xD0, 0x03, 
  0x61, 0x6C, 0x6C, 0xDA, 0x81, 0x0A, 0xDA, 0x81, 0x08, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x02, 0x00, 
  0x00, 0x30, 0x00, 0x02, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x33, 0x02, 0x03, 0x00, 0x19, 0x03, 0x02, 
  0x00, 0x1C, 0x03, 0x02, 0x00, 0x1A, 0x06, 0x00, 0x00, 0x2A, 0x04, 0x02, 0x00, 0x30, 0x04, 0x00, 
  0x00, 0x2A, 0x05, 0x03, 0x00, 0x33, 0x04, 0x05, 0x00, 0x01, 0x04, 0x00, 0x00, 0x2A, 0x04, 0x04, 
  0x00, 0x30, 0x03, 0x04, 0x00, 0x2A, 0x05, 0x05, 0x00, 0x33, 0x04, 0x05, 0x00, 0x19, 0x05, 0x04, 
  0x00, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x07, 0x06, 0x00, 0x33, 0x06, 0x07, 0x00, 0x03, 0x05, 0x00, 
  0x00, 0x85, 0x90, 0x01, 0x04, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x03, 
  0x00, 0x03, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x0D, 0x01, 0x11, 0x00, 0x11, 
  0x00, 0x11, 0x00, 0x11, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0xBF, 0xF9, 0x01, 0xD7, 
  0xCD, 0x00, 0x98, 0x00, 0x00, 0x03, 0x01, 0x01, 0x01, 0x02, 0x05, 0xCE, 0x0A, 0x6C, 0x6F, 0x61, 
  0x64, 0x2D, 0x69, 0x6D, 0x61, 0x67, 0x65, 0xDA, 0x05, 0xD3, 0x81, 0xE1, 0xDA, 0x01, 0xDA, 0x08, 
  0xDA, 0x0D, 0xDA, 0x0F, 0xDA, 0x11, 0xDA, 0x13, 0xDA, 0x15, 0xDA, 0x17, 0xDA, 0x19, 0xDA, 0x1B, 
  0xDA, 0x1D, 0xDA, 0x32, 0xDA, 0x36, 0xDA, 0x3B, 0xDA, 0x3E, 0xD7, 0xDC, 0x06, 0xCF, 0x0A, 0x74, 
  0x61, 0x6B, 0x65, 0x2D, 0x75, 0x6E, 0x74, 0x69, 0x6C, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0E, 
  0x02, 0x02, 0x02, 0x05, 0x1B, 0xCE, 0x0A, 0x74, 0x61, 0x6B, 0x65, 0x2D, 0x75, 0x6E, 0x74, 0x69, 
  0x6C, 0xDA, 0x05, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x09, 0x01, 0x01, 0x01, 0x05, 0x17, 0xCE, 
  0x06, 0x62, 0x79, 0x74, 0x65, 0x73, 0x3F, 0xDA, 0x05, 0xDA, 0x39, 0xDA, 0x73, 0xD0, 0x06, 0x73, 
  0x79, 0x6D, 0x62, 0x6F, 0x6C, 0xDA, 0x4D, 0xD0, 0x06, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2C, 
  0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x19, 
  0x03, 0x02, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x23, 0x04, 0x03, 0x05, 0x1C, 0x04, 0x03, 0x00, 0x27, 
  0x05, 0x00, 0x00, 0x03, 0x05, 0x00, 0x00, 0x2A, 0x06, 0x02, 0x00, 0x23, 0x05, 0x03, 0x06, 0x1C, 
  0x05, 0x03, 0x00, 0x27, 0x06, 0x00, 0x00, 0x03, 0x06, 0x00, 0x00, 0x2A, 0x07, 0x03, 0x00, 0x23, 
  0x06, 0x03, 0x07, 0x1C, 0x06, 0x03, 0x00, 0x27, 0x07, 0x00, 0x00, 0x03, 0x07, 0x00, 0x00, 0x2A, 
  0x08, 0x04, 0x00, 0x23, 0x07, 0x03, 0x08, 0x03, 0x07, 0x00, 0x00, 0x66, 0x01, 0x01, 0x0A, 0x00, 
  0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x07, 0x00, 0x07, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x1E, 0x00, 0x1E, 0x00, 0x1A, 0x00, 0x1A, 0x00, 0x1A, 0x00, 0x35, 0x00, 0x35, 0x00, 0x31, 0x00, 
  0x31, 0x00, 0x31, 0x00, 0x49, 0x00, 0x49, 0x00, 0x49, 0xD8, 0x0C, 0x73, 0x74, 0x72, 0x69, 0x6E, 
  0x67, 0x2F, 0x73, 0x6C, 0x69, 0x63, 0x65, 0xDA, 0x70, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0B, 
  0x02, 0x02, 0x02, 0x00, 0x18, 0xCE, 0x0A, 0x66, 0x69, 0x6E, 0x64, 0x2D, 0x69, 0x6E, 0x64, 0x65, 
  0x78, 0xDA, 0x05, 0x2C, 0x02, 0x00, 0x00, 0x3D, 0x03, 0x01, 0x00, 0x19, 0x04, 0x03, 0x00, 0x29, 
  0x05, 0x00, 0x00, 0x27, 0x06, 0x00, 0x00, 0x21, 0x08, 0x05, 0x04, 0x1C, 0x08, 0x03, 0x00, 0x19, 
  0x07, 0x06, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x26, 0x07, 0x00, 0x00, 0x1C, 0x07, 0x0B, 0x00, 0x38, 
  0x08, 0x01, 0x05, 0x19, 0x09, 0x08, 0x00, 0x2F, 0x09, 0x00, 0x00, 0x33, 0x08, 0x00, 0x00, 0x1C, 
  0x08, 0x03, 0x00, 0x28, 0x06, 0x00, 0x00, 0x1A, 0x03, 0x00, 0x00, 0x29, 0x0A, 0x01, 0x00, 0x06, 
  0x05, 0x05, 0x0A, 0x1A, 0xF1, 0xFF, 0xFF, 0x1C, 0x06, 0x02, 0x00, 0x04, 0x00, 0x00, 0x00, 0x03, 
  0x05, 0x00, 0x00, 0x83, 0x97, 0x01, 0x03, 0x0C, 0x00, 0x03, 0x01, 0x03, 0x01, 0x03, 0x01, 0x0E, 
  0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x0F, 0x00, 0x05, 0x01, 0x09, 
  0x00, 0x09, 0x00, 0x05, 0x00, 0x15, 0x00, 0x05, 0x00, 0x27, 0x00, 0x27, 0xBF, 0xFE, 0x03, 0x03, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x04, 0x01, 0x01, 0x01, 0x00, 
  0x04, 0xCE, 0x04, 0x6E, 0x69, 0x6C, 0x3F, 0xDA, 0x05, 0x2C, 0x01, 0x00, 0x00, 0x26, 0x03, 0x00, 
  0x00, 0x23, 0x02, 0x00, 0x03, 0x03, 0x02, 0x00, 0x00, 0x72, 0x01, 0x00, 0x25, 0x00, 0x25, 0x00, 
  0x25, 0x2C, 0x02, 0x00, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 
  0x00, 0x19, 0x04, 0x03, 0x00, 0x1C, 0x04, 0x03, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x1A, 0x02, 0x00, 
  0x00, 0x2A, 0x05, 0x02, 0x00, 0x19, 0x06, 0x05, 0x00, 0x3D, 0x07, 0x01, 0x00, 0x19, 0x08, 0x07, 
  0x00, 0x30, 0x00, 0x01, 0x00, 0x2A, 0x0A, 0x03, 0x00, 0x33, 0x09, 0x0A, 0x00, 0x19, 0x0A, 0x09, 
  0x00, 0x2F, 0x0A, 0x00, 0x00, 0x2A, 0x0D, 0x04, 0x00, 0x33, 0x0C, 0x0D, 0x00, 0x1C, 0x0C, 0x03, 
  0x00, 0x19, 0x0B, 0x08, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x0B, 0x0A, 0x00, 0x19, 0x0C, 0x0B, 
  0x00, 0x29, 0x0D, 0x00, 0x00, 0x31, 0x01, 0x0D, 0x0C, 0x34, 0x06, 0x00, 0x00, 0x83, 0xB5, 0x01, 
  0x03, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x03, 0x01, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 
  0x00, 0x03, 0x01, 0x0C, 0x00, 0x03, 0x01, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x10, 
  0x00, 0x10, 0x00, 0x10, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x03, 0x01, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0xCF, 0x09, 0x73, 0x6F, 0x72, 0x74, 0x65, 0x64, 0x2D, 0x62, 0x79, 0xD7, 
  0xCD, 0x02, 0xBA, 0x00, 0x00, 0x05, 0x02, 0x02, 0x02, 0x01, 0x05, 0x01, 0xCE, 0x09, 0x73, 0x6F, 
  0x72, 0x74, 0x65, 0x64, 0x2D, 0x62, 0x79, 0xDA, 0x05, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 
  0x02, 0x01, 0x02, 0x02, 0x07, 0xCE, 0x06, 0x73, 0x6F, 0x72, 0x74, 0x65, 0x64, 0xDA, 0x05, 0xD8, 
  0x0B, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x73, 0x6C, 0x69, 0x63, 0x65, 0xDA, 0x5E, 0x2C, 0x02, 
  0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 0x30, 0x03, 
  0x01, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x34, 0x04, 0x00, 0x00, 0x83, 0x07, 0x01, 0x03, 0x09, 0x00, 
  0x09, 0x00, 0x09, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x2C, 0x02, 0x00, 0x00, 0x2E, 0x03, 0x00, 
  0x00, 0x30, 0x01, 0x03, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x34, 0x04, 0x00, 0x00, 0xCD, 0x00, 0xD0, 
  0x00, 0x00, 0x05, 0x02, 0x02, 0x02, 0x00, 0x08, 0x01, 0xDA, 0x05, 0x2F, 0x00, 0x00, 0x00, 0x2B, 
  0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2B, 0x04, 0x00, 0x00, 0x33, 
  0x03, 0x04, 0x00, 0x21, 0x04, 0x02, 0x03, 0x03, 0x04, 0x00, 0x00, 0xBF, 0xFF, 0x83, 0x10, 0x1C, 
  0x00, 0x1C, 0x00, 0x1C, 0x00, 0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x19, 0x00, 0x19, 0x83, 0x0C, 
  0x01, 0x04, 0x0F, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x00, 0x00, 0x00, 0xCF, 0x0C, 0x62, 
  0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x73, 0x6C, 0x69, 0x63, 0x65, 0xD8, 0x0C, 0x62, 0x75, 0x66, 
  0x66, 0x65, 0x72, 0x2F, 0x73, 0x6C, 0x69, 0x63, 0x65, 0xCF, 0x0C, 0x61, 0x72, 0x72, 0x61, 0x79, 
  0x2F, 0x63, 0x6F, 0x6E, 0x63, 0x61, 0x74, 0xD8, 0x0C, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x63, 
  0x6F, 0x6E, 0x63, 0x61, 0x74, 0xCF, 0x07, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x3F, 0xD7, 0xCD, 
  0x00, 0x98, 0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 0x02, 0x07, 0xCE, 0x07, 0x73, 0x74, 0x72, 0x75, 
  0x63, 0x74, 0x3F, 0xDA, 0x05, 0xDA, 0x39, 0xDA, 0x80, 0x88, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 
  0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x23, 0x03, 
  0x02, 0x04, 0x03, 0x03, 0x00, 0x00, 0x62, 0x01, 0x00, 0x2D, 0x00, 0x2D, 0x00, 0x2D, 0x00, 0x2A, 
  0x00, 0x2A, 0x00, 0x2A, 0xCF, 0x04, 0x63, 0x6F, 0x6D, 0x70, 0xD7, 0xCD, 0x02, 0xBB, 0x00, 0x00, 
  0x18, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x01, 0x3F, 0x04, 0xCE, 0x04, 0x63, 0x6F, 0x6D, 
  0x70, 0xDA, 0x05, 0xDA, 0x70, 0x2C, 0x01, 0x00, 0x00, 0x3D, 0x02, 0x00, 0x00, 0x19, 0x03, 0x02, 
  0x00, 0x29, 0x04, 0x00, 0x00, 0x23, 0x02, 0x03, 0x04, 0x1C, 0x02, 0x02, 0x00, 0x04, 0x00, 0x00, 
  0x00, 0x29, 0x05, 0x01, 0x00, 0x23, 0x04, 0x03, 0x05, 0x1C, 0x04, 0x04, 0x00, 0x29, 0x06, 0x00, 
  0x00, 0x38, 0x05, 0x00, 0x06, 0x03, 0x05, 0x00, 0x00, 0x29, 0x06, 0x02, 0x00, 0x23, 0x05, 0x03, 
  0x06, 0x1C, 0x05, 0x07, 0x00, 0x3B, 0x06, 0x00, 0x00, 0x19, 0x07, 0x06, 0x00, 0x3B, 0x06, 0x00, 
  0x01, 0x19, 0x08, 0x06, 0x00, 0x2E, 0x06, 0x00, 0x00, 0x03, 0x06, 0x00, 0x00, 0x29, 0x09, 0x03, 
  0x00, 0x23, 0x06, 0x03, 0x09, 0x1C, 0x06, 0x09, 0x00, 0x3B, 0x09, 0x00, 0x00, 0x19, 0x0A, 0x09, 
  0x00, 0x3B, 0x09, 0x00, 0x01, 0x19, 0x0B, 0x09, 0x00, 0x3B, 0x09, 0x00, 0x02, 0x19, 0x0C, 0x09, 
  0x00, 0x2E, 0x09, 0x01, 0x00, 0x03, 0x09, 0x00, 0x00, 0x29, 0x0D, 0x04, 0x00, 0x23, 0x09, 0x03, 
  0x0D, 0x1C, 0x09, 0x0B, 0x00, 0x3B, 0x0D, 0x00, 0x00, 0x19, 0x0E, 0x0D, 0x00, 0x3B, 0x0D, 0x00, 
  0x01, 0x19, 0x0F, 0x0D, 0x00, 0x3B, 0x0D, 0x00, 0x02, 0x19, 0x10, 0x0D, 0x00, 0x3B, 0x0D, 0x00, 
  0x03, 0x19, 0x11, 0x0D, 0x00, 0x2E, 0x0D, 0x02, 0x00, 0x03, 0x0D, 0x00, 0x00, 0x3B, 0x0D, 0x00, 
  0x00, 0x19, 0x12, 0x0D, 0x00, 0x3B, 0x0D, 0x00, 0x01, 0x19, 0x13, 0x0D, 0x00, 0x3B, 0x0D, 0x00, 
  0x02, 0x19, 0x14, 0x0D, 0x00, 0x3B, 0x0D, 0x00, 0x03, 0x19, 0x15, 0x0D, 0x00, 0x2E, 0x0D, 0x03, 
  0x00, 0x29, 0x16, 0x04, 0x00, 0x29, 0x17, 0xFF, 0xFF, 0x31, 0x00, 0x16, 0x17, 0x2A, 0x17, 0x00, 
  0x00, 0x33, 0x16, 0x17, 0x00, 0x2F, 0x0D, 0x00, 0x00, 0x32, 0x16, 0x00, 0x00, 0x34, 0x01, 0x00, 
  0x00, 0xCD, 0x00, 0xD1, 0x00, 0x00, 0x03, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x06, 
  0x01, 0xDA, 0x05, 0x32, 0x00, 0x00, 0x00, 0x2B, 0x02, 0x00, 0x08, 0x33, 0x01, 0x02, 0x00, 0x2F, 
  0x01, 0x00, 0x00, 0x2B, 0x02, 0x00, 0x07, 0x34, 0x02, 0x00, 0x00, 0xBF, 0xFF, 0x82, 0x72, 0x2B, 
  0x00, 0x2B, 0x00, 0x2B, 0x00, 0x28, 0x00, 0x28, 0x00, 0x28, 0xCD, 0x00, 0xD1, 0x00, 0x00, 0x04, 
  0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x09, 0x01, 0xDA, 0x05, 0x32, 0x00, 0x00, 0x00, 
  0x2B, 0x02, 0x00, 0x0C, 0x33, 0x01, 0x02, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2B, 0x03, 0x00, 0x0B, 
  0x33, 0x02, 0x03, 0x00, 0x2F, 0x02, 0x00, 0x00, 0x2B, 0x01, 0x00, 0x0A, 0x34, 0x01, 0x00, 0x00, 
  0xBF, 0xFF, 0x82, 0x73, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x2D, 0x00, 0x2D, 0x00, 0x2D, 0x00, 
  0x2A, 0x00, 0x2A, 0x00, 0x2A, 0xCD, 0x00, 0xD1, 0x00, 0x00, 0x04, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 
  0xFF, 0xFF, 0x00, 0x0C, 0x01, 0xDA, 0x05, 0x32, 0x00, 0x00, 0x00, 0x2B, 0x02, 0x00, 0x11, 0x33, 
  0x01, 0x02, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2B, 0x03, 0x00, 0x10, 0x33, 0x02, 0x03, 0x00, 0x2F, 
  0x02, 0x00, 0x00, 0x2B, 0x03, 0x00, 0x0F, 0x33, 0x01, 0x03, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2B, 
  0x02, 0x00, 0x0E, 0x34, 0x02, 0x00, 0x00, 0xBF, 0xFF, 0x82, 0x74, 0x35, 0x00, 0x35, 0x00, 0x35, 
  0x00, 0x32, 0x00, 0x32, 0x00, 0x32, 0x00, 0x2F, 0x00, 0x2F, 0x00, 0x2F, 0x00, 0x2C, 0x00, 0x2C, 
  0x00, 0x2C, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x04, 0x01, 0x01, 0x01, 0x00, 0x0C, 0x01, 0xDA, 0x05, 
  0x2F, 0x00, 0x00, 0x00, 0x2B, 0x02, 0x00, 0x15, 0x33, 0x01, 0x02, 0x00, 0x2F, 0x01, 0x00, 0x00, 
  0x2B, 0x03, 0x00, 0x14, 0x33, 0x02, 0x03, 0x00, 0x2F, 0x02, 0x00, 0x00, 0x2B, 0x03, 0x00, 0x13, 
  0x33, 0x01, 0x03, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2B, 0x02, 0x00, 0x12, 0x34, 0x02, 0x00, 0x00, 
  0xBF, 0xFF, 0x82, 0x76, 0x1E, 0x00, 0x1E, 0x00, 0x1E, 0x00, 0x1B, 0x00, 0x1B, 0x00, 0x1B, 0x00, 
  0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x82, 0x6B, 0x01, 0x04, 0x09, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x02, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xFE, 0x03, 0x00, 0x03, 0x00, 0x03, 0x03, 0x07, 0x00, 
  0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x1E, 0x00, 0x1E, 0xBF, 0xFD, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x04, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x20, 0x00, 0x20, 
  0xBF, 0xFC, 0x03, 0x00, 0x03, 0x00, 0x03, 0x05, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 
  0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x22, 0x00, 0x22, 0x01, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x0D, 0x01, 0x0E, 0x00, 
  0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0xBF, 0xFF, 0x07, 0x00, 0x07, 0x00, 0x07, 0x80, 0xDD, 
  0x3F, 0x00, 0xCF, 0x05, 0x61, 0x73, 0x3F, 0x2D, 0x3E, 0xD7, 0xCD, 0x02, 0xBB, 0x00, 0x00, 0x07, 
  0x02, 0x02, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x03, 0x08, 0x02, 0xCE, 0x05, 0x61, 0x73, 0x3F, 0x2D, 
  0x3E, 0xDA, 0x05, 0xDA, 0x22, 0xD7, 0xCD, 0x02, 0xBA, 0x00, 0x00, 0x06, 0x02, 0x02, 0x02, 0x01, 
  0x07, 0x01, 0xCE, 0x08, 0x70, 0x6F, 0x73, 0x74, 0x77, 0x61, 0x6C, 0x6B, 0xDA, 0x05, 0xD7, 0xCD, 
  0x00, 0x98, 0x00, 0x00, 0x0A, 0x02, 0x02, 0x02, 0x09, 0x24, 0xCE, 0x04, 0x77, 0x61, 0x6C, 0x6B, 
  0xDA, 0x05, 0xDA, 0x39, 0xDA, 0x3A, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0A, 0x02, 0x02, 0x02, 
  0x00, 0x11, 0xCE, 0x09, 0x77, 0x61, 0x6C, 0x6B, 0x2D, 0x64, 0x69, 0x63, 0x74, 0xDA, 0x05, 0x2C, 
  0x02, 0x00, 0x00, 0x42, 0x03, 0x00, 0x00, 0x19, 0x04, 0x03, 0x00, 0x26, 0x06, 0x00, 0x00, 0x47, 
  0x05, 0x01, 0x06, 0x19, 0x06, 0x05, 0x00, 0x1D, 0x06, 0x0A, 0x00, 0x19, 0x05, 0x06, 0x00, 0x2F, 
  0x05, 0x00, 0x00, 0x33, 0x07, 0x00, 0x00, 0x38, 0x08, 0x01, 0x05, 0x2F, 0x08, 0x00, 0x00, 0x33, 
  0x09, 0x00, 0x00, 0x3A, 0x04, 0x07, 0x09, 0x47, 0x06, 0x01, 0x06, 0x1A, 0xF7, 0xFF, 0xFF, 0x03, 
  0x04, 0x00, 0x00, 0x84, 0x42, 0x01, 0x01, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x01, 0x0E, 0x00, 0x0E, 0x00, 0x17, 0x00, 0x14, 0x00, 0x14, 0x00, 0x05, 
  0xBF, 0xFF, 0x03, 0x00, 0x03, 0xBF, 0xFE, 0x01, 0xDA, 0x80, 0x88, 0xD8, 0x0F, 0x74, 0x61, 0x62, 
  0x6C, 0x65, 0x2F, 0x74, 0x6F, 0x2D, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0xD0, 0x05, 0x61, 0x72, 
  0x72, 0x61, 0x79, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0C, 0x02, 0x02, 0x02, 0x02, 0x15, 0xCE, 
  0x08, 0x77, 0x61, 0x6C, 0x6B, 0x2D, 0x69, 0x6E, 0x64, 0xDA, 0x05, 0xDA, 0x55, 0xDA, 0x52, 0x2C, 
  0x02, 0x00, 0x00, 0x3D, 0x03, 0x01, 0x00, 0x19, 0x04, 0x03, 0x00, 0x2F, 0x04, 0x00, 0x00, 0x2A, 
  0x06, 0x00, 0x00, 0x33, 0x05, 0x06, 0x00, 0x19, 0x06, 0x05, 0x00, 0x26, 0x08, 0x00, 0x00, 0x47, 
  0x07, 0x01, 0x08, 0x19, 0x08, 0x07, 0x00, 0x1D, 0x08, 0x0A, 0x00, 0x38, 0x07, 0x01, 0x08, 0x19, 
  0x09, 0x07, 0x00, 0x2F, 0x09, 0x00, 0x00, 0x33, 0x07, 0x00, 0x00, 0x30, 0x06, 0x07, 0x00, 0x2A, 
  0x0B, 0x01, 0x00, 0x33, 0x0A, 0x0B, 0x00, 0x47, 0x08, 0x01, 0x08, 0x1A, 0xF7, 0xFF, 0xFF, 0x03, 
  0x06, 0x00, 0x00, 0x84, 0x3C, 0x01, 0x01, 0x0C, 0x00, 0x03, 0x01, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 
  0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x20, 
  0x00, 0x20, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x03, 0x00, 0x03, 0xBF, 0xFD, 0x01, 0xDA, 
  0x72, 0xDA, 0x70, 0x2C, 0x02, 0x00, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 
  0x03, 0x04, 0x00, 0x19, 0x04, 0x03, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x23, 0x03, 0x04, 0x05, 0x1C, 
  0x03, 0x04, 0x00, 0x30, 0x00, 0x01, 0x00, 0x2A, 0x05, 0x02, 0x00, 0x34, 0x05, 0x00, 0x00, 0x2A, 
  0x06, 0x03, 0x00, 0x23, 0x05, 0x04, 0x06, 0x1C, 0x05, 0x07, 0x00, 0x30, 0x00, 0x01, 0x00, 0x2A, 
  0x07, 0x02, 0x00, 0x33, 0x06, 0x07, 0x00, 0x2F, 0x06, 0x00, 0x00, 0x2A, 0x07, 0x04, 0x00, 0x34, 
  0x07, 0x00, 0x00, 0x2A, 0x07, 0x05, 0x00, 0x23, 0x06, 0x04, 0x07, 0x1C, 0x06, 0x04, 0x00, 0x30, 
  0x00, 0x01, 0x00, 0x2A, 0x07, 0x06, 0x00, 0x34, 0x07, 0x00, 0x00, 0x2A, 0x08, 0x07, 0x00, 0x23, 
  0x07, 0x04, 0x08, 0x1C, 0x07, 0x07, 0x00, 0x30, 0x00, 0x01, 0x00, 0x2A, 0x09, 0x06, 0x00, 0x33, 
  0x08, 0x09, 0x00, 0x2F, 0x08, 0x00, 0x00, 0x2A, 0x09, 0x08, 0x00, 0x34, 0x09, 0x00, 0x00, 0x03, 
  0x01, 0x00, 0x00, 0x84, 0x48, 0x01, 0x06, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x01, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0xBF, 0xFF, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x02, 0x1E, 0x00, 0x1E, 0x00, 0x1E, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0xBF, 0xFE, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x03, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0xBF, 0xFD, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x04, 0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0xBF, 0xFC, 0x03, 
  0x2C, 0x02, 0x00, 0x00, 0x2E, 0x03, 0x00, 0x00, 0x30, 0x03, 0x01, 0x00, 0x2A, 0x05, 0x00, 0x00, 
  0x33, 0x04, 0x05, 0x00, 0x2F, 0x04, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0xCD, 0x00, 0xD0, 0x00, 
  0x00, 0x02, 0x01, 0x01, 0x01, 0x00, 0x04, 0x01, 0xDA, 0x05, 0x2B, 0x01, 0x00, 0x00, 0x30, 0x01, 
  0x00, 0x00, 0x2B, 0x01, 0x00, 0x02, 0x34, 0x01, 0x00, 0x00, 0xBF, 0xFF, 0x84, 0x5C, 0x14, 0x00, 
  0x14, 0x00, 0x14, 0x00, 0x14, 0x84, 0x58, 0x01, 0x04, 0x0C, 0x00, 0x06, 0x00, 0x06, 0x00, 0x06, 
  0x00, 0x03, 0x00, 0x03, 0x05, 0x00, 0x00, 0x00, 0xDA, 0x31, 0x2C, 0x03, 0x00, 0x00, 0x19, 0x04, 
  0x00, 0x00, 0x26, 0x06, 0x00, 0x00, 0x47, 0x05, 0x02, 0x06, 0x19, 0x06, 0x05, 0x00, 0x2E, 0x05, 
  0x01, 0x00, 0x33, 0x05, 0x05, 0x00, 0x03, 0x04, 0x00, 0x00, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x03, 
  0x01, 0x01, 0x01, 0x00, 0x06, 0x01, 0xDA, 0x05, 0x2B, 0x02, 0x00, 0x01, 0x23, 0x01, 0x00, 0x02, 
  0x1C, 0x01, 0x03, 0x00, 0x2B, 0x02, 0x00, 0x08, 0x03, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 
  0xBF, 0xFF, 0x84, 0x78, 0x2A, 0x00, 0x2A, 0x00, 0x26, 0x00, 0x26, 0x00, 0x26, 0x00, 0x26, 0xCD, 
  0x02, 0xFA, 0x00, 0x00, 0x07, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x03, 0x1C, 0x01, 0x01, 
  0xCE, 0x06, 0x5F, 0x77, 0x68, 0x69, 0x6C, 0x65, 0xDA, 0x05, 0xDA, 0x22, 0xDA, 0x81, 0x40, 0xDA, 
  0x31, 0x2B, 0x00, 0x00, 0x06, 0x1E, 0x00, 0x02, 0x00, 0x04, 0x00, 0x00, 0x00, 0x2B, 0x01, 0x00, 
  0x02, 0x2B, 0x02, 0x00, 0x06, 0x38, 0x00, 0x01, 0x02, 0x19, 0x01, 0x00, 0x00, 0x2A, 0x02, 0x00, 
  0x00, 0x33, 0x00, 0x02, 0x00, 0x19, 0x02, 0x00, 0x00, 0x2E, 0x00, 0x00, 0x00, 0x30, 0x00, 0x01, 
  0x00, 0x2A, 0x04, 0x01, 0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x00, 0x03, 0x00, 0x2B, 0x04, 0x00, 
  0x04, 0x30, 0x02, 0x04, 0x00, 0x44, 0x03, 0x00, 0x00, 0x2A, 0x05, 0x02, 0x00, 0x31, 0x05, 0x03, 
  0x00, 0x43, 0x04, 0x00, 0x00, 0x2D, 0x04, 0x00, 0x04, 0x2B, 0x05, 0x00, 0x02, 0x2B, 0x06, 0x00, 
  0x06, 0x47, 0x03, 0x05, 0x06, 0x2D, 0x03, 0x00, 0x06, 0x2C, 0x05, 0x00, 0x00, 0x34, 0x05, 0x00, 
  0x00, 0xBF, 0xFF, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x03, 0x01, 0x01, 0x01, 0x00, 0x06, 0x02, 0xDA, 
  0x05, 0x2B, 0x02, 0x00, 0x01, 0x23, 0x01, 0x00, 0x02, 0x1C, 0x01, 0x03, 0x00, 0x2B, 0x02, 0x01, 
  0x02, 0x03, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0xBF, 0xFF, 0x84, 0x78, 0x2A, 0x00, 
  0x2A, 0x00, 0x26, 0x00, 0x26, 0x00, 0x26, 0x00, 0x26, 0x84, 0x76, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x0E, 0x00, 0x0E, 0x00, 0x05, 0x01, 0x1E, 
  0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x05, 0x01, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 
  0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0xBF, 0xFD, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x04, 0x00, 0x00, 0x00, 0x84, 0x6F, 0x01, 0x06, 0x03, 0x01, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xBF, 0xF9, 0x01, 0x56, 0x01, 0x00, 0x00, 0xCF, 0x10, 0x62, 
  0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x62, 0x69, 0x74, 0x2D, 0x63, 0x6C, 0x65, 0x61, 0x72, 0xD8, 
  0x10, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x62, 0x69, 0x74, 0x2D, 0x63, 0x6C, 0x65, 0x61, 
  0x72, 0xCF, 0x05, 0x64, 0x65, 0x66, 0x65, 0x72, 0xDA, 0x30, 0xCF, 0x09, 0x70, 0x72, 0x6F, 0x70, 
  0x61, 0x67, 0x61, 0x74, 0x65, 0xDA, 0x2D, 0xDA, 0x80, 0x8C, 0xDA, 0x80, 0x8B, 0xCF, 0x04, 0x70, 
  0x6F, 0x73, 0x3F, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x04, 0x01, 0x01, 0x01, 0x00, 0x04, 0xCE, 
  0x04, 0x70, 0x6F, 0x73, 0x3F, 0xDA, 0x05, 0x2C, 0x01, 0x00, 0x00, 0x29, 0x03, 0x00, 0x00, 0x1F, 
  0x02, 0x00, 0x03, 0x03, 0x02, 0x00, 0x00, 0x55, 0x01, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0xCF, 
  0x09, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x73, 0x71, 0x72, 0x74, 0xD8, 0x09, 0x6D, 0x61, 0x74, 0x68, 
  0x2F, 0x73, 0x71, 0x72, 0x74, 0xCF, 0x05, 0x73, 0x74, 0x64, 0x69, 0x6E, 0xD8, 0x05, 0x73, 0x74, 
  0x64, 0x69, 0x6E, 0xCF, 0x0B, 0x66, 0x72, 0x65, 0x71, 0x75, 0x65, 0x6E, 0x63, 0x69, 0x65, 0x73, 
  0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0A, 0x01, 0x01, 0x01, 0x00, 0x15, 0xCE, 0x0B, 0x66, 0x72, 
  0x65, 0x71, 0x75, 0x65, 0x6E, 0x63, 0x69, 0x65, 0x73, 0xDA, 0x05, 0x2C, 0x01, 0x00, 0x00, 0x42, 
  0x02, 0x00, 0x00, 0x19, 0x03, 0x02, 0x00, 0x26, 0x05, 0x00, 0x00, 0x47, 0x04, 0x00, 0x05, 0x19, 
  0x05, 0x04, 0x00, 0x1D, 0x05, 0x0E, 0x00, 0x38, 0x04, 0x00, 0x05, 0x19, 0x06, 0x04, 0x00, 0x38, 
  0x04, 0x03, 0x06, 0x19, 0x07, 0x04, 0x00, 0x1C, 0x07, 0x05, 0x00, 0x29, 0x09, 0x01, 0x00, 0x06, 
  0x08, 0x09, 0x07, 0x19, 0x04, 0x08, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x29, 0x04, 0x01, 0x00, 0x3A, 
  0x03, 0x06, 0x04, 0x47, 0x05, 0x00, 0x05, 0x1A, 0xF3, 0xFF, 0xFF, 0x03, 0x03, 0x00, 0x00, 0x85, 
  0x38, 0x01, 0x03, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x01, 0x0C, 0x00, 0x05, 0x01, 0x14, 0x00, 0x1A, 0x00, 0x1A, 0x00, 0x14, 0x00, 0x14, 
  0x00, 0x14, 0x00, 0x05, 0xBF, 0xFE, 0x03, 0x00, 0x03, 0xBF, 0xFC, 0x01, 0xCF, 0x05, 0x73, 0x6C, 
  0x69, 0x63, 0x65, 0xD8, 0x05, 0x73, 0x6C, 0x69, 0x63, 0x65, 0xCF, 0x07, 0x6F, 0x73, 0x2F, 0x65, 
  0x78, 0x69, 0x74, 0xDA, 0x81, 0x0C, 0xCF, 0x03, 0x73, 0x65, 0x71, 0xD7, 0xCD, 0x00, 0x99, 0x00, 
  0x00, 0x09, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x05, 0x17, 0xCE, 0x03, 0x73, 0x65, 0x71, 
  0xDA, 0x05, 0xDA, 0x22, 0xDA, 0x26, 0xDA, 0x2F, 0xCF, 0x0A, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 
  0x70, 0x75, 0x73, 0x68, 0xCF, 0x04, 0x6C, 0x6F, 0x6F, 0x70, 0x2C, 0x02, 0x00, 0x00, 0x2A, 0x04, 
  0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x04, 0x03, 0x00, 0x3E, 0x05, 0x00, 0x00, 0x2A, 0x07, 
  0x01, 0x00, 0x31, 0x07, 0x04, 0x05, 0x43, 0x06, 0x00, 0x00, 0x2A, 0x07, 0x02, 0x00, 0x2F, 0x07, 
  0x00, 0x00, 0x32, 0x01, 0x00, 0x00, 0x43, 0x05, 0x00, 0x00, 0x2A, 0x08, 0x03, 0x00, 0x31, 0x08, 
  0x04, 0x05, 0x43, 0x07, 0x00, 0x00, 0x2A, 0x08, 0x04, 0x00, 0x31, 0x08, 0x00, 0x07, 0x43, 0x05, 
  0x00, 0x00, 0x2A, 0x08, 0x02, 0x00, 0x31, 0x08, 0x06, 0x05, 0x2F, 0x04, 0x00, 0x00, 0x43, 0x07, 
  0x00, 0x00, 0x03, 0x07, 0x00, 0x00, 0x82, 0x22, 0x01, 0x04, 0x0F, 0x00, 0x0F, 0x00, 0x03, 0x01, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0xDA, 0x80, 0x86, 0xDA, 0x80, 0x85, 0xCF, 0x0C, 0x74, 0x75, 0x70, 
  0x6C, 0x65, 0x2F, 0x73, 0x65, 0x74, 0x6D, 0x61, 0x70, 0xD8, 0x0C, 0x74, 0x75, 0x70, 0x6C, 0x65, 
  0x2F, 0x73, 0x65, 0x74, 0x6D, 0x61, 0x70, 0xCF, 0x06, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0xD7, 
  0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x02, 0x01, 0x02, 0x01, 0x07, 0xCE, 0x06, 0x72, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0xDA, 0x05, 0xD8, 0x06, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0x2C, 0x02, 0x00, 
  0x00, 0x30, 0x00, 0x01, 0x00, 0x43, 0x03, 0x00, 0x00, 0x29, 0x04, 0x00, 0x00, 0x30, 0x04, 0x03, 
  0x00, 0x2A, 0x04, 0x00, 0x00, 0x34, 0x04, 0x00, 0x00, 0x81, 0x5F, 0x01, 0x03, 0x0D, 0x00, 0x0D, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x02, 0x6F, 0x72, 0xD7, 0xCD, 0x00, 0x99, 
  0x00, 0x00, 0x0F, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x06, 0x2B, 0xCE, 0x02, 0x6F, 0x72, 
  0xDA, 0x05, 0xD7, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 0x02, 0x09, 0x01, 0xCE, 
  0x0B, 0x69, 0x64, 0x65, 0x6D, 0x70, 0x6F, 0x74, 0x65, 0x6E, 0x74, 0x3F, 0xDA, 0x05, 0xDA, 0x39, 
  0xD8, 0x03, 0x6E, 0x6F, 0x74, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 
  0x00, 0x33, 0x02, 0x03, 0x00, 0x2B, 0x04, 0x00, 0x01, 0x38, 0x03, 0x04, 0x02, 0x2F, 0x03, 0x00, 
  0x00, 0x2A, 0x02, 0x01, 0x00, 0x34, 0x02, 0x00, 0x00, 0xBF, 0xFF, 0x7E, 0x05, 0x00, 0x33, 0x00, 
  0x33, 0x00, 0x33, 0x00, 0x1E, 0x00, 0x1E, 0x00, 0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x04, 0xC9, 
  0xD5, 0x05, 0xDA, 0x81, 0x3C, 0xCB, 0xDA, 0x80, 0x88, 0xCB, 0xDA, 0x81, 0x1D, 0xCB, 0xDA, 0x3A, 
  0xCB, 0xDA, 0x72, 0xCB, 0xC9, 0xC9, 0xDA, 0x2E, 0xD8, 0x05, 0x74, 0x75, 0x70, 0x6C, 0x65, 0xDA, 
  0x22, 0xDA, 0x26, 0xDA, 0x2F, 0x2C, 0x01, 0x00, 0x00, 0x3D, 0x02, 0x00, 0x00, 0x19, 0x03, 0x02, 
  0x00, 0x29, 0x05, 0x01, 0x00, 0x07, 0x04, 0x03, 0x05, 0x19, 0x05, 0x04, 0x00, 0x38, 0x06, 0x00, 
  0x05, 0x19, 0x07, 0x06, 0x00, 0x29, 0x09, 0x00, 0x00, 0x1F, 0x08, 0x05, 0x09, 0x1C, 0x08, 0x20, 
  0x00, 0x29, 0x09, 0x01, 0x00, 0x07, 0x05, 0x05, 0x09, 0x38, 0x09, 0x00, 0x05, 0x19, 0x0A, 0x09, 
  0x00, 0x2F, 0x0A, 0x00, 0x00, 0x2A, 0x0B, 0x00, 0x00, 0x33, 0x09, 0x0B, 0x00, 0x1C, 0x09, 0x07, 
  0x00, 0x2A, 0x0B, 0x01, 0x00, 0x31, 0x0B, 0x0A, 0x0A, 0x2F, 0x07, 0x00, 0x00, 0x2A, 0x0B, 0x02, 
  0x00, 0x33, 0x07, 0x0B, 0x00, 0x1A, 0x11, 0x00, 0x00, 0x2A, 0x0C, 0x03, 0x00, 0x33, 0x0B, 0x0C, 
  0x00, 0x19, 0x0C, 0x0B, 0x00, 0x2A, 0x0B, 0x04, 0x00, 0x31, 0x0B, 0x0C, 0x0A, 0x2A, 0x0D, 0x02, 
  0x00, 0x33, 0x0B, 0x0D, 0x00, 0x2A, 0x0D, 0x01, 0x00, 0x31, 0x0D, 0x0C, 0x0C, 0x2F, 0x07, 0x00, 
  0x00, 0x2A, 0x0E, 0x02, 0x00, 0x33, 0x0D, 0x0E, 0x00, 0x2A, 0x0E, 0x05, 0x00, 0x31, 0x0E, 0x0B, 
  0x0D, 0x2A, 0x0E, 0x02, 0x00, 0x33, 0x07, 0x0E, 0x00, 0x1A, 0xDF, 0xFF, 0xFF, 0x03, 0x07, 0x00, 
  0x00, 0x81, 0x0D, 0x01, 0x04, 0x0C, 0x00, 0x03, 0x01, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x0C, 
  0x00, 0x03, 0x01, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x05, 0x00, 0x05, 0x01, 0x0D, 0x00, 0x05, 
  0x01, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x0E, 0x01, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 
  0x00, 0x10, 0xBF, 0xFF, 0x0E, 0x03, 0x1B, 0x00, 0x1B, 0x00, 0x12, 0x01, 0x1D, 0x00, 0x1D, 0x00, 
  0x1D, 0x00, 0x1D, 0x01, 0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x19, 0xBF, 0xFF, 0x12, 
  0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0xBF, 0xF9, 0x03, 0xBF, 0xF9, 0x01, 0xCF, 0x03, 0x6B, 0x76, 
  0x73, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x09, 0x01, 0x01, 0x01, 0x02, 0x14, 0xCE, 0x03, 0x6B, 
  0x76, 0x73, 0xDA, 0x05, 0xDA, 0x55, 0xDA, 0x52, 0x2C, 0x01, 0x00, 0x00, 0x3D, 0x02, 0x00, 0x00, 
  0x29, 0x04, 0x02, 0x00, 0x09, 0x03, 0x04, 0x02, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 
  0x33, 0x02, 0x04, 0x00, 0x19, 0x03, 0x02, 0x00, 0x26, 0x05, 0x00, 0x00, 0x47, 0x04, 0x00, 0x05, 
  0x19, 0x05, 0x04, 0x00, 0x1D, 0x05, 0x08, 0x00, 0x19, 0x04, 0x05, 0x00, 0x38, 0x06, 0x00, 0x04, 
  0x31, 0x03, 0x04, 0x06, 0x2A, 0x08, 0x01, 0x00, 0x33, 0x07, 0x08, 0x00, 0x47, 0x05, 0x00, 0x05, 
  0x1A, 0xF9, 0xFF, 0xFF, 0x03, 0x03, 0x00, 0x00, 0x85, 0x66, 0x01, 0x04, 0x1C, 0x00, 0x17, 0x00, 
  0x17, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x2A, 0x00, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x03, 0x00, 0x03, 0xBF, 
  0xFB, 0x01, 0xCF, 0x07, 0x6F, 0x73, 0x2F, 0x74, 0x69, 0x6D, 0x65, 0xD8, 0x07, 0x6F, 0x73, 0x2F, 
  0x74, 0x69, 0x6D, 0x65, 0xCF, 0x08, 0x64, 0x69, 0x73, 0x74, 0x69, 0x6E, 0x63, 0x74, 0xD7, 0xCD, 
  0x00, 0x98, 0x00, 0x00, 0x0B, 0x01, 0x01, 0x01, 0x01, 0x16, 0xCE, 0x08, 0x64, 0x69, 0x73, 0x74, 
  0x69, 0x6E, 0x63, 0x74, 0xDA, 0x05, 0xDA, 0x52, 0x2C, 0x01, 0x00, 0x00, 0x3E, 0x02, 0x00, 0x00, 
  0x19, 0x03, 0x02, 0x00, 0x42, 0x04, 0x00, 0x00, 0x19, 0x05, 0x04, 0x00, 0x26, 0x07, 0x00, 0x00, 
  0x47, 0x06, 0x00, 0x07, 0x19, 0x07, 0x06, 0x00, 0x1D, 0x07, 0x0D, 0x00, 0x38, 0x06, 0x00, 0x07, 
  0x19, 0x08, 0x06, 0x00, 0x38, 0x06, 0x05, 0x08, 0x1C, 0x06, 0x02, 0x00, 0x1A, 0x06, 0x00, 0x00, 
  0x27, 0x09, 0x00, 0x00, 0x3A, 0x05, 0x08, 0x09, 0x30, 0x03, 0x08, 0x00, 0x2A, 0x0A, 0x00, 0x00, 
  0x33, 0x09, 0x0A, 0x00, 0x47, 0x07, 0x00, 0x07, 0x1A, 0xF4, 0xFF, 0xFF, 0x03, 0x03, 0x00, 0x00, 
  0x85, 0x4E, 0x01, 0x03, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x12, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x26, 0x00, 
  0x26, 0x00, 0x38, 0x00, 0x38, 0x00, 0x38, 0x00, 0x03, 0x00, 0x03, 0xBF, 0xFB, 0x01, 0xCF, 0x0D, 
  0x67, 0x63, 0x73, 0x65, 0x74, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6C, 0xD8, 0x0D, 0x67, 
  0x63, 0x73, 0x65, 0x74, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6C, 0xCF, 0x06, 0x61, 0x73, 
  0x73, 0x65, 0x72, 0x74, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x04, 0x02, 0x01, 0x02, 0x01, 0x09, 
  0xCE, 0x06, 0x61, 0x73, 0x73, 0x65, 0x72, 0x74, 0xDA, 0x05, 0xCE, 0x0E, 0x61, 0x73, 0x73, 0x65, 
  0x72, 0x74, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x75, 0x72, 0x65, 0x2C, 0x02, 0x00, 0x00, 0x1C, 0x00, 
  0x02, 0x00, 0x03, 0x00, 0x00, 0x00, 0x1C, 0x01, 0x03, 0x00, 0x19, 0x03, 0x01, 0x00, 0x1A, 0x02, 
  0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x80, 0x8B, 
  0x01, 0x03, 0x03, 0x00, 0x03, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x0B, 0x00, 
  0x0B, 0xCF, 0x11, 0x74, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x73, 0x77, 0x61, 0x70, 0x2D, 0x62, 
  0x79, 0x74, 0x65, 0x73, 0xD8, 0x11, 0x74, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x73, 0x77, 0x61, 
  0x70, 0x2D, 0x62, 0x79, 0x74, 0x65, 0x73, 0xCF, 0x0A, 0x65, 0x6E, 0x76, 0x2D, 0x6C, 0x6F, 0x6F, 
  0x6B, 0x75, 0x70, 0xD8, 0x0A, 0x65, 0x6E, 0x76, 0x2D, 0x6C, 0x6F, 0x6F, 0x6B, 0x75, 0x70, 0xCF, 
  0x08, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x65, 0x78, 0x70, 0xD8, 0x08, 0x6D, 0x61, 0x74, 0x68, 0x2F, 
  0x65, 0x78, 0x70, 0xCF, 0x01, 0x3E, 0xD7, 0xCD, 0x00, 0x09, 0x00, 0x14, 0x06, 0x00, 0x00, 0xCD, 
  0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x10, 0xCE, 0x01, 0x3E, 0x3D, 0x01, 0x00, 0x00, 0x22, 0x02, 0x01, 
  0x02, 0x1B, 0x02, 0x0A, 0x00, 0x3B, 0x03, 0x00, 0x00, 0x29, 0x05, 0x01, 0x00, 0x38, 0x04, 0x00, 
  0x05, 0x1F, 0x02, 0x03, 0x04, 0x1C, 0x02, 0x07, 0x00, 0x05, 0x05, 0x05, 0x01, 0x19, 0x03, 0x04, 
  0x00, 0x23, 0x02, 0x05, 0x01, 0x1C, 0x02, 0xFA, 0xFF, 0x27, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 
  0x00, 0x28, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0xCF, 0x0A, 0x61, 0x72, 0x72, 0x61, 0x79, 
  0x2F, 0x70, 0x65, 0x65, 0x6B, 0xD8, 0x0A, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x70, 0x65, 0x65, 
  0x6B, 0xCF, 0x06, 0x69, 0x6E, 0x76, 0x65, 0x72, 0x74, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x07, 
  0x01, 0x01, 0x01, 0x00, 0x0D, 0xCE, 0x06, 0x69, 0x6E, 0x76, 0x65, 0x72, 0x74, 0xDA, 0x05, 0x2C, 
  0x01, 0x00, 0x00, 0x42, 0x02, 0x00, 0x00, 0x19, 0x03, 0x02, 0x00, 0x26, 0x05, 0x00, 0x00, 0x47, 
  0x04, 0x00, 0x05, 0x19, 0x05, 0x04, 0x00, 0x1D, 0x05, 0x06, 0x00, 0x19, 0x04, 0x05, 0x00, 0x38, 
  0x06, 0x00, 0x04, 0x3A, 0x03, 0x06, 0x04, 0x47, 0x05, 0x00, 0x05, 0x1A, 0xFB, 0xFF, 0xFF, 0x03, 
  0x03, 0x00, 0x00, 0x84, 0xB3, 0x01, 0x05, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x01, 0x0E, 0x00, 0x05, 0xBF, 0xFF, 0x03, 0x00, 0x03, 0xBF, 0xFA, 0x01, 
  0xCF, 0x07, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0xD7, 0xDC, 0x17, 0xCF, 0x08, 0x6F, 0x73, 
  0x2F, 0x6D, 0x6B, 0x64, 0x69, 0x72, 0xD8, 0x08, 0x6F, 0x73, 0x2F, 0x6D, 0x6B, 0x64, 0x69, 0x72, 
  0xDA, 0x81, 0x57, 0xD7, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x04, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 
  0xFF, 0x01, 0x05, 0xCE, 0x04, 0x6C, 0x6F, 0x6F, 0x70, 0xDA, 0x05, 0xD7, 0xCD, 0x00, 0x98, 0x00, 
  0x00, 0x1B, 0x03, 0x03, 0x03, 0x2D, 0x80, 0xF5, 0xCE, 0x05, 0x6C, 0x6F, 0x6F, 0x70, 0x31, 0xDA, 
  0x05, 0xDA, 0x2F, 0xDA, 0x4E, 0xD0, 0x05, 0x75, 0x6E, 0x74, 0x69, 0x6C, 0xCF, 0x05, 0x62, 0x72, 
  0x65, 0x61, 0x6B, 0xDA, 0x2E, 0xD0, 0x05, 0x77, 0x68, 0x69, 0x6C, 0x65, 0xD0, 0x03, 0x6C, 0x65, 
  0x74, 0xCF, 0x03, 0x6C, 0x65, 0x74, 0xD0, 0x05, 0x61, 0x66, 0x74, 0x65, 0x72, 0xD0, 0x06, 0x62, 
  0x65, 0x66, 0x6F, 0x72, 0x65, 0xD0, 0x06, 0x72, 0x65, 0x70, 0x65, 0x61, 0x74, 0xDA, 0x22, 0xCF, 
  0x03, 0x76, 0x61, 0x72, 0xDA, 0x81, 0x7B, 0xCF, 0x02, 0x2D, 0x2D, 0xCF, 0x05, 0x77, 0x68, 0x69, 
  0x6C, 0x65, 0xD0, 0x04, 0x77, 0x68, 0x65, 0x6E, 0xCF, 0x04, 0x77, 0x68, 0x65, 0x6E, 0xCE, 0x19, 
  0x75, 0x6E, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x20, 
  0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x72, 0x20, 0xDA, 0x6F, 0xD0, 0x05, 0x72, 0x61, 0x6E, 
  0x67, 0x65, 0xD7, 0xCD, 0x00, 0x09, 0x00, 0x09, 0x06, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 
  0x00, 0x13, 0xCE, 0x01, 0x2B, 0x3D, 0x01, 0x00, 0x00, 0x24, 0x02, 0x01, 0x00, 0x1C, 0x02, 0x03, 
  0x00, 0x29, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x24, 0x02, 0x01, 0x01, 0x1C, 0x02, 0x05, 
  0x00, 0x29, 0x03, 0x00, 0x00, 0x3B, 0x04, 0x00, 0x00, 0x06, 0x03, 0x03, 0x04, 0x03, 0x03, 0x00, 
  0x00, 0x3B, 0x03, 0x00, 0x00, 0x29, 0x05, 0x01, 0x00, 0x38, 0x04, 0x00, 0x05, 0x06, 0x03, 0x03, 
  0x04, 0x05, 0x05, 0x05, 0x01, 0x23, 0x02, 0x05, 0x01, 0x1C, 0x02, 0xFC, 0xFF, 0x03, 0x03, 0x00, 
  0x00, 0xDA, 0x59, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0C, 0x05, 0x05, 0x05, 0x02, 0x15, 0xCE, 
  0x0E, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x2D, 0x74, 0x65, 0x6D, 0x70, 0x6C, 0x61, 0x74, 0x65, 0xDA, 
  0x05, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 0x03, 0x0C, 0xCE, 0x0D, 0x63, 
  0x68, 0x65, 0x63, 0x6B, 0x2D, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x65, 0x64, 0xDA, 0x05, 0xD7, 0xCD, 
  0x00, 0x98, 0x00, 0x00, 0x07, 0x01, 0x01, 0x01, 0x03, 0x0D, 0xCE, 0x08, 0x69, 0x6E, 0x64, 0x65, 
  0x78, 0x65, 0x64, 0x3F, 0xDA, 0x05, 0xDA, 0x39, 0xDA, 0x81, 0x3C, 0xDA, 0x72, 0x2C, 0x01, 0x00, 
  0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x19, 0x03, 0x02, 
  0x00, 0x2A, 0x05, 0x01, 0x00, 0x23, 0x04, 0x03, 0x05, 0x1C, 0x04, 0x03, 0x00, 0x27, 0x05, 0x00, 
  0x00, 0x03, 0x05, 0x00, 0x00, 0x2A, 0x06, 0x02, 0x00, 0x23, 0x05, 0x03, 0x06, 0x03, 0x05, 0x00, 
  0x00, 0x6C, 0x01, 0x01, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x07, 0x00, 0x07, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x19, 0x00, 0x19, 0x00, 0x19, 0xCE, 0x1E, 0x65, 0x78, 0x70, 
  0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x20, 
  0x72, 0x61, 0x6E, 0x67, 0x65, 0x2C, 0x20, 0x67, 0x6F, 0x74, 0x20, 0xDA, 0x6F, 0x2C, 0x01, 0x00, 
  0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x1C, 0x02, 0x02, 
  0x00, 0x03, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x30, 0x03, 0x00, 0x00, 0x2A, 0x04, 0x02, 
  0x00, 0x33, 0x03, 0x04, 0x00, 0x01, 0x03, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x81, 0x89, 0x01, 
  0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x03, 0x00, 0x03, 0x02, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 
  0x00, 0x0C, 0x00, 0x05, 0x00, 0x05, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x11, 0x07, 0x07, 0x07, 
  0x06, 0x21, 0xCE, 0x0C, 0x66, 0x6F, 0x72, 0x2D, 0x74, 0x65, 0x6D, 0x70, 0x6C, 0x61, 0x74, 0x65, 
  0xDA, 0x05, 0xDA, 0x22, 0xDA, 0x81, 0x91, 0xDA, 0x26, 0xCF, 0x03, 0x73, 0x65, 0x74, 0xDA, 0x81, 
  0x93, 0xDA, 0x2F, 0x2C, 0x07, 0x00, 0x00, 0x2A, 0x09, 0x00, 0x00, 0x33, 0x08, 0x09, 0x00, 0x19, 
  0x09, 0x08, 0x00, 0x2A, 0x0A, 0x00, 0x00, 0x33, 0x08, 0x0A, 0x00, 0x19, 0x0A, 0x08, 0x00, 0x2A, 
  0x0B, 0x01, 0x00, 0x31, 0x0B, 0x09, 0x01, 0x43, 0x08, 0x00, 0x00, 0x2A, 0x0C, 0x02, 0x00, 0x31, 
  0x0C, 0x0A, 0x02, 0x43, 0x0B, 0x00, 0x00, 0x31, 0x04, 0x09, 0x0A, 0x43, 0x0C, 0x00, 0x00, 0x2A, 
  0x0E, 0x02, 0x00, 0x31, 0x0E, 0x00, 0x09, 0x43, 0x0D, 0x00, 0x00, 0x31, 0x05, 0x09, 0x03, 0x43, 
  0x0E, 0x00, 0x00, 0x2A, 0x10, 0x03, 0x00, 0x31, 0x10, 0x09, 0x0E, 0x43, 0x0F, 0x00, 0x00, 0x2A, 
  0x10, 0x04, 0x00, 0x31, 0x10, 0x0C, 0x0D, 0x32, 0x06, 0x00, 0x00, 0x2F, 0x0F, 0x00, 0x00, 0x43, 
  0x0E, 0x00, 0x00, 0x2A, 0x0D, 0x05, 0x00, 0x31, 0x0D, 0x08, 0x0B, 0x2F, 0x0E, 0x00, 0x00, 0x43, 
  0x0C, 0x00, 0x00, 0x03, 0x0C, 0x00, 0x00, 0x81, 0x7E, 0x01, 0x02, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x2C, 0x05, 0x00, 0x00, 0x2F, 0x01, 
  0x00, 0x00, 0x2A, 0x07, 0x00, 0x00, 0x33, 0x06, 0x07, 0x00, 0x3B, 0x07, 0x06, 0x00, 0x19, 0x08, 
  0x07, 0x00, 0x3B, 0x07, 0x06, 0x01, 0x19, 0x09, 0x07, 0x00, 0x3B, 0x07, 0x06, 0x02, 0x19, 0x0A, 
  0x07, 0x00, 0x1C, 0x0A, 0x03, 0x00, 0x19, 0x06, 0x0A, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x29, 0x06, 
  0x01, 0x00, 0x2F, 0x02, 0x00, 0x00, 0x43, 0x07, 0x00, 0x00, 0x31, 0x00, 0x08, 0x09, 0x31, 0x06, 
  0x04, 0x03, 0x2F, 0x07, 0x00, 0x00, 0x2A, 0x0B, 0x01, 0x00, 0x34, 0x0B, 0x00, 0x00, 0x81, 0x8E, 
  0x01, 0x02, 0x1B, 0x00, 0x1B, 0x00, 0x1B, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x01, 0x26, 0x00, 0x26, 0x00, 0x26, 0x00, 0x26, 0x00, 0x40, 0x00, 0x40, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xD0, 0x08, 0x72, 0x61, 0x6E, 0x67, 0x65, 
  0x2D, 0x74, 0x6F, 0xD7, 0xCD, 0x00, 0x09, 0x00, 0x17, 0x06, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 
  0xFF, 0x00, 0x10, 0xCE, 0x02, 0x3C, 0x3D, 0x3D, 0x01, 0x00, 0x00, 0x22, 0x02, 0x01, 0x02, 0x1B, 
  0x02, 0x0A, 0x00, 0x3B, 0x03, 0x00, 0x00, 0x29, 0x05, 0x01, 0x00, 0x38, 0x04, 0x00, 0x05, 0x46, 
  0x02, 0x03, 0x04, 0x1C, 0x02, 0x07, 0x00, 0x05, 0x05, 0x05, 0x01, 0x19, 0x03, 0x04, 0x00, 0x23, 
  0x02, 0x05, 0x01, 0x1C, 0x02, 0xFA, 0xFF, 0x27, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x28, 
  0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0xD0, 0x04, 0x64, 0x6F, 0x77, 0x6E, 0xD7, 0xCD, 0x00, 
  0x09, 0x00, 0x0A, 0x06, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x13, 0xCE, 0x01, 0x2D, 
  0x3D, 0x01, 0x00, 0x00, 0x24, 0x02, 0x01, 0x00, 0x1C, 0x02, 0x03, 0x00, 0x29, 0x03, 0x00, 0x00, 
  0x03, 0x03, 0x00, 0x00, 0x24, 0x02, 0x01, 0x01, 0x1C, 0x02, 0x05, 0x00, 0x29, 0x03, 0x00, 0x00, 
  0x3B, 0x04, 0x00, 0x00, 0x07, 0x03, 0x03, 0x04, 0x03, 0x03, 0x00, 0x00, 0x3B, 0x03, 0x00, 0x00, 
  0x29, 0x05, 0x01, 0x00, 0x38, 0x04, 0x00, 0x05, 0x07, 0x03, 0x03, 0x04, 0x05, 0x05, 0x05, 0x01, 
  0x23, 0x02, 0x05, 0x01, 0x1C, 0x02, 0xFC, 0xFF, 0x03, 0x03, 0x00, 0x00, 0xDA, 0x81, 0x7D, 0xD0, 
  0x07, 0x64, 0x6F, 0x77, 0x6E, 0x2D, 0x74, 0x6F, 0xD7, 0xCD, 0x00, 0x09, 0x00, 0x16, 0x06, 0x00, 
  0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x10, 0xCE, 0x02, 0x3E, 0x3D, 0x3D, 0x01, 0x00, 0x00, 
  0x22, 0x02, 0x01, 0x02, 0x1B, 0x02, 0x0A, 0x00, 0x3B, 0x03, 0x00, 0x00, 0x29, 0x05, 0x01, 0x00, 
  0x38, 0x04, 0x00, 0x05, 0x45, 0x02, 0x03, 0x04, 0x1C, 0x02, 0x07, 0x00, 0x05, 0x05, 0x05, 0x01, 
  0x19, 0x03, 0x04, 0x00, 0x23, 0x02, 0x05, 0x01, 0x1C, 0x02, 0xFA, 0xFF, 0x27, 0x03, 0x00, 0x00, 
  0x03, 0x03, 0x00, 0x00, 0x28, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0xD0, 0x04, 0x6B, 0x65, 
  0x79, 0x73, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0E, 0x04, 0x04, 0x04, 0x0B, 0x3E, 0xCE, 0x0D, 
  0x6B, 0x65, 0x79, 0x73, 0x2D, 0x74, 0x65, 0x6D, 0x70, 0x6C, 0x61, 0x74, 0x65, 0xDA, 0x05, 0xDA, 
  0x22, 0xDA, 0x81, 0x63, 0xDA, 0x26, 0xD7, 0xCD, 0x00, 0x08, 0x00, 0x1C, 0x02, 0x02, 0x01, 0x02, 
  0x00, 0x02, 0xCE, 0x04, 0x6E, 0x65, 0x78, 0x74, 0x47, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, 
  0xDA, 0x81, 0x91, 0xD7, 0xCD, 0x00, 0x09, 0x00, 0x19, 0x06, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 
  0xFF, 0x00, 0x10, 0xCE, 0x04, 0x6E, 0x6F, 0x74, 0x3D, 0x3D, 0x01, 0x00, 0x00, 0x22, 0x02, 0x01, 
  0x02, 0x1B, 0x02, 0x0A, 0x00, 0x3B, 0x03, 0x00, 0x00, 0x29, 0x05, 0x01, 0x00, 0x38, 0x04, 0x00, 
  0x05, 0x23, 0x02, 0x03, 0x04, 0x1C, 0x02, 0x07, 0x00, 0x05, 0x05, 0x05, 0x01, 0x19, 0x03, 0x04, 
  0x00, 0x23, 0x02, 0x05, 0x01, 0x1C, 0x02, 0xFA, 0xFF, 0x28, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 
  0x00, 0x27, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0xCF, 0x02, 0x69, 0x6E, 0xCF, 0x05, 0x74, 
  0x75, 0x70, 0x6C, 0x65, 0xDA, 0x81, 0xA1, 0xDA, 0x81, 0x93, 0xDA, 0x2F, 0x2C, 0x04, 0x00, 0x00, 
  0x2A, 0x06, 0x00, 0x00, 0x33, 0x05, 0x06, 0x00, 0x19, 0x06, 0x05, 0x00, 0x2F, 0x01, 0x00, 0x00, 
  0x2A, 0x08, 0x01, 0x00, 0x33, 0x07, 0x08, 0x00, 0x1C, 0x07, 0x03, 0x00, 0x19, 0x05, 0x01, 0x00, 
  0x1A, 0x04, 0x00, 0x00, 0x2A, 0x09, 0x00, 0x00, 0x33, 0x08, 0x09, 0x00, 0x19, 0x05, 0x08, 0x00, 
  0x19, 0x07, 0x05, 0x00, 0x23, 0x08, 0x07, 0x01, 0x1C, 0x08, 0x03, 0x00, 0x26, 0x05, 0x00, 0x00, 
  0x1A, 0x05, 0x00, 0x00, 0x2A, 0x0A, 0x02, 0x00, 0x31, 0x0A, 0x07, 0x01, 0x43, 0x09, 0x00, 0x00, 
  0x19, 0x05, 0x09, 0x00, 0x2A, 0x09, 0x03, 0x00, 0x26, 0x0A, 0x00, 0x00, 0x31, 0x09, 0x07, 0x0A, 
  0x43, 0x08, 0x00, 0x00, 0x2A, 0x0A, 0x04, 0x00, 0x31, 0x0A, 0x06, 0x08, 0x43, 0x09, 0x00, 0x00, 
  0x2A, 0x0A, 0x05, 0x00, 0x26, 0x0B, 0x00, 0x00, 0x31, 0x0A, 0x0B, 0x06, 0x43, 0x08, 0x00, 0x00, 
  0x1C, 0x02, 0x09, 0x00, 0x2A, 0x0C, 0x06, 0x00, 0x31, 0x0C, 0x07, 0x06, 0x43, 0x0B, 0x00, 0x00, 
  0x2A, 0x0D, 0x07, 0x00, 0x31, 0x0D, 0x06, 0x0B, 0x43, 0x0C, 0x00, 0x00, 0x19, 0x0A, 0x0C, 0x00, 
  0x1A, 0x02, 0x00, 0x00, 0x19, 0x0A, 0x06, 0x00, 0x2A, 0x0C, 0x02, 0x00, 0x31, 0x0C, 0x00, 0x0A, 
  0x43, 0x0B, 0x00, 0x00, 0x2A, 0x0C, 0x03, 0x00, 0x31, 0x0C, 0x07, 0x06, 0x43, 0x0A, 0x00, 0x00, 
  0x2A, 0x0D, 0x08, 0x00, 0x31, 0x0D, 0x06, 0x0A, 0x43, 0x0C, 0x00, 0x00, 0x2A, 0x0D, 0x09, 0x00, 
  0x31, 0x0D, 0x08, 0x0B, 0x32, 0x03, 0x00, 0x00, 0x2F, 0x0C, 0x00, 0x00, 0x43, 0x0A, 0x00, 0x00, 
  0x2A, 0x0B, 0x0A, 0x00, 0x31, 0x0B, 0x05, 0x09, 0x2F, 0x0A, 0x00, 0x00, 0x43, 0x08, 0x00, 0x00, 
  0x03, 0x08, 0x00, 0x00, 0x81, 0x9F, 0x01, 0x02, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x11, 0x00, 
  0x11, 0x00, 0x11, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x25, 0x00, 0x25, 0x00, 0x0D, 0x00, 
  0x05, 0x02, 0x11, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x1B, 0x00, 0x1B, 0x00, 0x1B, 0x00, 
  0x09, 0xBF, 0xFF, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x04, 0x19, 0x00, 0x23, 0x00, 0x23, 0x00, 0x23, 
  0x00, 0x23, 0x00, 0x23, 0x00, 0x23, 0x00, 0x19, 0x00, 0x19, 0x00, 0x19, 0xBF, 0xFC, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0xD0, 0x05, 0x70, 0x61, 0x69, 0x72, 0x73, 0xD0, 0x02, 0x69, 0x6E, 0xD7, 0xCD, 
  0x00, 0x98, 0x00, 0x00, 0x0D, 0x03, 0x03, 0x03, 0x0A, 0x37, 0xCE, 0x0D, 0x65, 0x61, 0x63, 0x68, 
  0x2D, 0x74, 0x65, 0x6D, 0x70, 0x6C, 0x61, 0x74, 0x65, 0xDA, 0x05, 0xDA, 0x22, 0xDA, 0x81, 0x63, 
  0xDA, 0x26, 0xDA, 0x81, 0xB0, 0xDA, 0x81, 0x91, 0xDA, 0x81, 0xB2, 0xDA, 0x80, 0xFA, 0xDA, 0x81, 
  0xA1, 0xDA, 0x81, 0x93, 0xDA, 0x2F, 0x2C, 0x03, 0x00, 0x00, 0x2A, 0x05, 0x00, 0x00, 0x33, 0x04, 
  0x05, 0x00, 0x19, 0x05, 0x04, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x07, 0x01, 0x00, 0x33, 0x06, 
  0x07, 0x00, 0x1C, 0x06, 0x03, 0x00, 0x19, 0x04, 0x01, 0x00, 0x1A, 0x04, 0x00, 0x00, 0x2A, 0x08, 
  0x00, 0x00, 0x33, 0x07, 0x08, 0x00, 0x19, 0x04, 0x07, 0x00, 0x19, 0x06, 0x04, 0x00, 0x23, 0x07, 
  0x06, 0x01, 0x1C, 0x07, 0x03, 0x00, 0x26, 0x04, 0x00, 0x00, 0x1A, 0x05, 0x00, 0x00, 0x2A, 0x09, 
  0x02, 0x00, 0x31, 0x09, 0x06, 0x01, 0x43, 0x08, 0x00, 0x00, 0x19, 0x04, 0x08, 0x00, 0x2A, 0x08, 
  0x03, 0x00, 0x26, 0x09, 0x00, 0x00, 0x31, 0x08, 0x06, 0x09, 0x43, 0x07, 0x00, 0x00, 0x2A, 0x09, 
  0x04, 0x00, 0x31, 0x09, 0x05, 0x07, 0x43, 0x08, 0x00, 0x00, 0x2A, 0x09, 0x05, 0x00, 0x26, 0x0A, 
  0x00, 0x00, 0x31, 0x09, 0x0A, 0x05, 0x43, 0x07, 0x00, 0x00, 0x2A, 0x0A, 0x06, 0x00, 0x31, 0x0A, 
  0x06, 0x05, 0x43, 0x09, 0x00, 0x00, 0x2A, 0x0B, 0x02, 0x00, 0x31, 0x0B, 0x00, 0x09, 0x43, 0x0A, 
  0x00, 0x00, 0x2A, 0x0B, 0x03, 0x00, 0x31, 0x0B, 0x06, 0x05, 0x43, 0x09, 0x00, 0x00, 0x2A, 0x0C, 
  0x07, 0x00, 0x31, 0x0C, 0x05, 0x09, 0x43, 0x0B, 0x00, 0x00, 0x2A, 0x0C, 0x08, 0x00, 0x31, 0x0C, 
  0x07, 0x0A, 0x32, 0x02, 0x00, 0x00, 0x2F, 0x0B, 0x00, 0x00, 0x43, 0x09, 0x00, 0x00, 0x2A, 0x0A, 
  0x09, 0x00, 0x31, 0x0A, 0x04, 0x08, 0x2F, 0x09, 0x00, 0x00, 0x43, 0x07, 0x00, 0x00, 0x03, 0x07, 
  0x00, 0x00, 0x81, 0x93, 0x01, 0x02, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x11, 0x00, 0x11, 0x00, 
  0x11, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x27, 0x00, 0x27, 0x00, 0x0D, 0x00, 0x05, 0x02, 
  0x11, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0x09, 0xBF, 
  0xFF, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0xD0, 0x07, 0x69, 0x74, 0x65, 0x72, 0x61, 0x74, 0x65, 0xD7, 0xCD, 0x00, 0x98, 0x00, 
  0x00, 0x0A, 0x03, 0x03, 0x03, 0x06, 0x16, 0xCE, 0x10, 0x69, 0x74, 0x65, 0x72, 0x61, 0x74, 0x65, 
  0x2D, 0x74, 0x65, 0x6D, 0x70, 0x6C, 0x61, 0x74, 0x65, 0xDA, 0x05, 0xDA, 0x22, 0xDA, 0x81, 0x91, 
  0xDA, 0x81, 0xA1, 0xDA, 0x26, 0xDA, 0x81, 0x93, 0xDA, 0x2F, 0x2C, 0x03, 0x00, 0x00, 0x2A, 0x05, 
  0x00, 0x00, 0x33, 0x04, 0x05, 0x00, 0x19, 0x05, 0x04, 0x00, 0x2A, 0x06, 0x01, 0x00, 0x26, 0x07, 
  0x00, 0x00, 0x31, 0x06, 0x05, 0x07, 0x43, 0x04, 0x00, 0x00, 0x2A, 0x07, 0x02, 0x00, 0x31, 0x07, 
  0x05, 0x01, 0x43, 0x06, 0x00, 0x00, 0x2A, 0x08, 0x03, 0x00, 0x31, 0x08, 0x00, 0x05, 0x43, 0x07, 
  0x00, 0x00, 0x2A, 0x09, 0x04, 0x00, 0x31, 0x09, 0x06, 0x07, 0x2F, 0x02, 0x00, 0x00, 0x43, 0x08, 
  0x00, 0x00, 0x2A, 0x07, 0x05, 0x00, 0x31, 0x07, 0x04, 0x08, 0x43, 0x06, 0x00, 0x00, 0x03, 0x06, 
  0x00, 0x00, 0x81, 0xAB, 0x01, 0x02, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xD0, 
  0x08, 0x67, 0x65, 0x6E, 0x65, 0x72, 0x61, 0x74, 0x65, 0xDA, 0x28, 0xDA, 0x26, 0xDA, 0x29, 0xDA, 
  0x2A, 0xDA, 0x2B, 0xCE, 0x15, 0x75, 0x6E, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 
  0x6C, 0x6F, 0x6F, 0x70, 0x20, 0x76, 0x65, 0x72, 0x62, 0x20, 0x2C, 0x03, 0x00, 0x00, 0x3D, 0x04, 
  0x01, 0x00, 0x46, 0x05, 0x04, 0x02, 0x1C, 0x05, 0x07, 0x00, 0x2A, 0x06, 0x00, 0x00, 0x2F, 0x06, 
  0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x43, 0x04, 0x00, 0x00, 0x03, 0x04, 0x00, 0x00, 0x1A, 0x01, 
  0x00, 0x00, 0x29, 0x06, 0x01, 0x00, 0x06, 0x05, 0x02, 0x06, 0x38, 0x04, 0x01, 0x05, 0x19, 0x06, 
  0x04, 0x00, 0x38, 0x04, 0x01, 0x02, 0x19, 0x07, 0x04, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x2A, 0x08, 
  0x01, 0x00, 0x33, 0x04, 0x08, 0x00, 0x1C, 0x04, 0x66, 0x00, 0x29, 0x09, 0x02, 0x00, 0x06, 0x08, 
  0x02, 0x09, 0x31, 0x00, 0x01, 0x08, 0x33, 0x09, 0x03, 0x00, 0x19, 0x08, 0x09, 0x00, 0x2A, 0x0A, 
  0x02, 0x00, 0x23, 0x09, 0x07, 0x0A, 0x1C, 0x09, 0x0D, 0x00, 0x2A, 0x0B, 0x03, 0x00, 0x2F, 0x0B, 
  0x00, 0x00, 0x43, 0x0A, 0x00, 0x00, 0x2A, 0x0C, 0x04, 0x00, 0x31, 0x0C, 0x06, 0x0A, 0x26, 0x0C, 
  0x00, 0x00, 0x2F, 0x0C, 0x00, 0x00, 0x43, 0x0B, 0x00, 0x00, 0x2A, 0x0C, 0x00, 0x00, 0x31, 0x0C, 
  0x0B, 0x08, 0x43, 0x0A, 0x00, 0x00, 0x03, 0x0A, 0x00, 0x00, 0x2A, 0x0B, 0x05, 0x00, 0x23, 0x0A, 
  0x07, 0x0B, 0x1C, 0x0A, 0x0D, 0x00, 0x2A, 0x0C, 0x03, 0x00, 0x2F, 0x0C, 0x00, 0x00, 0x43, 0x0B, 
  0x00, 0x00, 0x2A, 0x0D, 0x04, 0x00, 0x26, 0x0E, 0x00, 0x00, 0x31, 0x0D, 0x06, 0x0E, 0x2F, 0x0B, 
  0x00, 0x00, 0x43, 0x0C, 0x00, 0x00, 0x2A, 0x0D, 0x00, 0x00, 0x31, 0x0D, 0x0C, 0x08, 0x43, 0x0B, 
  0x00, 0x00, 0x03, 0x0B, 0x00, 0x00, 0x2A, 0x0C, 0x06, 0x00, 0x23, 0x0B, 0x07, 0x0C, 0x1C, 0x0B, 
  0x08, 0x00, 0x2A, 0x0D, 0x00, 0x00, 0x30, 0x0D, 0x08, 0x00, 0x43, 0x0C, 0x00, 0x00, 0x2A, 0x0E, 
  0x07, 0x00, 0x31, 0x0E, 0x06, 0x0C, 0x43, 0x0D, 0x00, 0x00, 0x03, 0x0D, 0x00, 0x00, 0x2A, 0x0D, 
  0x08, 0x00, 0x23, 0x0C, 0x07, 0x0D, 0x1C, 0x0C, 0x07, 0x00, 0x2A, 0x0E, 0x00, 0x00, 0x31, 0x0E, 
  0x08, 0x06, 0x26, 0x0E, 0x00, 0x00, 0x2F, 0x0E, 0x00, 0x00, 0x43, 0x0D, 0x00, 0x00, 0x03, 0x0D, 
  0x00, 0x00, 0x2A, 0x0E, 0x09, 0x00, 0x23, 0x0D, 0x07, 0x0E, 0x1C, 0x0D, 0x07, 0x00, 0x2A, 0x0F, 
  0x00, 0x00, 0x31, 0x0F, 0x06, 0x08, 0x26, 0x0F, 0x00, 0x00, 0x2F, 0x0F, 0x00, 0x00, 0x43, 0x0E, 
  0x00, 0x00, 0x03, 0x0E, 0x00, 0x00, 0x2A, 0x0F, 0x0A, 0x00, 0x23, 0x0E, 0x07, 0x0F, 0x1C, 0x0E, 
  0x16, 0x00, 0x2A, 0x10, 0x0B, 0x00, 0x33, 0x0F, 0x10, 0x00, 0x19, 0x10, 0x0F, 0x00, 0x2A, 0x11, 
  0x0C, 0x00, 0x31, 0x11, 0x10, 0x06, 0x43, 0x0F, 0x00, 0x00, 0x2A, 0x12, 0x0D, 0x00, 0x29, 0x13, 
  0x00, 0x00, 0x31, 0x12, 0x10, 0x13, 0x43, 0x11, 0x00, 0x00, 0x2A, 0x13, 0x0E, 0x00, 0x30, 0x13, 
  0x10, 0x00, 0x43, 0x12, 0x00, 0x00, 0x2A, 0x14, 0x0F, 0x00, 0x31, 0x14, 0x11, 0x08, 0x2F, 0x12, 
  0x00, 0x00, 0x43, 0x13, 0x00, 0x00, 0x2A, 0x12, 0x00, 0x00, 0x31, 0x12, 0x0F, 0x13, 0x43, 0x11, 
  0x00, 0x00, 0x03, 0x11, 0x00, 0x00, 0x2A, 0x10, 0x10, 0x00, 0x23, 0x0F, 0x07, 0x10, 0x1C, 0x0F, 
  0x05, 0x00, 0x2A, 0x11, 0x11, 0x00, 0x31, 0x11, 0x06, 0x08, 0x43, 0x10, 0x00, 0x00, 0x03, 0x10, 
  0x00, 0x00, 0x2A, 0x10, 0x12, 0x00, 0x30, 0x10, 0x07, 0x00, 0x2A, 0x11, 0x13, 0x00, 0x33, 0x10, 
  0x11, 0x00, 0x01, 0x10, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x29, 0x09, 
  0x02, 0x00, 0x06, 0x08, 0x02, 0x09, 0x38, 0x04, 0x01, 0x08, 0x19, 0x09, 0x04, 0x00, 0x29, 0x0A, 
  0x03, 0x00, 0x06, 0x04, 0x02, 0x0A, 0x31, 0x00, 0x01, 0x04, 0x33, 0x0A, 0x03, 0x00, 0x19, 0x04, 
  0x0A, 0x00, 0x2A, 0x0B, 0x14, 0x00, 0x23, 0x0A, 0x06, 0x0B, 0x1C, 0x0A, 0x07, 0x00, 0x31, 0x07, 
  0x09, 0x04, 0x2A, 0x0B, 0x15, 0x00, 0x2A, 0x0C, 0x16, 0x00, 0x30, 0x0B, 0x0C, 0x00, 0x2A, 0x0B, 
  0x17, 0x00, 0x34, 0x0B, 0x00, 0x00, 0x2A, 0x0C, 0x18, 0x00, 0x23, 0x0B, 0x06, 0x0C, 0x1C, 0x0B, 
  0x07, 0x00, 0x31, 0x07, 0x09, 0x04, 0x2A, 0x0C, 0x15, 0x00, 0x2A, 0x0D, 0x19, 0x00, 0x30, 0x0C, 
  0x0D, 0x00, 0x2A, 0x0C, 0x17, 0x00, 0x34, 0x0C, 0x00, 0x00, 0x2A, 0x0D, 0x1A, 0x00, 0x23, 0x0C, 
  0x06, 0x0D, 0x1C, 0x0C, 0x07, 0x00, 0x31, 0x07, 0x09, 0x04, 0x2A, 0x0D, 0x1B, 0x00, 0x2A, 0x0E, 
  0x1C, 0x00, 0x30, 0x0D, 0x0E, 0x00, 0x2A, 0x0D, 0x17, 0x00, 0x34, 0x0D, 0x00, 0x00, 0x2A, 0x0E, 
  0x1D, 0x00, 0x23, 0x0D, 0x06, 0x0E, 0x1C, 0x0D, 0x07, 0x00, 0x31, 0x07, 0x09, 0x04, 0x2A, 0x0E, 
  0x1B, 0x00, 0x2A, 0x0F, 0x1E, 0x00, 0x30, 0x0E, 0x0F, 0x00, 0x2A, 0x0E, 0x17, 0x00, 0x34, 0x0E, 
  0x00, 0x00, 0x2A, 0x0F, 0x1F, 0x00, 0x23, 0x0E, 0x06, 0x0F, 0x1C, 0x0E, 0x08, 0x00, 0x2F, 0x04, 
  0x00, 0x00, 0x43, 0x0F, 0x00, 0x00, 0x28, 0x10, 0x00, 0x00, 0x31, 0x07, 0x09, 0x10, 0x2F, 0x0F, 
  0x00, 0x00, 0x2A, 0x10, 0x20, 0x00, 0x34, 0x10, 0x00, 0x00, 0x2A, 0x10, 0x21, 0x00, 0x23, 0x0F, 
  0x06, 0x10, 0x1C, 0x0F, 0x08, 0x00, 0x2F, 0x04, 0x00, 0x00, 0x43, 0x10, 0x00, 0x00, 0x27, 0x11, 
  0x00, 0x00, 0x31, 0x07, 0x09, 0x11, 0x2F, 0x10, 0x00, 0x00, 0x2A, 0x11, 0x20, 0x00, 0x34, 0x11, 
  0x00, 0x00, 0x2A, 0x11, 0x22, 0x00, 0x23, 0x10, 0x06, 0x11, 0x1C, 0x10, 0x06, 0x00, 0x2F, 0x04, 
  0x00, 0x00, 0x43, 0x11, 0x00, 0x00, 0x31, 0x07, 0x09, 0x11, 0x2A, 0x12, 0x23, 0x00, 0x34, 0x12, 
  0x00, 0x00, 0x2A, 0x12, 0x24, 0x00, 0x23, 0x11, 0x06, 0x12, 0x1C, 0x11, 0x04, 0x00, 0x31, 0x07, 
  0x09, 0x04, 0x2A, 0x12, 0x25, 0x00, 0x34, 0x12, 0x00, 0x00, 0x2A, 0x13, 0x26, 0x00, 0x23, 0x12, 
  0x06, 0x13, 0x1C, 0x12, 0x25, 0x00, 0x2A, 0x14, 0x0B, 0x00, 0x33, 0x13, 0x14, 0x00, 0x19, 0x14, 
  0x13, 0x00, 0x2A, 0x15, 0x0B, 0x00, 0x33, 0x13, 0x15, 0x00, 0x19, 0x15, 0x13, 0x00, 0x30, 0x14, 
  0x09, 0x00, 0x44, 0x13, 0x00, 0x00, 0x2A, 0x17, 0x27, 0x00, 0x30, 0x17, 0x14, 0x00, 0x43, 0x16, 
  0x00, 0x00, 0x2A, 0x18, 0x28, 0x00, 0x31, 0x18, 0x07, 0x16, 0x43, 0x17, 0x00, 0x00, 0x2A, 0x18, 
  0x29, 0x00, 0x30, 0x18, 0x14, 0x00, 0x43, 0x16, 0x00, 0x00, 0x2A, 0x19, 0x2A, 0x00, 0x2A, 0x1A, 
  0x2B, 0x00, 0x31, 0x19, 0x1A, 0x16, 0x43, 0x18, 0x00, 0x00, 0x2A, 0x19, 0x03, 0x00, 0x2F, 0x19, 
  0x00, 0x00, 0x43, 0x16, 0x00, 0x00, 0x2A, 0x1A, 0x04, 0x00, 0x31, 0x1A, 0x18, 0x16, 0x43, 0x19, 
  0x00, 0x00, 0x2A, 0x18, 0x0F, 0x00, 0x27, 0x1A, 0x00, 0x00, 0x31, 0x18, 0x1A, 0x17, 0x30, 0x19, 
  0x04, 0x00, 0x43, 0x16, 0x00, 0x00, 0x2A, 0x18, 0x07, 0x00, 0x31, 0x18, 0x13, 0x16, 0x43, 0x17, 
  0x00, 0x00, 0x03, 0x17, 0x00, 0x00, 0x2A, 0x13, 0x2C, 0x00, 0x30, 0x13, 0x06, 0x00, 0x2A, 0x14, 
  0x13, 0x00, 0x33, 0x13, 0x14, 0x00, 0x01, 0x13, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x81, 0xB4, 
  0x01, 0x04, 0x0D, 0x00, 0x09, 0x00, 0x03, 0x01, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 
  0x0C, 0xBF, 0xFF, 0x03, 0x04, 0x09, 0x00, 0x09, 0xBF, 0xFF, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x04, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x03, 0x02, 0x23, 0x00, 0x23, 0x00, 0x12, 0x00, 
  0x12, 0x00, 0x07, 0x01, 0x09, 0x00, 0x09, 0x00, 0x09, 0x01, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 
  0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 
  0x12, 0xBF, 0xFF, 0x09, 0x00, 0x09, 0x00, 0x09, 0x02, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 
  0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 
  0xBF, 0xFE, 0x09, 0x00, 0x09, 0x00, 0x09, 0x03, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 
  0x10, 0x00, 0x10, 0x00, 0x10, 0xBF, 0xFD, 0x09, 0x00, 0x09, 0x00, 0x09, 0x04, 0x12, 0x00, 0x12, 
  0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0xBF, 0xFC, 0x09, 0x00, 0x09, 0x00, 0x09, 0x05, 
  0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0xBF, 0xFB, 0x09, 0x00, 0x09, 
  0x00, 0x09, 0x06, 0x13, 0x00, 0x13, 0x00, 0x13, 0x01, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 
  0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 
  0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0xBF, 0xF9, 0x09, 0x00, 
  0x09, 0x00, 0x09, 0x08, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x01, 0x12, 0x00, 0x12, 0x00, 
  0x12, 0x00, 0x12, 0x00, 0x0B, 0x00, 0x0B, 0xBF, 0xF4, 0x03, 0x0F, 0x09, 0x00, 0x09, 0x00, 0x03, 
  0x00, 0x03, 0x01, 0x1F, 0x00, 0x1F, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x03, 0x01, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x01, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0xBF, 0xFF, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x02, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 
  0x11, 0xBF, 0xFE, 0x05, 0x00, 0x05, 0x00, 0x05, 0x03, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 
  0x00, 0x0D, 0x00, 0x0D, 0xBF, 0xFD, 0x05, 0x00, 0x05, 0x00, 0x05, 0x04, 0x10, 0x00, 0x10, 0x00, 
  0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0xBF, 0xFC, 0x05, 0x00, 0x05, 0x00, 0x05, 0x05, 0x31, 
  0x00, 0x31, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0xBF, 0xFB, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x06, 0x31, 0x00, 0x31, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 
  0x0E, 0xBF, 0xFA, 0x05, 0x00, 0x05, 0x00, 0x05, 0x07, 0x29, 0x00, 0x29, 0x00, 0x0B, 0x00, 0x0B, 
  0x00, 0x0B, 0xBF, 0xF9, 0x05, 0x00, 0x05, 0x00, 0x05, 0x08, 0x10, 0x00, 0x10, 0x00, 0x10, 0xBF, 
  0xF8, 0x05, 0x00, 0x05, 0x00, 0x05, 0x09, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 
  0x00, 0x11, 0x01, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 
  0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 
  0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 
  0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x05, 0x0E, 
  0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x07, 0x00, 0x07, 0x2C, 0x02, 0x00, 0x00, 0x29, 0x03, 
  0x00, 0x00, 0x31, 0x01, 0x00, 0x03, 0x2A, 0x03, 0x00, 0x00, 0x34, 0x03, 0x00, 0x00, 0x81, 0xF5, 
  0x01, 0x23, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x0B, 0x73, 0x74, 0x72, 0x69, 0x6E, 
  0x67, 0x2F, 0x6A, 0x6F, 0x69, 0x6E, 0xD8, 0x0B, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x6A, 
  0x6F, 0x69, 0x6E, 0xCF, 0x0A, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x67, 0x61, 0x6D, 0x6D, 0x61, 0xD8, 
  0x0A, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x67, 0x61, 0x6D, 0x6D, 0x61, 0xCF, 0x09, 0x6D, 0x61, 0x74, 
  0x68, 0x2F, 0x61, 0x73, 0x69, 0x6E, 0xD8, 0x09, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x61, 0x73, 0x69, 
  0x6E, 0xCF, 0x06, 0x66, 0x69, 0x62, 0x65, 0x72, 0x3F, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 
  0x01, 0x01, 0x01, 0x02, 0x07, 0xCE, 0x06, 0x66, 0x69, 0x62, 0x65, 0x72, 0x3F, 0xDA, 0x05, 0xDA, 
  0x39, 0xDA, 0x81, 0x02, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 
  0x33, 0x02, 0x03, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x23, 0x03, 0x02, 0x04, 0x03, 0x03, 0x00, 0x00, 
  0x59, 0x01, 0x00, 0x2E, 0x00, 0x2E, 0x00, 0x2E, 0x00, 0x2B, 0x00, 0x2B, 0x00, 0x2B, 0xCF, 0x12, 
  0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x72, 0x65, 0x70, 0x6C, 0x61, 0x63, 0x65, 0x2D, 0x61, 
  0x6C, 0x6C, 0xD8, 0x12, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x72, 0x65, 0x70, 0x6C, 0x61, 
  0x63, 0x65, 0x2D, 0x61, 0x6C, 0x6C, 0xCF, 0x04, 0x6B, 0x65, 0x79, 0x73, 0xDA, 0x56, 0xCF, 0x0F, 
  0x6D, 0x61, 0x74, 0x68, 0x2F, 0x72, 0x6E, 0x67, 0x2D, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0xD8, 
  0x0F, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x72, 0x6E, 0x67, 0x2D, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 
  0xCF, 0x07, 0x67, 0x65, 0x74, 0x6C, 0x69, 0x6E, 0x65, 0xDA, 0x80, 0xFB, 0xCF, 0x04, 0x6B, 0x65, 
  0x65, 0x70, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0A, 0x02, 0x02, 0x02, 0x01, 0x14, 0xCE, 0x04, 
  0x6B, 0x65, 0x65, 0x70, 0xDA, 0x05, 0xDA, 0x52, 0x2C, 0x02, 0x00, 0x00, 0x3E, 0x03, 0x00, 0x00, 
  0x19, 0x04, 0x03, 0x00, 0x26, 0x06, 0x00, 0x00, 0x47, 0x05, 0x01, 0x06, 0x19, 0x06, 0x05, 0x00, 
  0x1D, 0x06, 0x0D, 0x00, 0x38, 0x05, 0x01, 0x06, 0x19, 0x07, 0x05, 0x00, 0x2F, 0x07, 0x00, 0x00, 
  0x33, 0x05, 0x00, 0x00, 0x19, 0x08, 0x05, 0x00, 0x1C, 0x08, 0x05, 0x00, 0x30, 0x04, 0x08, 0x00, 
  0x2A, 0x09, 0x00, 0x00, 0x33, 0x05, 0x09, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x47, 0x06, 0x01, 0x06, 
  0x1A, 0xF4, 0xFF, 0xFF, 0x03, 0x04, 0x00, 0x00, 0x83, 0x75, 0x01, 0x04, 0x03, 0x00, 0x03, 0x01, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x10, 0x00, 0x10, 0x00, 
  0x05, 0x00, 0x05, 0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xFF, 0x05, 0xBF, 0xFF, 0x03, 0x00, 
  0x03, 0xBF, 0xFB, 0x01, 0xCF, 0x04, 0x66, 0x69, 0x6E, 0x64, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 
  0x07, 0x02, 0x02, 0x02, 0x01, 0x0B, 0xCE, 0x04, 0x66, 0x69, 0x6E, 0x64, 0xDA, 0x05, 0xDA, 0x81, 
  0x21, 0x2C, 0x02, 0x00, 0x00, 0x30, 0x00, 0x01, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 
  0x00, 0x19, 0x04, 0x03, 0x00, 0x26, 0x06, 0x00, 0x00, 0x23, 0x05, 0x04, 0x06, 0x1C, 0x05, 0x02, 
  0x00, 0x04, 0x00, 0x00, 0x00, 0x38, 0x06, 0x01, 0x04, 0x03, 0x06, 0x00, 0x00, 0x83, 0xA2, 0x01, 
  0x05, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x07, 0x00, 0x07, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x15, 0x00, 0x15, 0xCF, 0x07, 0x66, 0x6C, 0x61, 0x74, 0x74, 0x65, 0x6E, 0xD7, 0xCD, 0x00, 
  0x98, 0x00, 0x00, 0x04, 0x01, 0x01, 0x01, 0x01, 0x05, 0xCE, 0x07, 0x66, 0x6C, 0x61, 0x74, 0x74, 
  0x65, 0x6E, 0xDA, 0x05, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x08, 0x02, 0x02, 0x02, 0x02, 0x14, 
  0xCE, 0x0C, 0x66, 0x6C, 0x61, 0x74, 0x74, 0x65, 0x6E, 0x2D, 0x69, 0x6E, 0x74, 0x6F, 0xDA, 0x05, 
  0xDA, 0x81, 0x9D, 0xDA, 0x52, 0x2C, 0x02, 0x00, 0x00, 0x26, 0x04, 0x00, 0x00, 0x47, 0x03, 0x01, 
  0x04, 0x19, 0x04, 0x03, 0x00, 0x1D, 0x04, 0x0F, 0x00, 0x38, 0x03, 0x01, 0x04, 0x19, 0x05, 0x03, 
  0x00, 0x2F, 0x05, 0x00, 0x00, 0x2A, 0x06, 0x00, 0x00, 0x33, 0x03, 0x06, 0x00, 0x1C, 0x03, 0x04, 
  0x00, 0x30, 0x00, 0x05, 0x00, 0x33, 0x06, 0x02, 0x00, 0x1A, 0x04, 0x00, 0x00, 0x30, 0x00, 0x05, 
  0x00, 0x2A, 0x07, 0x01, 0x00, 0x33, 0x06, 0x07, 0x00, 0x47, 0x04, 0x01, 0x04, 0x1A, 0xF2, 0xFF, 
  0xFF, 0x03, 0x00, 0x00, 0x00, 0x85, 0x56, 0x01, 0x04, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x01, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x05, 0x01, 0x07, 0x00, 0x07, 
  0xBF, 0xFF, 0x05, 0x02, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xFD, 0x03, 0x00, 0x03, 0xBF, 0xFC, 
  0x01, 0x2C, 0x01, 0x00, 0x00, 0x3E, 0x02, 0x00, 0x00, 0x30, 0x02, 0x00, 0x00, 0x2A, 0x03, 0x00, 
  0x00, 0x34, 0x03, 0x00, 0x00, 0x85, 0x60, 0x01, 0x04, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0xCF, 0x07, 0x63, 0x6F, 0x6D, 0x6D, 0x65, 0x6E, 0x74, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x01, 
  0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x02, 0xCE, 0x07, 0x63, 0x6F, 0x6D, 0x6D, 0x65, 
  0x6E, 0x74, 0xDA, 0x05, 0x2C, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x80, 0x9B, 0x01, 0x00, 
  0x01, 0xCF, 0x08, 0x6F, 0x73, 0x2F, 0x74, 0x6F, 0x75, 0x63, 0x68, 0xD8, 0x08, 0x6F, 0x73, 0x2F, 
  0x74, 0x6F, 0x75, 0x63, 0x68, 0xCF, 0x05, 0x64, 0x65, 0x66, 0x6E, 0x2D, 0xD7, 0xCD, 0x00, 0x99, 
  0x00, 0x00, 0x04, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x02, 0x06, 0xCE, 0x05, 0x64, 0x65, 
  0x66, 0x6E, 0x2D, 0xDA, 0x05, 0xDA, 0x65, 0xDA, 0x74, 0x2C, 0x02, 0x00, 0x00, 0x2A, 0x03, 0x00, 
  0x00, 0x30, 0x00, 0x03, 0x00, 0x32, 0x01, 0x00, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x34, 0x03, 0x00, 
  0x00, 0x33, 0x01, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x04, 0x6E, 
  0x69, 0x6C, 0x3F, 0xDA, 0x81, 0x23, 0xCF, 0x0A, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x2F, 0x6E, 
  0x65, 0x77, 0xD8, 0x0A, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x2F, 0x6E, 0x65, 0x77, 0xCF, 0x0A, 
  0x64, 0x6F, 0x63, 0x2D, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0xD7, 0xCD, 0x02, 0xBA, 0x00, 0x00, 
  0x13, 0x02, 0x01, 0x02, 0x08, 0x4F, 0x01, 0xCE, 0x0A, 0x64, 0x6F, 0x63, 0x2D, 0x66, 0x6F, 0x72, 
  0x6D, 0x61, 0x74, 0xDA, 0x05, 0xD0, 0x09, 0x64, 0x6F, 0x63, 0x2D, 0x77, 0x69, 0x64, 0x74, 0x68, 
  0xDA, 0x7D, 0xCE, 0x04, 0x20, 0x20, 0x20, 0x20, 0xDA, 0x67, 0xCE, 0x02, 0x20, 0x20, 0xDA, 0x6B, 
  0xD8, 0x10, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x70, 0x75, 0x73, 0x68, 0x2D, 0x62, 0x79, 
  0x74, 0x65, 0xDA, 0x80, 0xC4, 0x2C, 0x02, 0x00, 0x00, 0x1C, 0x01, 0x03, 0x00, 0x19, 0x03, 0x01, 
  0x00, 0x1A, 0x07, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x29, 0x05, 0x50, 0x00, 0x30, 0x04, 0x05, 
  0x00, 0x2A, 0x05, 0x01, 0x00, 0x33, 0x04, 0x05, 0x00, 0x19, 0x03, 0x04, 0x00, 0x29, 0x05, 0x08, 
  0x00, 0x07, 0x04, 0x03, 0x05, 0x19, 0x03, 0x04, 0x00, 0x2A, 0x05, 0x02, 0x00, 0x2F, 0x05, 0x00, 
  0x00, 0x3F, 0x05, 0x00, 0x00, 0x19, 0x06, 0x05, 0x00, 0x2A, 0x07, 0x03, 0x00, 0x2F, 0x07, 0x00, 
  0x00, 0x3F, 0x07, 0x00, 0x00, 0x19, 0x08, 0x07, 0x00, 0x29, 0x09, 0x00, 0x00, 0x2E, 0x0A, 0x00, 
  0x00, 0x19, 0x0B, 0x0A, 0x00, 0x26, 0x0D, 0x00, 0x00, 0x47, 0x0C, 0x00, 0x0D, 0x19, 0x0D, 0x0C, 
  0x00, 0x1D, 0x0D, 0x32, 0x00, 0x38, 0x0C, 0x00, 0x0D, 0x19, 0x0E, 0x0C, 0x00, 0x29, 0x10, 0x0A, 
  0x00, 0x23, 0x0F, 0x0E, 0x10, 0x1B, 0x0F, 0x03, 0x00, 0x27, 0x0F, 0x00, 0x00, 0x1A, 0x02, 0x00, 
  0x00, 0x28, 0x0F, 0x00, 0x00, 0x19, 0x10, 0x0F, 0x00, 0x1C, 0x0F, 0x09, 0x00, 0x29, 0x12, 0x20, 
  0x00, 0x23, 0x11, 0x0E, 0x12, 0x1B, 0x11, 0x03, 0x00, 0x27, 0x11, 0x00, 0x00, 0x1A, 0x02, 0x00, 
  0x00, 0x28, 0x11, 0x00, 0x00, 0x19, 0x0C, 0x11, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x0C, 0x10, 
  0x00, 0x1C, 0x0C, 0x0D, 0x00, 0x29, 0x10, 0x09, 0x00, 0x23, 0x0F, 0x0E, 0x10, 0x1C, 0x0F, 0x06, 
  0x00, 0x2A, 0x10, 0x04, 0x00, 0x30, 0x08, 0x10, 0x00, 0x2A, 0x11, 0x05, 0x00, 0x33, 0x10, 0x11, 
  0x00, 0x1A, 0x04, 0x00, 0x00, 0x30, 0x08, 0x0E, 0x00, 0x2A, 0x11, 0x06, 0x00, 0x33, 0x10, 0x11, 
  0x00, 0x1A, 0x10, 0x00, 0x00, 0x3D, 0x0F, 0x08, 0x00, 0x29, 0x11, 0x00, 0x00, 0x1F, 0x10, 0x0F, 
  0x11, 0x1C, 0x10, 0x03, 0x00, 0x33, 0x0F, 0x0B, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x29, 0x10, 0x0A, 
  0x00, 0x23, 0x0F, 0x0E, 0x10, 0x1C, 0x0F, 0x07, 0x00, 0x2A, 0x10, 0x07, 0x00, 0x30, 0x06, 0x10, 
  0x00, 0x2A, 0x11, 0x05, 0x00, 0x33, 0x10, 0x11, 0x00, 0x29, 0x09, 0x00, 0x00, 0x1A, 0x01, 0x00, 
  0x00, 0x47, 0x0D, 0x00, 0x0D, 0x1A, 0xCF, 0xFF, 0xFF, 0x33, 0x0C, 0x0B, 0x00, 0x03, 0x06, 0x00, 
  0x00, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04, 0x2B, 0x01, 0xCE, 0x08, 0x70, 
  0x75, 0x73, 0x68, 0x77, 0x6F, 0x72, 0x64, 0xDA, 0x05, 0xDA, 0x80, 0xC4, 0xDA, 0x6A, 0xDA, 0x6B, 
  0xDA, 0x80, 0xEF, 0x2C, 0x00, 0x00, 0x00, 0x2B, 0x01, 0x00, 0x09, 0x2B, 0x04, 0x00, 0x08, 0x3D, 
  0x03, 0x04, 0x00, 0x2B, 0x05, 0x00, 0x09, 0x06, 0x04, 0x05, 0x03, 0x29, 0x05, 0x01, 0x00, 0x06, 
  0x04, 0x04, 0x05, 0x2B, 0x05, 0x00, 0x03, 0x46, 0x03, 0x05, 0x04, 0x1C, 0x03, 0x05, 0x00, 0x29, 
  0x04, 0x00, 0x00, 0x2D, 0x04, 0x00, 0x09, 0x2A, 0x02, 0x00, 0x00, 0x1A, 0x06, 0x00, 0x00, 0x2B, 
  0x05, 0x00, 0x09, 0x29, 0x06, 0x01, 0x00, 0x06, 0x04, 0x05, 0x06, 0x2D, 0x04, 0x00, 0x09, 0x2A, 
  0x02, 0x01, 0x00, 0x19, 0x03, 0x02, 0x00, 0x2B, 0x05, 0x00, 0x08, 0x3D, 0x04, 0x05, 0x00, 0x2B, 
  0x06, 0x00, 0x09, 0x06, 0x05, 0x06, 0x04, 0x2D, 0x05, 0x00, 0x09, 0x29, 0x06, 0x00, 0x00, 0x1F, 
  0x04, 0x01, 0x06, 0x1C, 0x04, 0x06, 0x00, 0x2B, 0x06, 0x00, 0x06, 0x30, 0x06, 0x03, 0x00, 0x2A, 
  0x07, 0x02, 0x00, 0x33, 0x06, 0x07, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x2B, 0x04, 0x00, 0x06, 0x2B, 
  0x06, 0x00, 0x08, 0x30, 0x04, 0x06, 0x00, 0x2A, 0x06, 0x02, 0x00, 0x33, 0x04, 0x06, 0x00, 0x2B, 
  0x06, 0x00, 0x08, 0x2F, 0x06, 0x00, 0x00, 0x2A, 0x06, 0x03, 0x00, 0x34, 0x06, 0x00, 0x00, 0xBF, 
  0xFF, 0x86, 0x42, 0x03, 0x02, 0x05, 0x02, 0x21, 0x00, 0x21, 0x00, 0x16, 0x00, 0x16, 0x00, 0x16, 
  0x00, 0x16, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x07, 0x01, 0x0D, 0x00, 0x0D, 0xBF, 0xFF, 0x07, 0x00, 
  0x07, 0x02, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0xBF, 0xFE, 0x07, 0xBF, 0xFF, 0x05, 0x04, 
  0x11, 0x00, 0x11, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x09, 0x00, 0x09, 0x00, 0x05, 0x01, 
  0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xFF, 0x05, 0x02, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x86, 0x39, 0x01, 0x04, 
  0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0x1C, 0x00, 
  0x12, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x03, 0x02, 0x03, 0x00, 0x03, 0x0D, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 
  0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x09, 0x00, 0x09, 0x00, 0x1A, 0x00, 0x1A, 0x00, 0x1A, 0x00, 
  0x1A, 0x00, 0x1A, 0x00, 0x1A, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x05, 0x01, 0x0B, 0x00, 
  0x0B, 0x00, 0x07, 0x01, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0xBF, 0xFF, 0x07, 0x02, 0x09, 
  0x00, 0x09, 0x00, 0x09, 0xBF, 0xFD, 0x05, 0x05, 0x10, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x09, 0x00, 
  0x21, 0x00, 0x09, 0x01, 0x0F, 0x00, 0x0F, 0x00, 0x09, 0x01, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 
  0x0B, 0x01, 0x0B, 0xBF, 0xFE, 0x09, 0xBF, 0xF9, 0x03, 0x00, 0x03, 0x0C, 0x03, 0xBF, 0xDE, 0x01, 
  0x48, 0x03, 0x00, 0x00, 0xCF, 0x0E, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 0x75, 0x6E, 0x66, 0x62, 
  0x72, 0x65, 0x61, 0x6B, 0xD8, 0x0E, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 0x75, 0x6E, 0x66, 0x62, 
  0x72, 0x65, 0x61, 0x6B, 0xCF, 0x05, 0x6F, 0x73, 0x2F, 0x63, 0x64, 0xD8, 0x05, 0x6F, 0x73, 0x2F, 
  0x63, 0x64, 0xCF, 0x03, 0x73, 0x75, 0x6D, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x06, 0x01, 0x01, 
  0x01, 0x00, 0x0C, 0xCE, 0x03, 0x73, 0x75, 0x6D, 0xDA, 0x05, 0x2C, 0x01, 0x00, 0x00, 0x29, 0x02, 
  0x00, 0x00, 0x26, 0x04, 0x00, 0x00, 0x47, 0x03, 0x00, 0x04, 0x19, 0x04, 0x03, 0x00, 0x1D, 0x04, 
  0x06, 0x00, 0x38, 0x03, 0x00, 0x04, 0x19, 0x05, 0x03, 0x00, 0x06, 0x02, 0x02, 0x05, 0x47, 0x04, 
  0x00, 0x04, 0x1A, 0xFB, 0xFF, 0xFF, 0x03, 0x02, 0x00, 0x00, 0x82, 0x34, 0x01, 0x03, 0x03, 0x01, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x0E, 0x00, 0x03, 0x00, 
  0x03, 0xBF, 0xFC, 0x01, 0xCF, 0x0C, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x2F, 0x63, 0x6C, 0x6F, 
  0x73, 0x65, 0xD8, 0x0C, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x2F, 0x63, 0x6C, 0x6F, 0x73, 0x65, 
  0xCF, 0x0A, 0x64, 0x72, 0x6F, 0x70, 0x2D, 0x75, 0x6E, 0x74, 0x69, 0x6C, 0xD7, 0xCD, 0x00, 0x98, 
  0x00, 0x00, 0x0E, 0x02, 0x02, 0x02, 0x05, 0x1A, 0xCE, 0x0A, 0x64, 0x72, 0x6F, 0x70, 0x2D, 0x75, 
  0x6E, 0x74, 0x69, 0x6C, 0xDA, 0x05, 0xDA, 0x81, 0x1E, 0xDA, 0x81, 0x1F, 0xDA, 0x70, 0xDA, 0x81, 
  0x21, 0xDA, 0x81, 0x23, 0x2C, 0x02, 0x00, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 
  0x33, 0x03, 0x04, 0x00, 0x19, 0x04, 0x03, 0x00, 0x1C, 0x04, 0x03, 0x00, 0x2A, 0x05, 0x01, 0x00, 
  0x1A, 0x02, 0x00, 0x00, 0x2A, 0x05, 0x02, 0x00, 0x19, 0x06, 0x05, 0x00, 0x30, 0x00, 0x01, 0x00, 
  0x2A, 0x08, 0x03, 0x00, 0x33, 0x07, 0x08, 0x00, 0x19, 0x08, 0x07, 0x00, 0x3D, 0x09, 0x01, 0x00, 
  0x19, 0x0A, 0x09, 0x00, 0x2F, 0x08, 0x00, 0x00, 0x2A, 0x0D, 0x04, 0x00, 0x33, 0x0C, 0x0D, 0x00, 
  0x1C, 0x0C, 0x03, 0x00, 0x19, 0x0B, 0x0A, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x0B, 0x08, 0x00, 
  0x19, 0x0C, 0x0B, 0x00, 0x30, 0x01, 0x0C, 0x00, 0x34, 0x06, 0x00, 0x00, 0x83, 0xD0, 0x01, 0x03, 
  0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x03, 0x01, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 
  0x03, 0x01, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x0C, 0x00, 0x03, 0x01, 0x12, 0x00, 
  0x12, 0x00, 0x12, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x03, 0x01, 0x03, 0x00, 
  0x03, 0xCF, 0x09, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2F, 0x6E, 0x65, 0x77, 0xD8, 0x09, 0x74, 0x61, 
  0x62, 0x6C, 0x65, 0x2F, 0x6E, 0x65, 0x77, 0xCF, 0x07, 0x70, 0x72, 0x6F, 0x74, 0x65, 0x63, 0x74, 
  0xD7, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x09, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x09, 0x23, 
  0xCE, 0x07, 0x70, 0x72, 0x6F, 0x74, 0x65, 0x63, 0x74, 0xDA, 0x05, 0xDA, 0x22, 0xDA, 0x23, 0xDA, 
  0x24, 0xD0, 0x02, 0x69, 0x65, 0xDA, 0x28, 0xDA, 0x29, 0xDA, 0x81, 0xB2, 0xDA, 0x80, 0xF7, 0xDA, 
  0x81, 0x8D, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x19, 0x03, 
  0x02, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x02, 0x04, 0x00, 0x19, 0x04, 0x02, 0x00, 0x44, 0x02, 
  0x00, 0x00, 0x2A, 0x06, 0x01, 0x00, 0x30, 0x06, 0x02, 0x00, 0x32, 0x00, 0x00, 0x00, 0x43, 0x05, 
  0x00, 0x00, 0x2A, 0x06, 0x02, 0x00, 0x2A, 0x07, 0x03, 0x00, 0x31, 0x06, 0x05, 0x07, 0x43, 0x02, 
  0x00, 0x00, 0x2A, 0x06, 0x04, 0x00, 0x30, 0x06, 0x03, 0x00, 0x43, 0x05, 0x00, 0x00, 0x31, 0x03, 
  0x02, 0x04, 0x2F, 0x05, 0x00, 0x00, 0x44, 0x06, 0x00, 0x00, 0x2A, 0x05, 0x05, 0x00, 0x30, 0x05, 
  0x03, 0x00, 0x43, 0x02, 0x00, 0x00, 0x2A, 0x07, 0x06, 0x00, 0x2A, 0x08, 0x07, 0x00, 0x31, 0x07, 
  0x08, 0x02, 0x43, 0x05, 0x00, 0x00, 0x30, 0x05, 0x04, 0x00, 0x44, 0x02, 0x00, 0x00, 0x2A, 0x07, 
  0x08, 0x00, 0x31, 0x07, 0x06, 0x02, 0x43, 0x05, 0x00, 0x00, 0x03, 0x05, 0x00, 0x00, 0x80, 0xF1, 
  0x01, 0x05, 0x0B, 0x00, 0x0B, 0x00, 0x03, 0x00, 0x16, 0x00, 0x16, 0x00, 0x03, 0x01, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0xCF, 0x0F, 0x6D, 0x61, 0x6B, 0x65, 0x2D, 0x69, 0x6D, 0x61, 0x67, 
  0x65, 0x2D, 0x64, 0x69, 0x63, 0x74, 0xDA, 0x41, 0xCF, 0x06, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x66, 
  0xD7, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x05, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x01, 0x07, 
  0xCE, 0x06, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x66, 0xDA, 0x05, 0xD8, 0x0D, 0x73, 0x74, 0x72, 0x69, 
  0x6E, 0x67, 0x2F, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x2C, 0x02, 0x00, 0x00, 0x2F, 0x00, 0x00, 
  0x00, 0x32, 0x01, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 0x01, 0x03, 0x00, 
  0x00, 0x04, 0x00, 0x00, 0x00, 0x80, 0x90, 0x01, 0x03, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 
  0x00, 0x03, 0x00, 0x03, 0xCF, 0x0A, 0x66, 0x69, 0x6C, 0x65, 0x2F, 0x70, 0x6F, 0x70, 0x65, 0x6E, 
  0xD8, 0x0A, 0x66, 0x69, 0x6C, 0x65, 0x2F, 0x70, 0x6F, 0x70, 0x65, 0x6E, 0xCF, 0x06, 0x66, 0x69, 
  0x6C, 0x74, 0x65, 0x72, 0xDA, 0x80, 0xC3, 0xCF, 0x07, 0x70, 0x61, 0x72, 0x74, 0x69, 0x61, 0x6C, 
  0xD7, 0xCD, 0x02, 0xBB, 0x00, 0x00, 0x06, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x01, 0x09, 
  0x01, 0xCE, 0x07, 0x70, 0x61, 0x72, 0x74, 0x69, 0x61, 0x6C, 0xDA, 0x05, 0xD7, 0xCD, 0x00, 0x98, 
  0x00, 0x00, 0x04, 0x01, 0x01, 0x01, 0x00, 0x04, 0xCE, 0x05, 0x7A, 0x65, 0x72, 0x6F, 0x3F, 0xDA, 
  0x05, 0x2C, 0x01, 0x00, 0x00, 0x29, 0x03, 0x00, 0x00, 0x23, 0x02, 0x00, 0x03, 0x03, 0x02, 0x00, 
  0x00, 0x54, 0x01, 0x00, 0x27, 0x00, 0x27, 0x00, 0x27, 0x2C, 0x02, 0x00, 0x00, 0x3D, 0x03, 0x01, 
  0x00, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x05, 0x00, 0x00, 0x33, 0x04, 0x05, 0x00, 0x1C, 0x04, 0x02, 
  0x00, 0x03, 0x00, 0x00, 0x00, 0x2E, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0xCD, 0x00, 0xD1, 
  0x00, 0x00, 0x02, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x05, 0x01, 0xDA, 0x05, 0x2B, 
  0x01, 0x00, 0x01, 0x32, 0x01, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x2B, 0x01, 0x00, 0x00, 0x34, 
  0x01, 0x00, 0x00, 0xBF, 0xFF, 0x84, 0x9D, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 
  0x84, 0x99, 0x01, 0x03, 0x0E, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x03, 0x00, 0x03, 0x01, 
  0x05, 0x00, 0x05, 0x03, 0x00, 0x00, 0x00, 0xCF, 0x04, 0x6F, 0x6E, 0x65, 0x3F, 0xD7, 0xCD, 0x00, 
  0x98, 0x00, 0x00, 0x04, 0x01, 0x01, 0x01, 0x00, 0x04, 0xCE, 0x04, 0x6F, 0x6E, 0x65, 0x3F, 0xDA, 
  0x05, 0x2C, 0x01, 0x00, 0x00, 0x29, 0x03, 0x01, 0x00, 0x23, 0x02, 0x00, 0x03, 0x03, 0x02, 0x00, 
  0x00, 0x57, 0x01, 0x00, 0x2C, 0x00, 0x2C, 0x00, 0x2C, 0xCF, 0x08, 0x73, 0x68, 0x6F, 0x72, 0x74, 
  0x2D, 0x66, 0x6E, 0xD7, 0xCD, 0x02, 0xBA, 0x00, 0x00, 0x12, 0x01, 0x01, 0x01, 0x08, 0x2E, 0x02, 
  0xCE, 0x08, 0x73, 0x68, 0x6F, 0x72, 0x74, 0x2D, 0x66, 0x6E, 0xDA, 0x05, 0xD7, 0xCD, 0x00, 0x98, 
  0x00, 0x00, 0x0A, 0x02, 0x01, 0x02, 0x03, 0x19, 0xCE, 0x05, 0x6D, 0x61, 0x63, 0x65, 0x78, 0xDA, 
  0x05, 0xD7, 0xCD, 0x02, 0xBA, 0x00, 0x00, 0x1F, 0x02, 0x01, 0x02, 0x16, 0x67, 0x08, 0xCE, 0x06, 
  0x6D, 0x61, 0x63, 0x65, 0x78, 0x31, 0xDA, 0x05, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x01, 
  0x01, 0x01, 0x02, 0x07, 0xCE, 0x07, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x3F, 0xDA, 0x05, 0xDA, 
  0x39, 0xDA, 0x81, 0x1C, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 
  0x33, 0x02, 0x03, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x23, 0x03, 0x02, 0x04, 0x03, 0x03, 0x00, 0x00, 
  0x5B, 0x01, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x2D, 0x00, 0x2D, 0x00, 0x2D, 0xDA, 0x81, 
  0x93, 0xDA, 0x2F, 0xDA, 0x23, 0xDA, 0x81, 0x8A, 0xDA, 0x26, 0xCF, 0x05, 0x71, 0x75, 0x6F, 0x74, 
  0x65, 0xDA, 0x80, 0xC1, 0xDA, 0x81, 0x91, 0xCF, 0x0A, 0x71, 0x75, 0x61, 0x73, 0x69, 0x71, 0x75, 
  0x6F, 0x74, 0x65, 0xDA, 0x81, 0xA1, 0xDA, 0x2E, 0xDA, 0x39, 0xDA, 0x72, 0xD8, 0x0A, 0x74, 0x75, 
  0x70, 0x6C, 0x65, 0x2F, 0x74, 0x79, 0x70, 0x65, 0xD0, 0x08, 0x62, 0x72, 0x61, 0x63, 0x6B, 0x65, 
  0x74, 0x73, 0xDA, 0x80, 0xBF, 0xD8, 0x0E, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x2F, 0x62, 0x72, 0x61, 
  0x63, 0x6B, 0x65, 0x74, 0x73, 0xDA, 0x81, 0x3C, 0xDA, 0x80, 0x88, 0xDA, 0x81, 0x3B, 0xDA, 0x3A, 
  0x2C, 0x02, 0x00, 0x00, 0x1C, 0x01, 0x09, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 
  0x33, 0x03, 0x04, 0x00, 0x1C, 0x03, 0x04, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x34, 0x01, 0x00, 0x00, 
  0x1A, 0x01, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x2E, 0x03, 0x00, 0x00, 0x19, 0x04, 0x03, 0x00, 
  0x2E, 0x05, 0x01, 0x00, 0x19, 0x06, 0x05, 0x00, 0x2E, 0x07, 0x02, 0x00, 0x19, 0x08, 0x07, 0x00, 
  0x2E, 0x09, 0x03, 0x00, 0x19, 0x0A, 0x09, 0x00, 0x2E, 0x0B, 0x04, 0x00, 0x19, 0x0C, 0x0B, 0x00, 
  0x2E, 0x0D, 0x05, 0x00, 0x19, 0x0E, 0x0D, 0x00, 0x2E, 0x0F, 0x06, 0x00, 0x19, 0x10, 0x0F, 0x00, 
  0x2A, 0x11, 0x01, 0x00, 0x2A, 0x12, 0x02, 0x00, 0x31, 0x11, 0x0C, 0x12, 0x2A, 0x11, 0x03, 0x00, 
  0x31, 0x0C, 0x11, 0x0E, 0x2A, 0x11, 0x04, 0x00, 0x2A, 0x12, 0x05, 0x00, 0x31, 0x11, 0x0C, 0x12, 
  0x2A, 0x11, 0x06, 0x00, 0x2A, 0x12, 0x07, 0x00, 0x31, 0x0A, 0x11, 0x12, 0x2A, 0x11, 0x08, 0x00, 
  0x2A, 0x12, 0x09, 0x00, 0x31, 0x11, 0x0A, 0x12, 0x2A, 0x11, 0x0A, 0x00, 0x31, 0x10, 0x11, 0x0A, 
  0x2A, 0x11, 0x0B, 0x00, 0x30, 0x11, 0x0C, 0x00, 0x41, 0x11, 0x00, 0x00, 0x19, 0x12, 0x11, 0x00, 
  0x2E, 0x13, 0x07, 0x00, 0x19, 0x14, 0x13, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x16, 0x0C, 0x00, 
  0x33, 0x15, 0x16, 0x00, 0x19, 0x16, 0x15, 0x00, 0x2A, 0x18, 0x0D, 0x00, 0x23, 0x17, 0x16, 0x18, 
  0x1C, 0x17, 0x14, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x1A, 0x0E, 0x00, 0x33, 0x19, 0x1A, 0x00, 
  0x2A, 0x1B, 0x0F, 0x00, 0x23, 0x1A, 0x19, 0x1B, 0x1C, 0x1A, 0x09, 0x00, 0x30, 0x04, 0x00, 0x00, 
  0x2A, 0x1B, 0x10, 0x00, 0x33, 0x19, 0x1B, 0x00, 0x32, 0x19, 0x00, 0x00, 0x2A, 0x1C, 0x11, 0x00, 
  0x33, 0x1B, 0x1C, 0x00, 0x19, 0x18, 0x1B, 0x00, 0x1A, 0x04, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
  0x33, 0x19, 0x14, 0x00, 0x19, 0x18, 0x19, 0x00, 0x19, 0x15, 0x18, 0x00, 0x1A, 0x1E, 0x00, 0x00, 
  0x2A, 0x1A, 0x12, 0x00, 0x23, 0x19, 0x16, 0x1A, 0x1C, 0x19, 0x06, 0x00, 0x30, 0x04, 0x00, 0x00, 
  0x2A, 0x1B, 0x10, 0x00, 0x33, 0x1A, 0x1B, 0x00, 0x19, 0x18, 0x1A, 0x00, 0x1A, 0x15, 0x00, 0x00, 
  0x2A, 0x1C, 0x13, 0x00, 0x23, 0x1B, 0x16, 0x1C, 0x1C, 0x1B, 0x08, 0x00, 0x30, 0x00, 0x04, 0x00, 
  0x33, 0x1C, 0x06, 0x00, 0x2F, 0x1C, 0x00, 0x00, 0x2A, 0x1E, 0x14, 0x00, 0x33, 0x1D, 0x1E, 0x00, 
  0x19, 0x1A, 0x1D, 0x00, 0x1A, 0x0A, 0x00, 0x00, 0x2A, 0x1E, 0x15, 0x00, 0x23, 0x1D, 0x16, 0x1E, 
  0x1C, 0x1D, 0x05, 0x00, 0x30, 0x00, 0x04, 0x00, 0x33, 0x1E, 0x06, 0x00, 0x19, 0x1C, 0x1E, 0x00, 
  0x1A, 0x02, 0x00, 0x00, 0x19, 0x1C, 0x00, 0x00, 0x19, 0x1A, 0x1C, 0x00, 0x19, 0x18, 0x1A, 0x00, 
  0x19, 0x15, 0x18, 0x00, 0x19, 0x16, 0x15, 0x00, 0x03, 0x16, 0x00, 0x00, 0xCD, 0x00, 0xD8, 0x00, 
  0x00, 0x03, 0x01, 0x01, 0x01, 0x00, 0x05, 0x01, 0xDA, 0x71, 0xDA, 0x05, 0x2C, 0x01, 0x00, 0x00, 
  0x2B, 0x02, 0x00, 0x01, 0x30, 0x00, 0x02, 0x00, 0x2B, 0x02, 0x00, 0x02, 0x34, 0x02, 0x00, 0x00, 
  0xBF, 0xFF, 0x86, 0xA6, 0x03, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0xCD, 0x00, 0xD8, 
  0x00, 0x00, 0x0B, 0x02, 0x02, 0x02, 0x00, 0x17, 0x01, 0xCE, 0x07, 0x64, 0x6F, 0x74, 0x61, 0x62, 
  0x6C, 0x65, 0xDA, 0x05, 0x2C, 0x02, 0x00, 0x00, 0x42, 0x03, 0x00, 0x00, 0x19, 0x04, 0x03, 0x00, 
  0x26, 0x06, 0x00, 0x00, 0x47, 0x05, 0x00, 0x06, 0x19, 0x06, 0x05, 0x00, 0x26, 0x08, 0x00, 0x00, 
  0x23, 0x07, 0x08, 0x06, 0x1B, 0x07, 0x03, 0x00, 0x27, 0x07, 0x00, 0x00, 0x1A, 0x02, 0x00, 0x00, 
  0x28, 0x07, 0x00, 0x00, 0x1C, 0x07, 0x0A, 0x00, 0x2F, 0x06, 0x00, 0x00, 0x2B, 0x09, 0x00, 0x04, 
  0x33, 0x08, 0x09, 0x00, 0x38, 0x09, 0x00, 0x06, 0x2F, 0x09, 0x00, 0x00, 0x33, 0x0A, 0x01, 0x00, 
  0x3A, 0x04, 0x08, 0x0A, 0x47, 0x06, 0x00, 0x06, 0x1A, 0xF1, 0xFF, 0xFF, 0x03, 0x04, 0x00, 0x00, 
  0xBF, 0xFF, 0x86, 0xA8, 0x03, 0x01, 0x05, 0x00, 0x05, 0x01, 0x0E, 0x00, 0x0E, 0x00, 0x05, 0x01, 
  0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x05, 0x01, 0x11, 0x00, 
  0x11, 0x00, 0x11, 0x00, 0x27, 0x00, 0x1D, 0x00, 0x1D, 0x00, 0x07, 0x01, 0x10, 0xBF, 0xFE, 0x05, 
  0xBF, 0xFD, 0x03, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x09, 0x01, 0x01, 0x01, 0x08, 0x26, 0x01, 0xCE, 
  0x0F, 0x65, 0x78, 0x70, 0x61, 0x6E, 0x64, 0x2D, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 
  0xDA, 0x05, 0xDA, 0x39, 0xDA, 0x81, 0x3C, 0xDA, 0x80, 0xBF, 0xDA, 0x72, 0xDA, 0x70, 0xDA, 0x3A, 
  0xDA, 0x80, 0x88, 0xDA, 0x81, 0x3B, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 
  0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x19, 0x03, 0x02, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x23, 0x02, 
  0x03, 0x04, 0x1C, 0x02, 0x04, 0x00, 0x30, 0x01, 0x00, 0x00, 0x2A, 0x04, 0x02, 0x00, 0x34, 0x04, 
  0x00, 0x00, 0x2A, 0x05, 0x03, 0x00, 0x23, 0x04, 0x03, 0x05, 0x1C, 0x04, 0x07, 0x00, 0x30, 0x01, 
  0x00, 0x00, 0x2A, 0x06, 0x02, 0x00, 0x33, 0x05, 0x06, 0x00, 0x2F, 0x05, 0x00, 0x00, 0x2A, 0x06, 
  0x04, 0x00, 0x34, 0x06, 0x00, 0x00, 0x2A, 0x06, 0x05, 0x00, 0x23, 0x05, 0x03, 0x06, 0x1C, 0x05, 
  0x04, 0x00, 0x30, 0x00, 0x01, 0x00, 0x2B, 0x06, 0x00, 0x06, 0x34, 0x06, 0x00, 0x00, 0x2A, 0x07, 
  0x06, 0x00, 0x23, 0x06, 0x03, 0x07, 0x1C, 0x06, 0x07, 0x00, 0x30, 0x00, 0x01, 0x00, 0x2B, 0x08, 
  0x00, 0x06, 0x33, 0x07, 0x08, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x2A, 0x08, 0x07, 0x00, 0x34, 0x08, 
  0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2B, 0x07, 0x00, 0x04, 0x34, 0x07, 0x00, 0x00, 0xBF, 0xFF, 
  0x86, 0xB0, 0x03, 0x01, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x01, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0xBF, 0xFF, 0x05, 0x00, 0x05, 0x00, 0x05, 0x02, 0x1B, 
  0x00, 0x1B, 0x00, 0x1B, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0xBF, 0xFE, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x03, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0xBF, 0xFD, 0x05, 0x00, 0x05, 0x00, 0x05, 0x04, 0x20, 
  0x00, 0x20, 0x00, 0x20, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 
  0xCD, 0x00, 0xD8, 0x00, 0x00, 0x0B, 0x01, 0x01, 0x01, 0x02, 0x20, 0x01, 0xCE, 0x09, 0x65, 0x78, 
  0x70, 0x61, 0x6E, 0x64, 0x64, 0x65, 0x66, 0xDA, 0x05, 0xDA, 0x70, 0xDA, 0x81, 0x2E, 0x2C, 0x01, 
  0x00, 0x00, 0x3D, 0x02, 0x00, 0x00, 0x29, 0x04, 0x01, 0x00, 0x07, 0x03, 0x02, 0x04, 0x38, 0x02, 
  0x00, 0x03, 0x19, 0x03, 0x02, 0x00, 0x29, 0x05, 0x01, 0x00, 0x38, 0x04, 0x00, 0x05, 0x19, 0x05, 
  0x04, 0x00, 0x29, 0x07, 0x00, 0x00, 0x38, 0x06, 0x00, 0x07, 0x2F, 0x05, 0x00, 0x00, 0x2B, 0x08, 
  0x00, 0x08, 0x33, 0x07, 0x08, 0x00, 0x30, 0x06, 0x07, 0x00, 0x3E, 0x06, 0x00, 0x00, 0x29, 0x07, 
  0x02, 0x00, 0x29, 0x08, 0xFE, 0xFF, 0x31, 0x00, 0x07, 0x08, 0x2A, 0x08, 0x00, 0x00, 0x33, 0x07, 
  0x08, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x2B, 0x09, 0x00, 0x04, 0x33, 0x08, 0x09, 0x00, 0x2F, 0x08, 
  0x00, 0x00, 0x3E, 0x08, 0x00, 0x00, 0x31, 0x06, 0x07, 0x08, 0x2A, 0x0A, 0x01, 0x00, 0x33, 0x09, 
  0x0A, 0x00, 0x2F, 0x09, 0x00, 0x00, 0x2A, 0x06, 0x00, 0x00, 0x34, 0x06, 0x00, 0x00, 0xBF, 0xFF, 
  0x86, 0xB8, 0x03, 0x01, 0x18, 0x00, 0x15, 0x00, 0x15, 0x00, 0x0F, 0x00, 0x05, 0x01, 0x10, 0x00, 
  0x10, 0x00, 0x05, 0x03, 0x0B, 0x00, 0x0B, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0xBF, 0xFF, 0x07, 
  0x00, 0x07, 0x02, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x01, 0x0B, 0x00, 0x0B, 
  0x00, 0x0B, 0xBF, 0xFD, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xFF, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x06, 0x01, 0x01, 0x01, 0x03, 0x10, 0x01, 
  0xCE, 0x09, 0x65, 0x78, 0x70, 0x61, 0x6E, 0x64, 0x61, 0x6C, 0x6C, 0xDA, 0x05, 0xDA, 0x70, 0xDA, 
  0x80, 0xBF, 0xDA, 0x81, 0x65, 0x2C, 0x01, 0x00, 0x00, 0x29, 0x02, 0x01, 0x00, 0x30, 0x00, 0x02, 
  0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2B, 0x03, 0x00, 0x04, 0x30, 0x03, 0x02, 
  0x00, 0x2A, 0x04, 0x01, 0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x02, 0x03, 0x00, 0x29, 0x05, 0x00, 
  0x00, 0x38, 0x04, 0x00, 0x05, 0x2F, 0x04, 0x00, 0x00, 0x32, 0x02, 0x00, 0x00, 0x2A, 0x05, 0x02, 
  0x00, 0x34, 0x05, 0x00, 0x00, 0xBF, 0xFF, 0x86, 0xC1, 0x03, 0x01, 0x1A, 0x00, 0x1A, 0x00, 0x1A, 
  0x00, 0x1A, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x05, 0x01, 0x0C, 0x00, 0x0C, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x08, 0x01, 0x01, 
  0x01, 0x05, 0x26, 0x01, 0xCE, 0x08, 0x65, 0x78, 0x70, 0x61, 0x6E, 0x64, 0x66, 0x6E, 0xDA, 0x05, 
  0xDA, 0x82, 0x15, 0xDA, 0x70, 0xDA, 0x80, 0xBF, 0xDA, 0x23, 0xDA, 0x81, 0x65, 0x2C, 0x01, 0x00, 
  0x00, 0x29, 0x03, 0x01, 0x00, 0x38, 0x02, 0x00, 0x03, 0x19, 0x03, 0x02, 0x00, 0x2F, 0x03, 0x00, 
  0x00, 0x2A, 0x05, 0x00, 0x00, 0x33, 0x04, 0x05, 0x00, 0x1C, 0x04, 0x11, 0x00, 0x29, 0x05, 0x03, 
  0x00, 0x30, 0x00, 0x05, 0x00, 0x2A, 0x06, 0x01, 0x00, 0x33, 0x05, 0x06, 0x00, 0x2B, 0x06, 0x00, 
  0x04, 0x30, 0x06, 0x05, 0x00, 0x2A, 0x07, 0x02, 0x00, 0x33, 0x06, 0x07, 0x00, 0x19, 0x05, 0x06, 
  0x00, 0x29, 0x07, 0x02, 0x00, 0x38, 0x06, 0x00, 0x07, 0x2A, 0x07, 0x03, 0x00, 0x31, 0x07, 0x03, 
  0x06, 0x32, 0x05, 0x00, 0x00, 0x2A, 0x07, 0x04, 0x00, 0x34, 0x07, 0x00, 0x00, 0x29, 0x05, 0x02, 
  0x00, 0x30, 0x00, 0x05, 0x00, 0x2A, 0x06, 0x01, 0x00, 0x33, 0x05, 0x06, 0x00, 0x2B, 0x06, 0x00, 
  0x04, 0x30, 0x06, 0x05, 0x00, 0x2A, 0x07, 0x02, 0x00, 0x33, 0x06, 0x07, 0x00, 0x19, 0x05, 0x06, 
  0x00, 0x2A, 0x06, 0x03, 0x00, 0x30, 0x06, 0x03, 0x00, 0x32, 0x05, 0x00, 0x00, 0x2A, 0x06, 0x04, 
  0x00, 0x34, 0x06, 0x00, 0x00, 0xBF, 0xFF, 0x86, 0xC5, 0x03, 0x01, 0x0D, 0x00, 0x0D, 0x00, 0x05, 
  0x01, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x05, 0x02, 0x1E, 0x00, 0x1E, 0x00, 0x1E, 0x00, 0x1E, 
  0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x09, 0x01, 0x17, 0x00, 0x17, 0x00, 0x09, 
  0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x02, 0x1E, 0x00, 0x1E, 0x00, 0x1E, 0x00, 0x1E, 
  0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x09, 0x01, 0x09, 0x00, 0x09, 0x00, 0x09, 
  0x00, 0x09, 0x00, 0x09, 0xCD, 0x00, 0xF8, 0x00, 0x00, 0x07, 0x01, 0x01, 0x01, 0x01, 0x0C, 0x01, 
  0x01, 0xCE, 0x08, 0x65, 0x78, 0x70, 0x61, 0x6E, 0x64, 0x71, 0x71, 0xDA, 0x05, 0xDA, 0x81, 0x65, 
  0x2C, 0x01, 0x00, 0x00, 0x2E, 0x02, 0x00, 0x00, 0x19, 0x03, 0x02, 0x00, 0x29, 0x05, 0x00, 0x00, 
  0x38, 0x04, 0x00, 0x05, 0x29, 0x06, 0x01, 0x00, 0x38, 0x05, 0x00, 0x06, 0x2F, 0x05, 0x00, 0x00, 
  0x33, 0x06, 0x03, 0x00, 0x30, 0x04, 0x06, 0x00, 0x2A, 0x05, 0x00, 0x00, 0x34, 0x05, 0x00, 0x00, 
  0xBF, 0xFF, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x0A, 0x01, 0x01, 0x01, 0x0D, 0x42, 0x01, 0xCE, 0x02, 
  0x71, 0x71, 0xDA, 0x05, 0xDA, 0x39, 0xDA, 0x72, 0xCF, 0x07, 0x75, 0x6E, 0x71, 0x75, 0x6F, 0x74, 
  0x65, 0xCF, 0x10, 0x75, 0x6E, 0x71, 0x75, 0x6F, 0x74, 0x65, 0x2D, 0x73, 0x70, 0x6C, 0x69, 0x63, 
  0x69, 0x6E, 0x67, 0xDA, 0x81, 0x65, 0xDA, 0x80, 0xBF, 0xDA, 0x70, 0xDA, 0x81, 0x3C, 0xDA, 0x3A, 
  0xDA, 0x81, 0x69, 0xDA, 0x07, 0xDA, 0x80, 0x88, 0xDA, 0x80, 0x8E, 0x2C, 0x01, 0x00, 0x00, 0x2F, 
  0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x19, 0x03, 0x02, 0x00, 0x2A, 
  0x04, 0x01, 0x00, 0x23, 0x02, 0x03, 0x04, 0x1C, 0x02, 0x1C, 0x00, 0x29, 0x05, 0x00, 0x00, 0x38, 
  0x04, 0x00, 0x05, 0x19, 0x05, 0x04, 0x00, 0x2A, 0x06, 0x02, 0x00, 0x23, 0x04, 0x06, 0x05, 0x19, 
  0x06, 0x04, 0x00, 0x1C, 0x06, 0x03, 0x00, 0x19, 0x04, 0x06, 0x00, 0x1A, 0x04, 0x00, 0x00, 0x2A, 
  0x08, 0x03, 0x00, 0x23, 0x07, 0x08, 0x05, 0x19, 0x04, 0x07, 0x00, 0x1C, 0x04, 0x09, 0x00, 0x29, 
  0x07, 0x01, 0x00, 0x38, 0x06, 0x00, 0x07, 0x2F, 0x06, 0x00, 0x00, 0x2B, 0x08, 0x00, 0x04, 0x33, 
  0x07, 0x08, 0x00, 0x30, 0x05, 0x07, 0x00, 0x2A, 0x06, 0x04, 0x00, 0x34, 0x06, 0x00, 0x00, 0x30, 
  0x01, 0x00, 0x00, 0x2A, 0x07, 0x05, 0x00, 0x33, 0x06, 0x07, 0x00, 0x2F, 0x06, 0x00, 0x00, 0x2A, 
  0x07, 0x06, 0x00, 0x34, 0x07, 0x00, 0x00, 0x2A, 0x05, 0x07, 0x00, 0x23, 0x04, 0x03, 0x05, 0x1C, 
  0x04, 0x04, 0x00, 0x30, 0x01, 0x00, 0x00, 0x2A, 0x05, 0x05, 0x00, 0x34, 0x05, 0x00, 0x00, 0x2A, 
  0x06, 0x08, 0x00, 0x23, 0x05, 0x03, 0x06, 0x1C, 0x05, 0x0A, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 
  0x07, 0x09, 0x00, 0x33, 0x06, 0x07, 0x00, 0x30, 0x01, 0x06, 0x00, 0x2A, 0x08, 0x05, 0x00, 0x33, 
  0x07, 0x08, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x2A, 0x06, 0x0A, 0x00, 0x34, 0x06, 0x00, 0x00, 0x2A, 
  0x07, 0x0B, 0x00, 0x23, 0x06, 0x03, 0x07, 0x1C, 0x06, 0x0A, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 
  0x08, 0x09, 0x00, 0x33, 0x07, 0x08, 0x00, 0x30, 0x01, 0x07, 0x00, 0x2A, 0x09, 0x05, 0x00, 0x33, 
  0x08, 0x09, 0x00, 0x2F, 0x08, 0x00, 0x00, 0x2A, 0x07, 0x0C, 0x00, 0x34, 0x07, 0x00, 0x00, 0x03, 
  0x00, 0x00, 0x00, 0x00, 0x86, 0xD0, 0x05, 0x01, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x07, 0x00, 
  0x07, 0x00, 0x07, 0x00, 0x07, 0x02, 0x1A, 0x00, 0x1A, 0x00, 0x12, 0x01, 0x1A, 0x00, 0x1A, 0x00, 
  0x16, 0x00, 0x16, 0x00, 0x16, 0x00, 0x16, 0x00, 0x2A, 0x00, 0x2A, 0x00, 0x16, 0x00, 0x12, 0x01, 
  0x25, 0x00, 0x25, 0x00, 0x1E, 0x00, 0x1E, 0x00, 0x1E, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x01, 
  0x21, 0x00, 0x21, 0x00, 0x21, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0xBF, 0xFB, 0x07, 0x00, 0x07, 
  0x00, 0x07, 0x06, 0x10, 0x00, 0x10, 0x00, 0x10, 0xBF, 0xFA, 0x07, 0x00, 0x07, 0x00, 0x07, 0x07, 
  0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x17, 0x00, 0x17, 0x00, 0x17, 0x00, 0x10, 0x00, 0x10, 0x00, 
  0x10, 0xBF, 0xF9, 0x07, 0x00, 0x07, 0x00, 0x07, 0x08, 0x21, 0x00, 0x21, 0x00, 0x21, 0x00, 0x19, 
  0x00, 0x19, 0x00, 0x19, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0xBF, 0xF8, 0x07, 0x86, 0xCF, 0x03, 
  0x01, 0x05, 0x00, 0x05, 0x0B, 0x0C, 0x00, 0x0C, 0x00, 0x19, 0x00, 0x19, 0x00, 0x15, 0x00, 0x15, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x0E, 0x01, 0x01, 0x01, 0x07, 
  0x2E, 0x01, 0xCE, 0x05, 0x64, 0x6F, 0x74, 0x75, 0x70, 0xDA, 0x05, 0xDA, 0x7D, 0xDA, 0x03, 0xDA, 
  0x35, 0xD0, 0x0A, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x2D, 0x66, 0x6F, 0x72, 0x6D, 0xD8, 0x06, 0x73, 
  0x65, 0x74, 0x64, 0x79, 0x6E, 0xDA, 0x70, 0xDA, 0x80, 0xBF, 0x2C, 0x01, 0x00, 0x00, 0x29, 0x03, 
  0x00, 0x00, 0x38, 0x02, 0x00, 0x03, 0x19, 0x03, 0x02, 0x00, 0x2B, 0x05, 0x00, 0x12, 0x38, 0x04, 
  0x05, 0x03, 0x19, 0x05, 0x04, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x07, 0x00, 0x00, 0x33, 0x06, 
  0x07, 0x00, 0x19, 0x07, 0x06, 0x00, 0x1C, 0x07, 0x03, 0x00, 0x19, 0x06, 0x07, 0x00, 0x1A, 0x03, 
  0x00, 0x00, 0x41, 0x08, 0x00, 0x00, 0x19, 0x06, 0x08, 0x00, 0x19, 0x07, 0x06, 0x00, 0x2A, 0x08, 
  0x01, 0x00, 0x2F, 0x08, 0x00, 0x00, 0x33, 0x08, 0x07, 0x00, 0x19, 0x09, 0x08, 0x00, 0x2A, 0x0A, 
  0x02, 0x00, 0x2F, 0x0A, 0x00, 0x00, 0x33, 0x0A, 0x07, 0x00, 0x19, 0x0B, 0x0A, 0x00, 0x1C, 0x05, 
  0x03, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x34, 0x05, 0x00, 0x00, 0x1C, 0x0B, 0x0B, 0x00, 0x2A, 0x0C, 
  0x03, 0x00, 0x30, 0x0C, 0x00, 0x00, 0x2A, 0x0D, 0x04, 0x00, 0x33, 0x0C, 0x0D, 0x00, 0x29, 0x0C, 
  0x01, 0x00, 0x30, 0x00, 0x0C, 0x00, 0x2A, 0x0D, 0x05, 0x00, 0x33, 0x0C, 0x0D, 0x00, 0x32, 0x0C, 
  0x00, 0x00, 0x34, 0x09, 0x00, 0x00, 0x2B, 0x0C, 0x00, 0x04, 0x30, 0x0C, 0x00, 0x00, 0x2A, 0x0D, 
  0x06, 0x00, 0x33, 0x0C, 0x0D, 0x00, 0x2F, 0x0C, 0x00, 0x00, 0x2A, 0x0D, 0x05, 0x00, 0x34, 0x0D, 
  0x00, 0x00, 0xBF, 0xFF, 0x86, 0xE9, 0x03, 0x01, 0x0C, 0x00, 0x0C, 0x00, 0x05, 0x01, 0x0C, 0x00, 
  0x0C, 0x00, 0x05, 0x01, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 
  0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x05, 0x01, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x05, 0x01, 
  0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x05, 0x01, 0x05, 0x01, 0x09, 0x00, 0x09, 0xBF, 0xFF, 0x05, 
  0x02, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x29, 0x00, 0x29, 0x00, 0x29, 0x00, 0x29, 
  0x00, 0x25, 0x00, 0x25, 0x01, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x07, 0x00, 0x07, 
  0x00, 0x07, 0x86, 0x9D, 0x01, 0x05, 0x03, 0x01, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x05, 0x01, 
  0x0E, 0x00, 0x0E, 0xBF, 0xFF, 0x05, 0xBF, 0xFF, 0x03, 0x04, 0x03, 0x00, 0x03, 0x02, 0x03, 0x00, 
  0x03, 0x08, 0x03, 0x00, 0x03, 0x08, 0x03, 0x00, 0x03, 0x09, 0x03, 0x00, 0x03, 0x04, 0x03, 0x00, 
  0x03, 0x0A, 0x03, 0x00, 0x03, 0x0E, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x0C, 0x03, 0x00, 
  0x03, 0x0C, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 
  0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x12, 0x00, 0x12, 0x00, 0x0E, 0x01, 0x21, 0x00, 0x21, 0x00, 
  0x21, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0xBF, 0xFF, 0x0E, 0x00, 0x0E, 0x02, 0x10, 0x00, 0x10, 
  0xBF, 0xFE, 0x0E, 0xBF, 0xFF, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x04, 0x0E, 
  0x00, 0x0E, 0x00, 0x0E, 0xBF, 0xFC, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x05, 
  0x20, 0x00, 0x20, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0xBF, 0xFB, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x06, 0x0E, 0x00, 0x0E, 0xBF, 0xFA, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0xBF, 0xFF, 0x03, 0xBF, 0xA9, 0x01, 0x56, 0x01, 0x04, 0x00, 0xD7, 
  0xCD, 0x00, 0x98, 0x00, 0x00, 0x0E, 0x02, 0x02, 0x02, 0x0C, 0x63, 0xCE, 0x09, 0x64, 0x65, 0x65, 
  0x70, 0x2D, 0x6E, 0x6F, 0x74, 0x3D, 0xDA, 0x05, 0xDA, 0x39, 0xDA, 0x72, 0xDA, 0x80, 0xBF, 0xDA, 
  0x80, 0xC1, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x08, 0x02, 0x02, 0x02, 0x01, 0x17, 0xCE, 0x04, 
  0x73, 0x6F, 0x6D, 0x65, 0xDA, 0x05, 0xDA, 0x81, 0x62, 0x2C, 0x02, 0x00, 0x00, 0x26, 0x03, 0x00, 
  0x00, 0x26, 0x05, 0x00, 0x00, 0x47, 0x04, 0x01, 0x05, 0x19, 0x05, 0x04, 0x00, 0x1D, 0x05, 0x11, 
  0x00, 0x38, 0x04, 0x01, 0x05, 0x19, 0x06, 0x04, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x07, 0x00, 
  0x00, 0x33, 0x04, 0x07, 0x00, 0x1C, 0x04, 0x02, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x1A, 0x09, 0x00, 
  0x00, 0x2F, 0x06, 0x00, 0x00, 0x33, 0x04, 0x00, 0x00, 0x19, 0x07, 0x04, 0x00, 0x1C, 0x07, 0x03, 
  0x00, 0x19, 0x03, 0x07, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x47, 0x05, 0x01, 0x05, 0x1A, 0xF0, 0xFF, 
  0xFF, 0x03, 0x03, 0x00, 0x00, 0x87, 0x07, 0x01, 0x04, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x1A, 0x00, 0x1A, 0x00, 0x1A, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x30, 0x00, 0x30, 0x00, 0x25, 0x00, 0x25, 0x00, 0x3A, 0x00, 0x25, 0x00, 0x03, 
  0x00, 0x03, 0xBF, 0xFB, 0x01, 0xDA, 0x81, 0x3C, 0xDA, 0x80, 0x88, 0xD7, 0xCD, 0x00, 0x98, 0x00, 
  0x00, 0x0A, 0x01, 0x01, 0x01, 0x03, 0x1A, 0xCE, 0x05, 0x70, 0x61, 0x69, 0x72, 0x73, 0xDA, 0x05, 
  0xDA, 0x55, 0xDA, 0x81, 0x65, 0xDA, 0x52, 0x2C, 0x01, 0x00, 0x00, 0x3D, 0x02, 0x00, 0x00, 0x2F, 
  0x02, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x02, 0x03, 0x00, 0x26, 
  0x05, 0x00, 0x00, 0x47, 0x04, 0x00, 0x05, 0x19, 0x05, 0x04, 0x00, 0x26, 0x07, 0x00, 0x00, 0x23, 
  0x06, 0x07, 0x05, 0x1B, 0x06, 0x03, 0x00, 0x27, 0x06, 0x00, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x28, 
  0x06, 0x00, 0x00, 0x1C, 0x06, 0x0A, 0x00, 0x38, 0x07, 0x00, 0x05, 0x30, 0x05, 0x07, 0x00, 0x2A, 
  0x09, 0x01, 0x00, 0x33, 0x08, 0x09, 0x00, 0x30, 0x02, 0x08, 0x00, 0x2A, 0x09, 0x02, 0x00, 0x33, 
  0x07, 0x09, 0x00, 0x47, 0x05, 0x00, 0x05, 0x1A, 0xF1, 0xFF, 0xFF, 0x03, 0x02, 0x00, 0x00, 0x85, 
  0x2E, 0x01, 0x03, 0x17, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x03, 0x01, 0x0A, 0x00, 0x0A, 
  0x00, 0x03, 0x01, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x03, 
  0x01, 0x1E, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x0C, 
  0xBF, 0xFE, 0x03, 0xBF, 0xFB, 0x01, 0xDA, 0x3A, 0xDA, 0x81, 0x3B, 0xDA, 0x81, 0x1D, 0xDA, 0x6F, 
  0x2C, 0x02, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 
  0x19, 0x04, 0x03, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x06, 0x00, 0x00, 0x33, 0x05, 0x06, 0x00, 
  0x23, 0x06, 0x04, 0x05, 0x1B, 0x06, 0x03, 0x00, 0x27, 0x06, 0x00, 0x00, 0x1A, 0x02, 0x00, 0x00, 
  0x28, 0x06, 0x00, 0x00, 0x19, 0x05, 0x06, 0x00, 0x1C, 0x05, 0x02, 0x00, 0x03, 0x05, 0x00, 0x00, 
  0x2A, 0x07, 0x01, 0x00, 0x23, 0x06, 0x04, 0x07, 0x1C, 0x06, 0x12, 0x00, 0x3D, 0x07, 0x00, 0x00, 
  0x3D, 0x08, 0x01, 0x00, 0x23, 0x09, 0x07, 0x08, 0x1B, 0x09, 0x03, 0x00, 0x27, 0x09, 0x00, 0x00, 
  0x1A, 0x02, 0x00, 0x00, 0x28, 0x09, 0x00, 0x00, 0x19, 0x07, 0x09, 0x00, 0x1C, 0x07, 0x02, 0x00, 
  0x03, 0x07, 0x00, 0x00, 0x31, 0x02, 0x00, 0x01, 0x2A, 0x09, 0x02, 0x00, 0x33, 0x08, 0x09, 0x00, 
  0x2A, 0x09, 0x03, 0x00, 0x30, 0x09, 0x08, 0x00, 0x2A, 0x09, 0x04, 0x00, 0x34, 0x09, 0x00, 0x00, 
  0x2A, 0x08, 0x05, 0x00, 0x23, 0x07, 0x04, 0x08, 0x1C, 0x07, 0x12, 0x00, 0x3D, 0x08, 0x00, 0x00, 
  0x3D, 0x09, 0x01, 0x00, 0x23, 0x0A, 0x08, 0x09, 0x1B, 0x0A, 0x03, 0x00, 0x27, 0x0A, 0x00, 0x00, 
  0x1A, 0x02, 0x00, 0x00, 0x28, 0x0A, 0x00, 0x00, 0x19, 0x08, 0x0A, 0x00, 0x1C, 0x08, 0x02, 0x00, 
  0x03, 0x08, 0x00, 0x00, 0x31, 0x02, 0x00, 0x01, 0x2A, 0x0A, 0x02, 0x00, 0x33, 0x09, 0x0A, 0x00, 
  0x2A, 0x0A, 0x03, 0x00, 0x30, 0x0A, 0x09, 0x00, 0x2A, 0x0A, 0x04, 0x00, 0x34, 0x0A, 0x00, 0x00, 
  0x2A, 0x09, 0x06, 0x00, 0x23, 0x08, 0x04, 0x09, 0x1C, 0x08, 0x09, 0x00, 0x2F, 0x00, 0x00, 0x00, 
  0x2A, 0x0A, 0x07, 0x00, 0x33, 0x09, 0x0A, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x0B, 0x07, 0x00, 
  0x33, 0x0A, 0x0B, 0x00, 0x30, 0x09, 0x0A, 0x00, 0x34, 0x02, 0x00, 0x00, 0x2A, 0x0A, 0x08, 0x00, 
  0x23, 0x09, 0x04, 0x0A, 0x1C, 0x09, 0x09, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x0B, 0x09, 0x00, 
  0x33, 0x0A, 0x0B, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x0C, 0x09, 0x00, 0x33, 0x0B, 0x0C, 0x00, 
  0x30, 0x0A, 0x0B, 0x00, 0x34, 0x02, 0x00, 0x00, 0x2A, 0x0B, 0x0A, 0x00, 0x23, 0x0A, 0x04, 0x0B, 
  0x1C, 0x0A, 0x0D, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x0C, 0x0B, 0x00, 0x33, 0x0B, 0x0C, 0x00, 
  0x2F, 0x01, 0x00, 0x00, 0x2A, 0x0D, 0x0B, 0x00, 0x33, 0x0C, 0x0D, 0x00, 0x23, 0x0D, 0x0B, 0x0C, 
  0x1B, 0x0D, 0x03, 0x00, 0x27, 0x0D, 0x00, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x28, 0x0D, 0x00, 0x00, 
  0x03, 0x0D, 0x00, 0x00, 0x23, 0x0B, 0x00, 0x01, 0x1B, 0x0B, 0x03, 0x00, 0x27, 0x0B, 0x00, 0x00, 
  0x1A, 0x02, 0x00, 0x00, 0x28, 0x0B, 0x00, 0x00, 0x03, 0x0B, 0x00, 0x00, 0x87, 0x0F, 0x01, 0x04, 
  0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x03, 0x02, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xBF, 0xFF, 0x03, 0x00, 0x03, 0x00, 0x03, 0x02, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x01, 0x18, 0x00, 0x23, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 
  0x00, 0x12, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x3E, 0x00, 0x3E, 0x00, 0x3E, 0x00, 0x2F, 
  0x00, 0x2F, 0x00, 0x2F, 0x00, 0x2F, 0xBF, 0xFF, 0x05, 0x00, 0x05, 0x00, 0x05, 0x02, 0x18, 0x00, 
  0x23, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x0E, 0x00, 0x0E, 0x00, 
  0x0E, 0x00, 0x3E, 0x00, 0x3E, 0x00, 0x3E, 0x00, 0x2F, 0x00, 0x2F, 0x00, 0x2F, 0x00, 0x2F, 0xBF, 
  0xFE, 0x05, 0x00, 0x05, 0x00, 0x05, 0x03, 0x1A, 0x00, 0x1A, 0x00, 0x1A, 0x00, 0x24, 0x00, 0x24, 
  0x00, 0x24, 0x00, 0x0F, 0x00, 0x0F, 0xBF, 0xFD, 0x05, 0x00, 0x05, 0x00, 0x05, 0x04, 0x19, 0x00, 
  0x19, 0x00, 0x19, 0x00, 0x2D, 0x00, 0x2D, 0x00, 0x2D, 0x00, 0x0E, 0x00, 0x0E, 0xBF, 0xFC, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x05, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 
  0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x01, 0x07, 0x00, 0x07, 
  0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0xCE, 0x1A, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x20, 
  0x65, 0x78, 0x70, 0x61, 0x6E, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x74, 0x6F, 0x6F, 0x20, 0x6E, 0x65, 
  0x73, 0x74, 0x65, 0x64, 0x2C, 0x02, 0x00, 0x00, 0x19, 0x03, 0x00, 0x00, 0x30, 0x00, 0x01, 0x00, 
  0x2A, 0x05, 0x00, 0x00, 0x33, 0x04, 0x05, 0x00, 0x19, 0x05, 0x04, 0x00, 0x29, 0x06, 0x00, 0x00, 
  0x30, 0x05, 0x03, 0x00, 0x2A, 0x08, 0x01, 0x00, 0x33, 0x07, 0x08, 0x00, 0x1C, 0x07, 0x0E, 0x00, 
  0x29, 0x08, 0x01, 0x00, 0x06, 0x06, 0x06, 0x08, 0x29, 0x09, 0xC8, 0x00, 0x1F, 0x08, 0x06, 0x09, 
  0x1C, 0x08, 0x04, 0x00, 0x2A, 0x09, 0x02, 0x00, 0x01, 0x09, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 
  0x19, 0x03, 0x05, 0x00, 0x30, 0x05, 0x01, 0x00, 0x2A, 0x08, 0x00, 0x00, 0x33, 0x05, 0x08, 0x00, 
  0x1A, 0xF0, 0xFF, 0xFF, 0x03, 0x05, 0x00, 0x00, 0x87, 0x33, 0x01, 0x07, 0x03, 0x01, 0x10, 0x00, 
  0x10, 0x00, 0x10, 0x00, 0x03, 0x01, 0x03, 0x01, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 
  0x0C, 0x00, 0x0C, 0x00, 0x09, 0x00, 0x09, 0x00, 0x05, 0x01, 0x07, 0x00, 0x07, 0xBF, 0xFF, 0x05, 
  0x02, 0x05, 0x01, 0x12, 0x00, 0x12, 0x00, 0x12, 0xBF, 0xFC, 0x03, 0xBF, 0xF6, 0x01, 0xCF, 0x01, 
  0x24, 0xD8, 0x06, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0xDA, 0x52, 0xCF, 0x01, 0x26, 0xCF, 0x02, 
  0x24, 0x26, 0xD2, 0x00, 0x00, 0xDA, 0x23, 0x2C, 0x01, 0x00, 0x00, 0x29, 0x02, 0xFF, 0xFF, 0x28, 
  0x03, 0x00, 0x00, 0x2E, 0x04, 0x00, 0x00, 0x19, 0x05, 0x04, 0x00, 0x2E, 0x06, 0x01, 0x00, 0x19, 
  0x07, 0x06, 0x00, 0x30, 0x00, 0x07, 0x00, 0x2A, 0x09, 0x00, 0x00, 0x33, 0x08, 0x09, 0x00, 0x19, 
  0x09, 0x08, 0x00, 0x3E, 0x0A, 0x00, 0x00, 0x19, 0x0B, 0x0A, 0x00, 0x29, 0x0A, 0x00, 0x00, 0x29, 
  0x0D, 0x01, 0x00, 0x06, 0x0C, 0x0D, 0x02, 0x19, 0x0D, 0x0C, 0x00, 0x21, 0x0C, 0x0A, 0x0D, 0x1C, 
  0x0C, 0x0C, 0x00, 0x19, 0x0E, 0x0A, 0x00, 0x2A, 0x0F, 0x01, 0x00, 0x30, 0x0F, 0x0E, 0x00, 0x2A, 
  0x10, 0x02, 0x00, 0x33, 0x0F, 0x10, 0x00, 0x30, 0x0B, 0x0F, 0x00, 0x2A, 0x11, 0x03, 0x00, 0x33, 
  0x10, 0x11, 0x00, 0x29, 0x0F, 0x01, 0x00, 0x06, 0x0A, 0x0A, 0x0F, 0x1A, 0xF4, 0xFF, 0xFF, 0x19, 
  0x0A, 0x0B, 0x00, 0x1C, 0x03, 0x07, 0x00, 0x2A, 0x0D, 0x04, 0x00, 0x2A, 0x0E, 0x05, 0x00, 0x30, 
  0x0D, 0x0E, 0x00, 0x43, 0x0D, 0x00, 0x00, 0x19, 0x0C, 0x0D, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x2A, 
  0x0C, 0x06, 0x00, 0x32, 0x0A, 0x00, 0x00, 0x32, 0x0C, 0x00, 0x00, 0x44, 0x0D, 0x00, 0x00, 0x2A, 
  0x0E, 0x07, 0x00, 0x31, 0x0E, 0x0D, 0x09, 0x43, 0x0C, 0x00, 0x00, 0x03, 0x0C, 0x00, 0x00, 0xCD, 
  0x00, 0xD8, 0x00, 0x00, 0x04, 0x01, 0x01, 0x01, 0x01, 0x08, 0x01, 0xCE, 0x0F, 0x73, 0x61, 0x77, 
  0x2D, 0x73, 0x70, 0x65, 0x63, 0x69, 0x61, 0x6C, 0x2D, 0x61, 0x72, 0x67, 0xDA, 0x05, 0xD7, 0xCD, 
  0x00, 0x99, 0x00, 0x00, 0x03, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x02, 0x05, 0xCE, 0x03, 
  0x6D, 0x61, 0x78, 0xDA, 0x05, 0xDA, 0x81, 0x7D, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x07, 0x02, 
  0x02, 0x02, 0x00, 0x11, 0xCE, 0x07, 0x65, 0x78, 0x74, 0x72, 0x65, 0x6D, 0x65, 0xDA, 0x05, 0x2C, 
  0x02, 0x00, 0x00, 0x3B, 0x03, 0x01, 0x00, 0x19, 0x04, 0x03, 0x00, 0x26, 0x05, 0x00, 0x00, 0x47, 
  0x03, 0x01, 0x05, 0x19, 0x05, 0x03, 0x00, 0x1D, 0x05, 0x0A, 0x00, 0x38, 0x03, 0x01, 0x05, 0x19, 
  0x06, 0x03, 0x00, 0x30, 0x06, 0x04, 0x00, 0x33, 0x03, 0x00, 0x00, 0x1C, 0x03, 0x03, 0x00, 0x19, 
  0x04, 0x06, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x47, 0x05, 0x01, 0x05, 0x1A, 0xF7, 0xFF, 0xFF, 0x03, 
  0x04, 0x00, 0x00, 0x82, 0x83, 0x01, 0x05, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x14, 0x00, 0x14, 0x00, 0x10, 0x00, 0x22, 0x00, 0x10, 
  0x00, 0x03, 0x00, 0x03, 0xBF, 0xFA, 0x01, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x30, 
  0x02, 0x00, 0x00, 0x2A, 0x02, 0x01, 0x00, 0x34, 0x02, 0x00, 0x00, 0x82, 0x8C, 0x01, 0x02, 0x0C, 
  0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x2C, 0x01, 0x00, 0x00, 0x2B, 0x02, 0x00, 0x02, 0x30, 0x02, 
  0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2D, 0x02, 0x00, 0x02, 0x2B, 0x03, 
  0x00, 0x02, 0x03, 0x03, 0x00, 0x00, 0xBF, 0xFF, 0x87, 0x6C, 0x03, 0x02, 0x19, 0x00, 0x19, 0x00, 
  0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x05, 0x00, 0x05, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x09, 0x01, 
  0x01, 0x01, 0x07, 0x28, 0x01, 0xCE, 0x0A, 0x6F, 0x6E, 0x2D, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 
  0x67, 0xDA, 0x05, 0xDA, 0x82, 0x30, 0xDA, 0x80, 0x96, 0xCF, 0x02, 0x24, 0x30, 0xDA, 0x82, 0x33, 
  0xDA, 0x81, 0x1F, 0xD8, 0x0B, 0x73, 0x63, 0x61, 0x6E, 0x2D, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 
  0xD8, 0x04, 0x6E, 0x61, 0x74, 0x3F, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x30, 0x02, 
  0x00, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x33, 0x02, 0x03, 0x00, 0x1C, 0x02, 0x22, 0x00, 0x2A, 0x04, 
  0x00, 0x00, 0x23, 0x03, 0x04, 0x00, 0x1C, 0x03, 0x07, 0x00, 0x29, 0x04, 0x00, 0x00, 0x2F, 0x04, 
  0x00, 0x00, 0x2B, 0x05, 0x00, 0x05, 0x33, 0x04, 0x05, 0x00, 0x2A, 0x04, 0x02, 0x00, 0x03, 0x04, 
  0x00, 0x00, 0x2A, 0x05, 0x03, 0x00, 0x23, 0x04, 0x05, 0x00, 0x1C, 0x04, 0x04, 0x00, 0x27, 0x05, 
  0x00, 0x00, 0x2D, 0x05, 0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x29, 0x05, 0x01, 0x00, 0x30, 0x00, 
  0x05, 0x00, 0x2A, 0x06, 0x04, 0x00, 0x33, 0x05, 0x06, 0x00, 0x2F, 0x05, 0x00, 0x00, 0x2A, 0x07, 
  0x05, 0x00, 0x33, 0x06, 0x07, 0x00, 0x19, 0x05, 0x06, 0x00, 0x2F, 0x05, 0x00, 0x00, 0x2A, 0x07, 
  0x06, 0x00, 0x33, 0x06, 0x07, 0x00, 0x1C, 0x06, 0x05, 0x00, 0x2F, 0x05, 0x00, 0x00, 0x2B, 0x08, 
  0x00, 0x05, 0x33, 0x07, 0x08, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 
  0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xBF, 0xFF, 0x87, 0x6F, 0x03, 0x02, 0x09, 0x00, 0x09, 0x00, 
  0x09, 0x00, 0x09, 0x00, 0x05, 0x02, 0x09, 0x00, 0x09, 0xBF, 0xFF, 0x07, 0x03, 0x0B, 0x00, 0x0B, 
  0x00, 0x0B, 0x00, 0x0B, 0x01, 0x0B, 0x00, 0x0B, 0x01, 0x09, 0x00, 0x09, 0xBF, 0xFB, 0x07, 0x07, 
  0x0B, 0x00, 0x0B, 0xBF, 0xFF, 0x09, 0x05, 0x21, 0x00, 0x21, 0x00, 0x21, 0x00, 0x21, 0x00, 0x14, 
  0x00, 0x14, 0x00, 0x14, 0x00, 0x0B, 0x01, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0B, 0x01, 0x0D, 
  0x00, 0x0D, 0x00, 0x0D, 0xBF, 0xFF, 0x0B, 0xBF, 0xFE, 0x09, 0xBF, 0xF6, 0x07, 0xBF, 0xFF, 0x05, 
  0x87, 0x62, 0x01, 0x08, 0x03, 0x01, 0x03, 0x01, 0x03, 0x00, 0x03, 0x03, 0x03, 0x00, 0x03, 0x13, 
  0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x03, 0x01, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x22, 0x00, 
  0x22, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x39, 0x00, 0x39, 0x00, 0x39, 0x00, 
  0x39, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x03, 0x01, 
  0x15, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x2C, 0x00, 0x00, 
  0x00, 0xCF, 0x0A, 0x66, 0x69, 0x6C, 0x65, 0x2F, 0x63, 0x6C, 0x6F, 0x73, 0x65, 0xDA, 0x81, 0x08, 
  0xCF, 0x07, 0x6D, 0x61, 0x72, 0x73, 0x68, 0x61, 0x6C, 0xD8, 0x07, 0x6D, 0x61, 0x72, 0x73, 0x68, 
  0x61, 0x6C, 0xCF, 0x0E, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x70, 0x72, 0x6F, 0x64, 0x75, 
  0x63, 0x65, 0xDA, 0x80, 0xF5, 0xCF, 0x0A, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x65, 0x78, 0x70, 0x6D, 
  0x31, 0xD8, 0x0A, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x65, 0x78, 0x70, 0x6D, 0x31, 0xCF, 0x0D, 0x62, 
  0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0xDA, 0x6D, 0xCF, 0x12, 
  0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2F, 0x65, 0x78, 0x70, 0x61, 0x6E, 0x64, 0x2D, 0x70, 0x61, 
  0x74, 0x68, 0xDA, 0x80, 0xB7, 0xCF, 0x12, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x68, 0x61, 
  0x73, 0x2D, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x3F, 0xDA, 0x80, 0x96, 0xCF, 0x04, 0x6E, 0x65, 
  0x78, 0x74, 0xDA, 0x81, 0xB0, 0xCF, 0x06, 0x65, 0x64, 0x65, 0x66, 0x65, 0x72, 0xD7, 0xCD, 0x00, 
  0x99, 0x00, 0x00, 0x0B, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x0C, 0x2F, 0xCE, 0x06, 0x65, 
  0x64, 0x65, 0x66, 0x65, 0x72, 0xDA, 0x05, 0xDA, 0x22, 0xDA, 0x23, 0xDA, 0x24, 0xDA, 0x25, 0xDA, 
  0x26, 0xDA, 0x28, 0xDA, 0x29, 0xDA, 0x2A, 0xDA, 0x2B, 0xDA, 0x2D, 0xDA, 0x2F, 0xDA, 0x2E, 0x2C, 
  0x02, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x04, 0x03, 0x00, 0x2A, 
  0x05, 0x00, 0x00, 0x33, 0x03, 0x05, 0x00, 0x19, 0x05, 0x03, 0x00, 0x44, 0x03, 0x00, 0x00, 0x2A, 
  0x07, 0x01, 0x00, 0x30, 0x07, 0x03, 0x00, 0x32, 0x01, 0x00, 0x00, 0x43, 0x06, 0x00, 0x00, 0x2A, 
  0x07, 0x02, 0x00, 0x2A, 0x08, 0x03, 0x00, 0x31, 0x07, 0x06, 0x08, 0x43, 0x03, 0x00, 0x00, 0x2A, 
  0x07, 0x04, 0x00, 0x31, 0x07, 0x04, 0x03, 0x43, 0x06, 0x00, 0x00, 0x2A, 0x07, 0x05, 0x00, 0x30, 
  0x07, 0x04, 0x00, 0x43, 0x03, 0x00, 0x00, 0x2A, 0x08, 0x04, 0x00, 0x31, 0x08, 0x05, 0x03, 0x43, 
  0x07, 0x00, 0x00, 0x2A, 0x08, 0x06, 0x00, 0x30, 0x08, 0x04, 0x00, 0x43, 0x03, 0x00, 0x00, 0x2A, 
  0x09, 0x07, 0x00, 0x2A, 0x0A, 0x08, 0x00, 0x31, 0x09, 0x03, 0x0A, 0x43, 0x08, 0x00, 0x00, 0x2A, 
  0x09, 0x09, 0x00, 0x31, 0x09, 0x05, 0x04, 0x43, 0x03, 0x00, 0x00, 0x2A, 0x0A, 0x0A, 0x00, 0x31, 
  0x0A, 0x00, 0x03, 0x43, 0x09, 0x00, 0x00, 0x2A, 0x0A, 0x0B, 0x00, 0x31, 0x0A, 0x08, 0x05, 0x2F, 
  0x09, 0x00, 0x00, 0x43, 0x03, 0x00, 0x00, 0x2A, 0x09, 0x0A, 0x00, 0x31, 0x09, 0x06, 0x07, 0x2F, 
  0x03, 0x00, 0x00, 0x43, 0x08, 0x00, 0x00, 0x03, 0x08, 0x00, 0x00, 0x81, 0x37, 0x01, 0x04, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xCF, 0x07, 0x69, 0x66, 0x2D, 0x77, 
  0x69, 0x74, 0x68, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0B, 0x03, 0x02, 0x03, 0x03, 0x1A, 0xCE, 
  0x07, 0x69, 0x66, 0x2D, 0x77, 0x69, 0x74, 0x68, 0xDA, 0x05, 0xDA, 0x20, 0xDA, 0x30, 0xDA, 0x31, 
  0x3B, 0x03, 0x00, 0x00, 0x19, 0x04, 0x03, 0x00, 0x3B, 0x03, 0x00, 0x01, 0x19, 0x05, 0x03, 0x00, 
  0x3B, 0x03, 0x00, 0x02, 0x19, 0x06, 0x03, 0x00, 0x2C, 0x00, 0x00, 0x00, 0x30, 0x04, 0x05, 0x00, 
  0x44, 0x03, 0x00, 0x00, 0x1C, 0x06, 0x03, 0x00, 0x19, 0x07, 0x06, 0x00, 0x1A, 0x02, 0x00, 0x00, 
  0x2A, 0x07, 0x00, 0x00, 0x30, 0x07, 0x04, 0x00, 0x43, 0x07, 0x00, 0x00, 0x2F, 0x01, 0x00, 0x00, 
  0x43, 0x08, 0x00, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x32, 0x08, 0x00, 0x00, 0x2A, 0x0A, 0x01, 0x00, 
  0x33, 0x09, 0x0A, 0x00, 0x2A, 0x08, 0x02, 0x00, 0x31, 0x08, 0x03, 0x09, 0x2F, 0x02, 0x00, 0x00, 
  0x43, 0x07, 0x00, 0x00, 0x03, 0x07, 0x00, 0x00, 0x81, 0x75, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 
  0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x05, 0x03, 0x00, 0x03, 0x01, 0x15, 0x00, 0x15, 0x00, 
  0x15, 0x00, 0x15, 0x00, 0x14, 0x00, 0x14, 0x00, 0x2F, 0x00, 0x2F, 0x00, 0x07, 0x00, 0x07, 0x00, 
  0x07, 0x00, 0x07, 0xBF, 0xFF, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x04, 
  0x6E, 0x61, 0x6E, 0x3F, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x03, 0x01, 0x01, 0x01, 0x00, 0x07, 
  0xCE, 0x04, 0x6E, 0x61, 0x6E, 0x3F, 0xDA, 0x05, 0x2C, 0x01, 0x00, 0x00, 0x23, 0x02, 0x00, 0x00, 
  0x1B, 0x02, 0x03, 0x00, 0x27, 0x02, 0x00, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x28, 0x02, 0x00, 0x00, 
  0x03, 0x02, 0x00, 0x00, 0x51, 0x01, 0x00, 0x24, 0x00, 0x24, 0x00, 0x24, 0x00, 0x24, 0x00, 0x24, 
  0x00, 0x24, 0xCF, 0x0C, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x63, 0x6C, 0x65, 0x61, 0x72, 
  0xDA, 0x80, 0xEF, 0xCF, 0x01, 0x2A, 0xD7, 0xCD, 0x00, 0x09, 0x00, 0x0B, 0x06, 0x00, 0x00, 0xCD, 
  0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x13, 0xCE, 0x01, 0x2A, 0x3D, 0x01, 0x00, 0x00, 0x24, 0x02, 0x01, 
  0x00, 0x1C, 0x02, 0x03, 0x00, 0x29, 0x03, 0x01, 0x00, 0x03, 0x03, 0x00, 0x00, 0x24, 0x02, 0x01, 
  0x01, 0x1C, 0x02, 0x05, 0x00, 0x29, 0x03, 0x01, 0x00, 0x3B, 0x04, 0x00, 0x00, 0x09, 0x03, 0x03, 
  0x04, 0x03, 0x03, 0x00, 0x00, 0x3B, 0x03, 0x00, 0x00, 0x29, 0x05, 0x01, 0x00, 0x38, 0x04, 0x00, 
  0x05, 0x09, 0x03, 0x03, 0x04, 0x05, 0x05, 0x05, 0x01, 0x23, 0x02, 0x05, 0x01, 0x1C, 0x02, 0xFC, 
  0xFF, 0x03, 0x03, 0x00, 0x00, 0xCF, 0x03, 0x67, 0x65, 0x74, 0xD7, 0xCD, 0x00, 0x08, 0x00, 0x1B, 
  0x04, 0x03, 0x02, 0x03, 0x00, 0x06, 0xCE, 0x03, 0x67, 0x65, 0x74, 0x39, 0x00, 0x00, 0x01, 0x26, 
  0x03, 0x00, 0x00, 0x23, 0x03, 0x00, 0x03, 0x1B, 0x03, 0x02, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 
  0x02, 0x00, 0x00, 0xCF, 0x07, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0xD7, 0xCD, 0x00, 0x98, 
  0x00, 0x00, 0x0A, 0x02, 0x02, 0x02, 0x02, 0x23, 0xCE, 0x07, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 
  0x65, 0xDA, 0x05, 0xD0, 0x07, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0xD7, 0xCD, 0x00, 0x98, 
  0x00, 0x00, 0x07, 0x02, 0x02, 0x02, 0x00, 0x0E, 0xCE, 0x11, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 
  0x65, 0x2D, 0x70, 0x72, 0x69, 0x6D, 0x69, 0x74, 0x69, 0x76, 0x65, 0xDA, 0x05, 0x2C, 0x02, 0x00, 
  0x00, 0x23, 0x03, 0x00, 0x01, 0x1C, 0x03, 0x03, 0x00, 0x29, 0x04, 0x00, 0x00, 0x03, 0x04, 0x00, 
  0x00, 0x21, 0x04, 0x00, 0x01, 0x1C, 0x04, 0x03, 0x00, 0x29, 0x05, 0xFF, 0xFF, 0x03, 0x05, 0x00, 
  0x00, 0x1F, 0x05, 0x00, 0x01, 0x1C, 0x05, 0x03, 0x00, 0x29, 0x06, 0x01, 0x00, 0x03, 0x06, 0x00, 
  0x00, 0x04, 0x00, 0x00, 0x00, 0x82, 0xA0, 0x01, 0x06, 0x05, 0xBF, 0xFF, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x02, 0x05, 0xBF, 0xFE, 0x03, 0x00, 0x03, 0x00, 0x03, 0x03, 0x05, 0xBF, 0xFD, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x2C, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x39, 0x03, 0x00, 
  0x04, 0x19, 0x04, 0x03, 0x00, 0x1C, 0x04, 0x05, 0x00, 0x30, 0x00, 0x01, 0x00, 0x33, 0x05, 0x04, 
  0x00, 0x19, 0x03, 0x05, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x26, 0x03, 0x00, 0x00, 0x19, 0x04, 0x03, 
  0x00, 0x1C, 0x04, 0x02, 0x00, 0x03, 0x04, 0x00, 0x00, 0x2A, 0x05, 0x00, 0x00, 0x39, 0x03, 0x01, 
  0x05, 0x19, 0x05, 0x03, 0x00, 0x1C, 0x05, 0x0C, 0x00, 0x30, 0x01, 0x00, 0x00, 0x33, 0x06, 0x05, 
  0x00, 0x19, 0x07, 0x06, 0x00, 0x1C, 0x07, 0x05, 0x00, 0x29, 0x09, 0x00, 0x00, 0x07, 0x08, 0x09, 
  0x07, 0x19, 0x06, 0x08, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x26, 0x06, 0x00, 0x00, 0x19, 0x03, 0x06, 
  0x00, 0x1A, 0x02, 0x00, 0x00, 0x26, 0x03, 0x00, 0x00, 0x19, 0x05, 0x03, 0x00, 0x1C, 0x05, 0x02, 
  0x00, 0x03, 0x05, 0x00, 0x00, 0x30, 0x00, 0x01, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x34, 0x03, 0x00, 
  0x00, 0x82, 0xAA, 0x01, 0x08, 0x12, 0x00, 0x12, 0x00, 0x05, 0x00, 0x05, 0x00, 0x24, 0x00, 0x24, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xBF, 0xFF, 0x03, 0x00, 0x03, 0x00, 0x03, 0x02, 0x12, 0x00, 
  0x12, 0x00, 0x05, 0x00, 0x05, 0x01, 0x14, 0x00, 0x14, 0xBF, 0xFF, 0x05, 0x00, 0x05, 0x01, 0x1D, 
  0x00, 0x1D, 0xBF, 0xFF, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xBF, 
  0xFE, 0x03, 0x00, 0x03, 0x00, 0x03, 0x04, 0x05, 0x00, 0x05, 0x00, 0x05, 0xCF, 0x0C, 0x70, 0x61, 
  0x72, 0x73, 0x65, 0x72, 0x2F, 0x65, 0x72, 0x72, 0x6F, 0x72, 0xDA, 0x80, 0xE7, 0xCF, 0x0A, 0x6F, 
  0x73, 0x2F, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0xD8, 0x0A, 0x6F, 0x73, 0x2F, 0x65, 0x78, 
  0x65, 0x63, 0x75, 0x74, 0x65, 0xCF, 0x09, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x6E, 0x65, 0x77, 
  0xDA, 0x55, 0xCF, 0x09, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x63, 0x65, 0x69, 0x6C, 0xD8, 0x09, 0x6D, 
  0x61, 0x74, 0x68, 0x2F, 0x63, 0x65, 0x69, 0x6C, 0xCF, 0x0D, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 
  0x75, 0x6E, 0x62, 0x72, 0x65, 0x61, 0x6B, 0xD8, 0x0D, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 0x75, 
  0x6E, 0x62, 0x72, 0x65, 0x61, 0x6B, 0xCF, 0x03, 0x61, 0x6E, 0x64, 0xD7, 0xCD, 0x00, 0x99, 0x00, 
  0x00, 0x0D, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x04, 0x26, 0xCE, 0x03, 0x61, 0x6E, 0x64, 
  0xDA, 0x05, 0xDA, 0x81, 0x63, 0xDA, 0x2E, 0xDA, 0x22, 0xDA, 0x26, 0x2C, 0x01, 0x00, 0x00, 0x27, 
  0x02, 0x00, 0x00, 0x3D, 0x03, 0x00, 0x00, 0x19, 0x04, 0x03, 0x00, 0x19, 0x05, 0x04, 0x00, 0x29, 
  0x07, 0x00, 0x00, 0x1F, 0x06, 0x05, 0x07, 0x1C, 0x06, 0x1E, 0x00, 0x29, 0x07, 0x01, 0x00, 0x07, 
  0x05, 0x05, 0x07, 0x38, 0x07, 0x00, 0x05, 0x19, 0x08, 0x07, 0x00, 0x27, 0x09, 0x00, 0x00, 0x23, 
  0x07, 0x02, 0x09, 0x1C, 0x07, 0x03, 0x00, 0x19, 0x02, 0x08, 0x00, 0x1A, 0x14, 0x00, 0x00, 0x2F, 
  0x08, 0x00, 0x00, 0x2A, 0x0A, 0x00, 0x00, 0x33, 0x09, 0x0A, 0x00, 0x1C, 0x09, 0x06, 0x00, 0x2A, 
  0x0A, 0x01, 0x00, 0x31, 0x0A, 0x08, 0x02, 0x2F, 0x08, 0x00, 0x00, 0x43, 0x02, 0x00, 0x00, 0x1A, 
  0x0B, 0x00, 0x00, 0x2A, 0x0B, 0x02, 0x00, 0x33, 0x0A, 0x0B, 0x00, 0x19, 0x0B, 0x0A, 0x00, 0x2A, 
  0x0A, 0x03, 0x00, 0x31, 0x0A, 0x0B, 0x08, 0x43, 0x0A, 0x00, 0x00, 0x2A, 0x0C, 0x01, 0x00, 0x31, 
  0x0C, 0x0A, 0x02, 0x2F, 0x0B, 0x00, 0x00, 0x43, 0x02, 0x00, 0x00, 0x1A, 0xE1, 0xFF, 0xFF, 0x03, 
  0x02, 0x00, 0x00, 0x80, 0xFB, 0x01, 0x04, 0x03, 0x01, 0x0C, 0x00, 0x03, 0x01, 0x03, 0x01, 0x0A, 
  0x00, 0x0A, 0x00, 0x03, 0x01, 0x05, 0x00, 0x05, 0x01, 0x0C, 0x00, 0x05, 0x01, 0x12, 0x00, 0x12, 
  0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x02, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x10, 0x01, 0x12, 
  0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0xBF, 0xFF, 0x10, 0x02, 0x1D, 0x00, 0x1D, 0x00, 0x16, 0x01, 
  0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0xBF, 0xF8, 0x03, 
  0xBF, 0xF9, 0x01, 0xCF, 0x04, 0x64, 0x72, 0x6F, 0x70, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0E, 
  0x02, 0x02, 0x02, 0x03, 0x1C, 0xCE, 0x04, 0x64, 0x72, 0x6F, 0x70, 0xDA, 0x05, 0xDA, 0x81, 0x1E, 
  0xDA, 0x81, 0x1F, 0xDA, 0x70, 0x2C, 0x02, 0x00, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x04, 0x00, 
  0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x04, 0x03, 0x00, 0x1C, 0x04, 0x03, 0x00, 0x2A, 0x05, 0x01, 
  0x00, 0x1A, 0x02, 0x00, 0x00, 0x2A, 0x05, 0x02, 0x00, 0x19, 0x06, 0x05, 0x00, 0x3D, 0x07, 0x01, 
  0x00, 0x19, 0x08, 0x07, 0x00, 0x29, 0x0B, 0x00, 0x00, 0x1F, 0x0A, 0x00, 0x0B, 0x1C, 0x0A, 0x03, 
  0x00, 0x19, 0x09, 0x00, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x29, 0x09, 0x00, 0x00, 0x19, 0x0A, 0x09, 
  0x00, 0x1F, 0x0C, 0x0A, 0x08, 0x1C, 0x0C, 0x03, 0x00, 0x19, 0x0B, 0x08, 0x00, 0x1A, 0x02, 0x00, 
  0x00, 0x19, 0x0B, 0x0A, 0x00, 0x19, 0x0C, 0x0B, 0x00, 0x29, 0x0D, 0xFF, 0xFF, 0x31, 0x01, 0x0C, 
  0x0D, 0x34, 0x06, 0x00, 0x00, 0x83, 0xC5, 0x01, 0x03, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x03, 
  0x01, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x0C, 0x00, 0x03, 0x02, 0x0E, 
  0x00, 0x0E, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x12, 0x00, 0x0E, 
  0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0xDA, 0x47, 
  0xDA, 0x46, 0xCF, 0x07, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x70, 0x69, 0xC8, 0x18, 0x2D, 0x44, 0x54, 
  0xFB, 0x21, 0x09, 0x40, 0xCF, 0x08, 0x62, 0x6F, 0x6F, 0x6C, 0x65, 0x61, 0x6E, 0x3F, 0xD7, 0xCD, 
  0x00, 0x98, 0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 0x02, 0x07, 0xCE, 0x08, 0x62, 0x6F, 0x6F, 0x6C, 
  0x65, 0x61, 0x6E, 0x3F, 0xDA, 0x05, 0xDA, 0x39, 0xD0, 0x07, 0x62, 0x6F, 0x6F, 0x6C, 0x65, 0x61, 
  0x6E, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 
  0x00, 0x2A, 0x04, 0x01, 0x00, 0x23, 0x03, 0x02, 0x04, 0x03, 0x03, 0x00, 0x00, 0x65, 0x01, 0x00, 
  0x32, 0x00, 0x32, 0x00, 0x32, 0x00, 0x2F, 0x00, 0x2F, 0x00, 0x2F, 0xCF, 0x07, 0x72, 0x65, 0x64, 
  0x75, 0x63, 0x65, 0x32, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x09, 0x02, 0x02, 0x02, 0x00, 0x19, 
  0xCE, 0x07, 0x72, 0x65, 0x64, 0x75, 0x63, 0x65, 0x32, 0xDA, 0x05, 0x2C, 0x02, 0x00, 0x00, 0x26, 
  0x04, 0x00, 0x00, 0x47, 0x03, 0x01, 0x04, 0x19, 0x04, 0x03, 0x00, 0x26, 0x06, 0x00, 0x00, 0x23, 
  0x05, 0x06, 0x04, 0x1C, 0x05, 0x03, 0x00, 0x04, 0x00, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x38, 
  0x05, 0x01, 0x04, 0x19, 0x06, 0x05, 0x00, 0x47, 0x04, 0x01, 0x04, 0x26, 0x08, 0x00, 0x00, 0x23, 
  0x07, 0x08, 0x04, 0x1B, 0x07, 0x03, 0x00, 0x27, 0x07, 0x00, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x28, 
  0x07, 0x00, 0x00, 0x1C, 0x07, 0x06, 0x00, 0x38, 0x08, 0x01, 0x04, 0x30, 0x06, 0x08, 0x00, 0x33, 
  0x06, 0x00, 0x00, 0x47, 0x04, 0x01, 0x04, 0x1A, 0xF5, 0xFF, 0xFF, 0x03, 0x06, 0x00, 0x00, 0x83, 
  0x1A, 0x01, 0x04, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x07, 0x00, 0x07, 0x00, 0x03, 0x00, 0x11, 
  0x00, 0x03, 0x01, 0x0C, 0x00, 0x03, 0x01, 0x0A, 0x01, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 
  0x00, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x15, 0x00, 0x0E, 0x00, 0x0E, 0x01, 0x0C, 0xBF, 0xFE, 
  0x03, 0xBF, 0xF8, 0x01, 0xCF, 0x0F, 0x6C, 0x6F, 0x61, 0x64, 0x2D, 0x69, 0x6D, 0x61, 0x67, 0x65, 
  0x2D, 0x64, 0x69, 0x63, 0x74, 0xDA, 0x81, 0x17, 0xCF, 0x0E, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2F, 
  0x73, 0x65, 0x74, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0xDA, 0x80, 0xDA, 0xCF, 0x0E, 0x6F, 0x73, 0x2F, 
  0x70, 0x65, 0x72, 0x6D, 0x2D, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0xD8, 0x0E, 0x6F, 0x73, 0x2F, 
  0x70, 0x65, 0x72, 0x6D, 0x2D, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0xCF, 0x0C, 0x73, 0x74, 0x72, 
  0x69, 0x6E, 0x67, 0x2F, 0x74, 0x72, 0x69, 0x6D, 0x72, 0xD8, 0x0C, 0x73, 0x74, 0x72, 0x69, 0x6E, 
  0x67, 0x2F, 0x74, 0x72, 0x69, 0x6D, 0x72, 0xCF, 0x04, 0x63, 0x6F, 0x6E, 0x64, 0xD7, 0xCD, 0x02, 
  0xBB, 0x00, 0x00, 0x05, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x06, 0x01, 0xCE, 0x04, 
  0x63, 0x6F, 0x6E, 0x64, 0xDA, 0x05, 0x2C, 0x01, 0x00, 0x00, 0x2E, 0x02, 0x00, 0x00, 0x19, 0x03, 
  0x02, 0x00, 0x29, 0x04, 0x00, 0x00, 0x2F, 0x04, 0x00, 0x00, 0x34, 0x03, 0x00, 0x00, 0xCD, 0x00, 
  0xD8, 0x00, 0x00, 0x0A, 0x01, 0x01, 0x01, 0x02, 0x1E, 0x01, 0xCE, 0x03, 0x61, 0x75, 0x78, 0xDA, 
  0x05, 0xDA, 0x2E, 0xDA, 0x81, 0x65, 0x2C, 0x01, 0x00, 0x00, 0x2B, 0x03, 0x00, 0x00, 0x3D, 0x02, 
  0x03, 0x00, 0x07, 0x03, 0x02, 0x00, 0x19, 0x02, 0x03, 0x00, 0x29, 0x05, 0x00, 0x00, 0x23, 0x04, 
  0x02, 0x05, 0x1C, 0x04, 0x02, 0x00, 0x04, 0x00, 0x00, 0x00, 0x29, 0x06, 0x01, 0x00, 0x23, 0x05, 
  0x02, 0x06, 0x1C, 0x05, 0x04, 0x00, 0x2B, 0x07, 0x00, 0x00, 0x38, 0x06, 0x07, 0x00, 0x03, 0x06, 
  0x00, 0x00, 0x2B, 0x07, 0x00, 0x00, 0x38, 0x06, 0x07, 0x00, 0x29, 0x08, 0x01, 0x00, 0x06, 0x07, 
  0x00, 0x08, 0x2B, 0x09, 0x00, 0x00, 0x38, 0x08, 0x09, 0x07, 0x29, 0x09, 0x02, 0x00, 0x06, 0x07, 
  0x00, 0x09, 0x2F, 0x07, 0x00, 0x00, 0x33, 0x09, 0x01, 0x00, 0x2A, 0x07, 0x00, 0x00, 0x31, 0x07, 
  0x06, 0x08, 0x2F, 0x09, 0x00, 0x00, 0x2A, 0x07, 0x01, 0x00, 0x34, 0x07, 0x00, 0x00, 0xBF, 0xFF, 
  0x80, 0xB4, 0x03, 0x01, 0x15, 0x00, 0x15, 0x00, 0x12, 0x00, 0x05, 0x01, 0x09, 0x00, 0x09, 0x00, 
  0x05, 0x00, 0x05, 0x01, 0x0B, 0x00, 0x0B, 0x00, 0x07, 0x00, 0x19, 0x00, 0x19, 0x00, 0x19, 0x01, 
  0x14, 0x00, 0x14, 0x01, 0x1A, 0x00, 0x1A, 0x00, 0x10, 0x00, 0x10, 0x01, 0x15, 0x00, 0x15, 0x00, 
  0x10, 0x00, 0x10, 0xBF, 0xFE, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x80, 0xAE, 
  0x01, 0x06, 0x03, 0x00, 0x03, 0x07, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x00, 0x00, 0x00, 0xCF, 
  0x06, 0x65, 0x70, 0x72, 0x69, 0x6E, 0x66, 0xD8, 0x06, 0x65, 0x70, 0x72, 0x69, 0x6E, 0x66, 0xCF, 
  0x0A, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x61, 0x74, 0x61, 0x6E, 0x32, 0xD8, 0x0A, 0x6D, 0x61, 0x74, 
  0x68, 0x2F, 0x61, 0x74, 0x61, 0x6E, 0x32, 0xDA, 0x81, 0x95, 0xD7, 0xCD, 0x00, 0x99, 0x00, 0x00, 
  0x06, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x02, 0x09, 0xCE, 0x04, 0x77, 0x68, 0x65, 0x6E, 
  0xDA, 0x05, 0xDA, 0x2F, 0xDA, 0x2E, 0x2C, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x2F, 0x04, 
  0x00, 0x00, 0x32, 0x01, 0x00, 0x00, 0x43, 0x03, 0x00, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x31, 0x05, 
  0x00, 0x03, 0x43, 0x04, 0x00, 0x00, 0x03, 0x04, 0x00, 0x00, 0x80, 0xA4, 0x01, 0x03, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x06, 0x72, 
  0x65, 0x73, 0x75, 0x6D, 0x65, 0xDA, 0x28, 0xCF, 0x09, 0x66, 0x69, 0x6C, 0x65, 0x2F, 0x72, 0x65, 
  0x61, 0x64, 0xDA, 0x81, 0x0A, 0xCF, 0x0B, 0x70, 0x65, 0x67, 0x2F, 0x63, 0x6F, 0x6D, 0x70, 0x69, 
  0x6C, 0x65, 0xD8, 0x0B, 0x70, 0x65, 0x67, 0x2F, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0xCF, 
  0x08, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x70, 0x6F, 0x77, 0xD8, 0x08, 0x6D, 0x61, 0x74, 0x68, 0x2F, 
  0x70, 0x6F, 0x77, 0xCF, 0x06, 0x64, 0x69, 0x73, 0x61, 0x73, 0x6D, 0xD8, 0x06, 0x64, 0x69, 0x73, 
  0x61, 0x73, 0x6D, 0xCF, 0x05, 0x6D, 0x61, 0x74, 0x63, 0x68, 0xD7, 0xCD, 0x02, 0xBB, 0x00, 0x00, 
  0x0A, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x06, 0x22, 0x01, 0xCE, 0x05, 0x6D, 0x61, 0x74, 
  0x63, 0x68, 0xDA, 0x05, 0xDA, 0x81, 0x63, 0xDA, 0x22, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x04, 
  0x01, 0x01, 0x01, 0x00, 0x04, 0xCE, 0x03, 0x64, 0x65, 0x63, 0xDA, 0x05, 0x2C, 0x01, 0x00, 0x00, 
  0x29, 0x03, 0x01, 0x00, 0x07, 0x02, 0x00, 0x03, 0x03, 0x02, 0x00, 0x00, 0x80, 0x82, 0x01, 0x00, 
  0x20, 0x00, 0x20, 0x00, 0x20, 0xDA, 0x26, 0xDA, 0x81, 0x65, 0xDA, 0x2F, 0x2C, 0x02, 0x00, 0x00, 
  0x19, 0x03, 0x00, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x06, 0x00, 0x00, 0x33, 0x05, 0x06, 0x00, 
  0x1C, 0x05, 0x03, 0x00, 0x19, 0x04, 0x03, 0x00, 0x1A, 0x04, 0x00, 0x00, 0x2A, 0x07, 0x01, 0x00, 
  0x33, 0x06, 0x07, 0x00, 0x19, 0x04, 0x06, 0x00, 0x19, 0x05, 0x04, 0x00, 0x3D, 0x04, 0x01, 0x00, 
  0x19, 0x06, 0x04, 0x00, 0x2F, 0x06, 0x00, 0x00, 0x2A, 0x07, 0x02, 0x00, 0x33, 0x04, 0x07, 0x00, 
  0x19, 0x07, 0x04, 0x00, 0x2E, 0x04, 0x00, 0x00, 0x29, 0x08, 0x00, 0x00, 0x2F, 0x08, 0x00, 0x00, 
  0x33, 0x08, 0x04, 0x00, 0x19, 0x04, 0x08, 0x00, 0x23, 0x06, 0x03, 0x05, 0x1C, 0x06, 0x02, 0x00, 
  0x03, 0x04, 0x00, 0x00, 0x2A, 0x08, 0x03, 0x00, 0x31, 0x08, 0x05, 0x03, 0x2A, 0x09, 0x04, 0x00, 
  0x33, 0x08, 0x09, 0x00, 0x2A, 0x09, 0x05, 0x00, 0x31, 0x09, 0x08, 0x04, 0x2A, 0x09, 0x04, 0x00, 
  0x34, 0x09, 0x00, 0x00, 0xCD, 0x02, 0xFA, 0x00, 0x00, 0x0A, 0x01, 0x01, 0x01, 0x06, 0x27, 0x01, 
  0x01, 0xDA, 0x82, 0x7E, 0xDA, 0x05, 0xDA, 0x22, 0xD7, 0xCD, 0x02, 0xBA, 0x00, 0x00, 0x14, 0x04, 
  0x04, 0x04, 0x12, 0x80, 0xA8, 0x03, 0xCE, 0x07, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x2D, 0x31, 0xDA, 
  0x05, 0xCF, 0x01, 0x5F, 0xDA, 0x82, 0x15, 0xDA, 0x2A, 0xDA, 0x2E, 0xD2, 0x02, 0x00, 0xDA, 0x82, 
  0x16, 0xCF, 0x07, 0x5F, 0x30, 0x30, 0x30, 0x30, 0x31, 0x67, 0xDA, 0x26, 0xDA, 0x2F, 0xD7, 0xCD, 
  0x00, 0x98, 0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 0x02, 0x07, 0xCE, 0x06, 0x74, 0x75, 0x70, 0x6C, 
  0x65, 0x3F, 0xDA, 0x05, 0xDA, 0x39, 0xDA, 0x72, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
  0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x23, 0x03, 0x02, 0x04, 
  0x03, 0x03, 0x00, 0x00, 0x64, 0x01, 0x00, 0x2E, 0x00, 0x2E, 0x00, 0x2E, 0x00, 0x2B, 0x00, 0x2B, 
  0x00, 0x2B, 0xDA, 0x82, 0x18, 0xD0, 0x06, 0x70, 0x61, 0x72, 0x65, 0x6E, 0x73, 0xCF, 0x01, 0x40, 
  0xDA, 0x81, 0x9D, 0xDA, 0x81, 0x63, 0xDA, 0x22, 0xD7, 0xCD, 0x00, 0x08, 0x00, 0x08, 0x01, 0x01, 
  0x01, 0x01, 0x00, 0x02, 0xCE, 0x06, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x3D, 0x00, 0x00, 0x00, 
  0x03, 0x00, 0x00, 0x00, 0xCF, 0x01, 0x3C, 0xDA, 0x81, 0x65, 0xDA, 0x80, 0x89, 0x2C, 0x04, 0x00, 
  0x00, 0x2A, 0x06, 0x00, 0x00, 0x23, 0x05, 0x06, 0x00, 0x1C, 0x05, 0x02, 0x00, 0x34, 0x02, 0x00, 
  0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x07, 0x01, 0x00, 0x33, 0x06, 0x07, 0x00, 0x1C, 0x06, 0x17, 
  0x00, 0x38, 0x07, 0x03, 0x00, 0x1C, 0x07, 0x0B, 0x00, 0x2A, 0x09, 0x02, 0x00, 0x31, 0x09, 0x00, 
  0x01, 0x43, 0x08, 0x00, 0x00, 0x33, 0x09, 0x02, 0x00, 0x2A, 0x0B, 0x03, 0x00, 0x31, 0x0B, 0x08, 
  0x09, 0x2A, 0x0B, 0x04, 0x00, 0x2F, 0x0B, 0x00, 0x00, 0x43, 0x0A, 0x00, 0x00, 0x03, 0x0A, 0x00, 
  0x00, 0x27, 0x08, 0x00, 0x00, 0x3A, 0x03, 0x00, 0x08, 0x2A, 0x09, 0x05, 0x00, 0x31, 0x09, 0x00, 
  0x01, 0x43, 0x08, 0x00, 0x00, 0x33, 0x09, 0x02, 0x00, 0x2A, 0x0B, 0x06, 0x00, 0x31, 0x0B, 0x08, 
  0x09, 0x43, 0x0A, 0x00, 0x00, 0x03, 0x0A, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x09, 0x07, 
  0x00, 0x33, 0x08, 0x09, 0x00, 0x19, 0x09, 0x08, 0x00, 0x1C, 0x08, 0x08, 0x00, 0x2F, 0x00, 0x00, 
  0x00, 0x2A, 0x0B, 0x08, 0x00, 0x33, 0x0A, 0x0B, 0x00, 0x2A, 0x0C, 0x09, 0x00, 0x23, 0x0B, 0x0C, 
  0x0A, 0x19, 0x07, 0x0B, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x07, 0x09, 0x00, 0x1C, 0x07, 0x18, 
  0x00, 0x29, 0x09, 0x00, 0x00, 0x39, 0x08, 0x00, 0x09, 0x2A, 0x0A, 0x0A, 0x00, 0x23, 0x09, 0x08, 
  0x0A, 0x1C, 0x09, 0x0D, 0x00, 0x29, 0x0A, 0x01, 0x00, 0x39, 0x08, 0x00, 0x0A, 0x2A, 0x0B, 0x02, 
  0x00, 0x31, 0x0B, 0x08, 0x01, 0x43, 0x0A, 0x00, 0x00, 0x33, 0x08, 0x02, 0x00, 0x2A, 0x0C, 0x03, 
  0x00, 0x31, 0x0C, 0x0A, 0x08, 0x2A, 0x0C, 0x04, 0x00, 0x2F, 0x0C, 0x00, 0x00, 0x43, 0x0B, 0x00, 
  0x00, 0x03, 0x0B, 0x00, 0x00, 0x29, 0x0A, 0x00, 0x00, 0x38, 0x08, 0x00, 0x0A, 0x2E, 0x0A, 0x00, 
  0x00, 0x31, 0x08, 0x01, 0x0A, 0x2F, 0x03, 0x00, 0x00, 0x34, 0x04, 0x00, 0x00, 0x2F, 0x00, 0x00, 
  0x00, 0x2A, 0x09, 0x0B, 0x00, 0x33, 0x08, 0x09, 0x00, 0x1C, 0x08, 0x30, 0x00, 0x3D, 0x09, 0x00, 
  0x00, 0x19, 0x0A, 0x09, 0x00, 0x29, 0x09, 0xFF, 0xFF, 0x19, 0x0B, 0x01, 0x00, 0x2F, 0x0B, 0x00, 
  0x00, 0x2A, 0x0E, 0x0C, 0x00, 0x33, 0x0D, 0x0E, 0x00, 0x1C, 0x0D, 0x03, 0x00, 0x19, 0x0C, 0x0B, 
  0x00, 0x1A, 0x04, 0x00, 0x00, 0x2A, 0x0F, 0x0D, 0x00, 0x33, 0x0E, 0x0F, 0x00, 0x19, 0x0C, 0x0E, 
  0x00, 0x19, 0x0D, 0x0C, 0x00, 0x2A, 0x0E, 0x0B, 0x00, 0x30, 0x0E, 0x0D, 0x00, 0x43, 0x0C, 0x00, 
  0x00, 0x2A, 0x0F, 0x0E, 0x00, 0x30, 0x0F, 0x0D, 0x00, 0x43, 0x0E, 0x00, 0x00, 0x2A, 0x10, 0x0F, 
  0x00, 0x31, 0x10, 0x0E, 0x0A, 0x43, 0x0F, 0x00, 0x00, 0x2E, 0x0E, 0x01, 0x00, 0x33, 0x10, 0x0E, 
  0x00, 0x2A, 0x11, 0x03, 0x00, 0x2A, 0x12, 0x04, 0x00, 0x31, 0x11, 0x0F, 0x12, 0x2F, 0x10, 0x00, 
  0x00, 0x43, 0x0E, 0x00, 0x00, 0x2A, 0x10, 0x03, 0x00, 0x31, 0x10, 0x0C, 0x0E, 0x2A, 0x10, 0x04, 
  0x00, 0x2F, 0x10, 0x00, 0x00, 0x43, 0x0F, 0x00, 0x00, 0x19, 0x0C, 0x0F, 0x00, 0x23, 0x0E, 0x0B, 
  0x0D, 0x1C, 0x0E, 0x02, 0x00, 0x03, 0x0C, 0x00, 0x00, 0x2A, 0x0F, 0x05, 0x00, 0x31, 0x0F, 0x0D, 
  0x0B, 0x2A, 0x10, 0x10, 0x00, 0x33, 0x0F, 0x10, 0x00, 0x2A, 0x10, 0x06, 0x00, 0x31, 0x10, 0x0F, 
  0x0C, 0x2A, 0x10, 0x10, 0x00, 0x34, 0x10, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x0C, 0x11, 
  0x00, 0x33, 0x0B, 0x0C, 0x00, 0x1C, 0x0B, 0x23, 0x00, 0x26, 0x0C, 0x00, 0x00, 0x19, 0x0E, 0x01, 
  0x00, 0x2F, 0x0E, 0x00, 0x00, 0x2A, 0x11, 0x0C, 0x00, 0x33, 0x10, 0x11, 0x00, 0x1C, 0x10, 0x03, 
  0x00, 0x19, 0x0F, 0x0E, 0x00, 0x1A, 0x04, 0x00, 0x00, 0x2A, 0x12, 0x0D, 0x00, 0x33, 0x11, 0x12, 
  0x00, 0x19, 0x0F, 0x11, 0x00, 0x19, 0x10, 0x0F, 0x00, 0x2A, 0x11, 0x11, 0x00, 0x30, 0x11, 0x10, 
  0x00, 0x43, 0x0F, 0x00, 0x00, 0x2E, 0x11, 0x02, 0x00, 0x33, 0x12, 0x11, 0x00, 0x2A, 0x13, 0x03, 
  0x00, 0x31, 0x13, 0x0F, 0x12, 0x2A, 0x13, 0x04, 0x00, 0x2F, 0x13, 0x00, 0x00, 0x43, 0x11, 0x00, 
  0x00, 0x19, 0x0F, 0x11, 0x00, 0x23, 0x11, 0x0E, 0x10, 0x1C, 0x11, 0x02, 0x00, 0x03, 0x0F, 0x00, 
  0x00, 0x2A, 0x12, 0x05, 0x00, 0x31, 0x12, 0x10, 0x0E, 0x2A, 0x13, 0x10, 0x00, 0x33, 0x12, 0x13, 
  0x00, 0x2A, 0x13, 0x06, 0x00, 0x31, 0x13, 0x12, 0x0F, 0x2A, 0x13, 0x10, 0x00, 0x34, 0x13, 0x00, 
  0x00, 0x2A, 0x0F, 0x02, 0x00, 0x31, 0x0F, 0x00, 0x01, 0x43, 0x0E, 0x00, 0x00, 0x33, 0x0F, 0x02, 
  0x00, 0x2A, 0x12, 0x03, 0x00, 0x31, 0x12, 0x0E, 0x0F, 0x2A, 0x12, 0x04, 0x00, 0x2F, 0x12, 0x00, 
  0x00, 0x43, 0x11, 0x00, 0x00, 0x03, 0x11, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xCD, 0x00, 0xD0, 
  0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x11, 0x01, 0xDA, 0x05, 0xDA, 0x70, 0xDA, 0x82, 0x67, 
  0xDA, 0x2E, 0xDA, 0x82, 0x95, 0x2B, 0x00, 0x00, 0x00, 0x29, 0x01, 0x01, 0x00, 0x30, 0x00, 0x01, 
  0x00, 0x2A, 0x01, 0x00, 0x00, 0x33, 0x00, 0x01, 0x00, 0x2A, 0x02, 0x01, 0x00, 0x2F, 0x02, 0x00, 
  0x00, 0x32, 0x00, 0x00, 0x00, 0x43, 0x01, 0x00, 0x00, 0x2B, 0x02, 0x00, 0x02, 0x33, 0x00, 0x02, 
  0x00, 0x2A, 0x03, 0x02, 0x00, 0x31, 0x03, 0x01, 0x00, 0x2A, 0x03, 0x03, 0x00, 0x2F, 0x03, 0x00, 
  0x00, 0x43, 0x02, 0x00, 0x00, 0x03, 0x02, 0x00, 0x00, 0xBF, 0xFF, 0x85, 0xDB, 0x17, 0x00, 0x17, 
  0x00, 0x17, 0x00, 0x17, 0x00, 0x17, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x31, 
  0x00, 0x31, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0xCD, 0x00, 
  0xD8, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x02, 0x19, 0x01, 0xDA, 0x82, 0x7E, 0xDA, 0x05, 0xDA, 
  0x80, 0xFA, 0xDA, 0x81, 0x65, 0x2C, 0x00, 0x00, 0x00, 0x2B, 0x02, 0x00, 0x09, 0x29, 0x03, 0x01, 
  0x00, 0x06, 0x01, 0x02, 0x03, 0x2D, 0x01, 0x00, 0x09, 0x2B, 0x03, 0x00, 0x09, 0x2B, 0x04, 0x00, 
  0x0A, 0x23, 0x02, 0x03, 0x04, 0x1C, 0x02, 0x03, 0x00, 0x2B, 0x03, 0x00, 0x02, 0x34, 0x03, 0x00, 
  0x00, 0x2B, 0x04, 0x00, 0x00, 0x2B, 0x05, 0x00, 0x09, 0x38, 0x03, 0x04, 0x05, 0x2A, 0x04, 0x00, 
  0x00, 0x2B, 0x05, 0x00, 0x0D, 0x2B, 0x06, 0x00, 0x09, 0x31, 0x04, 0x05, 0x06, 0x2A, 0x05, 0x01, 
  0x00, 0x33, 0x04, 0x05, 0x00, 0x31, 0x03, 0x04, 0x00, 0x2B, 0x05, 0x00, 0x03, 0x2F, 0x05, 0x00, 
  0x00, 0x2B, 0x05, 0x00, 0x04, 0x34, 0x05, 0x00, 0x00, 0xBF, 0xFF, 0x85, 0xE6, 0x10, 0x01, 0x12, 
  0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x01, 0x16, 0x00, 0x16, 0x00, 0x16, 0x00, 0x12, 0x01, 0x14, 
  0x00, 0x14, 0x01, 0x1D, 0x00, 0x1D, 0x00, 0x1D, 0x00, 0x2C, 0x00, 0x2C, 0x00, 0x2C, 0x00, 0x2C, 
  0x00, 0x2C, 0x00, 0x2C, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0xCD, 0x00, 
  0xD8, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x05, 0x28, 0x01, 0xDA, 0x82, 0x7E, 0xDA, 0x05, 0xDA, 
  0x22, 0xDA, 0x82, 0x58, 0xDA, 0x26, 0xDA, 0x81, 0xB2, 0xDA, 0x2F, 0x2C, 0x00, 0x00, 0x00, 0x2B, 
  0x02, 0x00, 0x00, 0x2B, 0x03, 0x00, 0x0C, 0x47, 0x01, 0x02, 0x03, 0x2D, 0x01, 0x00, 0x0C, 0x2A, 
  0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x19, 0x03, 0x02, 0x00, 0x2B, 0x05, 0x00, 0x0C, 0x26, 
  0x06, 0x00, 0x00, 0x23, 0x04, 0x05, 0x06, 0x1C, 0x04, 0x03, 0x00, 0x2B, 0x05, 0x00, 0x02, 0x34, 
  0x05, 0x00, 0x00, 0x2A, 0x06, 0x01, 0x00, 0x2B, 0x07, 0x00, 0x10, 0x2B, 0x08, 0x00, 0x0C, 0x31, 
  0x06, 0x07, 0x08, 0x43, 0x05, 0x00, 0x00, 0x2A, 0x07, 0x02, 0x00, 0x31, 0x07, 0x03, 0x05, 0x43, 
  0x06, 0x00, 0x00, 0x2B, 0x07, 0x00, 0x00, 0x2B, 0x08, 0x00, 0x0C, 0x38, 0x05, 0x07, 0x08, 0x2A, 
  0x07, 0x03, 0x00, 0x26, 0x08, 0x00, 0x00, 0x31, 0x07, 0x08, 0x03, 0x43, 0x07, 0x00, 0x00, 0x30, 
  0x05, 0x07, 0x00, 0x43, 0x05, 0x00, 0x00, 0x31, 0x05, 0x03, 0x00, 0x2B, 0x07, 0x00, 0x03, 0x2F, 
  0x07, 0x00, 0x00, 0x2B, 0x08, 0x00, 0x04, 0x33, 0x07, 0x08, 0x00, 0x2A, 0x08, 0x04, 0x00, 0x31, 
  0x08, 0x06, 0x07, 0x43, 0x05, 0x00, 0x00, 0x03, 0x05, 0x00, 0x00, 0xBF, 0xFF, 0x85, 0xF3, 0x0E, 
  0x01, 0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x19, 0x01, 0x1A, 0x00, 0x1A, 0x00, 0x10, 0x01, 0x14, 
  0x00, 0x14, 0x00, 0x14, 0x00, 0x10, 0x01, 0x12, 0x00, 0x12, 0x01, 0x12, 0x00, 0x12, 0x00, 0x12, 
  0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x01, 0x20, 0x00, 0x20, 0x00, 0x20, 
  0x00, 0x31, 0x00, 0x31, 0x00, 0x31, 0x00, 0x31, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x16, 0x00, 0x16, 
  0x00, 0x16, 0x00, 0x16, 0x00, 0x16, 0xBF, 0xFF, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x85, 
  0xC6, 0x01, 0x04, 0x05, 0x00, 0x05, 0xBF, 0xFE, 0x03, 0x03, 0x05, 0x02, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0xBF, 0xFB, 0x03, 0x06, 0x09, 0x00, 0x05, 0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x20, 
  0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x02, 0x09, 0x00, 0x09, 
  0x01, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x24, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 
  0x02, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x05, 0x00, 0x05, 0x00, 0x26, 0x00, 0x26, 0x00, 0x26, 
  0x00, 0x1B, 0x00, 0x1B, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xBF, 0xF4, 0x03, 0x0D, 0x0C, 0x00, 
  0x0C, 0x00, 0x09, 0x00, 0x09, 0x00, 0x05, 0x02, 0x10, 0x00, 0x10, 0x00, 0x07, 0x00, 0x07, 0x00, 
  0x07, 0x00, 0x28, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x02, 
  0x09, 0x00, 0x09, 0x01, 0x09, 0xBF, 0xFE, 0x07, 0x00, 0x07, 0x00, 0x07, 0x05, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0xBF, 0xEB, 0x03, 0x17, 0x10, 0x00, 0x07, 0x01, 0x07, 0x01, 0x07, 0x00, 0x07, 0x00, 
  0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 
  0x07, 0x02, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 
  0x09, 0x00, 0x09, 0x03, 0x10, 0x00, 0x0F, 0xBF, 0xFD, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 
  0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0xBF, 0xFE, 0x07, 0x00, 
  0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 
  0x07, 0x00, 0x07, 0x00, 0x07, 0x0C, 0x05, 0x00, 0x05, 0x00, 0x05, 0xBF, 0xDB, 0x03, 0x27, 0x07, 
  0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 
  0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x02, 0x09, 0x00, 0x09, 0x00, 0x09, 0x01, 0x0E, 0x00, 0x0D, 
  0xBF, 0xFF, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0xBF, 0xFE, 0x07, 0x00, 0x07, 
  0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 
  0x00, 0x07, 0x00, 0x07, 0x0C, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x24, 0x00, 0x0B, 0x00, 0x0B, 
  0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0xBF, 0xCC, 0x03, 0x1D, 0x36, 0x01, 0x00, 0xDA, 
  0x26, 0xDA, 0x2A, 0xDA, 0x82, 0x95, 0xDA, 0x2E, 0x2C, 0x01, 0x00, 0x00, 0x2B, 0x03, 0x00, 0x07, 
  0x23, 0x02, 0x00, 0x03, 0x1C, 0x02, 0x04, 0x00, 0x2B, 0x04, 0x00, 0x01, 0x38, 0x03, 0x04, 0x00, 
  0x03, 0x03, 0x00, 0x00, 0x2B, 0x04, 0x00, 0x07, 0x21, 0x03, 0x00, 0x04, 0x1C, 0x03, 0x1D, 0x00, 
  0x2A, 0x05, 0x00, 0x00, 0x33, 0x04, 0x05, 0x00, 0x19, 0x05, 0x04, 0x00, 0x2B, 0x06, 0x00, 0x01, 
  0x38, 0x04, 0x06, 0x00, 0x2E, 0x06, 0x00, 0x00, 0x42, 0x07, 0x00, 0x00, 0x2B, 0x08, 0x00, 0x05, 
  0x31, 0x04, 0x08, 0x06, 0x2F, 0x07, 0x00, 0x00, 0x2A, 0x09, 0x01, 0x00, 0x33, 0x08, 0x09, 0x00, 
  0x2A, 0x06, 0x02, 0x00, 0x31, 0x06, 0x05, 0x08, 0x43, 0x04, 0x00, 0x00, 0x2A, 0x07, 0x03, 0x00, 
  0x2A, 0x08, 0x04, 0x00, 0x31, 0x07, 0x08, 0x04, 0x43, 0x06, 0x00, 0x00, 0x29, 0x07, 0x02, 0x00, 
  0x06, 0x04, 0x07, 0x00, 0x2F, 0x04, 0x00, 0x00, 0x33, 0x07, 0x01, 0x00, 0x2A, 0x08, 0x05, 0x00, 
  0x31, 0x08, 0x06, 0x07, 0x2F, 0x05, 0x00, 0x00, 0x43, 0x04, 0x00, 0x00, 0x03, 0x04, 0x00, 0x00, 
  0x04, 0x00, 0x00, 0x00, 0xBF, 0xFF, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 
  0x07, 0x02, 0xDA, 0x05, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x04, 0x01, 0x01, 0x01, 0x00, 0x04, 
  0xCE, 0x03, 0x69, 0x6E, 0x63, 0xDA, 0x05, 0x2C, 0x01, 0x00, 0x00, 0x29, 0x03, 0x01, 0x00, 0x06, 
  0x02, 0x00, 0x03, 0x03, 0x02, 0x00, 0x00, 0x80, 0x81, 0x01, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 
  0x2B, 0x00, 0x01, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x01, 0x00, 0x00, 0x33, 0x00, 0x01, 0x00, 
  0x2B, 0x02, 0x00, 0x01, 0x38, 0x01, 0x02, 0x00, 0x03, 0x01, 0x00, 0x00, 0x00, 0xBF, 0xFF, 0x86, 
  0x11, 0x60, 0x00, 0x60, 0x00, 0x60, 0x00, 0x60, 0x00, 0x56, 0x00, 0x56, 0x00, 0x56, 0x86, 0x0D, 
  0x06, 0x02, 0x0A, 0x00, 0x0A, 0xBF, 0xFF, 0x08, 0x01, 0x16, 0x00, 0x16, 0x00, 0x16, 0x01, 0x0A, 
  0x00, 0x0A, 0xBF, 0xFE, 0x08, 0x02, 0x16, 0x00, 0x16, 0x00, 0x16, 0x01, 0x3F, 0x00, 0x3F, 0x00, 
  0x4F, 0x00, 0x36, 0x00, 0x36, 0x00, 0x36, 0x00, 0x36, 0x00, 0x36, 0x00, 0x36, 0x00, 0x18, 0x00, 
  0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x18, 0x01, 0x21, 0x00, 0x21, 0x00, 
  0x1C, 0x00, 0x1C, 0xBF, 0xFF, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x18, 0xBF, 0xFD, 
  0x08, 0x01, 0x00, 0x00, 0x00, 0x85, 0xFE, 0x01, 0x0C, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x0E, 
  0x00, 0x05, 0x01, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x05, 0x01, 0x06, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0xBF, 0xFD, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xA2, 0x00, 0x00, 0x00, 0xCF, 
  0x07, 0x62, 0x72, 0x73, 0x68, 0x69, 0x66, 0x74, 0xD7, 0xCD, 0x00, 0x09, 0x00, 0x11, 0x06, 0x00, 
  0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x13, 0xCE, 0x07, 0x62, 0x72, 0x73, 0x68, 0x69, 0x66, 
  0x74, 0x3D, 0x01, 0x00, 0x00, 0x24, 0x02, 0x01, 0x00, 0x1C, 0x02, 0x03, 0x00, 0x29, 0x03, 0x01, 
  0x00, 0x03, 0x03, 0x00, 0x00, 0x24, 0x02, 0x01, 0x01, 0x1C, 0x02, 0x05, 0x00, 0x29, 0x03, 0x01, 
  0x00, 0x3B, 0x04, 0x00, 0x00, 0x14, 0x03, 0x03, 0x04, 0x03, 0x03, 0x00, 0x00, 0x3B, 0x03, 0x00, 
  0x00, 0x29, 0x05, 0x01, 0x00, 0x38, 0x04, 0x00, 0x05, 0x14, 0x03, 0x03, 0x04, 0x05, 0x05, 0x05, 
  0x01, 0x23, 0x02, 0x05, 0x01, 0x1C, 0x02, 0xFC, 0xFF, 0x03, 0x03, 0x00, 0x00, 0xCF, 0x0C, 0x70, 
  0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x77, 0x68, 0x65, 0x72, 0x65, 0xDA, 0x80, 0xE6, 0xCF, 0x06, 
  0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0xDA, 0x6F, 0xCF, 0x0A, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 
  0x74, 0x72, 0x69, 0x6D, 0xD8, 0x0A, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x74, 0x72, 0x69, 0x6D, 
  0xCF, 0x06, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0xDA, 0x69, 0xCF, 0x0C, 0x6D, 0x61, 0x74, 0x68, 
  0x2F, 0x72, 0x6E, 0x67, 0x2D, 0x69, 0x6E, 0x74, 0xD8, 0x0C, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x72, 
  0x6E, 0x67, 0x2D, 0x69, 0x6E, 0x74, 0xCF, 0x03, 0x2D, 0x3E, 0x3E, 0xD7, 0xCD, 0x00, 0xB9, 0x00, 
  0x00, 0x06, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x01, 0x06, 0x01, 0xCE, 0x03, 0x2D, 0x3E, 
  0x3E, 0xDA, 0x05, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x08, 0x03, 0x03, 0x03, 0x00, 0x0D, 0xCE, 
  0x06, 0x72, 0x65, 0x64, 0x75, 0x63, 0x65, 0xDA, 0x05, 0x2C, 0x03, 0x00, 0x00, 0x19, 0x04, 0x01, 
  0x00, 0x26, 0x06, 0x00, 0x00, 0x47, 0x05, 0x02, 0x06, 0x19, 0x06, 0x05, 0x00, 0x1D, 0x06, 0x07, 
  0x00, 0x38, 0x05, 0x02, 0x06, 0x19, 0x07, 0x05, 0x00, 0x30, 0x04, 0x07, 0x00, 0x33, 0x04, 0x00, 
  0x00, 0x47, 0x06, 0x02, 0x06, 0x1A, 0xFA, 0xFF, 0xFF, 0x03, 0x04, 0x00, 0x00, 0x83, 0x12, 0x01, 
  0x04, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x18, 
  0x00, 0x18, 0x00, 0x03, 0x00, 0x03, 0xBF, 0xFB, 0x01, 0x2C, 0x02, 0x00, 0x00, 0x2E, 0x03, 0x00, 
  0x00, 0x19, 0x04, 0x03, 0x00, 0x31, 0x04, 0x00, 0x01, 0x2A, 0x05, 0x00, 0x00, 0x34, 0x05, 0x00, 
  0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0A, 0x02, 0x02, 0x02, 0x06, 0x27, 0xCE, 0x03, 0x66, 0x6F, 
  0x70, 0xDA, 0x05, 0xDA, 0x39, 0xDA, 0x72, 0xDA, 0x81, 0x28, 0xDA, 0x81, 0x65, 0xDA, 0x81, 0x2E, 
  0xDA, 0x70, 0x2C, 0x02, 0x00, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x05, 0x00, 0x00, 0x33, 0x04, 
  0x05, 0x00, 0x2A, 0x06, 0x01, 0x00, 0x23, 0x05, 0x06, 0x04, 0x1C, 0x05, 0x0C, 0x00, 0x29, 0x06, 
  0x00, 0x00, 0x38, 0x04, 0x01, 0x06, 0x29, 0x06, 0x01, 0x00, 0x30, 0x01, 0x06, 0x00, 0x2A, 0x07, 
  0x02, 0x00, 0x33, 0x06, 0x07, 0x00, 0x30, 0x04, 0x06, 0x00, 0x2A, 0x08, 0x03, 0x00, 0x33, 0x07, 
  0x08, 0x00, 0x19, 0x03, 0x07, 0x00, 0x1A, 0x06, 0x00, 0x00, 0x3E, 0x04, 0x00, 0x00, 0x30, 0x01, 
  0x04, 0x00, 0x2A, 0x07, 0x03, 0x00, 0x33, 0x06, 0x07, 0x00, 0x19, 0x03, 0x06, 0x00, 0x3B, 0x04, 
  0x03, 0x00, 0x19, 0x05, 0x04, 0x00, 0x3B, 0x04, 0x03, 0x01, 0x19, 0x06, 0x04, 0x00, 0x2F, 0x05, 
  0x00, 0x00, 0x3E, 0x04, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x3E, 0x07, 0x00, 0x00, 0x31, 0x04, 
  0x06, 0x07, 0x2A, 0x09, 0x04, 0x00, 0x33, 0x08, 0x09, 0x00, 0x19, 0x04, 0x08, 0x00, 0x29, 0x07, 
  0x00, 0x00, 0x30, 0x04, 0x07, 0x00, 0x2A, 0x07, 0x05, 0x00, 0x34, 0x07, 0x00, 0x00, 0x84, 0x14, 
  0x03, 0x01, 0x1E, 0x00, 0x1E, 0x00, 0x1E, 0x00, 0x14, 0x00, 0x14, 0x00, 0x10, 0x01, 0x19, 0x00, 
  0x19, 0x00, 0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0xBF, 
  0xFF, 0x10, 0x00, 0x10, 0x02, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0xBF, 0xFE, 0x10, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x03, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 
  0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x84, 
  0x0F, 0x01, 0x05, 0x03, 0x00, 0x03, 0x06, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x0B, 0x6D, 0x61, 
  0x74, 0x68, 0x2F, 0x72, 0x61, 0x6E, 0x64, 0x6F, 0x6D, 0xD8, 0x0B, 0x6D, 0x61, 0x74, 0x68, 0x2F, 
  0x72, 0x61, 0x6E, 0x64, 0x6F, 0x6D, 0xCF, 0x09, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x70, 0x6F, 
  0x70, 0xD8, 0x09, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x70, 0x6F, 0x70, 0xCF, 0x07, 0x6B, 0x65, 
  0x79, 0x77, 0x6F, 0x72, 0x64, 0xD8, 0x07, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 0xCF, 0x0B, 
  0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x74, 0x72, 0x69, 0x6D, 0xD8, 0x0B, 0x62, 0x75, 0x66, 
  0x66, 0x65, 0x72, 0x2F, 0x74, 0x72, 0x69, 0x6D, 0xCF, 0x09, 0x62, 0x6F, 0x6F, 0x74, 0x2F, 0x61, 
  0x72, 0x67, 0x73, 0xD1, 0x02, 0xCE, 0x10, 0x62, 0x75, 0x69, 0x6C, 0x64, 0x5C, 0x6A, 0x61, 0x6E, 
  0x65, 0x74, 0x5F, 0x62, 0x6F, 0x6F, 0x74, 0xDA, 0x80, 0x95, 0xCF, 0x05, 0x70, 0x61, 0x69, 0x72, 
  0x73, 0xDA, 0x82, 0x2C, 0xCF, 0x0C, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x65, 0x6E, 0x73, 0x75, 
  0x72, 0x65, 0xD8, 0x0C, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x65, 0x6E, 0x73, 0x75, 0x72, 0x65, 
  0xCF, 0x0B, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x70, 0x6F, 0x70, 0x6E, 0xD8, 0x0B, 0x62, 
  0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x70, 0x6F, 0x70, 0x6E, 0xCF, 0x08, 0x6F, 0x73, 0x2F, 0x77, 
  0x68, 0x69, 0x63, 0x68, 0xD8, 0x08, 0x6F, 0x73, 0x2F, 0x77, 0x68, 0x69, 0x63, 0x68, 0xCF, 0x0A, 
  0x66, 0x69, 0x62, 0x65, 0x72, 0x2F, 0x72, 0x6F, 0x6F, 0x74, 0xD8, 0x0A, 0x66, 0x69, 0x62, 0x65, 
  0x72, 0x2F, 0x72, 0x6F, 0x6F, 0x74, 0xCF, 0x06, 0x66, 0x61, 0x6C, 0x73, 0x65, 0x3F, 0xD7, 0xCD, 
  0x00, 0x98, 0x00, 0x00, 0x04, 0x01, 0x01, 0x01, 0x00, 0x04, 0xCE, 0x06, 0x66, 0x61, 0x6C, 0x73, 
  0x65, 0x3F, 0xDA, 0x05, 0x2C, 0x01, 0x00, 0x00, 0x28, 0x03, 0x00, 0x00, 0x23, 0x02, 0x00, 0x03, 
  0x03, 0x02, 0x00, 0x00, 0x71, 0x01, 0x00, 0x29, 0x00, 0x29, 0x00, 0x29, 0xCF, 0x07, 0x73, 0x6F, 
  0x72, 0x74, 0x2D, 0x62, 0x79, 0xD7, 0xCD, 0x02, 0xBA, 0x00, 0x00, 0x05, 0x02, 0x02, 0x02, 0x01, 
  0x05, 0x01, 0xCE, 0x07, 0x73, 0x6F, 0x72, 0x74, 0x2D, 0x62, 0x79, 0xDA, 0x05, 0xDA, 0x5E, 0x2C, 
  0x02, 0x00, 0x00, 0x2E, 0x03, 0x00, 0x00, 0x30, 0x01, 0x03, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x34, 
  0x04, 0x00, 0x00, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x05, 0x02, 0x02, 0x02, 0x00, 0x08, 0x01, 0xDA, 
  0x05, 0x2F, 0x00, 0x00, 0x00, 0x2B, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2F, 0x01, 0x00, 
  0x00, 0x2B, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 0x21, 0x04, 0x02, 0x03, 0x03, 0x04, 0x00, 
  0x00, 0xBF, 0xFF, 0x83, 0x05, 0x1A, 0x00, 0x1A, 0x00, 0x1A, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 
  0x00, 0x17, 0x00, 0x17, 0x83, 0x01, 0x01, 0x04, 0x0D, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 
  0x00, 0x00, 0x00, 0xCF, 0x0C, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x73, 0x70, 0x6C, 0x69, 
  0x74, 0xD8, 0x0C, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x73, 0x70, 0x6C, 0x69, 0x74, 0xDA, 
  0x81, 0xB4, 0xDA, 0x81, 0x65, 0xCF, 0x0F, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 0x61, 0x72, 0x67, 
  0x2D, 0x73, 0x74, 0x61, 0x63, 0x6B, 0xD8, 0x0F, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 0x61, 0x72, 
  0x67, 0x2D, 0x73, 0x74, 0x61, 0x63, 0x6B, 0xCF, 0x08, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 
  0x3C, 0xD7, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x03, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x02, 
  0x05, 0xCE, 0x08, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0x3C, 0xDA, 0x05, 0xDA, 0x59, 0xD7, 
  0xCD, 0x00, 0x98, 0x00, 0x00, 0x0C, 0x02, 0x02, 0x02, 0x02, 0x23, 0xCE, 0x0E, 0x63, 0x6F, 0x6D, 
  0x70, 0x61, 0x72, 0x65, 0x2D, 0x72, 0x65, 0x64, 0x75, 0x63, 0x65, 0xDA, 0x05, 0xDA, 0x82, 0x5E, 
  0xDA, 0x81, 0x62, 0x2C, 0x02, 0x00, 0x00, 0x27, 0x03, 0x00, 0x00, 0x29, 0x04, 0x00, 0x00, 0x3D, 
  0x05, 0x01, 0x00, 0x29, 0x07, 0x01, 0x00, 0x07, 0x06, 0x05, 0x07, 0x19, 0x05, 0x06, 0x00, 0x21, 
  0x06, 0x04, 0x05, 0x1C, 0x06, 0x1A, 0x00, 0x19, 0x07, 0x04, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x33, 
  0x08, 0x01, 0x00, 0x29, 0x0A, 0x01, 0x00, 0x06, 0x09, 0x07, 0x0A, 0x2F, 0x09, 0x00, 0x00, 0x33, 
  0x0A, 0x01, 0x00, 0x30, 0x08, 0x0A, 0x00, 0x2A, 0x0B, 0x00, 0x00, 0x33, 0x09, 0x0B, 0x00, 0x19, 
  0x08, 0x09, 0x00, 0x29, 0x09, 0x00, 0x00, 0x30, 0x08, 0x09, 0x00, 0x33, 0x09, 0x00, 0x00, 0x19, 
  0x0A, 0x09, 0x00, 0x2F, 0x0A, 0x00, 0x00, 0x2A, 0x0B, 0x01, 0x00, 0x33, 0x09, 0x0B, 0x00, 0x1C, 
  0x09, 0x04, 0x00, 0x28, 0x03, 0x00, 0x00, 0x1A, 0x05, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x29, 
  0x08, 0x01, 0x00, 0x06, 0x04, 0x04, 0x08, 0x1A, 0xE6, 0xFF, 0xFF, 0x03, 0x03, 0x00, 0x00, 0x82, 
  0xB7, 0x01, 0x01, 0x03, 0x01, 0x03, 0x00, 0x19, 0x00, 0x16, 0x00, 0x16, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x01, 0x1B, 0x00, 0x1B, 0x00, 0x26, 0x00, 0x26, 0x00, 0x22, 0x00, 0x22, 
  0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0xBF, 0xFF, 0x03, 0x02, 0x13, 0x00, 0x13, 0x00, 0x13, 0xBF, 
  0xFE, 0x03, 0x03, 0x10, 0x00, 0x10, 0x00, 0x10, 0xBF, 0xFD, 0x03, 0x04, 0x05, 0x01, 0x05, 0xBF, 
  0xFB, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xBF, 0xFE, 0x01, 0x2C, 0x01, 0x00, 0x00, 0x2A, 
  0x02, 0x00, 0x00, 0x30, 0x02, 0x00, 0x00, 0x2A, 0x02, 0x01, 0x00, 0x34, 0x02, 0x00, 0x00, 0x82, 
  0xC6, 0x01, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x05, 0x65, 0x61, 0x63, 0x68, 
  0x6B, 0xD7, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x05, 0x02, 0x02, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x01, 
  0x06, 0xCE, 0x05, 0x65, 0x61, 0x63, 0x68, 0x6B, 0xDA, 0x05, 0xDA, 0x81, 0xB5, 0x2C, 0x03, 0x00, 
  0x00, 0x28, 0x04, 0x00, 0x00, 0x31, 0x00, 0x01, 0x04, 0x2F, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x00, 
  0x00, 0x34, 0x04, 0x00, 0x00, 0x81, 0xE6, 0x01, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0xCF, 0x0B, 0x72, 0x75, 0x6E, 0x2D, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0xDA, 
  0x81, 0x07, 0xCF, 0x0D, 0x74, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x6C, 0x65, 0x6E, 0x67, 0x74, 
  0x68, 0xD8, 0x0D, 0x74, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 
  0xCF, 0x04, 0x64, 0x65, 0x66, 0x2D, 0xD7, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x06, 0x01, 0x01, 0xCD, 
  0x7F, 0xFF, 0xFF, 0xFF, 0x02, 0x07, 0xCE, 0x04, 0x64, 0x65, 0x66, 0x2D, 0xDA, 0x05, 0xDA, 0x26, 
  0xDA, 0x65, 0x2C, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x31, 0x04, 
  0x00, 0x05, 0x32, 0x01, 0x00, 0x00, 0x43, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x38, 0x01, 
  0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x02, 0x3E, 0x3D, 
  0xDA, 0x81, 0xAC, 0xCF, 0x06, 0x67, 0x65, 0x6E, 0x73, 0x79, 0x6D, 0xDA, 0x22, 0xCF, 0x0C, 0x70, 
  0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x73, 0x74, 0x61, 0x74, 0x65, 0xD8, 0x0C, 0x70, 0x61, 0x72, 
  0x73, 0x65, 0x72, 0x2F, 0x73, 0x74, 0x61, 0x74, 0x65, 0xCF, 0x05, 0x74, 0x61, 0x62, 0x6C, 0x65, 
  0xDA, 0x07, 0xCF, 0x10, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x70, 0x75, 0x73, 0x68, 0x2D, 
  0x62, 0x79, 0x74, 0x65, 0xDA, 0x81, 0xEB, 0xDA, 0x4A, 0xDA, 0x49, 0xCF, 0x0D, 0x64, 0x65, 0x62, 
  0x75, 0x67, 0x2F, 0x6C, 0x69, 0x6E, 0x65, 0x61, 0x67, 0x65, 0xD8, 0x0D, 0x64, 0x65, 0x62, 0x75, 
  0x67, 0x2F, 0x6C, 0x69, 0x6E, 0x65, 0x61, 0x67, 0x65, 0xCF, 0x05, 0x61, 0x70, 0x70, 0x6C, 0x79, 
  0xD7, 0xCD, 0x00, 0x09, 0x00, 0x03, 0x06, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x0C, 
  0xCE, 0x05, 0x61, 0x70, 0x70, 0x6C, 0x79, 0x3D, 0x02, 0x01, 0x00, 0x24, 0x03, 0x02, 0x00, 0x1B, 
  0x03, 0x09, 0x00, 0x29, 0x04, 0x00, 0x00, 0x38, 0x05, 0x01, 0x04, 0x05, 0x04, 0x04, 0x01, 0x23, 
  0x03, 0x04, 0x02, 0x1B, 0x03, 0x03, 0x00, 0x2F, 0x05, 0x00, 0x00, 0x1A, 0xFB, 0xFF, 0xFF, 0x32, 
  0x05, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0xCF, 0x04, 0x74, 0x79, 0x70, 0x65, 0xDA, 0x39, 0xCF, 
  0x0A, 0x6E, 0x65, 0x74, 0x2F, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0xD8, 0x0A, 0x6E, 0x65, 0x74, 
  0x2F, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0xCF, 0x04, 0x71, 0x75, 0x69, 0x74, 0xD7, 0xCD, 0x00, 
  0x98, 0x00, 0x00, 0x05, 0x01, 0x00, 0x01, 0x03, 0x0B, 0xCE, 0x04, 0x71, 0x75, 0x69, 0x74, 0xDA, 
  0x05, 0xDA, 0x80, 0xD4, 0xDA, 0x82, 0x26, 0xDA, 0x80, 0xF8, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x02, 
  0x00, 0x00, 0x27, 0x03, 0x00, 0x00, 0x30, 0x02, 0x03, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x33, 0x02, 
  0x03, 0x00, 0x2A, 0x03, 0x02, 0x00, 0x30, 0x03, 0x00, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x33, 0x03, 
  0x04, 0x00, 0x04, 0x00, 0x00, 0x00, 0x88, 0x3E, 0x01, 0x05, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xBF, 0xFA, 0x01, 0xCF, 0x08, 
  0x6F, 0x73, 0x2F, 0x72, 0x6D, 0x64, 0x69, 0x72, 0xD8, 0x08, 0x6F, 0x73, 0x2F, 0x72, 0x6D, 0x64, 
  0x69, 0x72, 0xCF, 0x06, 0x65, 0x6D, 0x70, 0x74, 0x79, 0x3F, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 
  0x05, 0x01, 0x01, 0x01, 0x00, 0x05, 0xCE, 0x06, 0x65, 0x6D, 0x70, 0x74, 0x79, 0x3F, 0xDA, 0x05, 
  0x2C, 0x01, 0x00, 0x00, 0x3D, 0x02, 0x00, 0x00, 0x29, 0x04, 0x00, 0x00, 0x23, 0x03, 0x04, 0x02, 
  0x03, 0x03, 0x00, 0x00, 0x73, 0x01, 0x00, 0x30, 0x00, 0x2B, 0x00, 0x2B, 0x00, 0x2B, 0xCF, 0x07, 
  0x6F, 0x73, 0x2F, 0x61, 0x72, 0x63, 0x68, 0xD8, 0x07, 0x6F, 0x73, 0x2F, 0x61, 0x72, 0x63, 0x68, 
  0xCF, 0x03, 0x69, 0x6E, 0x63, 0xDA, 0x82, 0x9F, 0xCF, 0x04, 0x62, 0x78, 0x6F, 0x72, 0xD7, 0xCD, 
  0x00, 0x09, 0x00, 0x0F, 0x06, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x13, 0xCE, 0x04, 
  0x62, 0x78, 0x6F, 0x72, 0x3D, 0x01, 0x00, 0x00, 0x24, 0x02, 0x01, 0x00, 0x1C, 0x02, 0x03, 0x00, 
  0x29, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x24, 0x02, 0x01, 0x01, 0x1C, 0x02, 0x05, 0x00, 
  0x29, 0x03, 0x00, 0x00, 0x3B, 0x04, 0x00, 0x00, 0x10, 0x03, 0x03, 0x04, 0x03, 0x03, 0x00, 0x00, 
  0x3B, 0x03, 0x00, 0x00, 0x29, 0x05, 0x01, 0x00, 0x38, 0x04, 0x00, 0x05, 0x10, 0x03, 0x03, 0x04, 
  0x05, 0x05, 0x05, 0x01, 0x23, 0x02, 0x05, 0x01, 0x1C, 0x02, 0xFC, 0xFF, 0x03, 0x03, 0x00, 0x00, 
  0xCF, 0x09, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0x3E, 0x3D, 0xD7, 0xCD, 0x00, 0x99, 0x00, 
  0x00, 0x03, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x02, 0x05, 0xCE, 0x09, 0x63, 0x6F, 0x6D, 
  0x70, 0x61, 0x72, 0x65, 0x3E, 0x3D, 0xDA, 0x05, 0xDA, 0x81, 0xAC, 0xDA, 0x82, 0xD2, 0x2C, 0x01, 
  0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x30, 0x02, 0x00, 0x00, 0x2A, 0x02, 0x01, 0x00, 0x34, 0x02, 
  0x00, 0x00, 0x82, 0xD5, 0x01, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x04, 0x77, 
  0x61, 0x6C, 0x6B, 0xDA, 0x81, 0x3F, 0xCF, 0x09, 0x77, 0x69, 0x74, 0x68, 0x2D, 0x73, 0x79, 0x6D, 
  0x73, 0xD7, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x0D, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x03, 
  0x19, 0xCE, 0x09, 0x77, 0x69, 0x74, 0x68, 0x2D, 0x73, 0x79, 0x6D, 0x73, 0xDA, 0x05, 0xDA, 0x22, 
  0xDA, 0x52, 0xDA, 0x81, 0x8D, 0x2C, 0x02, 0x00, 0x00, 0x29, 0x03, 0x00, 0x00, 0x3D, 0x04, 0x00, 
  0x00, 0x19, 0x05, 0x04, 0x00, 0x3E, 0x06, 0x00, 0x00, 0x19, 0x07, 0x06, 0x00, 0x21, 0x08, 0x03, 
  0x05, 0x1C, 0x08, 0x0B, 0x00, 0x38, 0x09, 0x00, 0x03, 0x2A, 0x0A, 0x00, 0x00, 0x2F, 0x0A, 0x00, 
  0x00, 0x43, 0x0A, 0x00, 0x00, 0x31, 0x07, 0x09, 0x0A, 0x2A, 0x0C, 0x01, 0x00, 0x33, 0x0B, 0x0C, 
  0x00, 0x29, 0x09, 0x01, 0x00, 0x06, 0x03, 0x03, 0x09, 0x1A, 0xF5, 0xFF, 0xFF, 0x32, 0x07, 0x00, 
  0x00, 0x43, 0x08, 0x00, 0x00, 0x2A, 0x0A, 0x02, 0x00, 0x30, 0x0A, 0x08, 0x00, 0x32, 0x01, 0x00, 
  0x00, 0x43, 0x09, 0x00, 0x00, 0x03, 0x09, 0x00, 0x00, 0x81, 0x1F, 0x01, 0x03, 0x03, 0x01, 0x0C, 
  0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x01, 0x0A, 0x00, 0x03, 0x01, 0x17, 0x00, 0x23, 0x00, 0x23, 
  0x00, 0x23, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 0xBF, 0xFE, 0x03, 0x03, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x0C, 0x66, 
  0x69, 0x62, 0x65, 0x72, 0x2F, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0xDA, 0x29, 0xCF, 0x0E, 0x74, 
  0x68, 0x72, 0x65, 0x61, 0x64, 0x2F, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0xD8, 0x0E, 0x74, 
  0x68, 0x72, 0x65, 0x61, 0x64, 0x2F, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0xCF, 0x0A, 0x66, 
  0x69, 0x6C, 0x65, 0x2F, 0x66, 0x6C, 0x75, 0x73, 0x68, 0xD8, 0x0A, 0x66, 0x69, 0x6C, 0x65, 0x2F, 
  0x66, 0x6C, 0x75, 0x73, 0x68, 0xCF, 0x0A, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x6E, 0x65, 
  0x77, 0xD8, 0x0A, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x6E, 0x65, 0x77, 0xCF, 0x05, 0x6F, 
  0x73, 0x2F, 0x72, 0x6D, 0xD8, 0x05, 0x6F, 0x73, 0x2F, 0x72, 0x6D, 0xCF, 0x04, 0x74, 0x61, 0x6B, 
  0x65, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0E, 0x02, 0x02, 0x02, 0x03, 0x1C, 0xCE, 0x04, 0x74, 
  0x61, 0x6B, 0x65, 0xDA, 0x05, 0xDA, 0x81, 0x1E, 0xDA, 0x81, 0x1F, 0xDA, 0x70, 0x2C, 0x02, 0x00, 
  0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x04, 0x03, 
  0x00, 0x1C, 0x04, 0x03, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x2A, 0x05, 0x02, 
  0x00, 0x19, 0x06, 0x05, 0x00, 0x3D, 0x07, 0x01, 0x00, 0x19, 0x08, 0x07, 0x00, 0x29, 0x0B, 0x00, 
  0x00, 0x1F, 0x0A, 0x00, 0x0B, 0x1C, 0x0A, 0x03, 0x00, 0x19, 0x09, 0x00, 0x00, 0x1A, 0x02, 0x00, 
  0x00, 0x29, 0x09, 0x00, 0x00, 0x19, 0x0A, 0x09, 0x00, 0x1F, 0x0C, 0x0A, 0x08, 0x1C, 0x0C, 0x03, 
  0x00, 0x19, 0x0B, 0x08, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x0B, 0x0A, 0x00, 0x19, 0x0C, 0x0B, 
  0x00, 0x29, 0x0D, 0x00, 0x00, 0x31, 0x01, 0x0D, 0x0C, 0x34, 0x06, 0x00, 0x00, 0x83, 0xAA, 0x01, 
  0x03, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x03, 0x01, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 
  0x00, 0x03, 0x01, 0x0C, 0x00, 0x03, 0x02, 0x0E, 0x00, 0x0E, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 
  0x00, 0x0A, 0x00, 0x03, 0x01, 0x10, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x03, 
  0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x08, 0x70, 0x6F, 0x73, 0x74, 0x77, 0x61, 0x6C, 0x6B, 
  0xDA, 0x81, 0x40, 0xCF, 0x0E, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2F, 0x6C, 0x6F, 0x61, 0x64, 
  0x69, 0x6E, 0x67, 0xDA, 0x80, 0xCD, 0xCF, 0x0C, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x74, 
  0x72, 0x69, 0x6D, 0x6C, 0xD8, 0x0C, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x74, 0x72, 0x69, 
  0x6D, 0x6C, 0xDA, 0x76, 0xDA, 0x75, 0xCF, 0x0C, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x63, 
  0x6C, 0x6F, 0x6E, 0x65, 0xD8, 0x0C, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x63, 0x6C, 0x6F, 
  0x6E, 0x65, 0xCF, 0x09, 0x6F, 0x73, 0x2F, 0x6D, 0x6B, 0x74, 0x69, 0x6D, 0x65, 0xD8, 0x09, 0x6F, 
  0x73, 0x2F, 0x6D, 0x6B, 0x74, 0x69, 0x6D, 0x65, 0xCF, 0x0E, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 
  0x2F, 0x6C, 0x6F, 0x61, 0x64, 0x65, 0x72, 0x73, 0xDA, 0x80, 0xD0, 0xDA, 0x80, 0x8A, 0xDA, 0x80, 
  0x89, 0xCF, 0x05, 0x72, 0x61, 0x6E, 0x67, 0x65, 0xD7, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x12, 0x00, 
  0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x05, 0x5F, 0xCE, 0x05, 0x72, 0x61, 0x6E, 0x67, 0x65, 0xDA, 
  0x05, 0xDA, 0x55, 0xDA, 0x82, 0x0B, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x04, 0x01, 0x01, 0x01, 
  0x00, 0x04, 0xCE, 0x04, 0x6E, 0x65, 0x67, 0x3F, 0xDA, 0x05, 0x2C, 0x01, 0x00, 0x00, 0x29, 0x03, 
  0x00, 0x00, 0x21, 0x02, 0x00, 0x03, 0x03, 0x02, 0x00, 0x00, 0x56, 0x01, 0x00, 0x2D, 0x00, 0x2D, 
  0x00, 0x2D, 0xDA, 0x52, 0xCE, 0x22, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x31, 
  0x20, 0x74, 0x6F, 0x20, 0x33, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 
  0x74, 0x6F, 0x20, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x2C, 0x01, 0x00, 0x00, 0x3D, 0x02, 0x00, 0x00, 
  0x19, 0x03, 0x02, 0x00, 0x29, 0x04, 0x01, 0x00, 0x23, 0x02, 0x03, 0x04, 0x1C, 0x02, 0x11, 0x00, 
  0x3B, 0x04, 0x00, 0x00, 0x19, 0x05, 0x04, 0x00, 0x2F, 0x05, 0x00, 0x00, 0x2A, 0x06, 0x00, 0x00, 
  0x33, 0x04, 0x06, 0x00, 0x19, 0x06, 0x04, 0x00, 0x29, 0x04, 0x00, 0x00, 0x19, 0x07, 0x05, 0x00, 
  0x21, 0x08, 0x04, 0x07, 0x1C, 0x08, 0x06, 0x00, 0x19, 0x09, 0x04, 0x00, 0x3A, 0x06, 0x09, 0x09, 
  0x29, 0x0A, 0x01, 0x00, 0x06, 0x04, 0x04, 0x0A, 0x1A, 0xFA, 0xFF, 0xFF, 0x03, 0x06, 0x00, 0x00, 
  0x29, 0x05, 0x02, 0x00, 0x23, 0x04, 0x03, 0x05, 0x1C, 0x04, 0x15, 0x00, 0x3B, 0x05, 0x00, 0x00, 
  0x19, 0x06, 0x05, 0x00, 0x3B, 0x05, 0x00, 0x01, 0x19, 0x07, 0x05, 0x00, 0x07, 0x05, 0x07, 0x06, 
  0x2F, 0x05, 0x00, 0x00, 0x2A, 0x09, 0x00, 0x00, 0x33, 0x08, 0x09, 0x00, 0x19, 0x05, 0x08, 0x00, 
  0x19, 0x08, 0x06, 0x00, 0x19, 0x09, 0x07, 0x00, 0x21, 0x0A, 0x08, 0x09, 0x1C, 0x0A, 0x07, 0x00, 
  0x19, 0x0B, 0x08, 0x00, 0x07, 0x0C, 0x0B, 0x06, 0x3A, 0x05, 0x0C, 0x0B, 0x29, 0x0C, 0x01, 0x00, 
  0x06, 0x08, 0x08, 0x0C, 0x1A, 0xF9, 0xFF, 0xFF, 0x03, 0x05, 0x00, 0x00, 0x29, 0x06, 0x03, 0x00, 
  0x23, 0x05, 0x03, 0x06, 0x1C, 0x05, 0x2D, 0x00, 0x3B, 0x06, 0x00, 0x00, 0x19, 0x07, 0x06, 0x00, 
  0x3B, 0x06, 0x00, 0x01, 0x19, 0x08, 0x06, 0x00, 0x3B, 0x06, 0x00, 0x02, 0x19, 0x09, 0x06, 0x00, 
  0x2F, 0x09, 0x00, 0x00, 0x2A, 0x0A, 0x01, 0x00, 0x33, 0x06, 0x0A, 0x00, 0x1C, 0x06, 0x03, 0x00, 
  0x3E, 0x0A, 0x00, 0x00, 0x03, 0x0A, 0x00, 0x00, 0x2F, 0x09, 0x00, 0x00, 0x2A, 0x0B, 0x02, 0x00, 
  0x33, 0x0A, 0x0B, 0x00, 0x1C, 0x0A, 0x10, 0x00, 0x3E, 0x0B, 0x00, 0x00, 0x19, 0x0C, 0x0B, 0x00, 
  0x19, 0x0B, 0x07, 0x00, 0x19, 0x0D, 0x08, 0x00, 0x1F, 0x0E, 0x0B, 0x0D, 0x1C, 0x0E, 0x09, 0x00, 
  0x19, 0x0F, 0x0B, 0x00, 0x30, 0x0C, 0x0F, 0x00, 0x2A, 0x11, 0x03, 0x00, 0x33, 0x10, 0x11, 0x00, 
  0x29, 0x11, 0x00, 0x00, 0x07, 0x10, 0x11, 0x09, 0x07, 0x0B, 0x0B, 0x10, 0x1A, 0xF7, 0xFF, 0xFF, 
  0x03, 0x0C, 0x00, 0x00, 0x3E, 0x0B, 0x00, 0x00, 0x19, 0x0C, 0x0B, 0x00, 0x19, 0x0B, 0x07, 0x00, 
  0x19, 0x0D, 0x08, 0x00, 0x21, 0x0E, 0x0B, 0x0D, 0x1C, 0x0E, 0x07, 0x00, 0x19, 0x0F, 0x0B, 0x00, 
  0x30, 0x0C, 0x0F, 0x00, 0x2A, 0x11, 0x03, 0x00, 0x33, 0x10, 0x11, 0x00, 0x06, 0x0B, 0x0B, 0x09, 
  0x1A, 0xF9, 0xFF, 0xFF, 0x03, 0x0C, 0x00, 0x00, 0x2A, 0x06, 0x04, 0x00, 0x01, 0x06, 0x00, 0x00, 
  0x04, 0x00, 0x00, 0x00, 0x83, 0x7F, 0x01, 0x05, 0x09, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x02, 0x09, 0x00, 0x09, 0x01, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x09, 0x01, 0x09, 0x00, 
  0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x14, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0xBF, 
  0xFD, 0x07, 0xBF, 0xFF, 0x03, 0x00, 0x03, 0x00, 0x03, 0x07, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 
  0x09, 0x01, 0x1D, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x09, 0x01, 0x09, 0x00, 0x09, 0x00, 
  0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x1D, 0x00, 0x14, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0xBF, 
  0xFD, 0x07, 0xBF, 0xFA, 0x03, 0x00, 0x03, 0x00, 0x03, 0x0C, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 
  0x09, 0x00, 0x09, 0x00, 0x09, 0x02, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0xBF, 0xFF, 0x09, 0x00, 0x09, 
  0x00, 0x09, 0x02, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0xBF, 0xFE, 0x09, 0x02, 0x14, 0x00, 0x14, 0x00, 
  0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 
  0x27, 0x00, 0x27, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x01, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 
  0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 
  0x0B, 0x00, 0x0B, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0xDA, 0x82, 0x9C, 0xDA, 0x59, 0xCF, 0x07, 
  0x6F, 0x73, 0x2F, 0x6C, 0x69, 0x6E, 0x6B, 0xD8, 0x07, 0x6F, 0x73, 0x2F, 0x6C, 0x69, 0x6E, 0x6B, 
  0xCF, 0x12, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x61, 0x73, 0x63, 0x69, 0x69, 0x2D, 0x6C, 
  0x6F, 0x77, 0x65, 0x72, 0xD8, 0x12, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x61, 0x73, 0x63, 
  0x69, 0x69, 0x2D, 0x6C, 0x6F, 0x77, 0x65, 0x72, 0xCF, 0x01, 0x2F, 0xD7, 0xCD, 0x00, 0x09, 0x00, 
  0x0C, 0x06, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x13, 0xCE, 0x01, 0x2F, 0x3D, 0x01, 
  0x00, 0x00, 0x24, 0x02, 0x01, 0x00, 0x1C, 0x02, 0x03, 0x00, 0x29, 0x03, 0x01, 0x00, 0x03, 0x03, 
  0x00, 0x00, 0x24, 0x02, 0x01, 0x01, 0x1C, 0x02, 0x05, 0x00, 0x29, 0x03, 0x01, 0x00, 0x3B, 0x04, 
  0x00, 0x00, 0x0B, 0x03, 0x03, 0x04, 0x03, 0x03, 0x00, 0x00, 0x3B, 0x03, 0x00, 0x00, 0x29, 0x05, 
  0x01, 0x00, 0x38, 0x04, 0x00, 0x05, 0x0B, 0x03, 0x03, 0x04, 0x05, 0x05, 0x05, 0x01, 0x23, 0x02, 
  0x05, 0x01, 0x1C, 0x02, 0xFC, 0xFF, 0x03, 0x03, 0x00, 0x00, 0xCF, 0x09, 0x67, 0x63, 0x63, 0x6F, 
  0x6C, 0x6C, 0x65, 0x63, 0x74, 0xD8, 0x09, 0x67, 0x63, 0x63, 0x6F, 0x6C, 0x6C, 0x65, 0x63, 0x74, 
  0xCF, 0x06, 0x74, 0x72, 0x61, 0x63, 0x65, 0x76, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x15, 0x01, 
  0x01, 0x01, 0x14, 0x4C, 0xCE, 0x06, 0x74, 0x72, 0x61, 0x63, 0x65, 0x76, 0xDA, 0x05, 0xDA, 0x82, 
  0x25, 0xDA, 0x82, 0x34, 0xDA, 0x7D, 0xDA, 0x0F, 0xDA, 0x80, 0xDC, 0xCE, 0x0A, 0x74, 0x72, 0x61, 
  0x63, 0x65, 0x20, 0x5B, 0x25, 0x73, 0x5D, 0xDA, 0x82, 0x03, 0xCE, 0x05, 0x74, 0x72, 0x61, 0x63, 
  0x65, 0xDA, 0x83, 0x18, 0xCE, 0x01, 0x3A, 0xCE, 0x17, 0x20, 0x6F, 0x6E, 0x20, 0x6C, 0x69, 0x6E, 
  0x65, 0x20, 0x25, 0x64, 0x2C, 0x20, 0x63, 0x6F, 0x6C, 0x75, 0x6D, 0x6E, 0x20, 0x25, 0x64, 0x3A, 
  0xCE, 0x07, 0x20, 0x25, 0x6A, 0x20, 0x69, 0x73, 0x20, 0xDA, 0x6F, 0xDA, 0x22, 0xDA, 0x82, 0x16, 
  0xDA, 0x82, 0x81, 0xD0, 0x0D, 0x70, 0x72, 0x65, 0x74, 0x74, 0x79, 0x2D, 0x66, 0x6F, 0x72, 0x6D, 
  0x61, 0x74, 0xCE, 0x02, 0x25, 0x71, 0xD8, 0x07, 0x65, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x66, 0xDA, 
  0x81, 0x8D, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x30, 0x02, 
  0x03, 0x00, 0x2A, 0x03, 0x02, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2F, 0x02, 0x00, 0x00, 0x2A, 0x04, 
  0x03, 0x00, 0x33, 0x03, 0x04, 0x00, 0x3B, 0x02, 0x03, 0x00, 0x19, 0x04, 0x02, 0x00, 0x3B, 0x02, 
  0x03, 0x01, 0x19, 0x05, 0x02, 0x00, 0x2A, 0x02, 0x04, 0x00, 0x2F, 0x02, 0x00, 0x00, 0x2A, 0x06, 
  0x02, 0x00, 0x33, 0x02, 0x06, 0x00, 0x19, 0x06, 0x02, 0x00, 0x1C, 0x06, 0x07, 0x00, 0x2A, 0x08, 
  0x05, 0x00, 0x30, 0x08, 0x06, 0x00, 0x2A, 0x09, 0x06, 0x00, 0x33, 0x08, 0x09, 0x00, 0x19, 0x07, 
  0x08, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x2A, 0x07, 0x07, 0x00, 0x19, 0x08, 0x07, 0x00, 0x2F, 0x04, 
  0x00, 0x00, 0x2A, 0x0B, 0x08, 0x00, 0x33, 0x0A, 0x0B, 0x00, 0x19, 0x0B, 0x0A, 0x00, 0x1C, 0x0B, 
  0x03, 0x00, 0x19, 0x0A, 0x0B, 0x00, 0x1A, 0x05, 0x00, 0x00, 0x2F, 0x05, 0x00, 0x00, 0x2A, 0x0D, 
  0x08, 0x00, 0x33, 0x0C, 0x0D, 0x00, 0x19, 0x0A, 0x0C, 0x00, 0x1C, 0x0A, 0x03, 0x00, 0x2A, 0x09, 
  0x09, 0x00, 0x1A, 0x06, 0x00, 0x00, 0x2A, 0x0B, 0x0A, 0x00, 0x31, 0x0B, 0x04, 0x05, 0x2A, 0x0C, 
  0x06, 0x00, 0x33, 0x0B, 0x0C, 0x00, 0x19, 0x09, 0x0B, 0x00, 0x19, 0x0A, 0x09, 0x00, 0x2A, 0x0B, 
  0x0B, 0x00, 0x31, 0x08, 0x0A, 0x0B, 0x2A, 0x0C, 0x0C, 0x00, 0x33, 0x0B, 0x0C, 0x00, 0x19, 0x0C, 
  0x0B, 0x00, 0x2A, 0x0E, 0x0D, 0x00, 0x33, 0x0D, 0x0E, 0x00, 0x19, 0x0E, 0x0D, 0x00, 0x30, 0x0E, 
  0x00, 0x00, 0x44, 0x0F, 0x00, 0x00, 0x2A, 0x11, 0x0E, 0x00, 0x30, 0x11, 0x00, 0x00, 0x43, 0x10, 
  0x00, 0x00, 0x2A, 0x12, 0x0F, 0x00, 0x31, 0x12, 0x0C, 0x10, 0x43, 0x11, 0x00, 0x00, 0x2A, 0x12, 
  0x02, 0x00, 0x2A, 0x13, 0x10, 0x00, 0x2A, 0x14, 0x11, 0x00, 0x31, 0x12, 0x13, 0x14, 0x43, 0x10, 
  0x00, 0x00, 0x2A, 0x13, 0x12, 0x00, 0x31, 0x13, 0x10, 0x0E, 0x43, 0x12, 0x00, 0x00, 0x2A, 0x13, 
  0x13, 0x00, 0x31, 0x13, 0x0F, 0x11, 0x30, 0x12, 0x0E, 0x00, 0x43, 0x10, 0x00, 0x00, 0x03, 0x10, 
  0x00, 0x00, 0x83, 0xF3, 0x01, 0x04, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 
  0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x0B, 0x00, 
  0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x03, 0x01, 0x0E, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 
  0x15, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x03, 0x01, 0x16, 0x00, 0x16, 0x00, 0x16, 0x00, 
  0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x12, 0x00, 
  0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x2D, 0x00, 0x2D, 0x00, 0x2D, 0x00, 0x2D, 0x00, 0x0E, 0x00, 
  0x03, 0x01, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x03, 0x01, 0x0A, 0x00, 0x0A, 0x00, 
  0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x0A, 0x67, 0x63, 0x69, 
  0x6E, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6C, 0xD8, 0x0A, 0x67, 0x63, 0x69, 0x6E, 0x74, 0x65, 0x72, 
  0x76, 0x61, 0x6C, 0xCF, 0x06, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0xDA, 0x82, 0x31, 0xCF, 0x0B, 
  0x62, 0x6F, 0x6F, 0x74, 0x2F, 0x63, 0x6F, 0x6E, 0x66, 0x69, 0x67, 0xD3, 0x00, 0xCF, 0x08, 0x6F, 
  0x73, 0x2F, 0x73, 0x68, 0x65, 0x6C, 0x6C, 0xD8, 0x08, 0x6F, 0x73, 0x2F, 0x73, 0x68, 0x65, 0x6C, 
  0x6C, 0xCF, 0x02, 0x3C, 0x3D, 0xDA, 0x81, 0xA6, 0xCF, 0x03, 0x6E, 0x6F, 0x74, 0xDA, 0x81, 0x62, 
  0xCF, 0x06, 0x65, 0x76, 0x65, 0x72, 0x79, 0x3F, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x06, 0x01, 
  0x01, 0x01, 0x00, 0x11, 0xCE, 0x06, 0x65, 0x76, 0x65, 0x72, 0x79, 0x3F, 0xDA, 0x05, 0x2C, 0x01, 
  0x00, 0x00, 0x27, 0x02, 0x00, 0x00, 0x26, 0x04, 0x00, 0x00, 0x47, 0x03, 0x00, 0x04, 0x19, 0x04, 
  0x03, 0x00, 0x1D, 0x04, 0x0B, 0x00, 0x38, 0x03, 0x00, 0x04, 0x19, 0x05, 0x03, 0x00, 0x1C, 0x02, 
  0x02, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x1A, 0x06, 0x00, 0x00, 0x1C, 0x05, 0x02, 0x00, 0x1A, 0x02, 
  0x00, 0x00, 0x19, 0x02, 0x05, 0x00, 0x47, 0x04, 0x00, 0x04, 0x1A, 0xF6, 0xFF, 0xFF, 0x03, 0x02, 
  0x00, 0x00, 0x84, 0x9F, 0x01, 0x04, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x05, 0x00, 0x05, 0x00, 0x0F, 0xBF, 
  0xFF, 0x03, 0x00, 0x03, 0xBF, 0xFB, 0x01, 0xCF, 0x05, 0x74, 0x72, 0x61, 0x63, 0x65, 0xD8, 0x05, 
  0x74, 0x72, 0x61, 0x63, 0x65, 0xCF, 0x12, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x61, 0x73, 
  0x63, 0x69, 0x69, 0x2D, 0x75, 0x70, 0x70, 0x65, 0x72, 0xD8, 0x12, 0x73, 0x74, 0x72, 0x69, 0x6E, 
  0x67, 0x2F, 0x61, 0x73, 0x63, 0x69, 0x69, 0x2D, 0x75, 0x70, 0x70, 0x65, 0x72, 0xCF, 0x11, 0x66, 
  0x69, 0x62, 0x65, 0x72, 0x2F, 0x73, 0x65, 0x74, 0x6D, 0x61, 0x78, 0x73, 0x74, 0x61, 0x63, 0x6B, 
  0xD8, 0x11, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2F, 0x73, 0x65, 0x74, 0x6D, 0x61, 0x78, 0x73, 0x74, 
  0x61, 0x63, 0x6B, 0xCF, 0x0C, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2F, 0x72, 0x61, 0x77, 0x67, 0x65, 
  0x74, 0xD8, 0x0C, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2F, 0x72, 0x61, 0x77, 0x67, 0x65, 0x74, 0xCF, 
  0x06, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x66, 0xD8, 0x06, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x66, 0xCF, 
  0x08, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x73, 0x69, 0x6E, 0xD8, 0x08, 0x6D, 0x61, 0x74, 0x68, 0x2F, 
  0x73, 0x69, 0x6E, 0xCF, 0x07, 0x69, 0x6E, 0x74, 0x2F, 0x75, 0x36, 0x34, 0xD8, 0x07, 0x69, 0x6E, 
  0x74, 0x2F, 0x75, 0x36, 0x34, 0xCF, 0x06, 0x6D, 0x61, 0x70, 0x63, 0x61, 0x74, 0xD7, 0xCD, 0x00, 
  0x98, 0x00, 0x00, 0x0A, 0x02, 0x02, 0x02, 0x01, 0x11, 0xCE, 0x06, 0x6D, 0x61, 0x70, 0x63, 0x61, 
  0x74, 0xDA, 0x05, 0xDA, 0x81, 0x2E, 0x2C, 0x02, 0x00, 0x00, 0x3E, 0x03, 0x00, 0x00, 0x19, 0x04, 
  0x03, 0x00, 0x26, 0x06, 0x00, 0x00, 0x47, 0x05, 0x01, 0x06, 0x19, 0x06, 0x05, 0x00, 0x1D, 0x06, 
  0x0A, 0x00, 0x38, 0x05, 0x01, 0x06, 0x19, 0x07, 0x05, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x33, 0x05, 
  0x00, 0x00, 0x30, 0x04, 0x05, 0x00, 0x2A, 0x09, 0x00, 0x00, 0x33, 0x08, 0x09, 0x00, 0x47, 0x06, 
  0x01, 0x06, 0x1A, 0xF7, 0xFF, 0xFF, 0x03, 0x04, 0x00, 0x00, 0x83, 0x58, 0x01, 0x04, 0x03, 0x00, 
  0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x17, 0x00, 
  0x17, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xBF, 0xFF, 0x03, 0x00, 0x03, 0xBF, 0xFB, 0x01, 0xCF, 
  0x0B, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x74, 0x72, 0x69, 0x6D, 0xD8, 0x0B, 0x73, 0x74, 
  0x72, 0x69, 0x6E, 0x67, 0x2F, 0x74, 0x72, 0x69, 0x6D, 0xCF, 0x05, 0x64, 0x65, 0x62, 0x75, 0x67, 
  0xD7, 0xCD, 0x00, 0x08, 0x00, 0x01, 0x01, 0x01, 0x00, 0x01, 0x00, 0x02, 0xCE, 0x05, 0x64, 0x65, 
  0x62, 0x75, 0x67, 0x36, 0x00, 0x00, 0x02, 0x03, 0x00, 0x00, 0x00, 0xCF, 0x0A, 0x6D, 0x61, 0x74, 
  0x68, 0x2F, 0x61, 0x73, 0x69, 0x6E, 0x68, 0xD8, 0x0A, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x61, 0x73, 
  0x69, 0x6E, 0x68, 0xCF, 0x04, 0x69, 0x6E, 0x74, 0x3F, 0xD8, 0x04, 0x69, 0x6E, 0x74, 0x3F, 0xCF, 
  0x0A, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x6C, 0x6F, 0x67, 0x31, 0x30, 0xD8, 0x0A, 0x6D, 0x61, 0x74, 
  0x68, 0x2F, 0x6C, 0x6F, 0x67, 0x31, 0x30, 0xCF, 0x0A, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x66, 
  0x69, 0x6C, 0x6C, 0xD8, 0x0A, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x66, 0x69, 0x6C, 0x6C, 0xCF, 
  0x0B, 0x73, 0x63, 0x61, 0x6E, 0x2D, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0xDA, 0x82, 0x3C, 0xCF, 
  0x06, 0x73, 0x6F, 0x72, 0x74, 0x65, 0x64, 0xDA, 0x81, 0x29, 0xCF, 0x06, 0x62, 0x79, 0x74, 0x65, 
  0x73, 0x3F, 0xDA, 0x81, 0x1E, 0xCF, 0x06, 0x64, 0x6F, 0x66, 0x69, 0x6C, 0x65, 0xDA, 0x81, 0x0E, 
  0xCF, 0x05, 0x73, 0x6C, 0x75, 0x72, 0x70, 0xDA, 0x81, 0x15, 0xCF, 0x03, 0x61, 0x6C, 0x6C, 0xD7, 
  0xCD, 0x00, 0x98, 0x00, 0x00, 0x07, 0x02, 0x02, 0x02, 0x00, 0x10, 0xCE, 0x03, 0x61, 0x6C, 0x6C, 
  0xDA, 0x05, 0x2C, 0x02, 0x00, 0x00, 0x27, 0x03, 0x00, 0x00, 0x26, 0x05, 0x00, 0x00, 0x47, 0x04, 
  0x01, 0x05, 0x19, 0x05, 0x04, 0x00, 0x1D, 0x05, 0x0A, 0x00, 0x38, 0x04, 0x01, 0x05, 0x19, 0x06, 
  0x04, 0x00, 0x1C, 0x03, 0x02, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x1A, 0x05, 0x00, 0x00, 0x2F, 0x06, 
  0x00, 0x00, 0x33, 0x03, 0x00, 0x00, 0x47, 0x05, 0x01, 0x05, 0x1A, 0xF7, 0xFF, 0xFF, 0x03, 0x03, 
  0x00, 0x00, 0x86, 0xFF, 0x01, 0x04, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x28, 0x00, 0x28, 0x00, 0x03, 0x00, 
  0x03, 0xBF, 0xFB, 0x01, 0xCF, 0x06, 0x61, 0x72, 0x72, 0x61, 0x79, 0x3F, 0xD7, 0xCD, 0x00, 0x98, 
  0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 0x02, 0x07, 0xCE, 0x06, 0x61, 0x72, 0x72, 0x61, 0x79, 0x3F, 
  0xDA, 0x05, 0xDA, 0x39, 0xDA, 0x81, 0x3C, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 
  0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x23, 0x03, 0x02, 0x04, 0x03, 
  0x03, 0x00, 0x00, 0x63, 0x01, 0x00, 0x2F, 0x00, 0x2F, 0x00, 0x2F, 0x00, 0x2C, 0x00, 0x2C, 0x00, 
  0x2C, 0xCF, 0x09, 0x61, 0x62, 0x73, 0x74, 0x72, 0x61, 0x63, 0x74, 0x3F, 0xD8, 0x09, 0x61, 0x62, 
  0x73, 0x74, 0x72, 0x61, 0x63, 0x74, 0x3F, 0xCF, 0x11, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 
  0x66, 0x72, 0x6F, 0x6D, 0x2D, 0x62, 0x79, 0x74, 0x65, 0x73, 0xD8, 0x11, 0x73, 0x74, 0x72, 0x69, 
  0x6E, 0x67, 0x2F, 0x66, 0x72, 0x6F, 0x6D, 0x2D, 0x62, 0x79, 0x74, 0x65, 0x73, 0xCF, 0x07, 0x69, 
  0x6E, 0x74, 0x2F, 0x73, 0x36, 0x34, 0xD8, 0x07, 0x69, 0x6E, 0x74, 0x2F, 0x73, 0x36, 0x34, 0xCF, 
  0x0A, 0x6F, 0x73, 0x2F, 0x73, 0x79, 0x6D, 0x6C, 0x69, 0x6E, 0x6B, 0xD8, 0x0A, 0x6F, 0x73, 0x2F, 
  0x73, 0x79, 0x6D, 0x6C, 0x69, 0x6E, 0x6B, 0xDA, 0x81, 0x8D, 0xD7, 0xCD, 0x00, 0x99, 0x00, 0x00, 
  0x0F, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x08, 0x29, 0xCE, 0x03, 0x6C, 0x65, 0x74, 0xDA, 
  0x05, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 0x00, 0x06, 0xCE, 0x04, 0x6F, 
  0x64, 0x64, 0x3F, 0xDA, 0x05, 0x2C, 0x01, 0x00, 0x00, 0x29, 0x03, 0x02, 0x00, 0x0C, 0x02, 0x00, 
  0x03, 0x29, 0x04, 0x01, 0x00, 0x23, 0x03, 0x04, 0x02, 0x03, 0x03, 0x00, 0x00, 0x53, 0x01, 0x00, 
  0x2A, 0x00, 0x2A, 0x00, 0x25, 0x00, 0x25, 0x00, 0x25, 0xCE, 0x27, 0x65, 0x78, 0x70, 0x65, 0x63, 
  0x74, 0x65, 0x64, 0x20, 0x65, 0x76, 0x65, 0x6E, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 
  0x6F, 0x66, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x6C, 
  0x65, 0x74, 0xDA, 0x2F, 0xDA, 0x26, 0xDA, 0x81, 0x65, 0xDA, 0x52, 0xDA, 0x81, 0x2E, 0xDA, 0x70, 
  0x2C, 0x02, 0x00, 0x00, 0x3D, 0x03, 0x00, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x05, 0x00, 0x00, 
  0x33, 0x04, 0x05, 0x00, 0x1C, 0x04, 0x04, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x01, 0x03, 0x00, 0x00, 
  0x1A, 0x01, 0x00, 0x00, 0x3D, 0x03, 0x00, 0x00, 0x19, 0x04, 0x03, 0x00, 0x29, 0x05, 0x00, 0x00, 
  0x2A, 0x06, 0x02, 0x00, 0x2F, 0x06, 0x00, 0x00, 0x3E, 0x06, 0x00, 0x00, 0x19, 0x07, 0x06, 0x00, 
  0x21, 0x08, 0x05, 0x04, 0x1C, 0x08, 0x11, 0x00, 0x29, 0x0B, 0x01, 0x00, 0x06, 0x0A, 0x05, 0x0B, 
  0x38, 0x09, 0x00, 0x0A, 0x19, 0x0B, 0x09, 0x00, 0x38, 0x09, 0x00, 0x05, 0x19, 0x0C, 0x09, 0x00, 
  0x2A, 0x09, 0x03, 0x00, 0x31, 0x09, 0x0C, 0x0B, 0x2A, 0x0D, 0x04, 0x00, 0x33, 0x09, 0x0D, 0x00, 
  0x30, 0x07, 0x09, 0x00, 0x2A, 0x0E, 0x05, 0x00, 0x33, 0x0D, 0x0E, 0x00, 0x29, 0x09, 0x02, 0x00, 
  0x06, 0x05, 0x05, 0x09, 0x1A, 0xEF, 0xFF, 0xFF, 0x30, 0x07, 0x01, 0x00, 0x2A, 0x09, 0x06, 0x00, 
  0x33, 0x08, 0x09, 0x00, 0x29, 0x09, 0x00, 0x00, 0x30, 0x07, 0x09, 0x00, 0x2A, 0x09, 0x07, 0x00, 
  0x34, 0x09, 0x00, 0x00, 0x80, 0xD1, 0x01, 0x05, 0x0D, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 
  0x03, 0x00, 0x20, 0x00, 0x20, 0x00, 0x03, 0x01, 0x0C, 0x00, 0x03, 0x01, 0x03, 0x01, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x0A, 0x00, 0x03, 0x01, 0x0F, 0x00, 0x0F, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x17, 0x00, 0x17, 0x00, 0x17, 0x00, 0x17, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 0xBF, 0xFD, 0x03, 0x04, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x08, 0x6E, 0x65, 0x74, 0x2F, 0x72, 0x65, 
  0x61, 0x64, 0xD8, 0x08, 0x6E, 0x65, 0x74, 0x2F, 0x72, 0x65, 0x61, 0x64, 0xCF, 0x06, 0x73, 0x74, 
  0x64, 0x65, 0x72, 0x72, 0xD8, 0x06, 0x73, 0x74, 0x64, 0x65, 0x72, 0x72, 0xCF, 0x0A, 0x6D, 0x61, 
  0x74, 0x68, 0x2F, 0x61, 0x63, 0x6F, 0x73, 0x68, 0xD8, 0x0A, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x61, 
  0x63, 0x6F, 0x73, 0x68, 0xCF, 0x06, 0x75, 0x6E, 0x6C, 0x65, 0x73, 0x73, 0xD7, 0xCD, 0x00, 0x99, 
  0x00, 0x00, 0x07, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x02, 0x0B, 0xCE, 0x06, 0x75, 0x6E, 
  0x6C, 0x65, 0x73, 0x73, 0xDA, 0x05, 0xDA, 0x2F, 0xDA, 0x2E, 0x2C, 0x02, 0x00, 0x00, 0x2A, 0x04, 
  0x00, 0x00, 0x2F, 0x04, 0x00, 0x00, 0x32, 0x01, 0x00, 0x00, 0x43, 0x03, 0x00, 0x00, 0x2A, 0x05, 
  0x01, 0x00, 0x26, 0x06, 0x00, 0x00, 0x31, 0x05, 0x00, 0x06, 0x2F, 0x03, 0x00, 0x00, 0x43, 0x04, 
  0x00, 0x00, 0x03, 0x04, 0x00, 0x00, 0x80, 0xA9, 0x01, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x08, 0x63, 
  0x6C, 0x69, 0x2D, 0x6D, 0x61, 0x69, 0x6E, 0xD7, 0xCD, 0x02, 0xBA, 0x00, 0x00, 0x1E, 0x01, 0x01, 
  0x01, 0x32, 0x80, 0xDE, 0x13, 0xCE, 0x08, 0x63, 0x6C, 0x69, 0x2D, 0x6D, 0x61, 0x69, 0x6E, 0xDA, 
  0x05, 0xD0, 0x04, 0x61, 0x72, 0x67, 0x73, 0xDA, 0x82, 0x26, 0xCE, 0x0A, 0x4A, 0x41, 0x4E, 0x45, 
  0x54, 0x5F, 0x50, 0x41, 0x54, 0x48, 0xD8, 0x09, 0x6F, 0x73, 0x2F, 0x67, 0x65, 0x74, 0x65, 0x6E, 
  0x76, 0xD0, 0x07, 0x73, 0x79, 0x73, 0x70, 0x61, 0x74, 0x68, 0xCE, 0x10, 0x4A, 0x41, 0x4E, 0x45, 
  0x54, 0x5F, 0x48, 0x45, 0x41, 0x44, 0x45, 0x52, 0x50, 0x41, 0x54, 0x48, 0xD0, 0x0A, 0x68, 0x65, 
  0x61, 0x64, 0x65, 0x72, 0x70, 0x61, 0x74, 0x68, 0xCE, 0x01, 0x65, 0xCE, 0x01, 0x71, 0xCE, 0x01, 
  0x64, 0xCE, 0x01, 0x63, 0xCE, 0x01, 0x6D, 0xCE, 0x01, 0x6E, 0xCE, 0x01, 0x6B, 0xCE, 0x01, 0x70, 
  0xCE, 0x01, 0x72, 0xCE, 0x01, 0x68, 0xCE, 0x01, 0x73, 0xDA, 0x81, 0xA8, 0xCE, 0x01, 0x76, 0xCE, 
  0x01, 0x6C, 0xDA, 0x81, 0x1F, 0xDA, 0x80, 0xDB, 0xDA, 0x81, 0x28, 0xD0, 0x06, 0x70, 0x72, 0x65, 
  0x66, 0x69, 0x78, 0xDA, 0x67, 0xDA, 0x80, 0xD4, 0xDA, 0x80, 0xD5, 0xDA, 0x80, 0xD3, 0xDA, 0x81, 
  0x0E, 0xCF, 0x04, 0x6D, 0x61, 0x69, 0x6E, 0xDA, 0x03, 0xDA, 0x70, 0xDA, 0x81, 0x00, 0xDA, 0x79, 
  0xDA, 0x80, 0xF7, 0xDA, 0x81, 0x62, 0xCE, 0x06, 0x4A, 0x61, 0x6E, 0x65, 0x74, 0x20, 0xCE, 0x0A, 
  0x31, 0x2E, 0x31, 0x30, 0x2E, 0x31, 0x2D, 0x64, 0x65, 0x76, 0xCE, 0x05, 0x6C, 0x6F, 0x63, 0x61, 
  0x6C, 0xCE, 0x25, 0x20, 0x20, 0x43, 0x6F, 0x70, 0x79, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x28, 
  0x43, 0x29, 0x20, 0x32, 0x30, 0x31, 0x37, 0x2D, 0x32, 0x30, 0x32, 0x30, 0x20, 0x43, 0x61, 0x6C, 
  0x76, 0x69, 0x6E, 0x20, 0x52, 0x6F, 0x73, 0x65, 0xD8, 0x05, 0x70, 0x72, 0x69, 0x6E, 0x74, 0xD8, 
  0x05, 0x66, 0x6C, 0x75, 0x73, 0x68, 0xD0, 0x05, 0x64, 0x65, 0x62, 0x75, 0x67, 0xDA, 0x80, 0xFB, 
  0xCE, 0x05, 0x25, 0x2E, 0x32, 0x30, 0x51, 0xCE, 0x05, 0x25, 0x2E, 0x32, 0x30, 0x71, 0xDA, 0x83, 
  0x2B, 0xDA, 0x7C, 0xD7, 0xCD, 0x02, 0xBA, 0x00, 0x00, 0x0D, 0x03, 0x00, 0x03, 0x07, 0x27, 0x02, 
  0xCE, 0x04, 0x72, 0x65, 0x70, 0x6C, 0xDA, 0x05, 0xDA, 0x80, 0xDB, 0xDA, 0x80, 0xD3, 0xDA, 0x80, 
  0xE0, 0xDA, 0x80, 0xDF, 0xDA, 0x80, 0x9A, 0xDA, 0x83, 0x9A, 0xDA, 0x81, 0x07, 0x2C, 0x03, 0x00, 
  0x00, 0x26, 0x06, 0x00, 0x00, 0x23, 0x05, 0x06, 0x02, 0x1C, 0x05, 0x05, 0x00, 0x2A, 0x07, 0x00, 
  0x00, 0x33, 0x06, 0x07, 0x00, 0x19, 0x04, 0x06, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x04, 0x02, 
  0x00, 0x19, 0x05, 0x04, 0x00, 0x26, 0x08, 0x00, 0x00, 0x23, 0x07, 0x08, 0x00, 0x1C, 0x07, 0x04, 
  0x00, 0x2E, 0x08, 0x00, 0x00, 0x19, 0x06, 0x08, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x06, 0x00, 
  0x00, 0x19, 0x07, 0x06, 0x00, 0x2E, 0x08, 0x01, 0x00, 0x19, 0x09, 0x08, 0x00, 0x1C, 0x01, 0x03, 
  0x00, 0x19, 0x0A, 0x01, 0x00, 0x1A, 0x05, 0x00, 0x00, 0x29, 0x0B, 0x01, 0x00, 0x30, 0x05, 0x0B, 
  0x00, 0x33, 0x0B, 0x09, 0x00, 0x19, 0x0A, 0x0B, 0x00, 0x2A, 0x0B, 0x01, 0x00, 0x2A, 0x0C, 0x02, 
  0x00, 0x31, 0x0B, 0x05, 0x0C, 0x2A, 0x0B, 0x03, 0x00, 0x31, 0x07, 0x0B, 0x0A, 0x2A, 0x0B, 0x04, 
  0x00, 0x2A, 0x0C, 0x05, 0x00, 0x30, 0x0B, 0x0C, 0x00, 0x41, 0x0A, 0x00, 0x00, 0x2F, 0x0A, 0x00, 
  0x00, 0x2A, 0x0B, 0x06, 0x00, 0x34, 0x0B, 0x00, 0x00, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x06, 0x02, 
  0x02, 0x02, 0x08, 0x15, 0x01, 0xDA, 0x05, 0xDA, 0x80, 0xE6, 0xD0, 0x0A, 0x64, 0x65, 0x6C, 0x69, 
  0x6D, 0x69, 0x74, 0x65, 0x72, 0x73, 0xDA, 0x82, 0xE0, 0xCE, 0x05, 0x72, 0x65, 0x70, 0x6C, 0x3A, 
  0xDA, 0x83, 0x28, 0xCE, 0x02, 0x3E, 0x20, 0xDA, 0x6F, 0xDA, 0x80, 0xFB, 0x2F, 0x01, 0x00, 0x00, 
  0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x29, 0x03, 0x00, 0x00, 0x2F, 0x03, 0x00, 0x00, 
  0x33, 0x03, 0x02, 0x00, 0x2A, 0x02, 0x01, 0x00, 0x30, 0x01, 0x02, 0x00, 0x2A, 0x04, 0x02, 0x00, 
  0x33, 0x02, 0x04, 0x00, 0x2A, 0x04, 0x03, 0x00, 0x2A, 0x05, 0x04, 0x00, 0x31, 0x04, 0x03, 0x05, 
  0x2A, 0x04, 0x05, 0x00, 0x30, 0x02, 0x04, 0x00, 0x2A, 0x05, 0x06, 0x00, 0x33, 0x04, 0x05, 0x00, 
  0x2B, 0x02, 0x00, 0x05, 0x31, 0x04, 0x00, 0x02, 0x2A, 0x02, 0x07, 0x00, 0x34, 0x02, 0x00, 0x00, 
  0xBF, 0xFF, 0x8A, 0x2A, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x02, 
  0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0xBF, 0xFC, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 
  0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0xBF, 0xFF, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0xCD, 
  0x02, 0xFA, 0x00, 0x00, 0x06, 0x02, 0x02, 0x02, 0x00, 0x05, 0x01, 0x02, 0xCE, 0x0D, 0x6D, 0x61, 
  0x6B, 0x65, 0x2D, 0x6F, 0x6E, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0xDA, 0x05, 0x2C, 0x02, 0x00, 
  0x00, 0x2E, 0x03, 0x00, 0x00, 0x19, 0x04, 0x03, 0x00, 0x2E, 0x05, 0x01, 0x00, 0x03, 0x05, 0x00, 
  0x00, 0xBF, 0xFF, 0xCD, 0x02, 0xFA, 0x00, 0x00, 0x10, 0x02, 0x02, 0x02, 0x0F, 0x34, 0x02, 0x01, 
  0xCE, 0x0E, 0x65, 0x6E, 0x74, 0x65, 0x72, 0x2D, 0x64, 0x65, 0x62, 0x75, 0x67, 0x67, 0x65, 0x72, 
  0xDA, 0x05, 0xDA, 0x80, 0xDB, 0xDA, 0x81, 0x02, 0xD0, 0x0B, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2D, 
  0x6C, 0x65, 0x76, 0x65, 0x6C, 0xD0, 0x06, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0xD3, 0x12, 0xCF, 
  0x05, 0x2E, 0x73, 0x74, 0x65, 0x70, 0xD3, 0x03, 0xDA, 0x03, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 
  0x09, 0x01, 0x00, 0x01, 0x02, 0x14, 0xCE, 0x05, 0x2E, 0x73, 0x74, 0x65, 0x70, 0xDA, 0x05, 0xD7, 
  0xCD, 0x00, 0x98, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x05, 0xCE, 0x06, 0x2E, 0x66, 0x69, 
  0x62, 0x65, 0x72, 0xDA, 0x05, 0xDA, 0x81, 0x02, 0xDA, 0x7D, 0x2C, 0x00, 0x00, 0x00, 0x2A, 0x01, 
  0x00, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x01, 0x01, 0x00, 0x34, 0x01, 0x00, 0x00, 0x89, 0x72, 
  0x01, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xD8, 0x0A, 0x64, 0x65, 0x62, 0x75, 0x67, 
  0x2F, 0x73, 0x74, 0x65, 0x70, 0x2C, 0x01, 0x00, 0x00, 0x26, 0x02, 0x00, 0x00, 0x29, 0x03, 0x00, 
  0x00, 0x1C, 0x00, 0x03, 0x00, 0x19, 0x04, 0x00, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x29, 0x04, 0x01, 
  0x00, 0x19, 0x05, 0x04, 0x00, 0x21, 0x04, 0x03, 0x05, 0x1C, 0x04, 0x0A, 0x00, 0x19, 0x06, 0x03, 
  0x00, 0x2A, 0x08, 0x00, 0x00, 0x33, 0x07, 0x08, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x2A, 0x08, 0x01, 
  0x00, 0x33, 0x02, 0x08, 0x00, 0x29, 0x07, 0x01, 0x00, 0x06, 0x03, 0x03, 0x07, 0x1A, 0xF6, 0xFF, 
  0xFF, 0x03, 0x02, 0x00, 0x00, 0x8A, 0x07, 0x01, 0x03, 0x03, 0x01, 0x03, 0x00, 0x0C, 0x00, 0x0C, 
  0x00, 0x0C, 0x00, 0x0C, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x1A, 0x00, 0x1A, 
  0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0xBF, 0xFF, 0x03, 0x00, 0x03, 0x00, 0x03, 0xBF, 0xFC, 0x01, 
  0xDA, 0x09, 0xCE, 0x30, 0x28, 0x2E, 0x73, 0x74, 0x65, 0x70, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 
  0x6E, 0x29, 0x0A, 0x0A, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x6E, 0x65, 0x78, 0x74, 0x20, 0x6E, 0x20, 0x69, 0x6E, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x69, 
  0x6F, 0x6E, 0x73, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x8A, 0x07, 0x01, 0xCF, 0x07, 
  0x2E, 0x64, 0x69, 0x73, 0x61, 0x73, 0x6D, 0xD3, 0x03, 0xDA, 0x03, 0xD7, 0xCD, 0x00, 0x98, 0x00, 
  0x00, 0x07, 0x01, 0x00, 0x01, 0x03, 0x0C, 0xCE, 0x07, 0x2E, 0x64, 0x69, 0x73, 0x61, 0x73, 0x6D, 
  0xDA, 0x05, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x06, 0x01, 0x00, 0x01, 0x02, 0x0D, 0xCE, 0x06, 
  0x2E, 0x66, 0x72, 0x61, 0x6D, 0x65, 0xDA, 0x05, 0xDA, 0x83, 0xA7, 0xD8, 0x0B, 0x64, 0x65, 0x62, 
  0x75, 0x67, 0x2F, 0x73, 0x74, 0x61, 0x63, 0x6B, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 
  0x33, 0x02, 0x03, 0x00, 0x2F, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x33, 0x03, 0x04, 0x00, 
  0x19, 0x02, 0x03, 0x00, 0x1C, 0x00, 0x03, 0x00, 0x19, 0x04, 0x00, 0x00, 0x1A, 0x02, 0x00, 0x00, 
  0x29, 0x04, 0x00, 0x00, 0x38, 0x05, 0x02, 0x04, 0x03, 0x05, 0x00, 0x00, 0x89, 0x83, 0x01, 0x03, 
  0x1B, 0x00, 0x1B, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x03, 0x01, 0x0D, 0x00, 0x0D, 0x00, 
  0x0D, 0x00, 0x0D, 0x00, 0x03, 0x00, 0x03, 0xDA, 0x78, 0xDA, 0x82, 0x8D, 0x2C, 0x01, 0x00, 0x00, 
  0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x19, 0x03, 0x02, 0x00, 
  0x2A, 0x04, 0x01, 0x00, 0x2F, 0x04, 0x00, 0x00, 0x33, 0x04, 0x03, 0x00, 0x19, 0x05, 0x04, 0x00, 
  0x2F, 0x05, 0x00, 0x00, 0x2A, 0x06, 0x02, 0x00, 0x34, 0x06, 0x00, 0x00, 0x89, 0x9B, 0x01, 0x03, 
  0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x03, 0x01, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x03, 0x01, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0xDA, 0x09, 0xCE, 0x3D, 0x28, 0x2E, 0x64, 0x69, 0x73, 0x61, 0x73, 
  0x6D, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x6E, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x73, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x61, 0x73, 0x73, 0x65, 0x6D, 0x62, 0x6C, 0x79, 0x20, 0x66, 0x6F, 0x72, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x75, 0x6E, 
  0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x89, 0x9B, 0x01, 
  0xCF, 0x06, 0x2E, 0x70, 0x70, 0x61, 0x73, 0x6D, 0xD3, 0x03, 0xDA, 0x03, 0xD7, 0xCD, 0x00, 0x98, 
  0x00, 0x00, 0x20, 0x01, 0x00, 0x01, 0x24, 0x80, 0x94, 0xCE, 0x06, 0x2E, 0x70, 0x70, 0x61, 0x73, 
  0x6D, 0xDA, 0x05, 0xDA, 0x83, 0xB1, 0xDA, 0x78, 0xDA, 0x82, 0x8D, 0xD0, 0x08, 0x62, 0x79, 0x74, 
  0x65, 0x63, 0x6F, 0x64, 0x65, 0xD0, 0x02, 0x70, 0x63, 0xD0, 0x09, 0x73, 0x6F, 0x75, 0x72, 0x63, 
  0x65, 0x6D, 0x61, 0x70, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x05, 
  0xCE, 0x07, 0x2E, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0xDA, 0x05, 0xDA, 0x83, 0xA1, 0xDA, 0x7D, 
  0x2C, 0x00, 0x00, 0x00, 0x2A, 0x01, 0x00, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x01, 0x01, 0x00, 
  0x34, 0x01, 0x00, 0x00, 0x89, 0x77, 0x01, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCE, 
  0x0B, 0x0A, 0x20, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0x3A, 0x20, 0xDA, 0x83, 0x95, 0xD0, 
  0x04, 0x6E, 0x61, 0x6D, 0x65, 0xDA, 0x80, 0x9A, 0xDA, 0x67, 0xDA, 0x80, 0xFA, 0xCE, 0x0E, 0x20, 
  0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x3A, 0x20, 0x20, 0x20, 0xCE, 0x02, 0x20, 
  0x5B, 0xCE, 0x01, 0x5D, 0xD0, 0x09, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x61, 0x6E, 0x74, 0x73, 0xCE, 
  0x12, 0x20, 0x20, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x61, 0x6E, 0x74, 0x73, 0x3A, 0x20, 0x20, 0x25, 
  0x2E, 0x34, 0x71, 0xDA, 0x83, 0x44, 0xD0, 0x05, 0x73, 0x6C, 0x6F, 0x74, 0x73, 0xCE, 0x13, 0x20, 
  0x20, 0x73, 0x6C, 0x6F, 0x74, 0x73, 0x3A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x25, 0x2E, 0x34, 
  0x71, 0x0A, 0xDA, 0x6A, 0xD8, 0x0D, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x72, 0x65, 0x70, 
  0x65, 0x61, 0x74, 0xDA, 0x82, 0x18, 0xDA, 0x82, 0x19, 0xDA, 0x82, 0x54, 0xD8, 0x04, 0x70, 0x72, 
  0x69, 0x6E, 0xDA, 0x83, 0x9D, 0xDA, 0x81, 0xEA, 0xDA, 0x6F, 0xDA, 0x80, 0xBF, 0xDA, 0x81, 0xC2, 
  0xCE, 0x05, 0x25, 0x2E, 0x32, 0x30, 0x73, 0xD8, 0x05, 0x70, 0x72, 0x69, 0x6E, 0x66, 0xCE, 0x08, 
  0x20, 0x23, 0x20, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0xDA, 0x80, 0xEA, 0x2C, 0x01, 0x00, 0x00, 0x2F, 
  0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x19, 0x03, 0x02, 0x00, 0x2A, 
  0x04, 0x01, 0x00, 0x2F, 0x04, 0x00, 0x00, 0x33, 0x04, 0x03, 0x00, 0x19, 0x05, 0x04, 0x00, 0x2F, 
  0x05, 0x00, 0x00, 0x2A, 0x07, 0x02, 0x00, 0x33, 0x06, 0x07, 0x00, 0x19, 0x07, 0x06, 0x00, 0x2A, 
  0x09, 0x03, 0x00, 0x38, 0x08, 0x07, 0x09, 0x19, 0x09, 0x08, 0x00, 0x2A, 0x0A, 0x04, 0x00, 0x2F, 
  0x0A, 0x00, 0x00, 0x33, 0x0A, 0x03, 0x00, 0x19, 0x0B, 0x0A, 0x00, 0x2A, 0x0D, 0x05, 0x00, 0x38, 
  0x0C, 0x07, 0x0D, 0x19, 0x0D, 0x0C, 0x00, 0x29, 0x0E, 0xFE, 0xFF, 0x29, 0x0F, 0xFE, 0xFF, 0x30, 
  0x0E, 0x0F, 0x00, 0x43, 0x0E, 0x00, 0x00, 0x19, 0x0F, 0x0E, 0x00, 0x2A, 0x11, 0x06, 0x00, 0x33, 
  0x10, 0x11, 0x00, 0x2A, 0x11, 0x07, 0x00, 0x30, 0x11, 0x10, 0x00, 0x2A, 0x12, 0x08, 0x00, 0x33, 
  0x11, 0x12, 0x00, 0x2A, 0x10, 0x09, 0x00, 0x2F, 0x10, 0x00, 0x00, 0x33, 0x10, 0x07, 0x00, 0x2A, 
  0x12, 0x0A, 0x00, 0x2A, 0x13, 0x0B, 0x00, 0x31, 0x07, 0x12, 0x13, 0x2A, 0x13, 0x0C, 0x00, 0x33, 
  0x12, 0x13, 0x00, 0x2A, 0x13, 0x0D, 0x00, 0x2A, 0x14, 0x0E, 0x00, 0x31, 0x13, 0x10, 0x14, 0x2A, 
  0x13, 0x0F, 0x00, 0x30, 0x12, 0x13, 0x00, 0x2A, 0x14, 0x08, 0x00, 0x33, 0x13, 0x14, 0x00, 0x2A, 
  0x10, 0x10, 0x00, 0x2F, 0x10, 0x00, 0x00, 0x33, 0x10, 0x07, 0x00, 0x19, 0x12, 0x10, 0x00, 0x1C, 
  0x12, 0x06, 0x00, 0x2A, 0x10, 0x11, 0x00, 0x30, 0x10, 0x12, 0x00, 0x2A, 0x14, 0x12, 0x00, 0x33, 
  0x10, 0x14, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x2A, 0x10, 0x13, 0x00, 0x2F, 0x10, 0x00, 0x00, 0x33, 
  0x10, 0x03, 0x00, 0x2A, 0x12, 0x14, 0x00, 0x30, 0x12, 0x10, 0x00, 0x2A, 0x14, 0x12, 0x00, 0x33, 
  0x12, 0x14, 0x00, 0x2A, 0x10, 0x15, 0x00, 0x29, 0x14, 0x14, 0x00, 0x30, 0x10, 0x14, 0x00, 0x2A, 
  0x14, 0x16, 0x00, 0x33, 0x10, 0x14, 0x00, 0x19, 0x14, 0x10, 0x00, 0x29, 0x15, 0x00, 0x00, 0x3D, 
  0x16, 0x09, 0x00, 0x19, 0x17, 0x16, 0x00, 0x21, 0x16, 0x15, 0x17, 0x1C, 0x16, 0x46, 0x00, 0x19, 
  0x18, 0x15, 0x00, 0x2F, 0x18, 0x00, 0x00, 0x33, 0x19, 0x09, 0x00, 0x19, 0x1A, 0x19, 0x00, 0x2F, 
  0x1A, 0x00, 0x00, 0x2A, 0x1C, 0x17, 0x00, 0x33, 0x1B, 0x1C, 0x00, 0x2A, 0x1D, 0x18, 0x00, 0x23, 
  0x1C, 0x1B, 0x1D, 0x1C, 0x1C, 0x03, 0x00, 0x2A, 0x19, 0x19, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x2A, 
  0x19, 0x15, 0x00, 0x2F, 0x19, 0x00, 0x00, 0x2A, 0x1C, 0x1A, 0x00, 0x33, 0x1B, 0x1C, 0x00, 0x23, 
  0x1B, 0x18, 0x0B, 0x1C, 0x1B, 0x03, 0x00, 0x2A, 0x19, 0x1B, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x2A, 
  0x19, 0x1C, 0x00, 0x2F, 0x19, 0x00, 0x00, 0x2A, 0x1C, 0x1A, 0x00, 0x33, 0x1B, 0x1C, 0x00, 0x2A, 
  0x19, 0x1D, 0x00, 0x30, 0x19, 0x1A, 0x00, 0x2A, 0x1B, 0x1E, 0x00, 0x33, 0x19, 0x1B, 0x00, 0x2A, 
  0x1B, 0x15, 0x00, 0x30, 0x19, 0x1B, 0x00, 0x2A, 0x1C, 0x1F, 0x00, 0x33, 0x1B, 0x1C, 0x00, 0x30, 
  0x1B, 0x14, 0x00, 0x2A, 0x1C, 0x1D, 0x00, 0x33, 0x19, 0x1C, 0x00, 0x2A, 0x1B, 0x20, 0x00, 0x30, 
  0x1B, 0x19, 0x00, 0x2A, 0x1C, 0x21, 0x00, 0x33, 0x1B, 0x1C, 0x00, 0x1C, 0x0D, 0x19, 0x00, 0x2F, 
  0x18, 0x00, 0x00, 0x33, 0x19, 0x0D, 0x00, 0x3B, 0x1B, 0x19, 0x00, 0x19, 0x1C, 0x1B, 0x00, 0x3B, 
  0x1B, 0x19, 0x01, 0x19, 0x1D, 0x1B, 0x00, 0x30, 0x1C, 0x1D, 0x00, 0x43, 0x19, 0x00, 0x00, 0x19, 
  0x1B, 0x19, 0x00, 0x23, 0x19, 0x1B, 0x0F, 0x1B, 0x19, 0x03, 0x00, 0x27, 0x19, 0x00, 0x00, 0x1A, 
  0x02, 0x00, 0x00, 0x28, 0x19, 0x00, 0x00, 0x1C, 0x19, 0x09, 0x00, 0x19, 0x0F, 0x1B, 0x00, 0x2A, 
  0x1E, 0x22, 0x00, 0x2A, 0x1F, 0x23, 0x00, 0x31, 0x1E, 0x1C, 0x1F, 0x2F, 0x1D, 0x00, 0x00, 0x2A, 
  0x1F, 0x1A, 0x00, 0x33, 0x1E, 0x1F, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x2A, 
  0x1B, 0x08, 0x00, 0x33, 0x19, 0x1B, 0x00, 0x29, 0x19, 0x01, 0x00, 0x06, 0x15, 0x15, 0x19, 0x1A, 
  0xBA, 0xFF, 0xFF, 0x2A, 0x15, 0x08, 0x00, 0x34, 0x15, 0x00, 0x00, 0x89, 0xA7, 0x01, 0x03, 0x0E, 
  0x00, 0x0E, 0x00, 0x0E, 0x00, 0x03, 0x01, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x03, 0x01, 0x0D, 
  0x00, 0x0D, 0x00, 0x0D, 0x00, 0x03, 0x01, 0x11, 0x00, 0x11, 0x00, 0x03, 0x01, 0x0B, 0x00, 0x0B, 
  0x00, 0x0B, 0x00, 0x03, 0x01, 0x12, 0x00, 0x12, 0x00, 0x03, 0x01, 0x11, 0x00, 0x11, 0x00, 0x11, 
  0x00, 0x11, 0x00, 0x03, 0x01, 0x19, 0x00, 0x19, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x01, 0x1B, 0x00, 0x1B, 0x00, 0x1B, 0x00, 0x2D, 0x00, 0x2D, 0x00, 0x2D, 0x00, 0x2D, 0x00, 0x2D, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x18, 
  0x00, 0x18, 0x00, 0x18, 0x00, 0x03, 0x00, 0x03, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0xBF, 0xFF, 0x03, 0x02, 0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x01, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x03, 0x01, 0x03, 0x00, 
  0x16, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x16, 0x00, 0x16, 0xBF, 0xFF, 0x03, 
  0x02, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 
  0x00, 0x0B, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x0F, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 
  0x00, 0x0B, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x29, 0x00, 0x29, 0x00, 0x29, 0x00, 0x29, 
  0x00, 0x1C, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x05, 0x01, 0x15, 0x00, 0x15, 0x00, 0x07, 0x00, 0x07, 
  0x00, 0x07, 0x00, 0x07, 0x01, 0x11, 0x00, 0x11, 0xBF, 0xFF, 0x07, 0x02, 0x0F, 0x00, 0x0F, 0x00, 
  0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x09, 0x01, 0x0B, 0x01, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 
  0x0B, 0x00, 0x0B, 0x00, 0x0B, 0xBF, 0xFE, 0x09, 0xBF, 0xFD, 0x05, 0x06, 0x05, 0x00, 0x05, 0xBF, 
  0xF5, 0x03, 0x00, 0x03, 0x00, 0x03, 0x0C, 0x03, 0x00, 0x03, 0xDA, 0x09, 0xCE, 0x44, 0x28, 0x2E, 
  0x70, 0x70, 0x61, 0x73, 0x6D, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x6E, 0x29, 0x0A, 0x0A, 0x50, 
  0x72, 0x65, 0x74, 0x74, 0x79, 0x20, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x73, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x61, 0x73, 0x73, 0x65, 0x6D, 0x62, 0x6C, 0x79, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 
  0x6F, 0x6E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x89, 0xA7, 0x01, 0xCF, 0x06, 0x2E, 0x73, 
  0x74, 0x61, 0x63, 0x6B, 0xD3, 0x03, 0xDA, 0x03, 0xD7, 0xCD, 0x00, 0xB8, 0x00, 0x00, 0x05, 0x00, 
  0x00, 0x00, 0x03, 0x0C, 0x01, 0xCE, 0x06, 0x2E, 0x73, 0x74, 0x61, 0x63, 0x6B, 0xDA, 0x05, 0xDA, 
  0x83, 0x95, 0xD0, 0x01, 0x70, 0xDA, 0x24, 0x2C, 0x00, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x33, 
  0x01, 0x02, 0x00, 0x2E, 0x02, 0x00, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x30, 0x02, 0x03, 0x00, 0x2A, 
  0x04, 0x02, 0x00, 0x33, 0x03, 0x04, 0x00, 0x26, 0x04, 0x00, 0x00, 0x35, 0x02, 0x03, 0x04, 0x2A, 
  0x03, 0x00, 0x00, 0x34, 0x03, 0x00, 0x00, 0xCD, 0x00, 0x90, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
  0x05, 0x0C, 0xDA, 0x05, 0xDA, 0x7C, 0xDA, 0x82, 0x26, 0xDA, 0x83, 0xA7, 0xDA, 0x83, 0xBC, 0xDA, 
  0x7F, 0x2A, 0x00, 0x00, 0x00, 0x28, 0x01, 0x00, 0x00, 0x30, 0x00, 0x01, 0x00, 0x2A, 0x01, 0x01, 
  0x00, 0x33, 0x00, 0x01, 0x00, 0x2A, 0x02, 0x02, 0x00, 0x33, 0x01, 0x02, 0x00, 0x2A, 0x03, 0x03, 
  0x00, 0x33, 0x02, 0x03, 0x00, 0x30, 0x01, 0x02, 0x00, 0x2A, 0x03, 0x04, 0x00, 0x34, 0x03, 0x00, 
  0x00, 0x89, 0x80, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x33, 0x00, 0x33, 
  0x00, 0x3C, 0x00, 0x3C, 0x00, 0x21, 0x00, 0x21, 0x00, 0x21, 0x89, 0x7C, 0x01, 0x03, 0x03, 0x00, 
  0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 
  0x03, 0x00, 0x03, 0xDA, 0x09, 0xCE, 0x27, 0x28, 0x2E, 0x73, 0x74, 0x61, 0x63, 0x6B, 0x29, 0x0A, 
  0x0A, 0x50, 0x72, 0x69, 0x6E, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 
  0x6E, 0x74, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x73, 0x74, 0x61, 0x63, 0x6B, 0xDA, 0x0B, 
  0xD2, 0x03, 0x00, 0xDA, 0x05, 0x89, 0x7C, 0x01, 0xCF, 0x06, 0x2E, 0x66, 0x69, 0x62, 0x65, 0x72, 
  0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x83, 0xA7, 0xDA, 0x09, 0xCE, 0x2F, 0x28, 0x2E, 0x66, 0x69, 0x62, 
  0x65, 0x72, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 
  0x72, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x62, 0x65, 0x69, 0x6E, 0x67, 
  0x20, 0x64, 0x65, 0x62, 0x75, 0x67, 0x67, 0x65, 0x64, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 
  0x05, 0x89, 0x72, 0x01, 0xCF, 0x09, 0x2E, 0x62, 0x79, 0x74, 0x65, 0x63, 0x6F, 0x64, 0x65, 0xD3, 
  0x03, 0xDA, 0x03, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x04, 0x01, 0x00, 0x01, 0x02, 0x07, 0xCE, 
  0x09, 0x2E, 0x62, 0x79, 0x74, 0x65, 0x63, 0x6F, 0x64, 0x65, 0xDA, 0x05, 0xDA, 0x83, 0xB2, 0xDA, 
  0x83, 0xB8, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 
  0x03, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x34, 0x02, 0x00, 0x00, 0x89, 0xA2, 
  0x01, 0x03, 0x04, 0x00, 0x04, 0x00, 0x04, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xDA, 0x09, 0xCE, 
  0x3E, 0x28, 0x2E, 0x62, 0x79, 0x74, 0x65, 0x63, 0x6F, 0x64, 0x65, 0x20, 0x26, 0x6F, 0x70, 0x74, 
  0x20, 0x6E, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x79, 0x74, 
  0x65, 0x63, 0x6F, 0x64, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 
  0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0xDA, 
  0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x89, 0xA2, 0x01, 0xCF, 0x07, 0x2E, 0x73, 0x69, 0x67, 0x6E, 
  0x61, 0x6C, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x83, 0xBC, 0xDA, 0x09, 0xCE, 0x31, 0x28, 0x2E, 0x73, 
  0x69, 0x67, 0x6E, 0x61, 0x6C, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0x20, 0x62, 
  0x65, 0x69, 0x6E, 0x67, 0x20, 0x64, 0x65, 0x62, 0x75, 0x67, 0x67, 0x65, 0x64, 0x2E, 0xDA, 0x0B, 
  0xD2, 0x03, 0x00, 0xDA, 0x05, 0x89, 0x77, 0x01, 0xCF, 0x06, 0x2E, 0x66, 0x72, 0x61, 0x6D, 0x65, 
  0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x83, 0xB1, 0xDA, 0x09, 0xCE, 0x23, 0x28, 0x2E, 0x66, 0x72, 0x61, 
  0x6D, 0x65, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x6E, 0x29, 0x0A, 0x0A, 0x53, 0x68, 0x6F, 0x77, 
  0x20, 0x61, 0x20, 0x73, 0x74, 0x61, 0x63, 0x6B, 0x20, 0x66, 0x72, 0x61, 0x6D, 0x65, 0xDA, 0x0B, 
  0xD2, 0x03, 0x00, 0xDA, 0x05, 0x89, 0x83, 0x01, 0xCF, 0x05, 0x2E, 0x6E, 0x65, 0x78, 0x74, 0xD3, 
  0x03, 0xDA, 0x03, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x09, 0x01, 0x00, 0x01, 0x01, 0x13, 0xCE, 
  0x05, 0x2E, 0x6E, 0x65, 0x78, 0x74, 0xDA, 0x05, 0xDA, 0x83, 0xA7, 0x2C, 0x01, 0x00, 0x00, 0x26, 
  0x02, 0x00, 0x00, 0x29, 0x03, 0x00, 0x00, 0x1C, 0x00, 0x03, 0x00, 0x19, 0x04, 0x00, 0x00, 0x1A, 
  0x02, 0x00, 0x00, 0x29, 0x04, 0x01, 0x00, 0x19, 0x05, 0x04, 0x00, 0x21, 0x04, 0x03, 0x05, 0x1C, 
  0x04, 0x09, 0x00, 0x19, 0x06, 0x03, 0x00, 0x2A, 0x08, 0x00, 0x00, 0x33, 0x07, 0x08, 0x00, 0x26, 
  0x08, 0x00, 0x00, 0x35, 0x02, 0x07, 0x08, 0x29, 0x07, 0x01, 0x00, 0x06, 0x03, 0x03, 0x07, 0x1A, 
  0xF7, 0xFF, 0xFF, 0x03, 0x02, 0x00, 0x00, 0x89, 0xF9, 0x01, 0x03, 0x03, 0x01, 0x03, 0x00, 0x0C, 
  0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x16, 
  0x00, 0x16, 0x00, 0x0E, 0x00, 0x0E, 0xBF, 0xFF, 0x03, 0x00, 0x03, 0x00, 0x03, 0xBF, 0xFC, 0x01, 
  0xDA, 0x09, 0xCE, 0x2A, 0x28, 0x2E, 0x6E, 0x65, 0x78, 0x74, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 
  0x6E, 0x29, 0x0A, 0x0A, 0x47, 0x6F, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 
  0x78, 0x74, 0x20, 0x62, 0x72, 0x65, 0x61, 0x6B, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x2E, 0xDA, 0x0B, 
  0xD2, 0x03, 0x00, 0xDA, 0x05, 0x89, 0xF9, 0x01, 0xCF, 0x06, 0x2E, 0x63, 0x6C, 0x65, 0x61, 0x72, 
  0xD3, 0x03, 0xDA, 0x03, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x07, 0x15, 
  0xCE, 0x06, 0x2E, 0x63, 0x6C, 0x65, 0x61, 0x72, 0xDA, 0x05, 0xDA, 0x83, 0xB1, 0xDA, 0x78, 0xDA, 
  0x83, 0xB9, 0xDA, 0x81, 0xEF, 0xCE, 0x16, 0x43, 0x6C, 0x65, 0x61, 0x72, 0x65, 0x64, 0x20, 0x62, 
  0x72, 0x65, 0x61, 0x6B, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x20, 0x69, 0x6E, 0x20, 0xCE, 0x07, 0x20, 
  0x61, 0x74, 0x20, 0x70, 0x63, 0x3D, 0xDA, 0x83, 0x95, 0x2C, 0x00, 0x00, 0x00, 0x2A, 0x02, 0x00, 
  0x00, 0x33, 0x01, 0x02, 0x00, 0x19, 0x02, 0x01, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x2F, 0x03, 0x00, 
  0x00, 0x33, 0x03, 0x02, 0x00, 0x19, 0x04, 0x03, 0x00, 0x2A, 0x05, 0x02, 0x00, 0x2F, 0x05, 0x00, 
  0x00, 0x33, 0x05, 0x02, 0x00, 0x19, 0x06, 0x05, 0x00, 0x30, 0x04, 0x06, 0x00, 0x2A, 0x08, 0x03, 
  0x00, 0x33, 0x07, 0x08, 0x00, 0x2A, 0x08, 0x04, 0x00, 0x2A, 0x09, 0x05, 0x00, 0x31, 0x08, 0x04, 
  0x09, 0x2F, 0x06, 0x00, 0x00, 0x2A, 0x08, 0x06, 0x00, 0x34, 0x08, 0x00, 0x00, 0x89, 0xF0, 0x01, 
  0x03, 0x0E, 0x00, 0x0E, 0x00, 0x03, 0x01, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x03, 0x01, 0x0B, 
  0x00, 0x0B, 0x00, 0x0B, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xDA, 0x09, 0xCE, 0x26, 0x28, 0x2E, 0x63, 0x6C, 
  0x65, 0x61, 0x72, 0x29, 0x0A, 0x0A, 0x43, 0x6C, 0x65, 0x61, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x62, 0x72, 0x65, 0x61, 0x6B, 0x70, 0x6F, 0x69, 
  0x6E, 0x74, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x89, 0xF0, 0x01, 0xCF, 0x09, 0x2E, 0x62, 
  0x72, 0x65, 0x61, 0x6B, 0x61, 0x6C, 0x6C, 0xD3, 0x03, 0xDA, 0x03, 0xD7, 0xCD, 0x00, 0x98, 0x00, 
  0x00, 0x0C, 0x01, 0x00, 0x01, 0x06, 0x1C, 0xCE, 0x09, 0x2E, 0x62, 0x72, 0x65, 0x61, 0x6B, 0x61, 
  0x6C, 0x6C, 0xDA, 0x05, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x01, 0x00, 0x01, 0x02, 0x07, 
  0xCE, 0x03, 0x2E, 0x66, 0x6E, 0xDA, 0x05, 0xDA, 0x83, 0xB1, 0xDA, 0x78, 0x2C, 0x01, 0x00, 0x00, 
  0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2A, 0x04, 0x01, 0x00, 
  0x38, 0x03, 0x02, 0x04, 0x03, 0x03, 0x00, 0x00, 0x89, 0x89, 0x01, 0x03, 0x07, 0x00, 0x07, 0x00, 
  0x07, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xDA, 0x83, 0xDC, 0xD8, 0x0C, 0x64, 0x65, 0x62, 0x75, 
  0x67, 0x2F, 0x66, 0x62, 0x72, 0x65, 0x61, 0x6B, 0xCE, 0x04, 0x53, 0x65, 0x74, 0x20, 0xCE, 0x10, 
  0x20, 0x62, 0x72, 0x65, 0x61, 0x6B, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x73, 0x20, 0x69, 0x6E, 0x20, 
  0xDA, 0x83, 0x95, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 
  0x02, 0x03, 0x00, 0x19, 0x03, 0x02, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x33, 
  0x04, 0x05, 0x00, 0x19, 0x05, 0x04, 0x00, 0x29, 0x06, 0x00, 0x00, 0x3D, 0x07, 0x05, 0x00, 0x19, 
  0x08, 0x07, 0x00, 0x21, 0x07, 0x06, 0x08, 0x1C, 0x07, 0x08, 0x00, 0x19, 0x09, 0x06, 0x00, 0x30, 
  0x03, 0x09, 0x00, 0x2A, 0x0B, 0x02, 0x00, 0x33, 0x0A, 0x0B, 0x00, 0x29, 0x0A, 0x01, 0x00, 0x06, 
  0x06, 0x06, 0x0A, 0x1A, 0xF8, 0xFF, 0xFF, 0x3D, 0x06, 0x05, 0x00, 0x2A, 0x07, 0x03, 0x00, 0x2A, 
  0x08, 0x04, 0x00, 0x31, 0x07, 0x06, 0x08, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x07, 0x05, 0x00, 0x34, 
  0x07, 0x00, 0x00, 0x89, 0xC5, 0x01, 0x03, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x03, 0x01, 0x11, 
  0x00, 0x11, 0x00, 0x11, 0x00, 0x03, 0x01, 0x03, 0x00, 0x0C, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0xBF, 0xFF, 0x03, 0x00, 0x03, 0x00, 0x03, 0x02, 
  0x11, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xDA, 0x09, 0xCE, 
  0x50, 0x28, 0x2E, 0x62, 0x72, 0x65, 0x61, 0x6B, 0x61, 0x6C, 0x6C, 0x20, 0x26, 0x6F, 0x70, 0x74, 
  0x20, 0x6E, 0x29, 0x0A, 0x0A, 0x53, 0x65, 0x74, 0x20, 0x62, 0x72, 0x65, 0x61, 0x6B, 0x70, 0x6F, 
  0x69, 0x6E, 0x74, 0x73, 0x20, 0x6F, 0x6E, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x69, 0x6E, 0x73, 0x74, 
  0x72, 0x75, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 
  0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x89, 0xC5, 0x01, 0xCF, 0x06, 0x2E, 0x62, 0x72, 
  0x65, 0x61, 0x6B, 0xD3, 0x03, 0xDA, 0x03, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0A, 0x00, 0x00, 
  0x00, 0x07, 0x15, 0xCE, 0x06, 0x2E, 0x62, 0x72, 0x65, 0x61, 0x6B, 0xDA, 0x05, 0xDA, 0x83, 0xB1, 
  0xDA, 0x78, 0xDA, 0x83, 0xB9, 0xDA, 0x83, 0xFA, 0xCE, 0x12, 0x53, 0x65, 0x74, 0x20, 0x62, 0x72, 
  0x65, 0x61, 0x6B, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x20, 0x69, 0x6E, 0x20, 0xDA, 0x83, 0xF1, 0xDA, 
  0x83, 0x95, 0x2C, 0x00, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x33, 0x01, 0x02, 0x00, 0x19, 0x02, 
  0x01, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x33, 0x03, 0x02, 0x00, 0x19, 0x04, 
  0x03, 0x00, 0x2A, 0x05, 0x02, 0x00, 0x2F, 0x05, 0x00, 0x00, 0x33, 0x05, 0x02, 0x00, 0x19, 0x06, 
  0x05, 0x00, 0x30, 0x04, 0x06, 0x00, 0x2A, 0x08, 0x03, 0x00, 0x33, 0x07, 0x08, 0x00, 0x2A, 0x08, 
  0x04, 0x00, 0x2A, 0x09, 0x05, 0x00, 0x31, 0x08, 0x04, 0x09, 0x2F, 0x06, 0x00, 0x00, 0x2A, 0x08, 
  0x06, 0x00, 0x34, 0x08, 0x00, 0x00, 0x89, 0xE7, 0x01, 0x03, 0x0E, 0x00, 0x0E, 0x00, 0x03, 0x01, 
  0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x03, 0x01, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x03, 0x01, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0xDA, 0x09, 0xCE, 0x2B, 0x28, 0x2E, 0x62, 0x72, 0x65, 0x61, 0x6B, 0x29, 0x0A, 0x0A, 0x53, 
  0x65, 0x74, 0x20, 0x62, 0x72, 0x65, 0x61, 0x6B, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x20, 0x61, 0x74, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x70, 0x63, 0x2E, 
  0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x89, 0xE7, 0x01, 0xCF, 0x05, 0x2E, 0x73, 0x6C, 0x6F, 
  0x74, 0xD3, 0x03, 0xDA, 0x03, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x06, 0x02, 0x00, 0x02, 0x01, 
  0x0A, 0xCE, 0x05, 0x2E, 0x73, 0x6C, 0x6F, 0x74, 0xDA, 0x05, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 
  0x05, 0x01, 0x00, 0x01, 0x02, 0x07, 0xCE, 0x06, 0x2E, 0x73, 0x6C, 0x6F, 0x74, 0x73, 0xDA, 0x05, 
  0xDA, 0x83, 0xB1, 0xDA, 0x83, 0xC4, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 
  0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x38, 0x03, 0x02, 0x04, 0x03, 0x03, 
  0x00, 0x00, 0x89, 0x8E, 0x01, 0x03, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x2C, 0x02, 0x00, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 
  0x00, 0x1C, 0x00, 0x03, 0x00, 0x19, 0x04, 0x00, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x29, 0x04, 0x00, 
  0x00, 0x38, 0x05, 0x03, 0x04, 0x03, 0x05, 0x00, 0x00, 0x89, 0x93, 0x01, 0x03, 0x07, 0x00, 0x07, 
  0x00, 0x07, 0x00, 0x1A, 0x00, 0x1A, 0x00, 0x1A, 0x00, 0x1A, 0x00, 0x03, 0x00, 0x03, 0xDA, 0x09, 
  0xCE, 0x3A, 0x28, 0x2E, 0x73, 0x6C, 0x6F, 0x74, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x6E, 0x74, 
  0x68, 0x20, 0x66, 0x72, 0x61, 0x6D, 0x65, 0x2D, 0x69, 0x64, 0x78, 0x29, 0x0A, 0x0A, 0x47, 0x65, 
  0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x6E, 0x74, 0x68, 0x20, 0x73, 0x6C, 0x6F, 0x74, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 
  0x00, 0xDA, 0x05, 0x89, 0x93, 0x01, 0xCF, 0x06, 0x2E, 0x6E, 0x65, 0x78, 0x74, 0x63, 0xD3, 0x03, 
  0xDA, 0x03, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x04, 0x01, 0x00, 0x01, 0x02, 0x06, 0xCE, 0x06, 
  0x2E, 0x6E, 0x65, 0x78, 0x74, 0x63, 0xDA, 0x05, 0xDA, 0x83, 0xF2, 0xDA, 0x83, 0xEA, 0x2C, 0x01, 
  0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 
  0x01, 0x00, 0x34, 0x03, 0x00, 0x00, 0x8A, 0x01, 0x01, 0x03, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0xDA, 0x09, 0xCE, 0x4C, 0x28, 0x2E, 0x6E, 0x65, 0x78, 0x74, 0x63, 0x20, 0x26, 
  0x6F, 0x70, 0x74, 0x20, 0x6E, 0x29, 0x0A, 0x0A, 0x47, 0x6F, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x6E, 0x65, 0x78, 0x74, 0x20, 0x62, 0x72, 0x65, 0x61, 0x6B, 0x70, 0x6F, 0x69, 0x6E, 
  0x74, 0x2C, 0x20, 0x63, 0x6C, 0x65, 0x61, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x62, 0x72, 0x65, 0x61, 0x6B, 0x70, 0x6F, 0x69, 
  0x6E, 0x74, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x8A, 0x01, 0x01, 0xCF, 0x06, 0x2E, 
  0x73, 0x6C, 0x6F, 0x74, 0x73, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x84, 0x0B, 0xDA, 0x09, 0xCE, 0x37, 
  0x28, 0x2E, 0x73, 0x6C, 0x6F, 0x74, 0x73, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x6E, 0x29, 0x0A, 
  0x0A, 0x47, 0x65, 0x74, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x6F, 0x66, 
  0x20, 0x73, 0x6C, 0x6F, 0x74, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x73, 0x74, 0x61, 0x63, 
  0x6B, 0x20, 0x66, 0x72, 0x61, 0x6D, 0x65, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x89, 0x8E, 
  0x01, 0xCF, 0x09, 0x2E, 0x63, 0x6C, 0x65, 0x61, 0x72, 0x61, 0x6C, 0x6C, 0xD3, 0x03, 0xDA, 0x03, 
  0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0C, 0x01, 0x00, 0x01, 0x06, 0x1C, 0xCE, 0x09, 0x2E, 0x63, 
  0x6C, 0x65, 0x61, 0x72, 0x61, 0x6C, 0x6C, 0xDA, 0x05, 0xDA, 0x83, 0xF9, 0xDA, 0x83, 0xDC, 0xDA, 
  0x81, 0xEF, 0xCE, 0x08, 0x43, 0x6C, 0x65, 0x61, 0x72, 0x65, 0x64, 0x20, 0xDA, 0x83, 0xFC, 0xDA, 
  0x83, 0x95, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 
  0x03, 0x00, 0x19, 0x03, 0x02, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x33, 0x04, 
  0x05, 0x00, 0x19, 0x05, 0x04, 0x00, 0x29, 0x06, 0x00, 0x00, 0x3D, 0x07, 0x05, 0x00, 0x19, 0x08, 
  0x07, 0x00, 0x21, 0x07, 0x06, 0x08, 0x1C, 0x07, 0x08, 0x00, 0x19, 0x09, 0x06, 0x00, 0x30, 0x03, 
  0x09, 0x00, 0x2A, 0x0B, 0x02, 0x00, 0x33, 0x0A, 0x0B, 0x00, 0x29, 0x0A, 0x01, 0x00, 0x06, 0x06, 
  0x06, 0x0A, 0x1A, 0xF8, 0xFF, 0xFF, 0x3D, 0x06, 0x05, 0x00, 0x2A, 0x07, 0x03, 0x00, 0x2A, 0x08, 
  0x04, 0x00, 0x31, 0x07, 0x06, 0x08, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x07, 0x05, 0x00, 0x34, 0x07, 
  0x00, 0x00, 0x89, 0xCE, 0x01, 0x03, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x03, 0x01, 0x11, 0x00, 
  0x11, 0x00, 0x11, 0x00, 0x03, 0x01, 0x03, 0x00, 0x0C, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0xBF, 0xFF, 0x03, 0x00, 0x03, 0x00, 0x03, 0x02, 0x15, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xDA, 0x09, 0xCE, 0x42, 
  0x28, 0x2E, 0x63, 0x6C, 0x65, 0x61, 0x72, 0x61, 0x6C, 0x6C, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 
  0x6E, 0x29, 0x0A, 0x0A, 0x43, 0x6C, 0x65, 0x61, 0x72, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x62, 0x72, 
  0x65, 0x61, 0x6B, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x73, 0x20, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 
  0x6E, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x89, 0xCE, 0x01, 0xCF, 0x03, 0x2E, 0x66, 
  0x6E, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x83, 0xF9, 0xDA, 0x09, 0xCE, 0x26, 0x28, 0x2E, 0x66, 0x6E, 
  0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x6E, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 
  0x6F, 0x6E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x89, 0x89, 0x01, 0xCF, 0x07, 0x2E, 0x73, 
  0x6F, 0x75, 0x72, 0x63, 0x65, 0xD3, 0x03, 0xDA, 0x03, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0A, 
  0x01, 0x00, 0x01, 0x05, 0x12, 0xCE, 0x07, 0x2E, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0xDA, 0x05, 
  0xDA, 0x83, 0xB1, 0xDA, 0x80, 0x9A, 0xDA, 0x81, 0x15, 0xCE, 0x01, 0x0A, 0xDA, 0x83, 0x95, 0x2C, 
  0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x19, 
  0x03, 0x02, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x2F, 0x04, 0x00, 0x00, 0x33, 0x04, 0x03, 0x00, 0x19, 
  0x05, 0x04, 0x00, 0x2F, 0x05, 0x00, 0x00, 0x2A, 0x07, 0x02, 0x00, 0x33, 0x06, 0x07, 0x00, 0x19, 
  0x07, 0x06, 0x00, 0x2A, 0x08, 0x03, 0x00, 0x2A, 0x09, 0x03, 0x00, 0x31, 0x08, 0x07, 0x09, 0x2A, 
  0x08, 0x04, 0x00, 0x34, 0x08, 0x00, 0x00, 0x89, 0xDF, 0x01, 0x03, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 
  0x00, 0x03, 0x01, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x13, 0x00, 0x13, 0x00, 0x13, 
  0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xDA, 0x09, 0xCE, 0x47, 
  0x28, 0x2E, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x6E, 0x29, 
  0x0A, 0x0A, 0x53, 0x68, 0x6F, 0x77, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x6F, 0x75, 0x72, 0x63, 
  0x65, 0x20, 0x63, 0x6F, 0x64, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 
  0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x62, 0x65, 0x69, 0x6E, 0x67, 0x20, 0x64, 0x65, 
  0x62, 0x75, 0x67, 0x67, 0x65, 0x64, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x89, 0xDF, 
  0x01, 0xD7, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x08, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 
  0x13, 0xCE, 0x0A, 0x6D, 0x65, 0x72, 0x67, 0x65, 0x2D, 0x69, 0x6E, 0x74, 0x6F, 0xDA, 0x05, 0x2C, 
  0x02, 0x00, 0x00, 0x26, 0x04, 0x00, 0x00, 0x47, 0x03, 0x01, 0x04, 0x19, 0x04, 0x03, 0x00, 0x1D, 
  0x04, 0x0E, 0x00, 0x38, 0x03, 0x01, 0x04, 0x19, 0x05, 0x03, 0x00, 0x26, 0x06, 0x00, 0x00, 0x47, 
  0x03, 0x05, 0x06, 0x19, 0x06, 0x03, 0x00, 0x1D, 0x06, 0x06, 0x00, 0x19, 0x03, 0x06, 0x00, 0x38, 
  0x07, 0x05, 0x03, 0x3A, 0x00, 0x03, 0x07, 0x47, 0x06, 0x05, 0x06, 0x1A, 0xFB, 0xFF, 0xFF, 0x47, 
  0x04, 0x01, 0x04, 0x1A, 0xF3, 0xFF, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x85, 0x05, 0x01, 0x05, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x02, 0x14, 0x00, 0x05, 0xBF, 0xFE, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0xBF, 0xFB, 0x01, 0xDA, 0x7F, 0xDA, 0x80, 0x84, 0xCE, 0x0F, 0x65, 0x6E, 0x74, 0x65, 0x72, 
  0x69, 0x6E, 0x67, 0x20, 0x64, 0x65, 0x62, 0x75, 0x67, 0x5B, 0xCE, 0x12, 0x5D, 0x20, 0x2D, 0x20, 
  0x28, 0x71, 0x75, 0x69, 0x74, 0x29, 0x20, 0x74, 0x6F, 0x20, 0x65, 0x78, 0x69, 0x74, 0xDA, 0x83, 
  0x95, 0xDA, 0x83, 0x96, 0xCE, 0x0E, 0x65, 0x78, 0x69, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x64, 0x65, 
  0x62, 0x75, 0x67, 0x5B, 0xDA, 0x83, 0xC1, 0xD0, 0x0C, 0x72, 0x65, 0x73, 0x75, 0x6D, 0x65, 0x2D, 
  0x76, 0x61, 0x6C, 0x75, 0x65, 0x2C, 0x02, 0x00, 0x00, 0x2B, 0x03, 0x00, 0x05, 0x2F, 0x03, 0x00, 
  0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x04, 0x03, 0x00, 0x2A, 0x05, 0x01, 
  0x00, 0x3A, 0x04, 0x05, 0x00, 0x2A, 0x05, 0x02, 0x00, 0x2B, 0x06, 0x01, 0x01, 0x3A, 0x04, 0x05, 
  0x06, 0x2A, 0x05, 0x03, 0x00, 0x3A, 0x04, 0x05, 0x01, 0x2A, 0x05, 0x04, 0x00, 0x30, 0x04, 0x05, 
  0x00, 0x2A, 0x06, 0x05, 0x00, 0x33, 0x05, 0x06, 0x00, 0x30, 0x00, 0x01, 0x00, 0x2A, 0x07, 0x06, 
  0x00, 0x33, 0x06, 0x07, 0x00, 0x2A, 0x08, 0x07, 0x00, 0x33, 0x07, 0x08, 0x00, 0x2E, 0x08, 0x00, 
  0x00, 0x19, 0x09, 0x08, 0x00, 0x2A, 0x0A, 0x08, 0x00, 0x2B, 0x0B, 0x01, 0x01, 0x2A, 0x0C, 0x09, 
  0x00, 0x31, 0x0A, 0x0B, 0x0C, 0x2A, 0x0B, 0x0A, 0x00, 0x33, 0x0A, 0x0B, 0x00, 0x2A, 0x0C, 0x0B, 
  0x00, 0x33, 0x0B, 0x0C, 0x00, 0x29, 0x0D, 0x01, 0x00, 0x2B, 0x0E, 0x01, 0x01, 0x06, 0x0C, 0x0D, 
  0x0E, 0x30, 0x04, 0x0C, 0x00, 0x2B, 0x0E, 0x01, 0x02, 0x33, 0x0D, 0x0E, 0x00, 0x31, 0x09, 0x0D, 
  0x04, 0x2B, 0x0E, 0x00, 0x03, 0x33, 0x0C, 0x0E, 0x00, 0x2A, 0x0D, 0x0C, 0x00, 0x2B, 0x0E, 0x01, 
  0x01, 0x2A, 0x0F, 0x0D, 0x00, 0x31, 0x0D, 0x0E, 0x0F, 0x2A, 0x0E, 0x0A, 0x00, 0x33, 0x0D, 0x0E, 
  0x00, 0x2A, 0x0F, 0x0B, 0x00, 0x33, 0x0E, 0x0F, 0x00, 0x2A, 0x0F, 0x0E, 0x00, 0x2F, 0x0F, 0x00, 
  0x00, 0x34, 0x04, 0x00, 0x00, 0x00, 0xBF, 0xFF, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x0A, 0x02, 0x02, 
  0x02, 0x09, 0x1C, 0x02, 0xCE, 0x0F, 0x64, 0x65, 0x62, 0x75, 0x67, 0x67, 0x65, 0x72, 0x2D, 0x63, 
  0x68, 0x75, 0x6E, 0x6B, 0x73, 0xDA, 0x05, 0xDA, 0x83, 0x9B, 0xDA, 0x82, 0xE0, 0xDA, 0x80, 0xE6, 
  0xCE, 0x06, 0x64, 0x65, 0x62, 0x75, 0x67, 0x5B, 0xCE, 0x02, 0x5D, 0x3A, 0xDA, 0x83, 0x28, 0xDA, 
  0x83, 0x9D, 0xDA, 0x6F, 0xDA, 0x80, 0xFB, 0x2C, 0x02, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x30, 
  0x01, 0x03, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x04, 0x03, 0x00, 0x2F, 
  0x01, 0x00, 0x00, 0x2A, 0x06, 0x02, 0x00, 0x33, 0x05, 0x06, 0x00, 0x29, 0x06, 0x00, 0x00, 0x2F, 
  0x06, 0x00, 0x00, 0x33, 0x06, 0x05, 0x00, 0x19, 0x05, 0x06, 0x00, 0x2A, 0x07, 0x03, 0x00, 0x2B, 
  0x08, 0x00, 0x01, 0x2A, 0x09, 0x04, 0x00, 0x31, 0x07, 0x08, 0x09, 0x2A, 0x07, 0x05, 0x00, 0x31, 
  0x05, 0x07, 0x04, 0x2A, 0x07, 0x06, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x2A, 0x08, 0x07, 0x00, 0x33, 
  0x07, 0x08, 0x00, 0x19, 0x08, 0x07, 0x00, 0x2B, 0x09, 0x01, 0x04, 0x31, 0x08, 0x00, 0x09, 0x2A, 
  0x09, 0x08, 0x00, 0x34, 0x09, 0x00, 0x00, 0x01, 0xBF, 0xFF, 0x8A, 0x3A, 0x07, 0x01, 0x15, 0x00, 
  0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x09, 0x01, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x10, 0x00, 
  0x10, 0x00, 0x10, 0x00, 0x09, 0x01, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 
  0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x09, 0x01, 0x09, 0x00, 0x09, 0x00, 
  0x09, 0x00, 0x09, 0x8A, 0x31, 0x05, 0x02, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x07, 
  0x01, 0x07, 0x00, 0x07, 0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0x01, 0x07, 0x00, 0x07, 0x01, 0x07, 
  0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0x01, 0x07, 0x00, 0x07, 
  0x01, 0x07, 0x00, 0x07, 0x05, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 
  0x01, 0x07, 0x00, 0x07, 0x01, 0x34, 0x00, 0x34, 0x00, 0x34, 0x00, 0x1D, 0x00, 0x1D, 0x00, 0x1D, 
  0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 
  0x00, 0x07, 0x01, 0x07, 0x00, 0x07, 0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0x10, 0x00, 0x00, 0x00, 
  0xCD, 0x00, 0xD0, 0x00, 0x00, 0x06, 0x02, 0x02, 0x02, 0x0C, 0x24, 0x01, 0xDA, 0x05, 0xDA, 0x29, 
  0xDA, 0x2B, 0xDA, 0x03, 0xDA, 0x82, 0x93, 0xDA, 0x83, 0x2B, 0xDA, 0x83, 0x2C, 0xDA, 0x82, 0x58, 
  0xDA, 0x83, 0x44, 0xDA, 0x83, 0x96, 0xDA, 0x83, 0x97, 0xDA, 0x7F, 0xDA, 0x80, 0x84, 0x2F, 0x00, 
  0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x23, 0x03, 
  0x04, 0x02, 0x1C, 0x03, 0x12, 0x00, 0x2A, 0x02, 0x02, 0x00, 0x30, 0x02, 0x01, 0x00, 0x42, 0x02, 
  0x00, 0x00, 0x2B, 0x04, 0x00, 0x00, 0x2A, 0x05, 0x03, 0x00, 0x3A, 0x04, 0x05, 0x02, 0x2B, 0x02, 
  0x00, 0x00, 0x2A, 0x04, 0x04, 0x00, 0x2A, 0x05, 0x05, 0x00, 0x31, 0x02, 0x04, 0x05, 0x2A, 0x04, 
  0x06, 0x00, 0x33, 0x02, 0x04, 0x00, 0x30, 0x02, 0x01, 0x00, 0x2A, 0x05, 0x07, 0x00, 0x33, 0x04, 
  0x05, 0x00, 0x2A, 0x02, 0x08, 0x00, 0x34, 0x02, 0x00, 0x00, 0x2A, 0x02, 0x09, 0x00, 0x2F, 0x02, 
  0x00, 0x00, 0x2B, 0x04, 0x00, 0x00, 0x33, 0x02, 0x04, 0x00, 0x1C, 0x02, 0x04, 0x00, 0x30, 0x00, 
  0x01, 0x00, 0x2B, 0x04, 0x00, 0x04, 0x34, 0x04, 0x00, 0x00, 0x30, 0x00, 0x01, 0x00, 0x2A, 0x05, 
  0x0A, 0x00, 0x33, 0x04, 0x05, 0x00, 0x2A, 0x04, 0x0B, 0x00, 0x34, 0x04, 0x00, 0x00, 0xBF, 0xFF, 
  0x8A, 0x47, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x07, 0x02, 0x0B, 0x00, 
  0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x01, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 
  0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x01, 0x0B, 0x00, 0x0B, 0x01, 
  0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x09, 0x01, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x01, 
  0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x26, 0x00, 0x26, 0x8A, 0x2E, 0x03, 0x03, 0x05, 0x00, 0x05, 
  0x15, 0x05, 0x00, 0x05, 0x17, 0x00, 0x00, 0x00, 0x8A, 0x1D, 0x01, 0x07, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x10, 0x00, 0x10, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x01, 0x05, 0xBF, 0xFF, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x09, 0x03, 
  0x00, 0x03, 0x24, 0x1C, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0x29, 0x00, 0x29, 0x00, 0x29, 0x00, 0x1C, 
  0xBF, 0xFE, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x28, 0x00, 0x00, 0x00, 0x2C, 0x01, 0x00, 
  0x00, 0x2A, 0x02, 0x00, 0x00, 0x30, 0x02, 0x00, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x33, 0x02, 0x03, 
  0x00, 0x28, 0x03, 0x00, 0x00, 0x27, 0x04, 0x00, 0x00, 0x28, 0x05, 0x00, 0x00, 0x28, 0x06, 0x00, 
  0x00, 0x27, 0x07, 0x00, 0x00, 0x27, 0x08, 0x00, 0x00, 0x27, 0x09, 0x00, 0x00, 0x28, 0x0A, 0x00, 
  0x00, 0x28, 0x0B, 0x00, 0x00, 0x2A, 0x0C, 0x02, 0x00, 0x2F, 0x0C, 0x00, 0x00, 0x2A, 0x0D, 0x03, 
  0x00, 0x33, 0x0C, 0x0D, 0x00, 0x19, 0x0D, 0x0C, 0x00, 0x1C, 0x0D, 0x06, 0x00, 0x2A, 0x0C, 0x04, 
  0x00, 0x30, 0x0C, 0x0D, 0x00, 0x2A, 0x0E, 0x01, 0x00, 0x33, 0x0C, 0x0E, 0x00, 0x1A, 0x01, 0x00, 
  0x00, 0x2A, 0x0C, 0x05, 0x00, 0x2F, 0x0C, 0x00, 0x00, 0x2A, 0x0D, 0x03, 0x00, 0x33, 0x0C, 0x0D, 
  0x00, 0x19, 0x0D, 0x0C, 0x00, 0x1C, 0x0D, 0x06, 0x00, 0x2A, 0x0C, 0x06, 0x00, 0x30, 0x0C, 0x0D, 
  0x00, 0x2A, 0x0E, 0x01, 0x00, 0x33, 0x0C, 0x0E, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x2E, 0x0C, 0x00, 
  0x00, 0x2E, 0x0D, 0x01, 0x00, 0x2E, 0x0E, 0x02, 0x00, 0x2E, 0x0F, 0x03, 0x00, 0x2E, 0x10, 0x04, 
  0x00, 0x2E, 0x11, 0x05, 0x00, 0x2E, 0x12, 0x06, 0x00, 0x2E, 0x13, 0x07, 0x00, 0x2E, 0x14, 0x08, 
  0x00, 0x2E, 0x15, 0x09, 0x00, 0x2E, 0x16, 0x0A, 0x00, 0x2E, 0x17, 0x0B, 0x00, 0x2E, 0x18, 0x0C, 
  0x00, 0x2E, 0x19, 0x0D, 0x00, 0x2A, 0x1A, 0x07, 0x00, 0x2A, 0x1B, 0x08, 0x00, 0x31, 0x1A, 0x0C, 
  0x1B, 0x2A, 0x1A, 0x09, 0x00, 0x31, 0x0D, 0x1A, 0x0E, 0x2A, 0x1A, 0x0A, 0x00, 0x2A, 0x1B, 0x0B, 
  0x00, 0x31, 0x1A, 0x0F, 0x1B, 0x2A, 0x1A, 0x0C, 0x00, 0x31, 0x10, 0x1A, 0x11, 0x2A, 0x1A, 0x0D, 
  0x00, 0x2A, 0x1B, 0x0E, 0x00, 0x31, 0x1A, 0x12, 0x1B, 0x2A, 0x1A, 0x0F, 0x00, 0x31, 0x13, 0x1A, 
  0x14, 0x2A, 0x1A, 0x10, 0x00, 0x2A, 0x1B, 0x11, 0x00, 0x31, 0x1A, 0x15, 0x1B, 0x2A, 0x1A, 0x12, 
  0x00, 0x31, 0x16, 0x1A, 0x17, 0x2A, 0x1A, 0x13, 0x00, 0x2A, 0x1B, 0x14, 0x00, 0x31, 0x1A, 0x18, 
  0x1B, 0x2F, 0x19, 0x00, 0x00, 0x41, 0x0C, 0x00, 0x00, 0x19, 0x0D, 0x0C, 0x00, 0x2E, 0x0E, 0x0E, 
  0x00, 0x19, 0x0F, 0x0E, 0x00, 0x2E, 0x10, 0x0F, 0x00, 0x19, 0x11, 0x10, 0x00, 0x29, 0x12, 0x00, 
  0x00, 0x3D, 0x13, 0x00, 0x00, 0x19, 0x14, 0x13, 0x00, 0x21, 0x15, 0x12, 0x14, 0x1C, 0x15, 0x48, 
  0x00, 0x38, 0x16, 0x00, 0x12, 0x19, 0x17, 0x16, 0x00, 0x1C, 0x07, 0x0A, 0x00, 0x29, 0x18, 0x00, 
  0x00, 0x29, 0x19, 0x01, 0x00, 0x31, 0x17, 0x18, 0x19, 0x2A, 0x19, 0x15, 0x00, 0x33, 0x18, 0x19, 
  0x00, 0x2A, 0x1A, 0x12, 0x00, 0x23, 0x19, 0x1A, 0x18, 0x19, 0x16, 0x19, 0x00, 0x1A, 0x02, 0x00, 
  0x00, 0x19, 0x16, 0x07, 0x00, 0x1C, 0x16, 0x09, 0x00, 0x29, 0x18, 0x01, 0x00, 0x30, 0x17, 0x18, 
  0x00, 0x2A, 0x19, 0x15, 0x00, 0x33, 0x18, 0x19, 0x00, 0x30, 0x18, 0x12, 0x00, 0x33, 0x19, 0x0F, 
  0x00, 0x06, 0x12, 0x12, 0x19, 0x1A, 0x31, 0x00, 0x00, 0x28, 0x04, 0x00, 0x00, 0x2A, 0x19, 0x16, 
  0x00, 0x33, 0x18, 0x19, 0x00, 0x19, 0x19, 0x18, 0x00, 0x30, 0x00, 0x12, 0x00, 0x2A, 0x1A, 0x17, 
  0x00, 0x33, 0x18, 0x1A, 0x00, 0x19, 0x1A, 0x18, 0x00, 0x2A, 0x18, 0x00, 0x00, 0x3A, 0x19, 0x18, 
  0x1A, 0x2A, 0x18, 0x18, 0x00, 0x2A, 0x1B, 0x19, 0x00, 0x31, 0x17, 0x18, 0x1B, 0x2A, 0x18, 0x1A, 
  0x00, 0x2A, 0x1B, 0x1B, 0x00, 0x31, 0x18, 0x08, 0x1B, 0x2A, 0x18, 0x1C, 0x00, 0x31, 0x11, 0x18, 
  0x19, 0x2A, 0x1B, 0x1D, 0x00, 0x33, 0x18, 0x1B, 0x00, 0x2A, 0x1B, 0x1E, 0x00, 0x38, 0x18, 0x19, 
  0x1B, 0x2A, 0x1C, 0x1F, 0x00, 0x39, 0x1B, 0x18, 0x1C, 0x19, 0x18, 0x1B, 0x00, 0x1C, 0x18, 0x16, 
  0x00, 0x30, 0x00, 0x12, 0x00, 0x2A, 0x1C, 0x20, 0x00, 0x33, 0x1B, 0x1C, 0x00, 0x2F, 0x18, 0x00, 
  0x00, 0x32, 0x1B, 0x00, 0x00, 0x43, 0x1B, 0x00, 0x00, 0x31, 0x1B, 0x19, 0x17, 0x2A, 0x1D, 0x21, 
  0x00, 0x33, 0x1C, 0x1D, 0x00, 0x19, 0x1B, 0x1C, 0x00, 0x2F, 0x1B, 0x00, 0x00, 0x2A, 0x1D, 0x22, 
  0x00, 0x33, 0x1C, 0x1D, 0x00, 0x1C, 0x1C, 0x03, 0x00, 0x33, 0x1D, 0x1B, 0x00, 0x1A, 0x05, 0x00, 
  0x00, 0x2A, 0x1D, 0x23, 0x00, 0x2F, 0x1D, 0x00, 0x00, 0x33, 0x1D, 0x1B, 0x00, 0x01, 0x1D, 0x00, 
  0x00, 0x1A, 0x01, 0x00, 0x00, 0x19, 0x12, 0x14, 0x00, 0x1A, 0xB8, 0xFF, 0xFF, 0x2F, 0x0B, 0x00, 
  0x00, 0x2A, 0x17, 0x24, 0x00, 0x33, 0x16, 0x17, 0x00, 0x19, 0x17, 0x16, 0x00, 0x1C, 0x16, 0x07, 
  0x00, 0x1C, 0x03, 0x03, 0x00, 0x19, 0x18, 0x03, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x18, 0x04, 
  0x00, 0x19, 0x15, 0x18, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x15, 0x17, 0x00, 0x1C, 0x15, 0x35, 
  0x00, 0x1C, 0x05, 0x02, 0x00, 0x1A, 0x0A, 0x00, 0x00, 0x2A, 0x16, 0x25, 0x00, 0x2A, 0x17, 0x26, 
  0x00, 0x2A, 0x18, 0x12, 0x00, 0x31, 0x16, 0x17, 0x18, 0x2A, 0x16, 0x27, 0x00, 0x2A, 0x17, 0x28, 
  0x00, 0x30, 0x16, 0x17, 0x00, 0x2A, 0x17, 0x29, 0x00, 0x33, 0x16, 0x17, 0x00, 0x2A, 0x17, 0x2A, 
  0x00, 0x33, 0x16, 0x17, 0x00, 0x2E, 0x16, 0x10, 0x00, 0x19, 0x17, 0x16, 0x00, 0x2E, 0x16, 0x11, 
  0x00, 0x19, 0x18, 0x16, 0x00, 0x2A, 0x19, 0x16, 0x00, 0x33, 0x16, 0x19, 0x00, 0x19, 0x19, 0x16, 
  0x00, 0x1C, 0x0A, 0x05, 0x00, 0x2A, 0x16, 0x2B, 0x00, 0x27, 0x1A, 0x00, 0x00, 0x3A, 0x19, 0x16, 
  0x1A, 0x1A, 0x01, 0x00, 0x00, 0x1C, 0x06, 0x03, 0x00, 0x19, 0x16, 0x18, 0x00, 0x1A, 0x02, 0x00, 
  0x00, 0x2A, 0x16, 0x2C, 0x00, 0x19, 0x1A, 0x16, 0x00, 0x2E, 0x16, 0x12, 0x00, 0x19, 0x1B, 0x16, 
  0x00, 0x1C, 0x09, 0x03, 0x00, 0x2A, 0x16, 0x2D, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x2A, 0x16, 0x2E, 
  0x00, 0x2A, 0x1C, 0x2F, 0x00, 0x30, 0x1C, 0x16, 0x00, 0x2A, 0x1D, 0x01, 0x00, 0x33, 0x1C, 0x1D, 
  0x00, 0x1C, 0x09, 0x03, 0x00, 0x27, 0x16, 0x00, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x26, 0x16, 0x00, 
  0x00, 0x2A, 0x1C, 0x30, 0x00, 0x30, 0x1C, 0x16, 0x00, 0x2A, 0x1D, 0x01, 0x00, 0x33, 0x1C, 0x1D, 
  0x00, 0x26, 0x16, 0x00, 0x00, 0x31, 0x1B, 0x16, 0x19, 0x2A, 0x16, 0x31, 0x00, 0x34, 0x16, 0x00, 
  0x00, 0x04, 0x00, 0x00, 0x00, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x04, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 
  0xFF, 0xFF, 0x01, 0x0B, 0x01, 0xDA, 0x05, 0xD7, 0xCD, 0x02, 0xBA, 0x00, 0x00, 0x0D, 0x01, 0x01, 
  0x01, 0x0A, 0x1C, 0x04, 0xCE, 0x0B, 0x65, 0x76, 0x61, 0x6C, 0x2D, 0x73, 0x74, 0x72, 0x69, 0x6E, 
  0x67, 0xDA, 0x05, 0xDA, 0x6F, 0xDA, 0x80, 0xE4, 0xD0, 0x01, 0x69, 0xDA, 0x80, 0xE0, 0xDA, 0x80, 
  0xE1, 0xDA, 0x80, 0xDF, 0xDA, 0x80, 0x9A, 0xDA, 0x84, 0x35, 0xDA, 0x80, 0xE2, 0xDA, 0x81, 0x07, 
  0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 
  0x19, 0x03, 0x02, 0x00, 0x2E, 0x04, 0x00, 0x00, 0x19, 0x05, 0x04, 0x00, 0x26, 0x06, 0x00, 0x00, 
  0x2E, 0x07, 0x01, 0x00, 0x2E, 0x08, 0x02, 0x00, 0x2E, 0x09, 0x03, 0x00, 0x2A, 0x0A, 0x01, 0x00, 
  0x2A, 0x0B, 0x02, 0x00, 0x2A, 0x0C, 0x03, 0x00, 0x31, 0x0A, 0x0B, 0x0C, 0x2A, 0x0A, 0x04, 0x00, 
  0x31, 0x05, 0x0A, 0x07, 0x2A, 0x0A, 0x05, 0x00, 0x2A, 0x0B, 0x06, 0x00, 0x31, 0x0A, 0x08, 0x0B, 
  0x2A, 0x0A, 0x07, 0x00, 0x2A, 0x0B, 0x08, 0x00, 0x31, 0x0A, 0x0B, 0x09, 0x41, 0x07, 0x00, 0x00, 
  0x2F, 0x07, 0x00, 0x00, 0x2A, 0x09, 0x09, 0x00, 0x33, 0x08, 0x09, 0x00, 0x03, 0x06, 0x00, 0x00, 
  0xCD, 0x00, 0xD8, 0x00, 0x00, 0x06, 0x02, 0x02, 0x02, 0x02, 0x0E, 0x01, 0xDA, 0x81, 0x09, 0xDA, 
  0x05, 0xDA, 0x6B, 0xDA, 0x84, 0x27, 0x2C, 0x02, 0x00, 0x00, 0x2B, 0x03, 0x00, 0x03, 0x26, 0x04, 
  0x00, 0x00, 0x2D, 0x04, 0x00, 0x03, 0x1C, 0x03, 0x09, 0x00, 0x2B, 0x04, 0x00, 0x00, 0x30, 0x00, 
  0x04, 0x00, 0x2A, 0x05, 0x00, 0x00, 0x33, 0x04, 0x05, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x30, 0x00, 
  0x04, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x34, 0x04, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xBF, 0xFF, 
  0x88, 0x4C, 0x03, 0x01, 0x05, 0x01, 0x05, 0x00, 0x05, 0x01, 0x05, 0x01, 0x07, 0x00, 0x07, 0x00, 
  0x07, 0x00, 0x07, 0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xFE, 0x05, 0xCD, 0x00, 
  0x90, 0x00, 0x00, 0x05, 0x02, 0x02, 0x02, 0x03, 0x09, 0xDA, 0x05, 0xDA, 0x80, 0xE7, 0xCE, 0x0D, 
  0x70, 0x61, 0x72, 0x73, 0x65, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x3A, 0x20, 0xDA, 0x6F, 0x2F, 
  0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x30, 
  0x03, 0x02, 0x00, 0x2A, 0x04, 0x02, 0x00, 0x33, 0x03, 0x04, 0x00, 0x01, 0x03, 0x00, 0x00, 0x04, 
  0x00, 0x00, 0x00, 0x88, 0x57, 0x42, 0x00, 0x42, 0x00, 0x42, 0x00, 0x2A, 0x00, 0x2A, 0x00, 0x2A, 
  0x00, 0x2A, 0x00, 0x23, 0x00, 0x23, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x05, 0x02, 0x02, 0x02, 0x02, 
  0x0B, 0x01, 0xDA, 0x05, 0xDA, 0x29, 0xDA, 0x2B, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 
  0x33, 0x02, 0x03, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x23, 0x03, 0x02, 0x04, 0x1C, 0x03, 0x02, 0x00, 
  0x1A, 0x02, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x2D, 0x01, 0x00, 0x06, 0x2B, 0x02, 0x00, 0x06, 
  0x03, 0x02, 0x00, 0x00, 0xBF, 0xFF, 0x88, 0x5A, 0x29, 0x00, 0x29, 0x00, 0x29, 0x00, 0x26, 0x00, 
  0x26, 0x00, 0x1E, 0x00, 0x1E, 0x01, 0x20, 0x01, 0x1E, 0x00, 0x1E, 0x00, 0x1E, 0xCD, 0x00, 0x90, 
  0x00, 0x00, 0x04, 0x02, 0x02, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x02, 0x06, 0xDA, 0x05, 0xDA, 0x80, 
  0x82, 0xDA, 0x6F, 0x2A, 0x02, 0x00, 0x00, 0x30, 0x02, 0x00, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x33, 
  0x02, 0x03, 0x00, 0x01, 0x02, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x88, 0x55, 0x2C, 0x00, 0x2C, 
  0x00, 0x2C, 0x00, 0x2C, 0x00, 0x25, 0x00, 0x25, 0x88, 0x47, 0x01, 0x04, 0x0E, 0x00, 0x0E, 0x00, 
  0x0E, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x06, 0x03, 0x04, 0x21, 0x03, 0x1C, 0xBF, 0xFB, 0x23, 
  0xBF, 0xFF, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0xBF, 0xF4, 0x01, 0x49, 0x00, 0x00, 0x00, 0x28, 0x01, 0x00, 0x00, 0x2D, 0x01, 0x00, 0x04, 
  0x29, 0x02, 0x01, 0x00, 0x06, 0x01, 0x00, 0x02, 0x2B, 0x03, 0x00, 0x00, 0x38, 0x02, 0x03, 0x01, 
  0x2F, 0x02, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x01, 0x03, 0x00, 0x29, 0x02, 0x02, 0x00, 
  0x03, 0x02, 0x00, 0x00, 0xBF, 0xFF, 0x8A, 0xB4, 0x0C, 0x00, 0x0C, 0x01, 0x22, 0x00, 0x22, 0x00, 
  0x19, 0x00, 0x19, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0xBF, 0xFE, 0x0A, 0x00, 0x0A, 0xCD, 0x00, 
  0xD0, 0x00, 0x00, 0x01, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x04, 0x01, 0xDA, 0x05, 
  0x27, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x05, 0x29, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 
  0xBF, 0xFF, 0x8A, 0xA5, 0x12, 0x00, 0x12, 0x00, 0x0A, 0x00, 0x0A, 0xCD, 0x00, 0xD0, 0x00, 0x00, 
  0x01, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x04, 0x01, 0xDA, 0x05, 0x27, 0x00, 0x00, 
  0x00, 0x2D, 0x00, 0x00, 0x0A, 0x29, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0xBF, 0xFF, 0x8A, 
  0xB7, 0x12, 0x00, 0x12, 0x00, 0x0A, 0x00, 0x0A, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x07, 0x01, 0x01, 
  0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x03, 0x16, 0x01, 0xDA, 0x05, 0xDA, 0x81, 0x0E, 0xDA, 0x81, 0x18, 
  0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0B, 0x03, 0x02, 0x03, 0x07, 0x1C, 0xCE, 0x04, 0x73, 0x70, 
  0x69, 0x74, 0xDA, 0x05, 0xD0, 0x02, 0x77, 0x62, 0xDA, 0x80, 0xD8, 0xDA, 0x81, 0x13, 0xCE, 0x0B, 
  0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x6D, 0x6F, 0x64, 0x65, 0x20, 0xDA, 0x6F, 0xD8, 0x0A, 0x66, 
  0x69, 0x6C, 0x65, 0x2F, 0x77, 0x72, 0x69, 0x74, 0x65, 0xDA, 0x81, 0x08, 0x2C, 0x03, 0x00, 0x00, 
  0x26, 0x06, 0x00, 0x00, 0x23, 0x05, 0x06, 0x02, 0x1C, 0x05, 0x03, 0x00, 0x2A, 0x04, 0x00, 0x00, 
  0x1A, 0x02, 0x00, 0x00, 0x19, 0x04, 0x02, 0x00, 0x19, 0x05, 0x04, 0x00, 0x30, 0x00, 0x05, 0x00, 
  0x2A, 0x07, 0x01, 0x00, 0x33, 0x06, 0x07, 0x00, 0x19, 0x07, 0x06, 0x00, 0x1C, 0x07, 0x02, 0x00, 
  0x1A, 0x08, 0x00, 0x00, 0x2A, 0x08, 0x02, 0x00, 0x2A, 0x09, 0x03, 0x00, 0x31, 0x08, 0x00, 0x09, 
  0x2F, 0x05, 0x00, 0x00, 0x2A, 0x09, 0x04, 0x00, 0x33, 0x08, 0x09, 0x00, 0x01, 0x08, 0x00, 0x00, 
  0x30, 0x07, 0x01, 0x00, 0x2A, 0x09, 0x05, 0x00, 0x33, 0x08, 0x09, 0x00, 0x2F, 0x07, 0x00, 0x00, 
  0x2A, 0x0A, 0x06, 0x00, 0x33, 0x09, 0x0A, 0x00, 0x04, 0x00, 0x00, 0x00, 0x85, 0x9A, 0x01, 0x04, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x0A, 0x00, 
  0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 
  0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x0D, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0xBF, 0xF8, 0x01, 0x29, 0x02, 0x01, 0x00, 0x06, 0x01, 0x00, 0x02, 0x2B, 0x03, 
  0x00, 0x00, 0x38, 0x02, 0x03, 0x01, 0x2F, 0x02, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x01, 
  0x03, 0x00, 0x19, 0x02, 0x01, 0x00, 0x29, 0x04, 0x02, 0x00, 0x06, 0x03, 0x00, 0x04, 0x2B, 0x05, 
  0x00, 0x00, 0x38, 0x04, 0x05, 0x03, 0x2F, 0x02, 0x00, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x33, 0x03, 
  0x05, 0x00, 0x30, 0x04, 0x03, 0x00, 0x2A, 0x06, 0x02, 0x00, 0x33, 0x05, 0x06, 0x00, 0x28, 0x03, 
  0x00, 0x00, 0x2D, 0x03, 0x00, 0x04, 0x29, 0x03, 0x03, 0x00, 0x03, 0x03, 0x00, 0x00, 0xBF, 0xFF, 
  0x8A, 0xAA, 0x24, 0x00, 0x24, 0x00, 0x1B, 0x00, 0x1B, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 
  0x0C, 0x01, 0x1B, 0x00, 0x1B, 0x00, 0x12, 0x00, 0x12, 0x00, 0x24, 0x00, 0x24, 0x00, 0x24, 0x00, 
  0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x01, 0x0C, 0x00, 0x0C, 0xBF, 0xFD, 0x0A, 0x00, 0x0A, 0xCD, 0x00, 
  0xD0, 0x00, 0x00, 0x04, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x02, 0x0A, 0x01, 0xDA, 0x05, 
  0xDA, 0x83, 0x7F, 0xDA, 0x82, 0x26, 0x29, 0x02, 0x01, 0x00, 0x06, 0x01, 0x00, 0x02, 0x2B, 0x03, 
  0x00, 0x00, 0x38, 0x02, 0x03, 0x01, 0x2A, 0x01, 0x00, 0x00, 0x30, 0x01, 0x02, 0x00, 0x2A, 0x03, 
  0x01, 0x00, 0x33, 0x01, 0x03, 0x00, 0x29, 0x02, 0x02, 0x00, 0x03, 0x02, 0x00, 0x00, 0xBF, 0xFF, 
  0x8A, 0xA8, 0x2E, 0x00, 0x2E, 0x00, 0x25, 0x00, 0x25, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 
  0x14, 0x00, 0x0A, 0x00, 0x0A, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x01, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 
  0xFF, 0xFF, 0x00, 0x04, 0x01, 0xDA, 0x05, 0x28, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x09, 0x29, 
  0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0xBF, 0xFF, 0x8A, 0xA7, 0x12, 0x00, 0x12, 0x00, 0x0A, 
  0x00, 0x0A, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x01, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 
  0x06, 0x01, 0xDA, 0x05, 0x27, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x0B, 0x28, 0x00, 0x00, 0x00, 
  0x2D, 0x00, 0x00, 0x08, 0x29, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0xBF, 0xFF, 0x8A, 0xA6, 
  0x12, 0x00, 0x12, 0x00, 0x2C, 0x00, 0x2C, 0x00, 0x0A, 0x00, 0x0A, 0xCD, 0x00, 0xD0, 0x00, 0x00, 
  0x01, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x04, 0x01, 0xDA, 0x05, 0x28, 0x00, 0x00, 
  0x00, 0x2D, 0x00, 0x00, 0x08, 0x29, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0xBF, 0xFF, 0x8A, 
  0xA4, 0x12, 0x00, 0x12, 0x00, 0x0A, 0x00, 0x0A, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x01, 0x00, 0x00, 
  0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x04, 0x01, 0xDA, 0x05, 0x27, 0x00, 0x00, 0x00, 0x2D, 0x00, 
  0x00, 0x03, 0x29, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0xBF, 0xFF, 0x8A, 0xA3, 0x12, 0x00, 
  0x12, 0x00, 0x0A, 0x00, 0x0A, 0xCD, 0x00, 0x90, 0x00, 0x00, 0x04, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 
  0xFF, 0xFF, 0x08, 0x14, 0xDA, 0x05, 0xD0, 0x0A, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x61, 0x62, 
  0x6C, 0x65, 0xCE, 0x05, 0x6A, 0x61, 0x6E, 0x65, 0x74, 0xDA, 0x7D, 0xCE, 0x07, 0x75, 0x73, 0x61, 
  0x67, 0x65, 0x3A, 0x20, 0xCE, 0x19, 0x20, 0x5B, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x5D, 
  0x20, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x20, 0x61, 0x72, 0x67, 0x73, 0x2E, 0x2E, 0x2E, 0xDA, 
  0x83, 0x95, 0xCE, 0x82, 0x9C, 0x4F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x20, 0x61, 0x72, 0x65, 
  0x3A, 0x0D, 0x0A, 0x20, 0x20, 0x2D, 0x68, 0x20, 0x3A, 0x20, 0x53, 0x68, 0x6F, 0x77, 0x20, 0x74, 
  0x68, 0x69, 0x73, 0x20, 0x68, 0x65, 0x6C, 0x70, 0x0D, 0x0A, 0x20, 0x20, 0x2D, 0x76, 0x20, 0x3A, 
  0x20, 0x50, 0x72, 0x69, 0x6E, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 
  0x6F, 0x6E, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x0D, 0x0A, 0x20, 0x20, 0x2D, 0x73, 0x20, 
  0x3A, 0x20, 0x55, 0x73, 0x65, 0x20, 0x72, 0x61, 0x77, 0x20, 0x73, 0x74, 0x64, 0x69, 0x6E, 0x20, 
  0x69, 0x6E, 0x73, 0x74, 0x65, 0x61, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x67, 0x65, 0x74, 0x6C, 0x69, 
  0x6E, 0x65, 0x20, 0x6C, 0x69, 0x6B, 0x65, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 
  0x61, 0x6C, 0x69, 0x74, 0x79, 0x0D, 0x0A, 0x20, 0x20, 0x2D, 0x65, 0x20, 0x63, 0x6F, 0x64, 0x65, 
  0x20, 0x3A, 0x20, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 
  0x69, 0x6E, 0x67, 0x20, 0x6F, 0x66, 0x20, 0x6A, 0x61, 0x6E, 0x65, 0x74, 0x0D, 0x0A, 0x20, 0x20, 
  0x2D, 0x64, 0x20, 0x3A, 0x20, 0x53, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x62, 
  0x75, 0x67, 0x20, 0x66, 0x6C, 0x61, 0x67, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 
  0x65, 0x70, 0x6C, 0x0D, 0x0A, 0x20, 0x20, 0x2D, 0x72, 0x20, 0x3A, 0x20, 0x45, 0x6E, 0x74, 0x65, 
  0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x70, 0x6C, 0x20, 0x61, 0x66, 0x74, 0x65, 0x72, 
  0x20, 0x72, 0x75, 0x6E, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x73, 0x63, 0x72, 
  0x69, 0x70, 0x74, 0x73, 0x0D, 0x0A, 0x20, 0x20, 0x2D, 0x70, 0x20, 0x3A, 0x20, 0x4B, 0x65, 0x65, 
  0x70, 0x20, 0x6F, 0x6E, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x69, 
  0x66, 0x20, 0x74, 0x68, 0x65, 0x72, 0x65, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x74, 0x6F, 0x70, 
  0x20, 0x6C, 0x65, 0x76, 0x65, 0x6C, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x28, 0x70, 0x65, 
  0x72, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6E, 0x74, 0x29, 0x0D, 0x0A, 0x20, 0x20, 0x2D, 0x71, 0x20, 
  0x3A, 0x20, 0x48, 0x69, 0x64, 0x65, 0x20, 0x6C, 0x6F, 0x67, 0x6F, 0x20, 0x28, 0x71, 0x75, 0x69, 
  0x65, 0x74, 0x29, 0x0D, 0x0A, 0x20, 0x20, 0x2D, 0x6B, 0x20, 0x3A, 0x20, 0x43, 0x6F, 0x6D, 0x70, 
  0x69, 0x6C, 0x65, 0x20, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x73, 0x20, 0x62, 0x75, 0x74, 0x20, 
  0x64, 0x6F, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x20, 0x28, 
  0x66, 0x6C, 0x79, 0x63, 0x68, 0x65, 0x63, 0x6B, 0x29, 0x0D, 0x0A, 0x20, 0x20, 0x2D, 0x6D, 0x20, 
  0x73, 0x79, 0x73, 0x70, 0x61, 0x74, 0x68, 0x20, 0x3A, 0x20, 0x53, 0x65, 0x74, 0x20, 0x73, 0x79, 
  0x73, 0x74, 0x65, 0x6D, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x6C, 0x6F, 
  0x61, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x67, 0x6C, 0x6F, 0x62, 0x61, 0x6C, 0x20, 0x6D, 0x6F, 0x64, 
  0x75, 0x6C, 0x65, 0x73, 0x0D, 0x0A, 0x20, 0x20, 0x2D, 0x63, 0x20, 0x73, 0x6F, 0x75, 0x72, 0x63, 
  0x65, 0x20, 0x6F, 0x75, 0x74, 0x70, 0x75, 0x74, 0x20, 0x3A, 0x20, 0x43, 0x6F, 0x6D, 0x70, 0x69, 
  0x6C, 0x65, 0x20, 0x6A, 0x61, 0x6E, 0x65, 0x74, 0x20, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x20, 
  0x63, 0x6F, 0x64, 0x65, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6D, 0x61, 
  0x67, 0x65, 0x0D, 0x0A, 0x20, 0x20, 0x2D, 0x6E, 0x20, 0x3A, 0x20, 0x44, 0x69, 0x73, 0x61, 0x62, 
  0x6C, 0x65, 0x20, 0x41, 0x4E, 0x53, 0x49, 0x20, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x20, 0x6F, 0x75, 
  0x74, 0x70, 0x75, 0x74, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x70, 0x6C, 
  0x0D, 0x0A, 0x20, 0x20, 0x2D, 0x6C, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x3A, 0x20, 0x45, 0x78, 
  0x65, 0x63, 0x75, 0x74, 0x65, 0x20, 0x63, 0x6F, 0x64, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 
  0x66, 0x69, 0x6C, 0x65, 0x20, 0x62, 0x65, 0x66, 0x6F, 0x72, 0x65, 0x20, 0x72, 0x75, 0x6E, 0x6E, 
  0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x61, 0x69, 0x6E, 0x20, 0x73, 0x63, 0x72, 
  0x69, 0x70, 0x74, 0x0D, 0x0A, 0x20, 0x20, 0x2D, 0x2D, 0x20, 0x3A, 0x20, 0x53, 0x74, 0x6F, 0x70, 
  0x20, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x69, 0x6E, 0x67, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 
  0x73, 0xDA, 0x81, 0x0C, 0x2A, 0x00, 0x00, 0x00, 0x2A, 0x01, 0x01, 0x00, 0x30, 0x00, 0x01, 0x00, 
  0x2A, 0x01, 0x02, 0x00, 0x33, 0x00, 0x01, 0x00, 0x2A, 0x01, 0x03, 0x00, 0x2A, 0x02, 0x04, 0x00, 
  0x31, 0x01, 0x00, 0x02, 0x2A, 0x02, 0x05, 0x00, 0x33, 0x01, 0x02, 0x00, 0x2A, 0x00, 0x06, 0x00, 
  0x2F, 0x00, 0x00, 0x00, 0x2A, 0x02, 0x05, 0x00, 0x33, 0x00, 0x02, 0x00, 0x29, 0x02, 0x00, 0x00, 
  0x2F, 0x02, 0x00, 0x00, 0x2A, 0x03, 0x07, 0x00, 0x33, 0x02, 0x03, 0x00, 0x29, 0x03, 0x01, 0x00, 
  0x03, 0x03, 0x00, 0x00, 0x8A, 0x8E, 0x1D, 0x00, 0x1D, 0x00, 0x1D, 0x00, 0x1D, 0x00, 0x1D, 0x00, 
  0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x01, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 
  0x0C, 0x10, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0xBF, 0xEE, 0x0A, 0x00, 0x0A, 0xCD, 0x00, 
  0xD0, 0x00, 0x00, 0x01, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x06, 0x01, 0xDA, 0x05, 
  0x27, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x06, 0x27, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x03, 
  0x29, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0xBF, 0xFF, 0x8A, 0xA2, 0x12, 0x00, 0x12, 0x00, 
  0x29, 0x00, 0x29, 0x00, 0x0A, 0x00, 0x0A, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x01, 0x00, 0x00, 0xCD, 
  0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x04, 0x01, 0xDA, 0x05, 0x28, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 
  0x07, 0x29, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0xBF, 0xFF, 0x8A, 0xAE, 0x12, 0x00, 0x12, 
  0x00, 0x0A, 0x00, 0x0A, 0xCD, 0x00, 0x90, 0x00, 0x00, 0x03, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 
  0xFF, 0x05, 0x0C, 0xDA, 0x05, 0xDA, 0x83, 0x92, 0xDA, 0x81, 0xA8, 0xDA, 0x83, 0x93, 0xDA, 0x83, 
  0x95, 0xDA, 0x81, 0x0C, 0x2A, 0x00, 0x00, 0x00, 0x2A, 0x01, 0x01, 0x00, 0x2A, 0x02, 0x02, 0x00, 
  0x31, 0x00, 0x01, 0x02, 0x2A, 0x01, 0x03, 0x00, 0x33, 0x00, 0x01, 0x00, 0x29, 0x01, 0x00, 0x00, 
  0x2F, 0x01, 0x00, 0x00, 0x2A, 0x02, 0x04, 0x00, 0x33, 0x01, 0x02, 0x00, 0x29, 0x02, 0x01, 0x00, 
  0x03, 0x02, 0x00, 0x00, 0x8A, 0xA1, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 
  0x12, 0x00, 0x38, 0x00, 0x38, 0x00, 0x38, 0x00, 0x38, 0x00, 0x0A, 0x00, 0x0A, 0xCD, 0x00, 0xD0, 
  0x00, 0x00, 0x04, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x04, 0x0E, 0x01, 0xDA, 0x05, 0xDA, 
  0x83, 0x8F, 0xDA, 0x67, 0xDA, 0x80, 0xD4, 0xD7, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x16, 0x01, 0x01, 
  0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x11, 0x5F, 0xCE, 0x07, 0x69, 0x6D, 0x70, 0x6F, 0x72, 0x74, 0x2A, 
  0xDA, 0x05, 0xDA, 0x50, 0xDA, 0x51, 0xDA, 0x07, 0xDA, 0x83, 0x8F, 0xD0, 0x02, 0x61, 0x73, 0xD0, 
  0x06, 0x65, 0x78, 0x70, 0x6F, 0x72, 0x74, 0xD7, 0xDC, 0x18, 0xDA, 0x83, 0x20, 0xDA, 0x6F, 0xDA, 
  0x82, 0xCC, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 0x00, 0x06, 0xCE, 0x04, 
  0x6C, 0x61, 0x73, 0x74, 0xDA, 0x05, 0x2C, 0x01, 0x00, 0x00, 0x3D, 0x02, 0x00, 0x00, 0x29, 0x04, 
  0x01, 0x00, 0x07, 0x03, 0x02, 0x04, 0x39, 0x02, 0x00, 0x03, 0x03, 0x02, 0x00, 0x00, 0x82, 0x99, 
  0x01, 0x03, 0x0E, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x03, 0x00, 0x03, 0xDA, 0x81, 0x65, 0xDA, 0x82, 
  0x15, 0xDA, 0x65, 0xDA, 0x81, 0x62, 0xDA, 0x80, 0xDA, 0xDA, 0x82, 0x31, 0x2C, 0x02, 0x00, 0x00, 
  0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x05, 0x01, 0x00, 
  0x33, 0x04, 0x05, 0x00, 0x19, 0x03, 0x04, 0x00, 0x32, 0x01, 0x00, 0x00, 0x2A, 0x06, 0x02, 0x00, 
  0x33, 0x05, 0x06, 0x00, 0x19, 0x06, 0x05, 0x00, 0x2A, 0x08, 0x03, 0x00, 0x38, 0x07, 0x06, 0x08, 
  0x19, 0x08, 0x07, 0x00, 0x2A, 0x09, 0x04, 0x00, 0x38, 0x07, 0x06, 0x09, 0x19, 0x09, 0x07, 0x00, 
  0x2A, 0x0A, 0x05, 0x00, 0x38, 0x07, 0x06, 0x0A, 0x19, 0x0A, 0x07, 0x00, 0x31, 0x00, 0x01, 0x06, 
  0x2A, 0x0B, 0x06, 0x00, 0x33, 0x07, 0x0B, 0x00, 0x19, 0x0B, 0x07, 0x00, 0x1C, 0x09, 0x07, 0x00, 
  0x2A, 0x0D, 0x07, 0x00, 0x30, 0x09, 0x0D, 0x00, 0x2A, 0x0E, 0x08, 0x00, 0x33, 0x0D, 0x0E, 0x00, 
  0x19, 0x0C, 0x0D, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x0C, 0x09, 0x00, 0x19, 0x0D, 0x0C, 0x00, 
  0x1C, 0x0D, 0x03, 0x00, 0x19, 0x0C, 0x0D, 0x00, 0x1A, 0x11, 0x00, 0x00, 0x1C, 0x08, 0x03, 0x00, 
  0x19, 0x0E, 0x08, 0x00, 0x1A, 0x0D, 0x00, 0x00, 0x2A, 0x0F, 0x07, 0x00, 0x30, 0x0F, 0x00, 0x00, 
  0x2A, 0x10, 0x09, 0x00, 0x33, 0x0F, 0x10, 0x00, 0x2F, 0x0F, 0x00, 0x00, 0x2A, 0x11, 0x0A, 0x00, 
  0x33, 0x10, 0x11, 0x00, 0x2A, 0x0F, 0x07, 0x00, 0x30, 0x10, 0x0F, 0x00, 0x2A, 0x11, 0x08, 0x00, 
  0x33, 0x0F, 0x11, 0x00, 0x19, 0x0E, 0x0F, 0x00, 0x19, 0x0C, 0x0E, 0x00, 0x19, 0x0D, 0x0C, 0x00, 
  0x26, 0x0F, 0x00, 0x00, 0x47, 0x0E, 0x0B, 0x0F, 0x19, 0x0F, 0x0E, 0x00, 0x1D, 0x0F, 0x26, 0x00, 
  0x38, 0x0E, 0x0B, 0x0F, 0x30, 0x0F, 0x0E, 0x00, 0x2A, 0x11, 0x0B, 0x00, 0x33, 0x10, 0x11, 0x00, 
  0x3B, 0x0E, 0x10, 0x00, 0x19, 0x11, 0x0E, 0x00, 0x3B, 0x0E, 0x10, 0x01, 0x19, 0x12, 0x0E, 0x00, 
  0x2F, 0x11, 0x00, 0x00, 0x2A, 0x10, 0x0C, 0x00, 0x33, 0x0E, 0x10, 0x00, 0x1C, 0x0E, 0x18, 0x00, 
  0x2A, 0x10, 0x0D, 0x00, 0x2F, 0x10, 0x00, 0x00, 0x33, 0x10, 0x12, 0x00, 0x2F, 0x10, 0x00, 0x00, 
  0x2A, 0x14, 0x0E, 0x00, 0x33, 0x13, 0x14, 0x00, 0x1C, 0x13, 0x10, 0x00, 0x2F, 0x0A, 0x00, 0x00, 
  0x2A, 0x14, 0x0E, 0x00, 0x33, 0x10, 0x14, 0x00, 0x2A, 0x14, 0x0D, 0x00, 0x30, 0x14, 0x10, 0x00, 
  0x42, 0x10, 0x00, 0x00, 0x30, 0x10, 0x12, 0x00, 0x2A, 0x15, 0x0F, 0x00, 0x33, 0x14, 0x15, 0x00, 
  0x19, 0x10, 0x14, 0x00, 0x30, 0x0D, 0x11, 0x00, 0x2A, 0x15, 0x10, 0x00, 0x33, 0x14, 0x15, 0x00, 
  0x3A, 0x03, 0x14, 0x10, 0x1A, 0x01, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x47, 0x0F, 0x0B, 0x0F, 
  0x1A, 0xDB, 0xFF, 0xFF, 0x04, 0x00, 0x00, 0x00, 0x89, 0x45, 0x01, 0x04, 0x1A, 0x00, 0x1A, 0x00, 
  0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x03, 0x01, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x03, 0x01, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x03, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x03, 0x02, 0x11, 0x00, 0x19, 0x00, 0x19, 0x00, 
  0x19, 0x00, 0x19, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0xBF, 0xFF, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 
  0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x03, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 
  0x00, 0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0xBF, 0xFD, 
  0x0F, 0x00, 0x0F, 0x00, 0x03, 0x04, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x24, 0x00, 
  0x24, 0x00, 0x24, 0x00, 0x03, 0x00, 0x3B, 0x00, 0x3B, 0x00, 0x3B, 0x00, 0x36, 0x00, 0x36, 0x00, 
  0x36, 0x00, 0x03, 0x01, 0x2A, 0x00, 0x2A, 0x00, 0x2A, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 
  0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x05, 0x01, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x05, 0xBF, 
  0xFE, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x29, 0x02, 0x01, 0x00, 0x06, 0x01, 
  0x00, 0x02, 0x2B, 0x03, 0x00, 0x00, 0x38, 0x02, 0x03, 0x01, 0x2A, 0x01, 0x00, 0x00, 0x2A, 0x03, 
  0x01, 0x00, 0x31, 0x02, 0x01, 0x03, 0x2A, 0x01, 0x02, 0x00, 0x2B, 0x03, 0x00, 0x08, 0x30, 0x01, 
  0x03, 0x00, 0x2A, 0x03, 0x03, 0x00, 0x33, 0x01, 0x03, 0x00, 0x29, 0x02, 0x02, 0x00, 0x03, 0x02, 
  0x00, 0x00, 0xBF, 0xFF, 0x8A, 0xB0, 0x1E, 0x00, 0x1E, 0x00, 0x15, 0x00, 0x15, 0x00, 0x0C, 0x00, 
  0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0xBF, 0xFF, 0x0A, 
  0x00, 0x0A, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x08, 0x02, 0x02, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x03, 
  0x0F, 0x01, 0xCE, 0x09, 0x64, 0x6F, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x72, 0xDA, 0x05, 0xCE, 
  0x0E, 0x75, 0x6E, 0x6B, 0x6E, 0x6F, 0x77, 0x6E, 0x20, 0x66, 0x6C, 0x61, 0x67, 0x20, 0x2D, 0xDA, 
  0x83, 0x95, 0xDA, 0x83, 0x8B, 0x2C, 0x02, 0x00, 0x00, 0x2B, 0x04, 0x00, 0x0D, 0x38, 0x03, 0x04, 
  0x00, 0x19, 0x04, 0x03, 0x00, 0x1C, 0x04, 0x03, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x34, 0x04, 0x00, 
  0x00, 0x2A, 0x05, 0x00, 0x00, 0x30, 0x05, 0x00, 0x00, 0x2A, 0x06, 0x01, 0x00, 0x33, 0x05, 0x06, 
  0x00, 0x2B, 0x06, 0x00, 0x0D, 0x2A, 0x07, 0x02, 0x00, 0x38, 0x05, 0x06, 0x07, 0x34, 0x05, 0x00, 
  0x00, 0xBF, 0xFF, 0x8A, 0xB9, 0x03, 0x01, 0x0C, 0x00, 0x0C, 0x00, 0x05, 0x01, 0x05, 0x00, 0x0B, 
  0x00, 0x0B, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x31, 0x00, 0x31, 0x00, 0x31, 
  0x00, 0x30, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x10, 0x04, 0x04, 0x04, 0x0C, 0x3F, 0x01, 0xCE, 0x09, 
  0x65, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x6F, 0x72, 0xDA, 0x05, 0xDA, 0x82, 0x97, 0xD5, 0x0A, 
  0xCF, 0x08, 0x64, 0x65, 0x66, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0xCB, 0xDA, 0x82, 0xDA, 0xD7, 0xCD, 
  0x00, 0x98, 0x00, 0x00, 0x04, 0x01, 0x01, 0x01, 0x02, 0x07, 0xCE, 0x0B, 0x69, 0x73, 0x2D, 0x73, 
  0x61, 0x66, 0x65, 0x2D, 0x64, 0x65, 0x66, 0xDA, 0x05, 0xDA, 0x84, 0x48, 0xD7, 0xCD, 0x00, 0x98, 
  0x00, 0x00, 0x09, 0x01, 0x01, 0x01, 0x08, 0x2B, 0xCE, 0x0F, 0x6E, 0x6F, 0x2D, 0x73, 0x69, 0x64, 
  0x65, 0x2D, 0x65, 0x66, 0x66, 0x65, 0x63, 0x74, 0x73, 0xDA, 0x05, 0xDA, 0x82, 0x97, 0xDA, 0x82, 
  0x18, 0xDA, 0x82, 0x19, 0xDA, 0x83, 0x60, 0xDA, 0x83, 0x63, 0xDA, 0x80, 0x89, 0xDA, 0x56, 0xD7, 
  0xCD, 0x00, 0x98, 0x00, 0x00, 0x0A, 0x01, 0x01, 0x01, 0x02, 0x17, 0xCE, 0x06, 0x76, 0x61, 0x6C, 
  0x75, 0x65, 0x73, 0xDA, 0x05, 0xDA, 0x55, 0xDA, 0x52, 0x2C, 0x01, 0x00, 0x00, 0x3D, 0x02, 0x00, 
  0x00, 0x2F, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x02, 0x03, 
  0x00, 0x26, 0x05, 0x00, 0x00, 0x47, 0x04, 0x00, 0x05, 0x19, 0x05, 0x04, 0x00, 0x26, 0x07, 0x00, 
  0x00, 0x23, 0x06, 0x07, 0x05, 0x1B, 0x06, 0x03, 0x00, 0x27, 0x06, 0x00, 0x00, 0x1A, 0x02, 0x00, 
  0x00, 0x28, 0x06, 0x00, 0x00, 0x1C, 0x06, 0x07, 0x00, 0x38, 0x07, 0x00, 0x05, 0x30, 0x02, 0x07, 
  0x00, 0x2A, 0x09, 0x01, 0x00, 0x33, 0x08, 0x09, 0x00, 0x47, 0x05, 0x00, 0x05, 0x1A, 0xF4, 0xFF, 
  0xFF, 0x03, 0x02, 0x00, 0x00, 0x85, 0x24, 0x01, 0x03, 0x17, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 
  0x00, 0x03, 0x01, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 
  0x00, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x15, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x0C, 
  0xBF, 0xFE, 0x03, 0xBF, 0xFB, 0x01, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 
  0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x1C, 0x02, 0x0B, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x04, 
  0x01, 0x00, 0x33, 0x03, 0x04, 0x00, 0x2A, 0x05, 0x02, 0x00, 0x23, 0x04, 0x03, 0x05, 0x1C, 0x04, 
  0x04, 0x00, 0x30, 0x01, 0x00, 0x00, 0x2A, 0x03, 0x03, 0x00, 0x34, 0x03, 0x00, 0x00, 0x04, 0x00, 
  0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x04, 0x04, 0x00, 0x33, 0x03, 0x04, 0x00, 0x1C, 0x03, 
  0x04, 0x00, 0x30, 0x01, 0x00, 0x00, 0x2A, 0x04, 0x03, 0x00, 0x34, 0x04, 0x00, 0x00, 0x2F, 0x00, 
  0x00, 0x00, 0x2A, 0x05, 0x05, 0x00, 0x33, 0x04, 0x05, 0x00, 0x1C, 0x04, 0x10, 0x00, 0x2F, 0x00, 
  0x00, 0x00, 0x2A, 0x06, 0x06, 0x00, 0x33, 0x05, 0x06, 0x00, 0x30, 0x01, 0x05, 0x00, 0x2A, 0x07, 
  0x03, 0x00, 0x33, 0x06, 0x07, 0x00, 0x19, 0x05, 0x06, 0x00, 0x1C, 0x06, 0x07, 0x00, 0x2F, 0x00, 
  0x00, 0x00, 0x2A, 0x08, 0x07, 0x00, 0x33, 0x07, 0x08, 0x00, 0x30, 0x01, 0x07, 0x00, 0x2A, 0x08, 
  0x03, 0x00, 0x34, 0x08, 0x00, 0x00, 0x03, 0x05, 0x00, 0x00, 0x27, 0x05, 0x00, 0x00, 0x03, 0x05, 
  0x00, 0x00, 0x8A, 0x5B, 0x01, 0x05, 0x05, 0x00, 0x05, 0x00, 0x05, 0xBF, 0xFF, 0x03, 0x02, 0x0C, 
  0x00, 0x0C, 0x00, 0x0C, 0x00, 0x09, 0x00, 0x09, 0x00, 0x05, 0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 
  0xBF, 0xFF, 0x05, 0x02, 0x05, 0x00, 0x05, 0x00, 0x05, 0xBF, 0xFC, 0x03, 0x05, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0xBF, 0xFA, 0x03, 0x07, 0x1F, 0x00, 0x1F, 0x00, 
  0x1F, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x05, 0x00, 0x05, 0x01, 0x1F, 0x00, 0x1F, 0x00, 
  0x1F, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0xBF, 0xFF, 0x05, 0xBF, 0xF9, 0x03, 0x00, 0x03, 0x2C, 
  0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2F, 
  0x02, 0x00, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x34, 0x03, 0x00, 0x00, 0x8A, 0x6A, 0x01, 0x00, 0x29, 
  0x00, 0x29, 0x00, 0x29, 0x00, 0x18, 0x00, 0x18, 0x00, 0x18, 0xCF, 0x09, 0x76, 0x61, 0x72, 0x67, 
  0x6C, 0x6F, 0x62, 0x61, 0x6C, 0xDA, 0x84, 0x53, 0xDA, 0x26, 0xDA, 0x84, 0x53, 0xCF, 0x09, 0x64, 
  0x65, 0x66, 0x67, 0x6C, 0x6F, 0x62, 0x61, 0x6C, 0xDA, 0x84, 0x53, 0xDA, 0x81, 0x91, 0xDA, 0x84, 
  0x53, 0xDA, 0x81, 0xE0, 0xCB, 0xDA, 0x76, 0xCB, 0xCF, 0x04, 0x64, 0x65, 0x66, 0x6E, 0xCB, 0xCF, 
  0x04, 0x76, 0x61, 0x72, 0x2D, 0xDA, 0x84, 0x53, 0xDA, 0x79, 0xCF, 0x03, 0x75, 0x73, 0x65, 0xDA, 
  0x70, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x08, 0x02, 0x02, 0x02, 0x05, 0x14, 0xCE, 0x05, 0x75, 
  0x73, 0x65, 0x2D, 0x32, 0xDA, 0x05, 0xDA, 0x6F, 0xDA, 0x83, 0x8F, 0xDA, 0x67, 0xDA, 0x80, 0xD5, 
  0xDA, 0x84, 0x49, 0x2C, 0x02, 0x00, 0x00, 0x26, 0x04, 0x00, 0x00, 0x47, 0x03, 0x01, 0x04, 0x19, 
  0x04, 0x03, 0x00, 0x1D, 0x04, 0x0F, 0x00, 0x38, 0x03, 0x01, 0x04, 0x19, 0x05, 0x03, 0x00, 0x2F, 
  0x05, 0x00, 0x00, 0x2A, 0x06, 0x00, 0x00, 0x33, 0x03, 0x06, 0x00, 0x2A, 0x06, 0x01, 0x00, 0x2A, 
  0x07, 0x02, 0x00, 0x31, 0x03, 0x06, 0x07, 0x2A, 0x06, 0x03, 0x00, 0x30, 0x06, 0x00, 0x00, 0x2A, 
  0x07, 0x04, 0x00, 0x33, 0x06, 0x07, 0x00, 0x47, 0x04, 0x01, 0x04, 0x1A, 0xF2, 0xFF, 0xFF, 0x04, 
  0x00, 0x00, 0x00, 0x8A, 0x71, 0x01, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 
  0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xD5, 0x04, 0xCF, 0x07, 
  0x69, 0x6D, 0x70, 0x6F, 0x72, 0x74, 0x2A, 0xCB, 0xCF, 0x06, 0x69, 0x6D, 0x70, 0x6F, 0x72, 0x74, 
  0xCB, 0xDA, 0x83, 0x5C, 0xCB, 0xDA, 0x81, 0x83, 0xCB, 0xDA, 0x0F, 0xDA, 0x80, 0xD5, 0xDA, 0x81, 
  0x65, 0xDA, 0x81, 0x5A, 0xDA, 0x81, 0x00, 0x2C, 0x04, 0x00, 0x00, 0x2B, 0x05, 0x00, 0x0B, 0x1C, 
  0x05, 0x3C, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x06, 0x00, 0x00, 0x33, 0x05, 0x06, 0x00, 0x1C, 
  0x05, 0x37, 0x00, 0x29, 0x06, 0x00, 0x00, 0x2F, 0x06, 0x00, 0x00, 0x33, 0x06, 0x01, 0x00, 0x19, 
  0x07, 0x06, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x2A, 0x08, 0x01, 0x00, 0x33, 0x06, 0x08, 0x00, 0x19, 
  0x08, 0x06, 0x00, 0x2F, 0x08, 0x00, 0x00, 0x2A, 0x09, 0x02, 0x00, 0x33, 0x06, 0x09, 0x00, 0x1C, 
  0x06, 0x06, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x33, 0x09, 0x08, 0x00, 0x1C, 0x09, 0x02, 0x00, 0x34, 
  0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x1C, 0x08, 0x02, 0x00, 0x34, 0x00, 0x00, 0x00, 0x2A, 
  0x0A, 0x03, 0x00, 0x23, 0x09, 0x0A, 0x07, 0x1C, 0x09, 0x08, 0x00, 0x29, 0x0A, 0x01, 0x00, 0x30, 
  0x01, 0x0A, 0x00, 0x2A, 0x0B, 0x04, 0x00, 0x33, 0x0A, 0x0B, 0x00, 0x30, 0x04, 0x0A, 0x00, 0x2A, 
  0x0B, 0x05, 0x00, 0x34, 0x0B, 0x00, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x2A, 0x0B, 0x06, 0x00, 0x33, 
  0x0A, 0x0B, 0x00, 0x1C, 0x0A, 0x15, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x0C, 0x07, 0x00, 0x33, 
  0x0B, 0x0C, 0x00, 0x3B, 0x0C, 0x0B, 0x00, 0x19, 0x0D, 0x0C, 0x00, 0x3B, 0x0C, 0x0B, 0x01, 0x19, 
  0x0E, 0x0C, 0x00, 0x32, 0x01, 0x00, 0x00, 0x2A, 0x0B, 0x08, 0x00, 0x30, 0x0B, 0x04, 0x00, 0x2A, 
  0x0C, 0x09, 0x00, 0x33, 0x0B, 0x0C, 0x00, 0x31, 0x0B, 0x0D, 0x0E, 0x2A, 0x0F, 0x0A, 0x00, 0x33, 
  0x0C, 0x0F, 0x00, 0x19, 0x0B, 0x0C, 0x00, 0x31, 0x0B, 0x02, 0x03, 0x2A, 0x0F, 0x0B, 0x00, 0x33, 
  0x0C, 0x0F, 0x00, 0x34, 0x0C, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x34, 
  0x00, 0x00, 0x00, 0xBF, 0xFF, 0x8A, 0xBD, 0x03, 0x02, 0x05, 0x00, 0x05, 0x01, 0x0D, 0x00, 0x0D, 
  0x00, 0x0D, 0x00, 0x07, 0x01, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x09, 0x01, 0x19, 0x00, 0x19, 
  0x00, 0x19, 0x00, 0x09, 0x03, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0xBF, 0xFE, 0x09, 0x03, 0x0F, 0x00, 
  0x0F, 0x00, 0x0B, 0x00, 0x23, 0x00, 0x0B, 0xBF, 0xFD, 0x09, 0x06, 0x0B, 0x02, 0x0B, 0x00, 0x0B, 
  0xBF, 0xF8, 0x09, 0x09, 0x1C, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0x0B, 0x00, 0x0B, 0x00, 
  0x0B, 0x02, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0xBF, 0xF5, 0x09, 0x0D, 0x19, 0x00, 0x19, 0x00, 0x19, 
  0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x01, 0x28, 0x00, 0x28, 0x00, 0x28, 0x00, 0x28, 
  0x00, 0x28, 0x00, 0x1A, 0x00, 0x1A, 0x00, 0x1A, 0xBF, 0xFF, 0x0D, 0x02, 0x10, 0x00, 0x10, 0x00, 
  0x10, 0x00, 0x0F, 0xBF, 0xF1, 0x09, 0xBF, 0xFD, 0x07, 0x13, 0x07, 0xCD, 0x00, 0x98, 0x00, 0x00, 
  0x07, 0x01, 0x01, 0x01, 0x07, 0x11, 0xCE, 0x09, 0x67, 0x65, 0x74, 0x70, 0x72, 0x6F, 0x6D, 0x70, 
  0x74, 0xDA, 0x05, 0xDA, 0x80, 0xE6, 0xDA, 0x83, 0x9B, 0xDA, 0x82, 0xE0, 0xCE, 0x06, 0x6A, 0x61, 
  0x6E, 0x65, 0x74, 0x3A, 0xDA, 0x83, 0x28, 0xDA, 0x83, 0x9D, 0xDA, 0x6F, 0x2C, 0x01, 0x00, 0x00, 
  0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x3B, 0x03, 0x02, 0x00, 
  0x19, 0x04, 0x03, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x30, 0x00, 0x03, 0x00, 0x2A, 0x05, 0x02, 0x00, 
  0x33, 0x03, 0x05, 0x00, 0x2A, 0x05, 0x03, 0x00, 0x2A, 0x06, 0x04, 0x00, 0x31, 0x05, 0x04, 0x06, 
  0x2A, 0x05, 0x05, 0x00, 0x30, 0x03, 0x05, 0x00, 0x2A, 0x05, 0x06, 0x00, 0x34, 0x05, 0x00, 0x00, 
  0x8A, 0xEB, 0x05, 0x01, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x07, 0x00, 0x07, 0x01, 0x21, 0x00, 
  0x21, 0x00, 0x21, 0x00, 0x21, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 
  0x07, 0x00, 0x07, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x08, 0x03, 0x03, 0x03, 0x06, 0x0E, 0xCE, 0x08, 
  0x67, 0x65, 0x74, 0x73, 0x74, 0x64, 0x69, 0x6E, 0xDA, 0x05, 0xD8, 0x06, 0x73, 0x74, 0x64, 0x6F, 
  0x75, 0x74, 0xDA, 0x84, 0x3C, 0xDA, 0x83, 0x04, 0xDA, 0x81, 0x4D, 0xDA, 0x81, 0x01, 0xDA, 0x81, 
  0x0A, 0x2C, 0x03, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x30, 0x04, 0x00, 0x00, 0x2A, 0x05, 0x01, 
  0x00, 0x33, 0x04, 0x05, 0x00, 0x2A, 0x05, 0x00, 0x00, 0x2F, 0x05, 0x00, 0x00, 0x2A, 0x06, 0x02, 
  0x00, 0x33, 0x05, 0x06, 0x00, 0x2A, 0x06, 0x03, 0x00, 0x2A, 0x07, 0x04, 0x00, 0x31, 0x06, 0x07, 
  0x01, 0x2A, 0x06, 0x05, 0x00, 0x34, 0x06, 0x00, 0x00, 0x8A, 0xEE, 0x05, 0x01, 0x07, 0x00, 0x07, 
  0x00, 0x07, 0x00, 0x07, 0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x01, 0x07, 0x00, 0x07, 
  0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x05, 0x02, 0x02, 0x02, 0x00, 
  0x08, 0x01, 0xCE, 0x08, 0x67, 0x65, 0x74, 0x63, 0x68, 0x75, 0x6E, 0x6B, 0xDA, 0x05, 0x2C, 0x02, 
  0x00, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2B, 0x04, 0x00, 0x17, 0x33, 0x03, 0x04, 0x00, 0x2B, 0x04, 
  0x00, 0x19, 0x31, 0x03, 0x00, 0x04, 0x2B, 0x04, 0x00, 0x1A, 0x34, 0x04, 0x00, 0x00, 0xBF, 0xFF, 
  0x8A, 0xF5, 0x05, 0x01, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 
  0x07, 0x8A, 0x77, 0x01, 0x05, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x02, 0x03, 0x01, 0x03, 
  0x01, 0x03, 0x01, 0x03, 0x01, 0x03, 0x01, 0x03, 0x01, 0x03, 0x01, 0x03, 0x01, 0x03, 0x02, 0x0F, 
  0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x03, 0x00, 0x03, 0x00, 0x2C, 0x00, 0x2C, 0x00, 0x2C, 
  0x00, 0x2C, 0x00, 0x03, 0x01, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x32, 0x00, 0x32, 0x00, 0x32, 0x00, 0x32, 0x00, 0x03, 0x2A, 0x0A, 0xBF, 0xF2, 0x0A, 0x12, 
  0x0A, 0xBF, 0xF2, 0x0A, 0xBF, 0xFF, 0x0A, 0xBF, 0xFF, 0x0A, 0xBF, 0xFF, 0x0A, 0xBF, 0xFE, 0x0A, 
  0xBF, 0xFF, 0x0A, 0xBF, 0xEA, 0x0A, 0x15, 0x0A, 0x0C, 0x0A, 0xBF, 0xF3, 0x0A, 0x0E, 0x0A, 0xBF, 
  0xDD, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x2D, 0x03, 0x00, 0x03, 0x04, 0x03, 0x00, 0x03, 0x19, 0x03, 0x01, 0x10, 
  0x00, 0x03, 0x01, 0x0A, 0x00, 0x03, 0x01, 0x0E, 0x00, 0x05, 0x01, 0x09, 0x00, 0x22, 0x00, 0x22, 
  0x00, 0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x1B, 0x00, 0x1B, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 
  0x00, 0x05, 0x01, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x07, 
  0xBF, 0xFF, 0x05, 0x03, 0x09, 0x01, 0x12, 0x00, 0x12, 0x00, 0x09, 0x01, 0x16, 0x00, 0x16, 0x00, 
  0x16, 0x00, 0x09, 0x01, 0x09, 0x00, 0x09, 0x01, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 
  0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x01, 0x1C, 0x00, 0x1C, 0x00, 
  0x17, 0x00, 0x17, 0x00, 0x09, 0x00, 0x09, 0x01, 0x27, 0x00, 0x27, 0x00, 0x27, 0x00, 0x20, 0x00, 
  0x20, 0x00, 0x20, 0x00, 0x17, 0x00, 0x17, 0x00, 0x17, 0x00, 0x0B, 0x01, 0x11, 0x00, 0x11, 0x00, 
  0x11, 0x00, 0x0D, 0x00, 0x23, 0x00, 0x0D, 0x00, 0x32, 0x00, 0x32, 0x00, 0x32, 0x00, 0x2B, 0xBF, 
  0xFE, 0x09, 0x03, 0x09, 0xBF, 0xF3, 0x03, 0x0F, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x09, 0x00, 
  0x09, 0x00, 0x23, 0x00, 0x23, 0x00, 0x23, 0x00, 0x23, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 
  0x03, 0x01, 0x05, 0x00, 0x05, 0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 
  0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x01, 0x05, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 0x03, 
  0x05, 0x00, 0x05, 0x04, 0x0E, 0x00, 0x0E, 0x00, 0x05, 0x01, 0x05, 0x00, 0x11, 0x00, 0x11, 0x00, 
  0x11, 0x00, 0x05, 0x01, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x05, 0x01, 0x05, 0x00, 
  0x05, 0x02, 0x1C, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x01, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xBF, 0xEE, 0x03, 0xF9, 0x2F, 0x80, 0x06, 
  0xCF, 0x04, 0x6E, 0x6F, 0x74, 0x3D, 0xDA, 0x81, 0xB2, 0xCF, 0x0C, 0x61, 0x72, 0x72, 0x61, 0x79, 
  0x2F, 0x69, 0x6E, 0x73, 0x65, 0x72, 0x74, 0xD8, 0x0C, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x69, 
  0x6E, 0x73, 0x65, 0x72, 0x74, 0xCF, 0x08, 0x72, 0x6F, 0x6F, 0x74, 0x2D, 0x65, 0x6E, 0x76, 0xDA, 
  0x00, 0xCF, 0x04, 0x68, 0x61, 0x73, 0x68, 0xD8, 0x04, 0x68, 0x61, 0x73, 0x68, 0xCF, 0x0E, 0x73, 
  0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x72, 0x65, 0x76, 0x65, 0x72, 0x73, 0x65, 0xD8, 0x0E, 0x73, 
  0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x72, 0x65, 0x76, 0x65, 0x72, 0x73, 0x65, 0xCF, 0x02, 0x70, 
  0x70, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 0x05, 0x0B, 0xCE, 0x02, 0x70, 
  0x70, 0xDA, 0x05, 0xDA, 0x83, 0x2B, 0xDA, 0x83, 0x2C, 0xDA, 0x7D, 0xDA, 0x83, 0x44, 0xDA, 0x83, 
  0x96, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x30, 0x02, 0x03, 
  0x00, 0x2A, 0x03, 0x02, 0x00, 0x33, 0x02, 0x03, 0x00, 0x30, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x03, 
  0x00, 0x33, 0x03, 0x04, 0x00, 0x2A, 0x02, 0x04, 0x00, 0x34, 0x02, 0x00, 0x00, 0x85, 0xA5, 0x01, 
  0x03, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x01, 0x03, 0x00, 0x03, 0xCF, 0x08, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0x3E, 0xD7, 0xCD, 
  0x00, 0x99, 0x00, 0x00, 0x03, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x02, 0x05, 0xCE, 0x08, 
  0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0x3E, 0xDA, 0x05, 0xDA, 0x81, 0x7D, 0xDA, 0x82, 0xD2, 
  0x2C, 0x01, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x30, 0x02, 0x00, 0x00, 0x2A, 0x02, 0x01, 0x00, 
  0x34, 0x02, 0x00, 0x00, 0x82, 0xD0, 0x01, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 
  0x06, 0x73, 0x65, 0x74, 0x64, 0x79, 0x6E, 0xDA, 0x82, 0x26, 0xCF, 0x03, 0x64, 0x79, 0x6E, 0xDA, 
  0x7D, 0xCF, 0x0E, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x63, 0x6F, 0x6E, 0x73, 0x75, 0x6D, 
  0x65, 0xDA, 0x80, 0xF3, 0xCF, 0x0D, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x72, 0x65, 0x70, 
  0x65, 0x61, 0x74, 0xDA, 0x83, 0xC6, 0xCF, 0x07, 0x70, 0x72, 0x6F, 0x64, 0x75, 0x63, 0x74, 0xD7, 
  0xCD, 0x00, 0x98, 0x00, 0x00, 0x06, 0x01, 0x01, 0x01, 0x00, 0x0C, 0xCE, 0x07, 0x70, 0x72, 0x6F, 
  0x64, 0x75, 0x63, 0x74, 0xDA, 0x05, 0x2C, 0x01, 0x00, 0x00, 0x29, 0x02, 0x01, 0x00, 0x26, 0x04, 
  0x00, 0x00, 0x47, 0x03, 0x00, 0x04, 0x19, 0x04, 0x03, 0x00, 0x1D, 0x04, 0x06, 0x00, 0x38, 0x03, 
  0x00, 0x04, 0x19, 0x05, 0x03, 0x00, 0x09, 0x02, 0x02, 0x05, 0x47, 0x04, 0x00, 0x04, 0x1A, 0xFB, 
  0xFF, 0xFF, 0x03, 0x02, 0x00, 0x00, 0x82, 0x40, 0x01, 0x03, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x0E, 0x00, 0x03, 0x00, 0x03, 0xBF, 0xFC, 0x01, 
  0xCF, 0x05, 0x61, 0x72, 0x72, 0x61, 0x79, 0xD8, 0x05, 0x61, 0x72, 0x72, 0x61, 0x79, 0xCF, 0x04, 
  0x64, 0x6F, 0x63, 0x2A, 0xD7, 0xCD, 0x02, 0xBA, 0x00, 0x00, 0x10, 0x01, 0x00, 0x01, 0x1A, 0x79, 
  0x01, 0xCE, 0x04, 0x64, 0x6F, 0x63, 0x2A, 0xDA, 0x05, 0xDA, 0x80, 0xCA, 0xD7, 0xCD, 0x00, 0x98, 
  0x00, 0x00, 0x0C, 0x01, 0x01, 0x01, 0x0C, 0x33, 0xCE, 0x0B, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x2D, 
  0x69, 0x6E, 0x64, 0x65, 0x78, 0xDA, 0x05, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x04, 0x02, 0x00, 
  0x02, 0x02, 0x05, 0xCE, 0x0C, 0x61, 0x6C, 0x6C, 0x2D, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 
  0x73, 0xDA, 0x05, 0xDA, 0x82, 0x15, 0xDA, 0x5F, 0x2C, 0x02, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 
  0x31, 0x03, 0x00, 0x01, 0x2A, 0x03, 0x01, 0x00, 0x34, 0x03, 0x00, 0x00, 0x86, 0x2B, 0x01, 0x05, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xDA, 0x80, 0xC3, 0xDA, 0x60, 0xD8, 0x08, 0x64, 0x65, 
  0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0xDA, 0x80, 0xBF, 0xDA, 0x83, 0x95, 0xDA, 0x6A, 0xDA, 0x81, 
  0xC2, 0xCE, 0x0B, 0x42, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x3A, 0x0A, 0x0A, 0xDA, 0x6F, 
  0xDA, 0x81, 0xED, 0xCE, 0x0B, 0x44, 0x79, 0x6E, 0x61, 0x6D, 0x69, 0x63, 0x73, 0x3A, 0x0A, 0x0A, 
  0x2C, 0x01, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x30, 0x00, 0x02, 0x00, 
  0x2A, 0x04, 0x01, 0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x02, 0x03, 0x00, 0x2A, 0x05, 0x02, 0x00, 
  0x33, 0x04, 0x05, 0x00, 0x30, 0x00, 0x04, 0x00, 0x2A, 0x06, 0x01, 0x00, 0x33, 0x05, 0x06, 0x00, 
  0x2A, 0x04, 0x03, 0x00, 0x30, 0x04, 0x05, 0x00, 0x2A, 0x06, 0x04, 0x00, 0x33, 0x04, 0x06, 0x00, 
  0x19, 0x05, 0x04, 0x00, 0x2A, 0x07, 0x05, 0x00, 0x33, 0x06, 0x07, 0x00, 0x2A, 0x07, 0x06, 0x00, 
  0x30, 0x02, 0x07, 0x00, 0x2A, 0x08, 0x07, 0x00, 0x33, 0x07, 0x08, 0x00, 0x2A, 0x08, 0x08, 0x00, 
  0x30, 0x08, 0x07, 0x00, 0x2A, 0x09, 0x09, 0x00, 0x33, 0x08, 0x09, 0x00, 0x2F, 0x08, 0x00, 0x00, 
  0x2A, 0x09, 0x0A, 0x00, 0x33, 0x07, 0x09, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x2A, 0x09, 0x05, 0x00, 
  0x33, 0x08, 0x09, 0x00, 0x2A, 0x09, 0x05, 0x00, 0x33, 0x07, 0x09, 0x00, 0x2A, 0x09, 0x06, 0x00, 
  0x30, 0x05, 0x09, 0x00, 0x2A, 0x0A, 0x07, 0x00, 0x33, 0x09, 0x0A, 0x00, 0x2A, 0x0A, 0x0B, 0x00, 
  0x30, 0x0A, 0x09, 0x00, 0x2A, 0x0B, 0x09, 0x00, 0x33, 0x0A, 0x0B, 0x00, 0x2F, 0x0A, 0x00, 0x00, 
  0x2A, 0x0B, 0x0A, 0x00, 0x33, 0x09, 0x0B, 0x00, 0x2F, 0x09, 0x00, 0x00, 0x2A, 0x0B, 0x05, 0x00, 
  0x33, 0x0A, 0x0B, 0x00, 0x2A, 0x09, 0x05, 0x00, 0x34, 0x09, 0x00, 0x00, 0x86, 0x5F, 0x01, 0x03, 
  0x1E, 0x00, 0x1E, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x03, 0x01, 0x2C, 0x00, 0x2C, 0x00, 
  0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x03, 0x01, 
  0x03, 0x00, 0x03, 0x01, 0x2E, 0x00, 0x2E, 0x00, 0x2E, 0x00, 0x2E, 0x00, 0x16, 0x00, 0x16, 0x00, 
  0x16, 0x00, 0x16, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 
  0x03, 0x00, 0x03, 0x01, 0x2E, 0x00, 0x2E, 0x00, 0x2E, 0x00, 0x2E, 0x00, 0x16, 0x00, 0x16, 0x00, 
  0x16, 0x00, 0x16, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 
  0x03, 0x00, 0x03, 0xDA, 0x7D, 0xDA, 0x81, 0x62, 0xCE, 0x07, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 
  0x20, 0xCE, 0x0B, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x2E, 0xDA, 0x83, 
  0x95, 0xD0, 0x03, 0x72, 0x65, 0x66, 0xDA, 0x39, 0xD0, 0x03, 0x76, 0x61, 0x72, 0xCE, 0x02, 0x20, 
  0x28, 0xCE, 0x01, 0x29, 0xDA, 0x6F, 0xDA, 0x35, 0xDA, 0x03, 0xDA, 0x81, 0xE9, 0xDA, 0x84, 0x27, 
  0xDA, 0x0B, 0xDA, 0x09, 0xDA, 0x67, 0xDA, 0x81, 0x04, 0xDA, 0x80, 0xEA, 0xDA, 0x81, 0xED, 0xCE, 
  0x1B, 0x20, 0x20, 0x20, 0x20, 0x6E, 0x6F, 0x20, 0x64, 0x6F, 0x63, 0x75, 0x6D, 0x65, 0x6E, 0x74, 
  0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x2E, 0xCE, 0x02, 0x0A, 0x0A, 
  0xDA, 0x80, 0xC1, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 
  0x02, 0x03, 0x00, 0x1C, 0x02, 0x05, 0x00, 0x2E, 0x03, 0x00, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x2A, 
  0x04, 0x01, 0x00, 0x34, 0x04, 0x00, 0x00, 0x1C, 0x00, 0x6C, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 
  0x04, 0x02, 0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x04, 0x03, 0x00, 0x2F, 0x04, 0x00, 0x00, 0x2A, 
  0x05, 0x03, 0x00, 0x33, 0x03, 0x05, 0x00, 0x1C, 0x03, 0x06, 0x00, 0x2A, 0x05, 0x04, 0x00, 0x2A, 
  0x06, 0x05, 0x00, 0x31, 0x05, 0x00, 0x06, 0x2A, 0x05, 0x06, 0x00, 0x34, 0x05, 0x00, 0x00, 0x2A, 
  0x06, 0x07, 0x00, 0x2F, 0x06, 0x00, 0x00, 0x33, 0x06, 0x04, 0x00, 0x1C, 0x06, 0x12, 0x00, 0x2A, 
  0x07, 0x07, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x33, 0x07, 0x04, 0x00, 0x29, 0x09, 0x00, 0x00, 0x38, 
  0x08, 0x07, 0x09, 0x2F, 0x08, 0x00, 0x00, 0x2A, 0x09, 0x08, 0x00, 0x33, 0x07, 0x09, 0x00, 0x2A, 
  0x08, 0x09, 0x00, 0x2A, 0x09, 0x0A, 0x00, 0x31, 0x08, 0x09, 0x07, 0x2A, 0x08, 0x0B, 0x00, 0x2F, 
  0x08, 0x00, 0x00, 0x2A, 0x09, 0x0C, 0x00, 0x33, 0x08, 0x09, 0x00, 0x19, 0x05, 0x08, 0x00, 0x1A, 
  0x0F, 0x00, 0x00, 0x2A, 0x08, 0x0D, 0x00, 0x2F, 0x08, 0x00, 0x00, 0x33, 0x08, 0x04, 0x00, 0x1C, 
  0x08, 0x03, 0x00, 0x2A, 0x07, 0x0D, 0x00, 0x1A, 0x08, 0x00, 0x00, 0x2A, 0x09, 0x0E, 0x00, 0x2F, 
  0x09, 0x00, 0x00, 0x33, 0x09, 0x04, 0x00, 0x2F, 0x09, 0x00, 0x00, 0x2A, 0x0B, 0x08, 0x00, 0x33, 
  0x0A, 0x0B, 0x00, 0x19, 0x07, 0x0A, 0x00, 0x19, 0x05, 0x07, 0x00, 0x2A, 0x06, 0x0F, 0x00, 0x2A, 
  0x07, 0x10, 0x00, 0x31, 0x06, 0x05, 0x07, 0x2A, 0x07, 0x0C, 0x00, 0x33, 0x06, 0x07, 0x00, 0x19, 
  0x05, 0x06, 0x00, 0x2A, 0x06, 0x11, 0x00, 0x2F, 0x06, 0x00, 0x00, 0x33, 0x06, 0x04, 0x00, 0x19, 
  0x07, 0x06, 0x00, 0x2A, 0x06, 0x12, 0x00, 0x2F, 0x06, 0x00, 0x00, 0x33, 0x06, 0x04, 0x00, 0x19, 
  0x08, 0x06, 0x00, 0x1C, 0x08, 0x03, 0x00, 0x19, 0x06, 0x05, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x2A, 
  0x06, 0x13, 0x00, 0x19, 0x09, 0x07, 0x00, 0x1C, 0x09, 0x12, 0x00, 0x3B, 0x0B, 0x09, 0x00, 0x19, 
  0x0C, 0x0B, 0x00, 0x3B, 0x0B, 0x09, 0x01, 0x19, 0x0D, 0x0B, 0x00, 0x3B, 0x0B, 0x09, 0x02, 0x19, 
  0x0E, 0x0B, 0x00, 0x2A, 0x0B, 0x0F, 0x00, 0x2A, 0x0F, 0x14, 0x00, 0x31, 0x0B, 0x0C, 0x0F, 0x2A, 
  0x0B, 0x15, 0x00, 0x31, 0x0D, 0x0B, 0x0E, 0x2A, 0x0B, 0x10, 0x00, 0x2F, 0x0B, 0x00, 0x00, 0x2A, 
  0x0F, 0x0C, 0x00, 0x33, 0x0B, 0x0F, 0x00, 0x19, 0x0A, 0x0B, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x2A, 
  0x0A, 0x13, 0x00, 0x1C, 0x08, 0x03, 0x00, 0x19, 0x0B, 0x08, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 
  0x0B, 0x07, 0x00, 0x1C, 0x0B, 0x03, 0x00, 0x2A, 0x09, 0x10, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x2A, 
  0x09, 0x13, 0x00, 0x1C, 0x08, 0x06, 0x00, 0x2F, 0x08, 0x00, 0x00, 0x2A, 0x0D, 0x16, 0x00, 0x33, 
  0x0C, 0x0D, 0x00, 0x19, 0x0B, 0x0C, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x2A, 0x0B, 0x17, 0x00, 0x2A, 
  0x0C, 0x18, 0x00, 0x31, 0x0C, 0x06, 0x0A, 0x2A, 0x0C, 0x18, 0x00, 0x31, 0x09, 0x0B, 0x0C, 0x2A, 
  0x0C, 0x06, 0x00, 0x34, 0x0C, 0x00, 0x00, 0x2A, 0x03, 0x19, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x2A, 
  0x03, 0x01, 0x00, 0x34, 0x03, 0x00, 0x00, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x02, 0x01, 0x01, 0x01, 
  0x01, 0x04, 0x01, 0xDA, 0x05, 0xD8, 0x0B, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x66, 0x69, 
  0x6E, 0x64, 0x2B, 0x01, 0x00, 0x00, 0x30, 0x01, 0x00, 0x00, 0x2A, 0x01, 0x00, 0x00, 0x34, 0x01, 
  0x00, 0x00, 0xBF, 0xFF, 0x86, 0x70, 0x1A, 0x00, 0x1A, 0x00, 0x1A, 0x00, 0x1A, 0x86, 0x6A, 0x01, 
  0x05, 0x05, 0x00, 0x05, 0x00, 0x05, 0xBF, 0xFF, 0x03, 0x02, 0x12, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0xBF, 0xFE, 0x03, 0x06, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x07, 0x01, 0x0B, 0x00, 0x0B, 
  0x00, 0x0B, 0x00, 0x07, 0x01, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x05, 0x17, 
  0x00, 0x17, 0x00, 0x17, 0xBF, 0xFF, 0x15, 0x01, 0x3C, 0x00, 0x3C, 0x00, 0x3C, 0x00, 0x38, 0x00, 
  0x38, 0x00, 0x32, 0x00, 0x32, 0x00, 0x32, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 
  0x20, 0x00, 0x20, 0x00, 0x20, 0xBF, 0xFF, 0x15, 0x00, 0x15, 0x02, 0x17, 0x00, 0x17, 0x00, 0x17, 
  0xBF, 0xFE, 0x15, 0x00, 0x15, 0x00, 0x15, 0x03, 0x1D, 0x00, 0x1D, 0x00, 0x1D, 0x00, 0x17, 0x00, 
  0x17, 0x00, 0x17, 0xBF, 0xFD, 0x15, 0x00, 0x15, 0xBF, 0xFF, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 
  0x0D, 0x00, 0x0D, 0xBF, 0xFF, 0x0B, 0x07, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x0B, 0x01, 0x12, 
  0x00, 0x12, 0x00, 0x12, 0x00, 0x0B, 0x02, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x01, 0x12, 
  0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x01, 0x14, 
  0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 
  0xBF, 0xFF, 0x12, 0x00, 0x12, 0x00, 0x12, 0x02, 0x16, 0x00, 0x16, 0x00, 0x16, 0x00, 0x16, 0x00, 
  0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x01, 0x12, 0x00, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 
  0x12, 0x00, 0x12, 0x00, 0x12, 0xBF, 0xFB, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 
  0x00, 0x0B, 0x09, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x00, 0x00, 0x00, 0xCF, 0x03, 
  0x6D, 0x61, 0x70, 0xDA, 0x80, 0xBF, 0xCF, 0x06, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0xDA, 0x84, 
  0x51, 0xCF, 0x04, 0x6A, 0x75, 0x78, 0x74, 0xD7, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x0B, 0x00, 0x00, 
  0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x08, 0x23, 0xCE, 0x04, 0x6A, 0x75, 0x78, 0x74, 0xDA, 0x05, 0xDA, 
  0x81, 0xB4, 0xDA, 0x22, 0xDA, 0x82, 0xE7, 0xDA, 0x81, 0x65, 0xDA, 0x52, 0xDA, 0x82, 0x32, 0xDA, 
  0x70, 0xDA, 0x23, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x2F, 0x02, 0x00, 0x00, 0x3E, 
  0x02, 0x00, 0x00, 0x19, 0x03, 0x02, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x33, 0x04, 0x05, 0x00, 0x19, 
  0x05, 0x04, 0x00, 0x26, 0x07, 0x00, 0x00, 0x47, 0x06, 0x00, 0x07, 0x19, 0x07, 0x06, 0x00, 0x1D, 
  0x07, 0x0C, 0x00, 0x38, 0x06, 0x00, 0x07, 0x19, 0x08, 0x06, 0x00, 0x2A, 0x06, 0x02, 0x00, 0x31, 
  0x06, 0x08, 0x05, 0x2A, 0x09, 0x03, 0x00, 0x33, 0x06, 0x09, 0x00, 0x30, 0x03, 0x06, 0x00, 0x2A, 
  0x0A, 0x04, 0x00, 0x33, 0x09, 0x0A, 0x00, 0x47, 0x07, 0x00, 0x07, 0x1A, 0xF5, 0xFF, 0xFF, 0x2A, 
  0x06, 0x05, 0x00, 0x30, 0x06, 0x05, 0x00, 0x2A, 0x07, 0x03, 0x00, 0x33, 0x06, 0x07, 0x00, 0x29, 
  0x07, 0x00, 0x00, 0x30, 0x03, 0x07, 0x00, 0x2A, 0x08, 0x06, 0x00, 0x33, 0x07, 0x08, 0x00, 0x2A, 
  0x08, 0x07, 0x00, 0x31, 0x08, 0x06, 0x07, 0x2A, 0x08, 0x03, 0x00, 0x34, 0x08, 0x00, 0x00, 0x83, 
  0xEA, 0x01, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x0E, 0x00, 0x0E, 0x00, 0x03, 
  0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x17, 0x00, 0x17, 
  0x00, 0x17, 0x00, 0x17, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xBF, 0xFF, 0x03, 0x00, 0x03, 0x02, 
  0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x08, 0x67, 0x65, 0x6E, 0x65, 0x72, 0x61, 0x74, 
  0x65, 0xD7, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x07, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x06, 
  0x14, 0xCE, 0x08, 0x67, 0x65, 0x6E, 0x65, 0x72, 0x61, 0x74, 0x65, 0xDA, 0x05, 0xDA, 0x2F, 0xCF, 
  0x05, 0x79, 0x69, 0x65, 0x6C, 0x64, 0xDA, 0x81, 0x57, 0xDA, 0x23, 0xCF, 0x09, 0x66, 0x69, 0x62, 
  0x65, 0x72, 0x2F, 0x6E, 0x65, 0x77, 0xDA, 0x81, 0x06, 0x2C, 0x02, 0x00, 0x00, 0x44, 0x03, 0x00, 
  0x00, 0x2A, 0x05, 0x00, 0x00, 0x2F, 0x05, 0x00, 0x00, 0x32, 0x01, 0x00, 0x00, 0x43, 0x04, 0x00, 
  0x00, 0x2A, 0x06, 0x01, 0x00, 0x30, 0x06, 0x04, 0x00, 0x43, 0x05, 0x00, 0x00, 0x2A, 0x06, 0x02, 
  0x00, 0x31, 0x06, 0x00, 0x05, 0x43, 0x04, 0x00, 0x00, 0x2A, 0x06, 0x03, 0x00, 0x31, 0x06, 0x03, 
  0x04, 0x43, 0x05, 0x00, 0x00, 0x2A, 0x04, 0x04, 0x00, 0x2A, 0x06, 0x05, 0x00, 0x31, 0x04, 0x05, 
  0x06, 0x43, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x82, 0x29, 0x01, 0x04, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0xCF, 0x0E, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x2F, 0x62, 0x72, 0x61, 0x63, 0x6B, 0x65, 
  0x74, 0x73, 0xDA, 0x82, 0x1A, 0xCF, 0x01, 0x2B, 0xDA, 0x81, 0x99, 0xCF, 0x0A, 0x6D, 0x61, 0x74, 
  0x68, 0x2F, 0x66, 0x6C, 0x6F, 0x6F, 0x72, 0xD8, 0x0A, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x66, 0x6C, 
  0x6F, 0x6F, 0x72, 0xCF, 0x04, 0x70, 0x72, 0x69, 0x6E, 0xDA, 0x83, 0xC7, 0xCF, 0x0B, 0x74, 0x75, 
  0x70, 0x6C, 0x65, 0x2F, 0x73, 0x6C, 0x69, 0x63, 0x65, 0xDA, 0x70, 0xDA, 0x84, 0x55, 0xD7, 0xCD, 
  0x00, 0x98, 0x00, 0x00, 0x08, 0x02, 0x02, 0x02, 0x03, 0x0C, 0xCE, 0x09, 0x64, 0x65, 0x66, 0x67, 
  0x6C, 0x6F, 0x62, 0x61, 0x6C, 0xDA, 0x05, 0xDA, 0x82, 0x31, 0xDA, 0x03, 0xDA, 0x82, 0x26, 0x2C, 
  0x02, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 
  0x04, 0x03, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x30, 0x05, 0x01, 0x00, 0x42, 0x05, 0x00, 0x00, 0x30, 
  0x04, 0x05, 0x00, 0x2A, 0x07, 0x02, 0x00, 0x33, 0x06, 0x07, 0x00, 0x04, 0x00, 0x00, 0x00, 0x42, 
  0x01, 0x03, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0xBF, 0xFC, 0x01, 0xCF, 0x09, 0x6F, 0x73, 0x2F, 0x73, 0x65, 0x74, 
  0x65, 0x6E, 0x76, 0xD8, 0x09, 0x6F, 0x73, 0x2F, 0x73, 0x65, 0x74, 0x65, 0x6E, 0x76, 0xCF, 0x04, 
  0x6E, 0x65, 0x67, 0x3F, 0xDA, 0x83, 0x18, 0xCF, 0x0A, 0x6D, 0x65, 0x72, 0x67, 0x65, 0x2D, 0x69, 
  0x6E, 0x74, 0x6F, 0xDA, 0x84, 0x2C, 0xCF, 0x07, 0x62, 0x6C, 0x73, 0x68, 0x69, 0x66, 0x74, 0xD7, 
  0xCD, 0x00, 0x09, 0x00, 0x10, 0x06, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x13, 0xCE, 
  0x07, 0x62, 0x6C, 0x73, 0x68, 0x69, 0x66, 0x74, 0x3D, 0x01, 0x00, 0x00, 0x24, 0x02, 0x01, 0x00, 
  0x1C, 0x02, 0x03, 0x00, 0x29, 0x03, 0x01, 0x00, 0x03, 0x03, 0x00, 0x00, 0x24, 0x02, 0x01, 0x01, 
  0x1C, 0x02, 0x05, 0x00, 0x29, 0x03, 0x01, 0x00, 0x3B, 0x04, 0x00, 0x00, 0x12, 0x03, 0x03, 0x04, 
  0x03, 0x03, 0x00, 0x00, 0x3B, 0x03, 0x00, 0x00, 0x29, 0x05, 0x01, 0x00, 0x38, 0x04, 0x00, 0x05, 
  0x12, 0x03, 0x03, 0x04, 0x05, 0x05, 0x05, 0x01, 0x23, 0x02, 0x05, 0x01, 0x1C, 0x02, 0xFC, 0xFF, 
  0x03, 0x03, 0x00, 0x00, 0xCF, 0x0B, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x62, 0x6C, 0x69, 
  0x74, 0xD8, 0x0B, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x62, 0x6C, 0x69, 0x74, 0xCF, 0x05, 
  0x7A, 0x65, 0x72, 0x6F, 0x3F, 0xDA, 0x82, 0x0B, 0xCF, 0x03, 0x64, 0x65, 0x63, 0xDA, 0x82, 0x91, 
  0xCF, 0x0E, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x62, 0x69, 0x74, 0x2D, 0x73, 0x65, 0x74, 
  0xD8, 0x0E, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x62, 0x69, 0x74, 0x2D, 0x73, 0x65, 0x74, 
  0xCF, 0x08, 0x6F, 0x73, 0x2F, 0x73, 0x6C, 0x65, 0x65, 0x70, 0xD8, 0x08, 0x6F, 0x73, 0x2F, 0x73, 
  0x6C, 0x65, 0x65, 0x70, 0xCF, 0x09, 0x6F, 0x73, 0x2F, 0x72, 0x65, 0x6E, 0x61, 0x6D, 0x65, 0xD8, 
  0x09, 0x6F, 0x73, 0x2F, 0x72, 0x65, 0x6E, 0x61, 0x6D, 0x65, 0xCF, 0x0B, 0x6F, 0x73, 0x2F, 0x70, 
  0x65, 0x72, 0x6D, 0x2D, 0x69, 0x6E, 0x74, 0xD8, 0x0B, 0x6F, 0x73, 0x2F, 0x70, 0x65, 0x72, 0x6D, 
  0x2D, 0x69, 0x6E, 0x74, 0xCF, 0x03, 0x63, 0x68, 0x72, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x08, 
  0x01, 0x01, 0x01, 0x03, 0x16, 0xCE, 0x03, 0x63, 0x68, 0x72, 0xDA, 0x05, 0xDA, 0x80, 0xCA, 0xCE, 
  0x23, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 
  0x20, 0x6F, 0x66, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x20, 0x31, 0x2C, 0x20, 0x67, 0x6F, 
  0x74, 0x20, 0x25, 0x76, 0xDA, 0x82, 0x03, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 
  0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x04, 0x03, 0x00, 0x1C, 0x03, 0x06, 0x00, 0x3D, 
  0x05, 0x00, 0x00, 0x29, 0x07, 0x01, 0x00, 0x23, 0x06, 0x05, 0x07, 0x19, 0x02, 0x06, 0x00, 0x1A, 
  0x02, 0x00, 0x00, 0x19, 0x02, 0x04, 0x00, 0x1C, 0x02, 0x02, 0x00, 0x1A, 0x06, 0x00, 0x00, 0x2A, 
  0x03, 0x01, 0x00, 0x30, 0x03, 0x00, 0x00, 0x2A, 0x04, 0x02, 0x00, 0x33, 0x03, 0x04, 0x00, 0x01, 
  0x03, 0x00, 0x00, 0x29, 0x02, 0x00, 0x00, 0x2F, 0x02, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x81, 
  0x50, 0x01, 0x03, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x1F, 0x00, 0x1C, 
  0x00, 0x1C, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x03, 0x00, 0x03, 0x01, 0x0C, 0x00, 0x0C, 
  0x00, 0x0C, 0x00, 0x0C, 0x00, 0x05, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x06, 0x67, 0x65, 
  0x74, 0x2D, 0x69, 0x6E, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x08, 0x03, 0x02, 0x03, 0x00, 0x13, 
  0xCE, 0x06, 0x67, 0x65, 0x74, 0x2D, 0x69, 0x6E, 0xDA, 0x05, 0x2C, 0x03, 0x00, 0x00, 0x19, 0x04, 
  0x00, 0x00, 0x26, 0x06, 0x00, 0x00, 0x47, 0x05, 0x01, 0x06, 0x19, 0x06, 0x05, 0x00, 0x1D, 0x06, 
  0x09, 0x00, 0x38, 0x05, 0x01, 0x06, 0x19, 0x07, 0x05, 0x00, 0x1C, 0x04, 0x02, 0x00, 0x1A, 0x02, 
  0x00, 0x00, 0x1A, 0x04, 0x00, 0x00, 0x39, 0x04, 0x04, 0x07, 0x47, 0x06, 0x01, 0x06, 0x1A, 0xF8, 
  0xFF, 0xFF, 0x26, 0x06, 0x00, 0x00, 0x23, 0x05, 0x06, 0x04, 0x1C, 0x05, 0x02, 0x00, 0x03, 0x02, 
  0x00, 0x00, 0x03, 0x04, 0x00, 0x00, 0x84, 0xC9, 0x01, 0x04, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x24, 0x00, 
  0x03, 0x00, 0x03, 0x01, 0x07, 0x00, 0x07, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x06, 0x72, 
  0x65, 0x64, 0x75, 0x63, 0x65, 0xDA, 0x82, 0xAE, 0xCF, 0x09, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x70, 
  0x6F, 0x73, 0x65, 0xDA, 0x80, 0xC6, 0xDA, 0x84, 0x5D, 0xD7, 0xCD, 0x00, 0xB9, 0x00, 0x00, 0x07, 
  0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x04, 0x0E, 0x01, 0xCE, 0x06, 0x69, 0x6D, 0x70, 0x6F, 
  0x72, 0x74, 0xDA, 0x05, 0xDA, 0x80, 0xBF, 0xDA, 0x6F, 0xDA, 0x84, 0x49, 0xDA, 0x81, 0x65, 0x2C, 
  0x02, 0x00, 0x00, 0x2E, 0x03, 0x00, 0x00, 0x30, 0x03, 0x01, 0x00, 0x2A, 0x05, 0x00, 0x00, 0x33, 
  0x04, 0x05, 0x00, 0x19, 0x03, 0x04, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x06, 0x01, 0x00, 0x33, 
  0x05, 0x06, 0x00, 0x2A, 0x06, 0x02, 0x00, 0x30, 0x06, 0x05, 0x00, 0x32, 0x03, 0x00, 0x00, 0x2A, 
  0x06, 0x03, 0x00, 0x34, 0x06, 0x00, 0x00, 0xCD, 0x00, 0x90, 0x00, 0x00, 0x03, 0x01, 0x01, 0x01, 
  0x02, 0x08, 0xDA, 0x05, 0xDA, 0x4E, 0xDA, 0x6F, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 
  0x33, 0x01, 0x02, 0x00, 0x1C, 0x01, 0x02, 0x00, 0x03, 0x00, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
  0x2A, 0x02, 0x01, 0x00, 0x34, 0x02, 0x00, 0x00, 0x89, 0x63, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 
  0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x89, 0x59, 0x01, 0x0A, 0x12, 0x00, 0x0D, 
  0x00, 0x0D, 0x00, 0x0D, 0x00, 0x03, 0x01, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x10, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2F, 0x61, 
  0x64, 0x64, 0x2D, 0x70, 0x61, 0x74, 0x68, 0x73, 0xD7, 0xCD, 0x00, 0xB8, 0x00, 0x00, 0x10, 0x02, 
  0x02, 0x02, 0x09, 0x32, 0x01, 0xCE, 0x10, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2F, 0x61, 0x64, 
  0x64, 0x2D, 0x70, 0x61, 0x74, 0x68, 0x73, 0xDA, 0x05, 0xCE, 0x05, 0x3A, 0x61, 0x6C, 0x6C, 0x3A, 
  0xDA, 0x6F, 0xDA, 0x80, 0xA3, 0xDA, 0x80, 0x91, 0xDA, 0x84, 0x67, 0xCE, 0x05, 0x3A, 0x73, 0x79, 
  0x73, 0x3A, 0xCE, 0x0B, 0x3A, 0x73, 0x79, 0x73, 0x3A, 0x2F, 0x3A, 0x61, 0x6C, 0x6C, 0x3A, 0xCE, 
  0x0B, 0x3A, 0x63, 0x75, 0x72, 0x3A, 0x2F, 0x3A, 0x61, 0x6C, 0x6C, 0x3A, 0xDA, 0x80, 0x97, 0x2C, 
  0x02, 0x00, 0x00, 0x2E, 0x03, 0x00, 0x00, 0x19, 0x04, 0x03, 0x00, 0x2A, 0x05, 0x00, 0x00, 0x2F, 
  0x05, 0x00, 0x00, 0x33, 0x05, 0x04, 0x00, 0x19, 0x06, 0x05, 0x00, 0x2A, 0x07, 0x00, 0x00, 0x30, 
  0x07, 0x00, 0x00, 0x2A, 0x08, 0x01, 0x00, 0x33, 0x07, 0x08, 0x00, 0x2A, 0x08, 0x02, 0x00, 0x31, 
  0x07, 0x01, 0x08, 0x43, 0x07, 0x00, 0x00, 0x2A, 0x08, 0x03, 0x00, 0x31, 0x08, 0x06, 0x07, 0x2A, 
  0x09, 0x04, 0x00, 0x33, 0x08, 0x09, 0x00, 0x2A, 0x07, 0x05, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x33, 
  0x07, 0x04, 0x00, 0x19, 0x09, 0x07, 0x00, 0x2A, 0x0A, 0x06, 0x00, 0x30, 0x0A, 0x00, 0x00, 0x2A, 
  0x0B, 0x01, 0x00, 0x33, 0x0A, 0x0B, 0x00, 0x2A, 0x0B, 0x02, 0x00, 0x31, 0x0A, 0x01, 0x0B, 0x43, 
  0x0A, 0x00, 0x00, 0x2A, 0x0B, 0x03, 0x00, 0x31, 0x0B, 0x09, 0x0A, 0x2A, 0x0C, 0x04, 0x00, 0x33, 
  0x0B, 0x0C, 0x00, 0x2A, 0x0A, 0x07, 0x00, 0x2F, 0x0A, 0x00, 0x00, 0x33, 0x0A, 0x04, 0x00, 0x19, 
  0x0C, 0x0A, 0x00, 0x2A, 0x0D, 0x07, 0x00, 0x30, 0x0D, 0x00, 0x00, 0x2A, 0x0E, 0x01, 0x00, 0x33, 
  0x0D, 0x0E, 0x00, 0x2A, 0x0E, 0x08, 0x00, 0x31, 0x0D, 0x01, 0x0E, 0x43, 0x0D, 0x00, 0x00, 0x2A, 
  0x0E, 0x03, 0x00, 0x31, 0x0E, 0x0C, 0x0D, 0x2A, 0x0F, 0x04, 0x00, 0x33, 0x0E, 0x0F, 0x00, 0x2A, 
  0x0D, 0x03, 0x00, 0x03, 0x0D, 0x00, 0x00, 0xCD, 0x02, 0xBA, 0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 
  0x02, 0x0B, 0x01, 0xCE, 0x0B, 0x66, 0x69, 0x6E, 0x64, 0x2D, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 
  0xDA, 0x05, 0xDA, 0x80, 0x91, 0xDA, 0x81, 0x21, 0x2C, 0x01, 0x00, 0x00, 0x2E, 0x02, 0x00, 0x00, 
  0x2A, 0x03, 0x00, 0x00, 0x30, 0x02, 0x03, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x33, 0x03, 0x04, 0x00, 
  0x19, 0x02, 0x03, 0x00, 0x1C, 0x02, 0x02, 0x00, 0x03, 0x02, 0x00, 0x00, 0x29, 0x03, 0x00, 0x00, 
  0x03, 0x03, 0x00, 0x00, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 0x02, 0x10, 0x01, 
  0xDA, 0x05, 0xDA, 0x80, 0xCA, 0xDA, 0x80, 0x96, 0x29, 0x01, 0x00, 0x00, 0x2F, 0x01, 0x00, 0x00, 
  0x33, 0x01, 0x00, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 
  0x19, 0x01, 0x02, 0x00, 0x1C, 0x02, 0x08, 0x00, 0x29, 0x03, 0x00, 0x00, 0x2F, 0x03, 0x00, 0x00, 
  0x33, 0x03, 0x00, 0x00, 0x2B, 0x04, 0x00, 0x00, 0x30, 0x04, 0x03, 0x00, 0x2A, 0x04, 0x01, 0x00, 
  0x34, 0x04, 0x00, 0x00, 0x03, 0x01, 0x00, 0x00, 0xBF, 0xFF, 0x88, 0xAA, 0x15, 0x00, 0x15, 0x00, 
  0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 
  0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x88, 0xA8, 0x03, 0x02, 0x15, 
  0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x01, 0x00, 0x00, 0x00, 0x88, 0xA1, 0x01, 0x07, 0x03, 0x00, 0x03, 0x03, 0x12, 0x00, 
  0x12, 0x00, 0x12, 0x00, 0x03, 0x01, 0x29, 0x00, 0x29, 0x00, 0x29, 0x00, 0x29, 0x00, 0x28, 0x00, 
  0x28, 0x00, 0x28, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x12, 0x00, 0x12, 0x00, 
  0x12, 0x00, 0x03, 0x01, 0x29, 0x00, 0x29, 0x00, 0x29, 0x00, 0x29, 0x00, 0x28, 0x00, 0x28, 0x00, 
  0x28, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 
  0x03, 0x01, 0x2C, 0x00, 0x2C, 0x00, 0x2C, 0x00, 0x2C, 0x00, 0x2B, 0x00, 0x2B, 0x00, 0x2B, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xBF, 0xF1, 0x01, 0x00, 0x01, 0xCF, 0x05, 0x70, 0x72, 
  0x69, 0x6E, 0x74, 0xDA, 0x83, 0x95, 0xCF, 0x10, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x6E, 0x65, 
  0x77, 0x2D, 0x66, 0x69, 0x6C, 0x6C, 0x65, 0x64, 0xD8, 0x10, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 
  0x6E, 0x65, 0x77, 0x2D, 0x66, 0x69, 0x6C, 0x6C, 0x65, 0x64, 0xCF, 0x06, 0x6C, 0x65, 0x6E, 0x67, 
  0x74, 0x68, 0xDA, 0x82, 0x9B, 0xDA, 0x81, 0x56, 0xDA, 0x52, 0xCF, 0x03, 0x6D, 0x69, 0x6E, 0xD7, 
  0xCD, 0x00, 0x99, 0x00, 0x00, 0x03, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x02, 0x05, 0xCE, 
  0x03, 0x6D, 0x69, 0x6E, 0xDA, 0x05, 0xDA, 0x59, 0xDA, 0x82, 0x38, 0x2C, 0x01, 0x00, 0x00, 0x2A, 
  0x02, 0x00, 0x00, 0x30, 0x02, 0x00, 0x00, 0x2A, 0x02, 0x01, 0x00, 0x34, 0x02, 0x00, 0x00, 0x82, 
  0x90, 0x01, 0x02, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0xCF, 0x09, 0x6D, 0x61, 0x74, 0x68, 
  0x2F, 0x6C, 0x6F, 0x67, 0x32, 0xD8, 0x09, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x6C, 0x6F, 0x67, 0x32, 
  0xCF, 0x10, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x63, 0x68, 0x65, 0x63, 0x6B, 0x2D, 0x73, 
  0x65, 0x74, 0xD8, 0x10, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x63, 0x68, 0x65, 0x63, 0x6B, 
  0x2D, 0x73, 0x65, 0x74, 0xDA, 0x7A, 0xDA, 0x79, 0xCF, 0x03, 0x6D, 0x61, 0x78, 0xDA, 0x82, 0x39, 
  0xCF, 0x0A, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 0x73, 0x74, 0x65, 0x70, 0xDA, 0x83, 0xA8, 0xCF, 
  0x0E, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2F, 0x67, 0x65, 0x74, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0xDA, 
  0x53, 0xCF, 0x11, 0x74, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x70, 0x72, 0x6F, 0x70, 0x65, 0x72, 
  0x74, 0x69, 0x65, 0x73, 0xD8, 0x11, 0x74, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x70, 0x72, 0x6F, 
  0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0xCF, 0x07, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 
  0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x06, 0x02, 0x02, 0x02, 0x03, 0x0D, 0xCE, 0x07, 0x64, 0x65, 
  0x66, 0x61, 0x75, 0x6C, 0x74, 0xDA, 0x05, 0xDA, 0x2A, 0xDA, 0x2E, 0xDA, 0x26, 0x2C, 0x02, 0x00, 
  0x00, 0x2A, 0x04, 0x00, 0x00, 0x26, 0x05, 0x00, 0x00, 0x31, 0x04, 0x05, 0x00, 0x43, 0x03, 0x00, 
  0x00, 0x2A, 0x05, 0x01, 0x00, 0x31, 0x05, 0x03, 0x01, 0x2F, 0x00, 0x00, 0x00, 0x43, 0x04, 0x00, 
  0x00, 0x2A, 0x05, 0x02, 0x00, 0x31, 0x05, 0x00, 0x04, 0x43, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 
  0x00, 0x80, 0x95, 0x01, 0x04, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x08, 0x63, 0x6F, 
  0x6D, 0x70, 0x74, 0x69, 0x6D, 0x65, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x07, 0x01, 0x01, 0x01, 
  0x07, 0x17, 0xCE, 0x04, 0x65, 0x76, 0x61, 0x6C, 0xDA, 0x05, 0xDA, 0x50, 0xDA, 0x51, 0xDA, 0x84, 
  0xDB, 0xDA, 0x81, 0x00, 0xDA, 0x39, 0xDA, 0x78, 0xDA, 0x80, 0xF7, 0x2C, 0x01, 0x00, 0x00, 0x2A, 
  0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2F, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x33, 
  0x03, 0x04, 0x00, 0x2A, 0x02, 0x02, 0x00, 0x31, 0x00, 0x03, 0x02, 0x2A, 0x04, 0x03, 0x00, 0x33, 
  0x02, 0x04, 0x00, 0x19, 0x03, 0x02, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x05, 0x04, 0x00, 0x33, 
  0x04, 0x05, 0x00, 0x2A, 0x06, 0x05, 0x00, 0x23, 0x05, 0x04, 0x06, 0x1C, 0x05, 0x02, 0x00, 0x34, 
  0x03, 0x00, 0x00, 0x2A, 0x04, 0x06, 0x00, 0x2F, 0x04, 0x00, 0x00, 0x33, 0x04, 0x03, 0x00, 0x01, 
  0x04, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x88, 0x60, 0x01, 0x04, 0x28, 0x00, 0x28, 0x00, 0x1A, 
  0x00, 0x1A, 0x00, 0x1A, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x03, 0x01, 0x0A, 
  0x00, 0x0A, 0x00, 0x0A, 0x00, 0x07, 0x00, 0x07, 0x00, 0x03, 0x01, 0x05, 0x01, 0x0C, 0x00, 0x0C, 
  0x00, 0x0C, 0x00, 0x05, 0x00, 0x05, 0xCF, 0x05, 0x6D, 0x65, 0x72, 0x67, 0x65, 0xD7, 0xCD, 0x00, 
  0x99, 0x00, 0x00, 0x09, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x15, 0xCE, 0x05, 0x6D, 
  0x65, 0x72, 0x67, 0x65, 0xDA, 0x05, 0x2C, 0x01, 0x00, 0x00, 0x42, 0x02, 0x00, 0x00, 0x19, 0x03, 
  0x02, 0x00, 0x26, 0x05, 0x00, 0x00, 0x47, 0x04, 0x00, 0x05, 0x19, 0x05, 0x04, 0x00, 0x1D, 0x05, 
  0x0E, 0x00, 0x38, 0x04, 0x00, 0x05, 0x19, 0x06, 0x04, 0x00, 0x26, 0x07, 0x00, 0x00, 0x47, 0x04, 
  0x06, 0x07, 0x19, 0x07, 0x04, 0x00, 0x1D, 0x07, 0x06, 0x00, 0x19, 0x04, 0x07, 0x00, 0x38, 0x08, 
  0x06, 0x04, 0x3A, 0x03, 0x04, 0x08, 0x47, 0x07, 0x06, 0x07, 0x1A, 0xFB, 0xFF, 0xFF, 0x47, 0x05, 
  0x00, 0x05, 0x1A, 0xF3, 0xFF, 0xFF, 0x03, 0x03, 0x00, 0x00, 0x85, 0x0F, 0x01, 0x05, 0x03, 0x00, 
  0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x02, 0x1A, 0x00, 0x05, 0xBF, 0xFE, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0xBF, 0xFA, 0x01, 0xCF, 0x02, 0x2D, 0x3E, 0xD7, 0xCD, 0x00, 0xB9, 0x00, 
  0x00, 0x06, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x01, 0x06, 0x01, 0xCE, 0x02, 0x2D, 0x3E, 
  0xDA, 0x05, 0xDA, 0x82, 0xAE, 0x2C, 0x02, 0x00, 0x00, 0x2E, 0x03, 0x00, 0x00, 0x19, 0x04, 0x03, 
  0x00, 0x31, 0x04, 0x00, 0x01, 0x2A, 0x05, 0x00, 0x00, 0x34, 0x05, 0x00, 0x00, 0xCD, 0x00, 0x98, 
  0x00, 0x00, 0x09, 0x02, 0x02, 0x02, 0x06, 0x25, 0xDA, 0x82, 0xAF, 0xDA, 0x05, 0xDA, 0x39, 0xDA, 
  0x72, 0xDA, 0x81, 0x28, 0xDA, 0x81, 0x65, 0xDA, 0x81, 0x2E, 0xDA, 0x70, 0x2C, 0x02, 0x00, 0x00, 
  0x2F, 0x01, 0x00, 0x00, 0x2A, 0x05, 0x00, 0x00, 0x33, 0x04, 0x05, 0x00, 0x2A, 0x06, 0x01, 0x00, 
  0x23, 0x05, 0x06, 0x04, 0x1C, 0x05, 0x0C, 0x00, 0x29, 0x06, 0x00, 0x00, 0x38, 0x04, 0x01, 0x06, 
  0x29, 0x06, 0x01, 0x00, 0x30, 0x01, 0x06, 0x00, 0x2A, 0x07, 0x02, 0x00, 0x33, 0x06, 0x07, 0x00, 
  0x30, 0x04, 0x06, 0x00, 0x2A, 0x08, 0x03, 0x00, 0x33, 0x07, 0x08, 0x00, 0x19, 0x03, 0x07, 0x00, 
  0x1A, 0x06, 0x00, 0x00, 0x3E, 0x04, 0x00, 0x00, 0x30, 0x01, 0x04, 0x00, 0x2A, 0x07, 0x03, 0x00, 
  0x33, 0x06, 0x07, 0x00, 0x19, 0x03, 0x06, 0x00, 0x3B, 0x04, 0x03, 0x00, 0x19, 0x05, 0x04, 0x00, 
  0x3B, 0x04, 0x03, 0x01, 0x19, 0x06, 0x04, 0x00, 0x30, 0x05, 0x00, 0x00, 0x3E, 0x04, 0x00, 0x00, 
  0x30, 0x04, 0x06, 0x00, 0x2A, 0x08, 0x04, 0x00, 0x33, 0x07, 0x08, 0x00, 0x19, 0x04, 0x07, 0x00, 
  0x29, 0x08, 0x00, 0x00, 0x30, 0x04, 0x08, 0x00, 0x2A, 0x08, 0x05, 0x00, 0x34, 0x08, 0x00, 0x00, 
  0x84, 0x07, 0x03, 0x01, 0x1E, 0x00, 0x1E, 0x00, 0x1E, 0x00, 0x14, 0x00, 0x14, 0x00, 0x10, 0x01, 
  0x19, 0x00, 0x19, 0x00, 0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x12, 0x00, 0x12, 0x00, 
  0x12, 0xBF, 0xFF, 0x10, 0x00, 0x10, 0x02, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0xBF, 0xFE, 
  0x10, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x03, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 
  0x10, 0x00, 0x10, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x84, 0x02, 0x01, 
  0x05, 0x03, 0x00, 0x03, 0x06, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x08, 0x69, 0x64, 0x65, 0x6E, 
  0x74, 0x69, 0x74, 0x79, 0xDA, 0x80, 0xC1, 0xCF, 0x09, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 
  0x3C, 0x3D, 0xD7, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x03, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 
  0x02, 0x05, 0xCE, 0x09, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0x3C, 0x3D, 0xDA, 0x05, 0xDA, 
  0x81, 0xA6, 0xDA, 0x82, 0xD2, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x30, 0x02, 0x00, 
  0x00, 0x2A, 0x02, 0x01, 0x00, 0x34, 0x02, 0x00, 0x00, 0x82, 0xCB, 0x01, 0x03, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0xCF, 0x03, 0x70, 0x75, 0x74, 0xD7, 0xCD, 0x00, 0x08, 0x00, 0x07, 0x03, 
  0x03, 0x03, 0x03, 0x00, 0x02, 0xCE, 0x03, 0x70, 0x75, 0x74, 0x3A, 0x00, 0x01, 0x02, 0x03, 0x00, 
  0x00, 0x00, 0xCF, 0x09, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x63, 0x6F, 0x73, 0x68, 0xD8, 0x09, 0x6D, 
  0x61, 0x74, 0x68, 0x2F, 0x63, 0x6F, 0x73, 0x68, 0xCF, 0x03, 0x66, 0x6F, 0x72, 0xD7, 0xCD, 0x00, 
  0x99, 0x00, 0x00, 0x08, 0x03, 0x03, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x03, 0x09, 0xCE, 0x03, 0x66, 
  0x6F, 0x72, 0xDA, 0x05, 0xDA, 0x59, 0xDA, 0x81, 0x99, 0xDA, 0x81, 0xA2, 0x2C, 0x04, 0x00, 0x00, 
  0x31, 0x00, 0x01, 0x02, 0x29, 0x05, 0x01, 0x00, 0x2A, 0x06, 0x00, 0x00, 0x2A, 0x07, 0x01, 0x00, 
  0x31, 0x05, 0x06, 0x07, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x05, 0x02, 0x00, 0x34, 0x05, 0x00, 0x00, 
  0x81, 0xE1, 0x01, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0xCF, 0x06, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0xD7, 0xCD, 0x00, 0x99, 0x00, 
  0x00, 0x09, 0x03, 0x03, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x09, 0xCE, 0x06, 0x75, 0x70, 0x64, 
  0x61, 0x74, 0x65, 0xDA, 0x05, 0x2C, 0x04, 0x00, 0x00, 0x39, 0x05, 0x00, 0x01, 0x19, 0x06, 0x05, 
  0x00, 0x2F, 0x06, 0x00, 0x00, 0x32, 0x03, 0x00, 0x00, 0x33, 0x07, 0x02, 0x00, 0x19, 0x08, 0x00, 
  0x00, 0x3A, 0x08, 0x01, 0x07, 0x03, 0x08, 0x00, 0x00, 0x84, 0xFD, 0x01, 0x05, 0x0C, 0x00, 0x03, 
  0x01, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x11, 0x63, 0x6F, 
  0x6D, 0x70, 0x61, 0x72, 0x65, 0x2D, 0x70, 0x72, 0x69, 0x6D, 0x69, 0x74, 0x69, 0x76, 0x65, 0xDA, 
  0x82, 0x5D, 0xCF, 0x0A, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x65, 0x6F, 0x66, 0xDA, 0x80, 
  0xF2, 0xCF, 0x09, 0x6E, 0x65, 0x74, 0x2F, 0x77, 0x72, 0x69, 0x74, 0x65, 0xD8, 0x09, 0x6E, 0x65, 
  0x74, 0x2F, 0x77, 0x72, 0x69, 0x74, 0x65, 0xCF, 0x07, 0x65, 0x78, 0x74, 0x72, 0x65, 0x6D, 0x65, 
  0xDA, 0x82, 0x38, 0xCF, 0x07, 0x65, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x66, 0xDA, 0x83, 0x2D, 0xCF, 
  0x0A, 0x74, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x6E, 0x65, 0x77, 0xD8, 0x0A, 0x74, 0x61, 0x72, 
  0x72, 0x61, 0x79, 0x2F, 0x6E, 0x65, 0x77, 0xCF, 0x0A, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x6C, 0x65, 
  0x61, 0x76, 0x65, 0xD7, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x13, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 
  0xFF, 0x04, 0x27, 0xCE, 0x0A, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x6C, 0x65, 0x61, 0x76, 0x65, 0xDA, 
  0x05, 0xDA, 0x82, 0x9B, 0xDA, 0x80, 0xBF, 0xDA, 0x84, 0xCD, 0xDA, 0x52, 0x2C, 0x01, 0x00, 0x00, 
  0x3E, 0x02, 0x00, 0x00, 0x19, 0x03, 0x02, 0x00, 0x3D, 0x04, 0x00, 0x00, 0x19, 0x05, 0x04, 0x00, 
  0x29, 0x07, 0x00, 0x00, 0x1F, 0x06, 0x05, 0x07, 0x1C, 0x06, 0x1F, 0x00, 0x2A, 0x07, 0x00, 0x00, 
  0x30, 0x07, 0x00, 0x00, 0x2A, 0x08, 0x01, 0x00, 0x33, 0x07, 0x08, 0x00, 0x32, 0x07, 0x00, 0x00, 
  0x2A, 0x09, 0x02, 0x00, 0x33, 0x08, 0x09, 0x00, 0x19, 0x07, 0x08, 0x00, 0x29, 0x08, 0x00, 0x00, 
  0x19, 0x09, 0x07, 0x00, 0x21, 0x0A, 0x08, 0x09, 0x1C, 0x0A, 0x12, 0x00, 0x19, 0x0B, 0x08, 0x00, 
  0x29, 0x0C, 0x00, 0x00, 0x19, 0x0D, 0x05, 0x00, 0x21, 0x0E, 0x0C, 0x0D, 0x1C, 0x0E, 0x0A, 0x00, 
  0x19, 0x0F, 0x0C, 0x00, 0x38, 0x10, 0x00, 0x0F, 0x38, 0x11, 0x10, 0x0B, 0x30, 0x03, 0x11, 0x00, 
  0x2A, 0x12, 0x03, 0x00, 0x33, 0x10, 0x12, 0x00, 0x29, 0x10, 0x01, 0x00, 0x06, 0x0C, 0x0C, 0x10, 
  0x1A, 0xF6, 0xFF, 0xFF, 0x29, 0x0C, 0x01, 0x00, 0x06, 0x08, 0x08, 0x0C, 0x1A, 0xEE, 0xFF, 0xFF, 
  0x1A, 0x01, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x85, 0x41, 0x01, 0x04, 0x03, 0x00, 0x03, 0x01, 
  0x0D, 0x00, 0x03, 0x01, 0x09, 0x00, 0x09, 0x00, 0x03, 0x01, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 
  0x14, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x02, 0x1B, 0x00, 
  0x17, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xFE, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0xBF, 0xFE, 0x03, 0xBF, 0xFA, 0x01, 0xCF, 0x08, 0x62, 0x72, 0x75, 0x73, 
  0x68, 0x69, 0x66, 0x74, 0xD7, 0xCD, 0x00, 0x09, 0x00, 0x12, 0x06, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 
  0xFF, 0xFF, 0x00, 0x13, 0xCE, 0x08, 0x62, 0x72, 0x75, 0x73, 0x68, 0x69, 0x66, 0x74, 0x3D, 0x01, 
  0x00, 0x00, 0x24, 0x02, 0x01, 0x00, 0x1C, 0x02, 0x03, 0x00, 0x29, 0x03, 0x01, 0x00, 0x03, 0x03, 
  0x00, 0x00, 0x24, 0x02, 0x01, 0x01, 0x1C, 0x02, 0x05, 0x00, 0x29, 0x03, 0x01, 0x00, 0x3B, 0x04, 
  0x00, 0x00, 0x16, 0x03, 0x03, 0x04, 0x03, 0x03, 0x00, 0x00, 0x3B, 0x03, 0x00, 0x00, 0x29, 0x05, 
  0x01, 0x00, 0x38, 0x04, 0x00, 0x05, 0x16, 0x03, 0x03, 0x04, 0x05, 0x05, 0x05, 0x01, 0x23, 0x02, 
  0x05, 0x01, 0x1C, 0x02, 0xFC, 0xFF, 0x03, 0x03, 0x00, 0x00, 0xCF, 0x07, 0x74, 0x72, 0x75, 0x74, 
  0x68, 0x79, 0x3F, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x03, 0x01, 0x01, 0x01, 0x00, 0x06, 0xCE, 
  0x07, 0x74, 0x72, 0x75, 0x74, 0x68, 0x79, 0x3F, 0xDA, 0x05, 0x2C, 0x01, 0x00, 0x00, 0x1C, 0x00, 
  0x03, 0x00, 0x27, 0x02, 0x00, 0x00, 0x03, 0x02, 0x00, 0x00, 0x28, 0x02, 0x00, 0x00, 0x03, 0x02, 
  0x00, 0x00, 0x6F, 0x01, 0x00, 0x2B, 0x00, 0x2B, 0x00, 0x2B, 0x00, 0x2B, 0x00, 0x2B, 0xCF, 0x0B, 
  0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 0x73, 0x74, 0x61, 0x63, 0x6B, 0xDA, 0x83, 0xB0, 0xCF, 0x08, 
  0x6F, 0x73, 0x2F, 0x75, 0x6D, 0x61, 0x73, 0x6B, 0xD8, 0x08, 0x6F, 0x73, 0x2F, 0x75, 0x6D, 0x61, 
  0x73, 0x6B, 0xCF, 0x09, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x74, 0x61, 0x6E, 0x68, 0xD8, 0x09, 0x6D, 
  0x61, 0x74, 0x68, 0x2F, 0x74, 0x61, 0x6E, 0x68, 0xCF, 0x0C, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 
  0x2F, 0x70, 0x61, 0x74, 0x68, 0x73, 0xDA, 0x80, 0x91, 0xCF, 0x0C, 0x61, 0x72, 0x72, 0x61, 0x79, 
  0x2F, 0x72, 0x65, 0x6D, 0x6F, 0x76, 0x65, 0xD8, 0x0C, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x72, 
  0x65, 0x6D, 0x6F, 0x76, 0x65, 0xCF, 0x0A, 0x74, 0x61, 0x6B, 0x65, 0x2D, 0x77, 0x68, 0x69, 0x6C, 
  0x65, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x02, 0x02, 0x02, 0x02, 0x07, 0xCE, 0x0A, 0x74, 
  0x61, 0x6B, 0x65, 0x2D, 0x77, 0x68, 0x69, 0x6C, 0x65, 0xDA, 0x05, 0xD7, 0xCD, 0x02, 0xBA, 0x00, 
  0x00, 0x03, 0x01, 0x01, 0x01, 0x00, 0x03, 0x01, 0xCE, 0x0A, 0x63, 0x6F, 0x6D, 0x70, 0x6C, 0x65, 
  0x6D, 0x65, 0x6E, 0x74, 0xDA, 0x05, 0x2C, 0x01, 0x00, 0x00, 0x2E, 0x02, 0x00, 0x00, 0x03, 0x02, 
  0x00, 0x00, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x03, 0x01, 0x01, 0x01, 0x01, 0x06, 0x01, 0xDA, 0x05, 
  0xDA, 0x81, 0x62, 0x2F, 0x00, 0x00, 0x00, 0x2B, 0x02, 0x00, 0x00, 0x33, 0x01, 0x02, 0x00, 0x2F, 
  0x01, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x34, 0x02, 0x00, 0x00, 0xBF, 0xFF, 0x82, 0x81, 0x10, 
  0x00, 0x10, 0x00, 0x10, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x82, 0x7E, 0x01, 0x03, 0x03, 0x00, 
  0x03, 0x01, 0x00, 0x00, 0x00, 0xDA, 0x81, 0x24, 0x2C, 0x02, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
  0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 0x30, 0x03, 0x01, 0x00, 0x2A, 0x04, 0x01, 0x00, 
  0x34, 0x04, 0x00, 0x00, 0x83, 0xBF, 0x01, 0x04, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0xCF, 0x0F, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x66, 0x69, 0x6E, 0x64, 
  0x2D, 0x61, 0x6C, 0x6C, 0xD8, 0x0F, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x66, 0x69, 0x6E, 
  0x64, 0x2D, 0x61, 0x6C, 0x6C, 0xCF, 0x04, 0x73, 0x6F, 0x6D, 0x65, 0xDA, 0x82, 0x2A, 0xCF, 0x04, 
  0x72, 0x65, 0x70, 0x6C, 0xDA, 0x84, 0x34, 0xCF, 0x07, 0x7A, 0x69, 0x70, 0x63, 0x6F, 0x6C, 0x6C, 
  0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x11, 0x02, 0x02, 0x02, 0x00, 0x19, 0xCE, 0x07, 0x7A, 0x69, 
  0x70, 0x63, 0x6F, 0x6C, 0x6C, 0xDA, 0x05, 0x2C, 0x02, 0x00, 0x00, 0x42, 0x03, 0x00, 0x00, 0x19, 
  0x04, 0x03, 0x00, 0x3D, 0x05, 0x00, 0x00, 0x19, 0x06, 0x05, 0x00, 0x3D, 0x07, 0x01, 0x00, 0x19, 
  0x08, 0x07, 0x00, 0x21, 0x0A, 0x06, 0x08, 0x1C, 0x0A, 0x03, 0x00, 0x19, 0x09, 0x06, 0x00, 0x1A, 
  0x02, 0x00, 0x00, 0x19, 0x09, 0x08, 0x00, 0x19, 0x0A, 0x09, 0x00, 0x29, 0x0B, 0x00, 0x00, 0x19, 
  0x0C, 0x0A, 0x00, 0x21, 0x0D, 0x0B, 0x0C, 0x1C, 0x0D, 0x08, 0x00, 0x19, 0x0E, 0x0B, 0x00, 0x38, 
  0x0F, 0x00, 0x0E, 0x38, 0x10, 0x01, 0x0E, 0x3A, 0x04, 0x0F, 0x10, 0x29, 0x0F, 0x01, 0x00, 0x06, 
  0x0B, 0x0B, 0x0F, 0x1A, 0xF8, 0xFF, 0xFF, 0x03, 0x04, 0x00, 0x00, 0x84, 0xBD, 0x01, 0x04, 0x03, 
  0x00, 0x03, 0x01, 0x0B, 0x00, 0x03, 0x01, 0x0B, 0x00, 0x03, 0x01, 0x10, 0x00, 0x0C, 0x00, 0x0C, 
  0x00, 0x0C, 0x00, 0x0C, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x01, 0x0E, 0x00, 0x18, 0x00, 0x05, 0xBF, 0xFF, 0x03, 0x00, 0x03, 0x00, 0x03, 0xBF, 0xF8, 0x01, 
  0xCF, 0x04, 0x63, 0x6F, 0x72, 0x6F, 0xD7, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x05, 0x00, 0x00, 0xCD, 
  0x7F, 0xFF, 0xFF, 0xFF, 0x05, 0x0C, 0xCE, 0x04, 0x63, 0x6F, 0x72, 0x6F, 0xDA, 0x05, 0xDA, 0x23, 
  0xDA, 0x82, 0x34, 0xDA, 0x81, 0x65, 0xDA, 0x24, 0xDA, 0x81, 0x06, 0x2C, 0x01, 0x00, 0x00, 0x2A, 
  0x02, 0x00, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x30, 0x02, 0x03, 0x00, 0x32, 0x00, 0x00, 0x00, 0x2A, 
  0x03, 0x02, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2A, 0x03, 0x03, 0x00, 0x2A, 0x04, 0x04, 0x00, 0x31, 
  0x03, 0x02, 0x04, 0x2A, 0x03, 0x02, 0x00, 0x34, 0x03, 0x00, 0x00, 0x82, 0x2F, 0x01, 0x03, 0x14, 
  0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0xCF, 0x0A, 0x64, 0x72, 0x6F, 0x70, 0x2D, 0x77, 0x68, 0x69, 0x6C, 0x65, 
  0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x02, 0x02, 0x02, 0x02, 0x07, 0xCE, 0x0A, 0x64, 0x72, 
  0x6F, 0x70, 0x2D, 0x77, 0x68, 0x69, 0x6C, 0x65, 0xDA, 0x05, 0xDA, 0x85, 0x0E, 0xDA, 0x81, 0xF9, 
  0x2C, 0x02, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 
  0x30, 0x03, 0x01, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x34, 0x04, 0x00, 0x00, 0x83, 0xDA, 0x01, 0x04, 
  0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x09, 0x6D, 0x61, 0x74, 
  0x68, 0x2F, 0x65, 0x78, 0x70, 0x32, 0xD8, 0x09, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x65, 0x78, 0x70, 
  0x32, 0xCF, 0x0F, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2F, 0x74, 0x6F, 0x2D, 0x73, 0x74, 0x72, 0x75, 
  0x63, 0x74, 0xDA, 0x81, 0x3B, 0xCF, 0x09, 0x6F, 0x73, 0x2F, 0x67, 0x65, 0x74, 0x65, 0x6E, 0x76, 
  0xDA, 0x83, 0x7E, 0xCF, 0x06, 0x6F, 0x73, 0x2F, 0x63, 0x77, 0x64, 0xD8, 0x06, 0x6F, 0x73, 0x2F, 
  0x63, 0x77, 0x64, 0xCF, 0x06, 0x65, 0x66, 0x6C, 0x75, 0x73, 0x68, 0xDA, 0x80, 0x84, 0xCF, 0x08, 
  0x6D, 0x61, 0x74, 0x68, 0x2F, 0x61, 0x62, 0x73, 0xD8, 0x08, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x61, 
  0x62, 0x73, 0xCF, 0x06, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0xDA, 0x81, 0x5D, 0xCF, 0x0C, 0x73, 
  0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x73, 0x6C, 0x69, 0x63, 0x65, 0xDA, 0x81, 0x1F, 0xCF, 0x0A, 
  0x66, 0x69, 0x6C, 0x65, 0x2F, 0x77, 0x72, 0x69, 0x74, 0x65, 0xDA, 0x84, 0x3C, 0xCF, 0x0B, 0x73, 
  0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x66, 0x69, 0x6E, 0x64, 0xDA, 0x84, 0x8D, 0xDA, 0x84, 0x54, 
  0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x08, 0x02, 0x02, 0x02, 0x03, 0x0E, 0xCE, 0x09, 0x76, 0x61, 
  0x72, 0x67, 0x6C, 0x6F, 0x62, 0x61, 0x6C, 0xDA, 0x05, 0xDA, 0x82, 0x31, 0xDA, 0x84, 0x87, 0xDA, 
  0x82, 0x26, 0x2C, 0x02, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 
  0x04, 0x00, 0x19, 0x04, 0x03, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x3E, 0x05, 0x00, 0x00, 0x2A, 0x06, 
  0x01, 0x00, 0x30, 0x06, 0x05, 0x00, 0x42, 0x05, 0x00, 0x00, 0x30, 0x04, 0x05, 0x00, 0x2A, 0x07, 
  0x02, 0x00, 0x33, 0x06, 0x07, 0x00, 0x04, 0x00, 0x00, 0x00, 0x49, 0x01, 0x03, 0x0E, 0x00, 0x0E, 
  0x00, 0x0E, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0xBF, 0xFC, 0x01, 0xCF, 0x02, 0x2D, 0x3D, 0xD7, 0xCD, 0x00, 0x98, 0x00, 
  0x00, 0x06, 0x02, 0x02, 0x02, 0x02, 0x08, 0xCE, 0x02, 0x2D, 0x3D, 0xDA, 0x05, 0xDA, 0x81, 0xA9, 
  0xDA, 0x81, 0xA1, 0x2C, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x31, 0x04, 0x00, 0x01, 0x43, 
  0x03, 0x00, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x31, 0x05, 0x00, 0x03, 0x43, 0x04, 0x00, 0x00, 0x03, 
  0x04, 0x00, 0x00, 0x80, 0x86, 0x01, 0x00, 0x31, 0x00, 0x31, 0x00, 0x31, 0x00, 0x31, 0x00, 0x31, 
  0x00, 0x31, 0x00, 0x31, 0xCF, 0x0C, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2F, 0x67, 0x65, 0x74, 0x65, 
  0x6E, 0x76, 0xDA, 0x51, 0xDA, 0x2A, 0xD7, 0xCD, 0x00, 0x09, 0x00, 0x18, 0x06, 0x00, 0x00, 0xCD, 
  0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x10, 0xCE, 0x01, 0x3D, 0x3D, 0x01, 0x00, 0x00, 0x22, 0x02, 0x01, 
  0x02, 0x1B, 0x02, 0x0A, 0x00, 0x3B, 0x03, 0x00, 0x00, 0x29, 0x05, 0x01, 0x00, 0x38, 0x04, 0x00, 
  0x05, 0x23, 0x02, 0x03, 0x04, 0x1C, 0x02, 0x07, 0x00, 0x05, 0x05, 0x05, 0x01, 0x19, 0x03, 0x04, 
  0x00, 0x23, 0x02, 0x05, 0x01, 0x1C, 0x02, 0xFA, 0xFF, 0x27, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 
  0x00, 0x28, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0xCF, 0x04, 0x2D, 0x3F, 0x3E, 0x3E, 0xD7, 
  0xCD, 0x00, 0xB9, 0x00, 0x00, 0x06, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x01, 0x06, 0x01, 
  0xCE, 0x04, 0x2D, 0x3F, 0x3E, 0x3E, 0xDA, 0x05, 0xDA, 0x82, 0xAE, 0x2C, 0x02, 0x00, 0x00, 0x2E, 
  0x03, 0x00, 0x00, 0x19, 0x04, 0x03, 0x00, 0x31, 0x04, 0x00, 0x01, 0x2A, 0x05, 0x00, 0x00, 0x34, 
  0x05, 0x00, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0E, 0x02, 0x02, 0x02, 0x09, 0x33, 0xDA, 0x82, 
  0xAF, 0xDA, 0x05, 0xDA, 0x39, 0xDA, 0x72, 0xDA, 0x81, 0x28, 0xDA, 0x81, 0x65, 0xDA, 0x22, 0xDA, 
  0x81, 0x2E, 0xDA, 0x70, 0xDA, 0x2E, 0xDA, 0x81, 0x8D, 0x2C, 0x02, 0x00, 0x00, 0x2F, 0x01, 0x00, 
  0x00, 0x2A, 0x05, 0x00, 0x00, 0x33, 0x04, 0x05, 0x00, 0x2A, 0x06, 0x01, 0x00, 0x23, 0x05, 0x06, 
  0x04, 0x1C, 0x05, 0x0C, 0x00, 0x29, 0x06, 0x00, 0x00, 0x38, 0x04, 0x01, 0x06, 0x29, 0x06, 0x01, 
  0x00, 0x30, 0x01, 0x06, 0x00, 0x2A, 0x07, 0x02, 0x00, 0x33, 0x06, 0x07, 0x00, 0x30, 0x04, 0x06, 
  0x00, 0x2A, 0x08, 0x03, 0x00, 0x33, 0x07, 0x08, 0x00, 0x19, 0x03, 0x07, 0x00, 0x1A, 0x06, 0x00, 
  0x00, 0x3E, 0x04, 0x00, 0x00, 0x30, 0x01, 0x04, 0x00, 0x2A, 0x07, 0x03, 0x00, 0x33, 0x06, 0x07, 
  0x00, 0x19, 0x03, 0x06, 0x00, 0x3B, 0x04, 0x03, 0x00, 0x19, 0x05, 0x04, 0x00, 0x3B, 0x04, 0x03, 
  0x01, 0x19, 0x06, 0x04, 0x00, 0x2A, 0x07, 0x04, 0x00, 0x33, 0x04, 0x07, 0x00, 0x19, 0x07, 0x04, 
  0x00, 0x2F, 0x05, 0x00, 0x00, 0x3E, 0x08, 0x00, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x3E, 0x09, 0x00, 
  0x00, 0x31, 0x08, 0x06, 0x09, 0x2A, 0x0B, 0x05, 0x00, 0x33, 0x0A, 0x0B, 0x00, 0x19, 0x08, 0x0A, 
  0x00, 0x30, 0x07, 0x00, 0x00, 0x44, 0x09, 0x00, 0x00, 0x29, 0x0B, 0x00, 0x00, 0x30, 0x08, 0x0B, 
  0x00, 0x2A, 0x0C, 0x06, 0x00, 0x33, 0x0B, 0x0C, 0x00, 0x2A, 0x0D, 0x07, 0x00, 0x31, 0x0D, 0x07, 
  0x0B, 0x43, 0x0C, 0x00, 0x00, 0x2A, 0x0D, 0x08, 0x00, 0x31, 0x0D, 0x09, 0x0C, 0x43, 0x0B, 0x00, 
  0x00, 0x03, 0x0B, 0x00, 0x00, 0x84, 0x33, 0x03, 0x01, 0x1E, 0x00, 0x1E, 0x00, 0x1E, 0x00, 0x14, 
  0x00, 0x14, 0x00, 0x10, 0x01, 0x19, 0x00, 0x19, 0x00, 0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x22, 
  0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0xBF, 0xFF, 0x10, 0x00, 0x10, 0x02, 0x12, 0x00, 0x12, 0x00, 
  0x12, 0x00, 0x12, 0xBF, 0xFE, 0x10, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x03, 0x0E, 
  0x00, 0x0E, 0x00, 0x05, 0x01, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 
  0x00, 0x10, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 0x00, 0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x22, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x84, 0x2C, 
  0x01, 0x07, 0x03, 0x00, 0x03, 0x07, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x09, 0x6D, 0x61, 0x74, 
  0x68, 0x2F, 0x73, 0x69, 0x6E, 0x68, 0xD8, 0x09, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x73, 0x69, 0x6E, 
  0x68, 0xCF, 0x0B, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x62, 0x79, 0x74, 0x65, 0xD8, 0x0B, 
  0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x62, 0x79, 0x74, 0x65, 0xCF, 0x0E, 0x73, 0x74, 0x72, 
  0x69, 0x6E, 0x67, 0x2F, 0x72, 0x65, 0x70, 0x6C, 0x61, 0x63, 0x65, 0xD8, 0x0E, 0x73, 0x74, 0x72, 
  0x69, 0x6E, 0x67, 0x2F, 0x72, 0x65, 0x70, 0x6C, 0x61, 0x63, 0x65, 0xCF, 0x0D, 0x6A, 0x61, 0x6E, 
  0x65, 0x74, 0x2F, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0xDA, 0x83, 0x92, 0xCF, 0x04, 0x61, 
  0x73, 0x2D, 0x3E, 0xD7, 0xCD, 0x02, 0xBB, 0x00, 0x00, 0x07, 0x02, 0x02, 0xCD, 0x7F, 0xFF, 0xFF, 
  0xFF, 0x03, 0x08, 0x02, 0xCE, 0x04, 0x61, 0x73, 0x2D, 0x3E, 0xDA, 0x05, 0xDA, 0x22, 0xDA, 0x81, 
  0x40, 0xDA, 0x81, 0x8D, 0x2C, 0x03, 0x00, 0x00, 0x19, 0x04, 0x00, 0x00, 0x26, 0x06, 0x00, 0x00, 
  0x47, 0x05, 0x02, 0x06, 0x19, 0x06, 0x05, 0x00, 0x2E, 0x05, 0x01, 0x00, 0x33, 0x05, 0x05, 0x00, 
  0x03, 0x04, 0x00, 0x00, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x03, 0x01, 0x01, 0x01, 0x00, 0x06, 0x01, 
  0xDA, 0x05, 0x2B, 0x02, 0x00, 0x01, 0x23, 0x01, 0x00, 0x02, 0x1C, 0x01, 0x03, 0x00, 0x2B, 0x02, 
  0x00, 0x08, 0x03, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xBF, 0xFF, 0x84, 0x6B, 0x2A, 0x00, 
  0x2A, 0x00, 0x26, 0x00, 0x26, 0x00, 0x26, 0x00, 0x26, 0xCD, 0x02, 0xFA, 0x00, 0x00, 0x07, 0x00, 
  0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x03, 0x1C, 0x01, 0x01, 0xDA, 0x81, 0x41, 0xDA, 0x05, 0xDA, 
  0x22, 0xDA, 0x81, 0x40, 0xDA, 0x81, 0x8D, 0x2B, 0x00, 0x00, 0x06, 0x1E, 0x00, 0x02, 0x00, 0x04, 
  0x00, 0x00, 0x00, 0x2B, 0x01, 0x00, 0x02, 0x2B, 0x02, 0x00, 0x06, 0x38, 0x00, 0x01, 0x02, 0x19, 
  0x01, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x33, 0x00, 0x02, 0x00, 0x19, 0x02, 0x00, 0x00, 0x2E, 
  0x00, 0x00, 0x00, 0x30, 0x00, 0x01, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 
  0x00, 0x03, 0x00, 0x2B, 0x04, 0x00, 0x04, 0x30, 0x02, 0x04, 0x00, 0x44, 0x03, 0x00, 0x00, 0x2A, 
  0x05, 0x02, 0x00, 0x31, 0x05, 0x03, 0x00, 0x43, 0x04, 0x00, 0x00, 0x2D, 0x04, 0x00, 0x04, 0x2B, 
  0x05, 0x00, 0x02, 0x2B, 0x06, 0x00, 0x06, 0x47, 0x03, 0x05, 0x06, 0x2D, 0x03, 0x00, 0x06, 0x2C, 
  0x05, 0x00, 0x00, 0x34, 0x05, 0x00, 0x00, 0xBF, 0xFF, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x03, 0x01, 
  0x01, 0x01, 0x00, 0x06, 0x02, 0xDA, 0x05, 0x2B, 0x02, 0x00, 0x01, 0x23, 0x01, 0x00, 0x02, 0x1C, 
  0x01, 0x03, 0x00, 0x2B, 0x02, 0x01, 0x02, 0x03, 0x02, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 
  0xBF, 0xFF, 0x84, 0x6B, 0x2A, 0x00, 0x2A, 0x00, 0x26, 0x00, 0x26, 0x00, 0x26, 0x00, 0x26, 0x84, 
  0x69, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x0E, 
  0x00, 0x0E, 0x00, 0x05, 0x01, 0x1E, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x05, 0x01, 0x0F, 
  0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0xBF, 0xFD, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x04, 0x00, 0x00, 0x00, 0x84, 0x63, 0x01, 
  0x05, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xBF, 0xFA, 0x01, 0x56, 
  0x01, 0x00, 0x00, 0xCF, 0x09, 0x66, 0x69, 0x6C, 0x65, 0x2F, 0x73, 0x65, 0x65, 0x6B, 0xD8, 0x09, 
  0x66, 0x69, 0x6C, 0x65, 0x2F, 0x73, 0x65, 0x65, 0x6B, 0xCF, 0x06, 0x70, 0x72, 0x6F, 0x6D, 0x70, 
  0x74, 0xD7, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x0E, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x0A, 
  0x38, 0xCE, 0x06, 0x70, 0x72, 0x6F, 0x6D, 0x70, 0x74, 0xDA, 0x05, 0xDA, 0x22, 0xDA, 0x2F, 0xDA, 
  0x23, 0xDA, 0x24, 0xD0, 0x02, 0x69, 0x30, 0xDA, 0x26, 0xDA, 0x28, 0xDA, 0x85, 0x31, 0xDA, 0x2D, 
  0xDA, 0x2E, 0x2C, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x04, 
  0x03, 0x00, 0x2A, 0x05, 0x00, 0x00, 0x33, 0x03, 0x05, 0x00, 0x19, 0x05, 0x03, 0x00, 0x2A, 0x06, 
  0x00, 0x00, 0x33, 0x03, 0x06, 0x00, 0x19, 0x06, 0x03, 0x00, 0x2A, 0x07, 0x00, 0x00, 0x33, 0x03, 
  0x07, 0x00, 0x19, 0x07, 0x03, 0x00, 0x44, 0x03, 0x00, 0x00, 0x2A, 0x09, 0x01, 0x00, 0x2F, 0x09, 
  0x00, 0x00, 0x32, 0x01, 0x00, 0x00, 0x43, 0x08, 0x00, 0x00, 0x30, 0x00, 0x08, 0x00, 0x44, 0x09, 
  0x00, 0x00, 0x2A, 0x0A, 0x02, 0x00, 0x31, 0x0A, 0x03, 0x09, 0x43, 0x08, 0x00, 0x00, 0x2A, 0x09, 
  0x03, 0x00, 0x2A, 0x0A, 0x04, 0x00, 0x31, 0x09, 0x08, 0x0A, 0x43, 0x03, 0x00, 0x00, 0x2A, 0x09, 
  0x05, 0x00, 0x31, 0x09, 0x07, 0x03, 0x43, 0x08, 0x00, 0x00, 0x2A, 0x09, 0x06, 0x00, 0x30, 0x09, 
  0x07, 0x00, 0x43, 0x03, 0x00, 0x00, 0x2A, 0x0A, 0x05, 0x00, 0x31, 0x0A, 0x04, 0x03, 0x43, 0x09, 
  0x00, 0x00, 0x30, 0x05, 0x06, 0x00, 0x44, 0x03, 0x00, 0x00, 0x2A, 0x0B, 0x05, 0x00, 0x31, 0x0B, 
  0x03, 0x04, 0x43, 0x0A, 0x00, 0x00, 0x2A, 0x0B, 0x07, 0x00, 0x31, 0x0B, 0x00, 0x05, 0x43, 0x03, 
  0x00, 0x00, 0x2A, 0x0C, 0x08, 0x00, 0x31, 0x0C, 0x04, 0x07, 0x43, 0x0B, 0x00, 0x00, 0x2A, 0x0D, 
  0x09, 0x00, 0x31, 0x0D, 0x03, 0x06, 0x2F, 0x0B, 0x00, 0x00, 0x43, 0x0C, 0x00, 0x00, 0x2A, 0x0B, 
  0x01, 0x00, 0x31, 0x0B, 0x08, 0x09, 0x30, 0x0A, 0x0C, 0x00, 0x43, 0x03, 0x00, 0x00, 0x03, 0x03, 
  0x00, 0x00, 0x81, 0x43, 0x01, 0x04, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0xCF, 0x0B, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x2F, 0x73, 0x65, 0x6E, 0x64, 
  0xD8, 0x0B, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x2F, 0x73, 0x65, 0x6E, 0x64, 0xCF, 0x08, 0x6D, 
  0x61, 0x74, 0x68, 0x2F, 0x74, 0x61, 0x6E, 0xD8, 0x08, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x74, 0x61, 
  0x6E, 0xCF, 0x08, 0x6D, 0x61, 0x6B, 0x65, 0x2D, 0x65, 0x6E, 0x76, 0xDA, 0x80, 0xDB, 0xCF, 0x0A, 
  0x61, 0x63, 0x63, 0x75, 0x6D, 0x75, 0x6C, 0x61, 0x74, 0x65, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 
  0x0B, 0x03, 0x03, 0x03, 0x02, 0x15, 0xCE, 0x0A, 0x61, 0x63, 0x63, 0x75, 0x6D, 0x75, 0x6C, 0x61, 
  0x74, 0x65, 0xDA, 0x05, 0xDA, 0x55, 0xDA, 0x52, 0x2C, 0x03, 0x00, 0x00, 0x19, 0x04, 0x01, 0x00, 
  0x3D, 0x05, 0x02, 0x00, 0x2F, 0x05, 0x00, 0x00, 0x2A, 0x07, 0x00, 0x00, 0x33, 0x06, 0x07, 0x00, 
  0x19, 0x05, 0x06, 0x00, 0x26, 0x08, 0x00, 0x00, 0x47, 0x07, 0x02, 0x08, 0x19, 0x08, 0x07, 0x00, 
  0x1D, 0x08, 0x0A, 0x00, 0x38, 0x07, 0x02, 0x08, 0x19, 0x09, 0x07, 0x00, 0x30, 0x04, 0x09, 0x00, 
  0x33, 0x04, 0x00, 0x00, 0x30, 0x05, 0x04, 0x00, 0x2A, 0x0A, 0x01, 0x00, 0x33, 0x07, 0x0A, 0x00, 
  0x47, 0x08, 0x02, 0x08, 0x1A, 0xF7, 0xFF, 0xFF, 0x03, 0x05, 0x00, 0x00, 0x83, 0x27, 0x01, 0x06, 
  0x03, 0x01, 0x17, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x28, 0x00, 0x28, 0x00, 0x0F, 0x00, 0x0F, 0x00, 
  0x0F, 0x00, 0x03, 0x00, 0x03, 0xBF, 0xF8, 0x01, 0xCF, 0x05, 0x70, 0x61, 0x72, 0x73, 0x65, 0xD7, 
  0xCD, 0x00, 0x98, 0x00, 0x00, 0x07, 0x01, 0x01, 0x01, 0x09, 0x1F, 0xCE, 0x05, 0x70, 0x61, 0x72, 
  0x73, 0x65, 0xDA, 0x05, 0xDA, 0x80, 0xEE, 0xDA, 0x80, 0xF3, 0xDA, 0x80, 0xF2, 0xDA, 0x80, 0xF4, 
  0xDA, 0x80, 0xF5, 0xDA, 0x80, 0xF6, 0xDA, 0x80, 0xF7, 0xDA, 0x80, 0xE7, 0xCE, 0x08, 0x6E, 0x6F, 
  0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 
  0x03, 0x00, 0x19, 0x03, 0x02, 0x00, 0x30, 0x03, 0x00, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x33, 0x02, 
  0x04, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x04, 0x02, 0x00, 0x33, 0x02, 0x04, 0x00, 0x2F, 0x03, 
  0x00, 0x00, 0x2A, 0x04, 0x03, 0x00, 0x33, 0x02, 0x04, 0x00, 0x1C, 0x02, 0x04, 0x00, 0x2F, 0x03, 
  0x00, 0x00, 0x2A, 0x04, 0x04, 0x00, 0x34, 0x04, 0x00, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x05, 
  0x05, 0x00, 0x33, 0x04, 0x05, 0x00, 0x2A, 0x06, 0x06, 0x00, 0x23, 0x05, 0x06, 0x04, 0x1C, 0x05, 
  0x06, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x2A, 0x06, 0x07, 0x00, 0x33, 0x04, 0x06, 0x00, 0x01, 0x04, 
  0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x2A, 0x04, 0x08, 0x00, 0x01, 0x04, 0x00, 0x00, 0x04, 0x00, 
  0x00, 0x00, 0x88, 0x69, 0x01, 0x04, 0x0B, 0x00, 0x0B, 0x00, 0x03, 0x01, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x05, 0x01, 
  0x07, 0x00, 0x07, 0x00, 0x07, 0x01, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x0B, 0x00, 0x0B, 0x00, 
  0x07, 0x01, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x09, 0x00, 0x09, 0x01, 0x09, 0x00, 0x09, 0x00, 
  0x09, 0xCF, 0x03, 0x2D, 0x3F, 0x3E, 0xD7, 0xCD, 0x00, 0xB9, 0x00, 0x00, 0x06, 0x01, 0x01, 0xCD, 
  0x7F, 0xFF, 0xFF, 0xFF, 0x01, 0x06, 0x01, 0xCE, 0x03, 0x2D, 0x3F, 0x3E, 0xDA, 0x05, 0xDA, 0x82, 
  0xAE, 0x2C, 0x02, 0x00, 0x00, 0x2E, 0x03, 0x00, 0x00, 0x19, 0x04, 0x03, 0x00, 0x31, 0x04, 0x00, 
  0x01, 0x2A, 0x05, 0x00, 0x00, 0x34, 0x05, 0x00, 0x00, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0E, 0x02, 
  0x02, 0x02, 0x09, 0x31, 0xDA, 0x82, 0xAF, 0xDA, 0x05, 0xDA, 0x39, 0xDA, 0x72, 0xDA, 0x81, 0x28, 
  0xDA, 0x81, 0x65, 0xDA, 0x22, 0xDA, 0x81, 0x2E, 0xDA, 0x70, 0xDA, 0x2E, 0xDA, 0x81, 0x8D, 0x2C, 
  0x02, 0x00, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x05, 0x00, 0x00, 0x33, 0x04, 0x05, 0x00, 0x2A, 
  0x06, 0x01, 0x00, 0x23, 0x05, 0x06, 0x04, 0x1C, 0x05, 0x0C, 0x00, 0x29, 0x06, 0x00, 0x00, 0x38, 
  0x04, 0x01, 0x06, 0x29, 0x06, 0x01, 0x00, 0x30, 0x01, 0x06, 0x00, 0x2A, 0x07, 0x02, 0x00, 0x33, 
  0x06, 0x07, 0x00, 0x30, 0x04, 0x06, 0x00, 0x2A, 0x08, 0x03, 0x00, 0x33, 0x07, 0x08, 0x00, 0x19, 
  0x03, 0x07, 0x00, 0x1A, 0x06, 0x00, 0x00, 0x3E, 0x04, 0x00, 0x00, 0x30, 0x01, 0x04, 0x00, 0x2A, 
  0x07, 0x03, 0x00, 0x33, 0x06, 0x07, 0x00, 0x19, 0x03, 0x06, 0x00, 0x3B, 0x04, 0x03, 0x00, 0x19, 
  0x05, 0x04, 0x00, 0x3B, 0x04, 0x03, 0x01, 0x19, 0x06, 0x04, 0x00, 0x2A, 0x07, 0x04, 0x00, 0x33, 
  0x04, 0x07, 0x00, 0x19, 0x07, 0x04, 0x00, 0x30, 0x05, 0x07, 0x00, 0x3E, 0x08, 0x00, 0x00, 0x30, 
  0x08, 0x06, 0x00, 0x2A, 0x0A, 0x05, 0x00, 0x33, 0x09, 0x0A, 0x00, 0x19, 0x08, 0x09, 0x00, 0x30, 
  0x07, 0x00, 0x00, 0x44, 0x0A, 0x00, 0x00, 0x29, 0x0B, 0x00, 0x00, 0x30, 0x08, 0x0B, 0x00, 0x2A, 
  0x0C, 0x06, 0x00, 0x33, 0x0B, 0x0C, 0x00, 0x2A, 0x0D, 0x07, 0x00, 0x31, 0x0D, 0x07, 0x0B, 0x43, 
  0x0C, 0x00, 0x00, 0x2A, 0x0D, 0x08, 0x00, 0x31, 0x0D, 0x0A, 0x0C, 0x43, 0x0B, 0x00, 0x00, 0x03, 
  0x0B, 0x00, 0x00, 0x84, 0x23, 0x03, 0x01, 0x1E, 0x00, 0x1E, 0x00, 0x1E, 0x00, 0x14, 0x00, 0x14, 
  0x00, 0x10, 0x01, 0x19, 0x00, 0x19, 0x00, 0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x12, 
  0x00, 0x12, 0x00, 0x12, 0xBF, 0xFF, 0x10, 0x00, 0x10, 0x02, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 
  0x12, 0xBF, 0xFE, 0x10, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x03, 0x0E, 0x00, 0x0E, 
  0x00, 0x05, 0x01, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x05, 0x01, 0x05, 
  0x00, 0x05, 0x00, 0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x84, 0x1C, 0x01, 0x07, 0x03, 0x00, 0x03, 0x07, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x04, 0x6C, 0x61, 0x73, 0x74, 0xDA, 0x84, 0x48, 0xCF, 0x08, 
  0x6F, 0x73, 0x2F, 0x63, 0x6C, 0x6F, 0x63, 0x6B, 0xD8, 0x08, 0x6F, 0x73, 0x2F, 0x63, 0x6C, 0x6F, 
  0x63, 0x6B, 0xCF, 0x06, 0x6F, 0x73, 0x2F, 0x64, 0x69, 0x72, 0xD8, 0x06, 0x6F, 0x73, 0x2F, 0x64, 
  0x69, 0x72, 0xCF, 0x07, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x3F, 0xDA, 0x82, 0x15, 0xCF, 0x07, 
  0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0xDA, 0x81, 0x00, 0xCF, 0x0D, 0x73, 0x74, 0x72, 0x69, 
  0x6E, 0x67, 0x2F, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0xDA, 0x82, 0x03, 0xCF, 0x09, 0x6D, 0x61, 
  0x74, 0x68, 0x2F, 0x6E, 0x65, 0x78, 0x74, 0xD8, 0x09, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x6E, 0x65, 
  0x78, 0x74, 0xCF, 0x10, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x70, 0x75, 0x73, 0x68, 0x2D, 
  0x77, 0x6F, 0x72, 0x64, 0xD8, 0x10, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x70, 0x75, 0x73, 
  0x68, 0x2D, 0x77, 0x6F, 0x72, 0x64, 0xCF, 0x0A, 0x6F, 0x73, 0x2F, 0x65, 0x6E, 0x76, 0x69, 0x72, 
  0x6F, 0x6E, 0xD8, 0x0A, 0x6F, 0x73, 0x2F, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0xCF, 0x0E, 
  0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x2F, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0xD8, 0x0E, 
  0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x2F, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0xCF, 0x01, 
  0x2D, 0xDA, 0x81, 0xA9, 0xCF, 0x08, 0x77, 0x68, 0x65, 0x6E, 0x2D, 0x6C, 0x65, 0x74, 0xD7, 0xCD, 
  0x00, 0x99, 0x00, 0x00, 0x06, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x02, 0x09, 0xCE, 0x08, 
  0x77, 0x68, 0x65, 0x6E, 0x2D, 0x6C, 0x65, 0x74, 0xDA, 0x05, 0xDA, 0x2F, 0xDA, 0x31, 0x2C, 0x02, 
  0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x2F, 0x04, 0x00, 0x00, 0x32, 0x01, 0x00, 0x00, 0x43, 0x03, 
  0x00, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x31, 0x05, 0x00, 0x03, 0x43, 0x04, 0x00, 0x00, 0x03, 0x04, 
  0x00, 0x00, 0x82, 0x66, 0x01, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x05, 0x76, 0x61, 0x72, 0x66, 0x6E, 0xD7, 0xCD, 0x00, 0x99, 
  0x00, 0x00, 0x16, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x12, 0x67, 0xCE, 0x05, 0x76, 0x61, 
  0x72, 0x66, 0x6E, 0xDA, 0x05, 0xDA, 0x74, 0xDA, 0x84, 0x48, 0xDA, 0x70, 0xDA, 0x4E, 0xDA, 0x80, 
  0xCA, 0xDA, 0x09, 0xCE, 0x11, 0x69, 0x6E, 0x76, 0x61, 0x6C, 0x69, 0x64, 0x20, 0x6D, 0x65, 0x74, 
  0x61, 0x64, 0x61, 0x74, 0x61, 0x20, 0xDA, 0x6F, 0xDA, 0x22, 0xDA, 0x82, 0x16, 0xDA, 0x7D, 0xDA, 
  0x84, 0x87, 0xDA, 0x81, 0x5F, 0xDA, 0x26, 0xDA, 0x82, 0x26, 0xDA, 0x08, 0xDA, 0x84, 0x2C, 0xDA, 
  0x81, 0x8D, 0x2C, 0x02, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x32, 0x01, 0x00, 0x00, 0x2A, 0x04, 
  0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x04, 0x03, 0x00, 0x2F, 0x04, 0x00, 0x00, 0x2A, 0x06, 
  0x01, 0x00, 0x33, 0x05, 0x06, 0x00, 0x19, 0x06, 0x05, 0x00, 0x29, 0x07, 0x02, 0x00, 0x29, 0x08, 
  0xFE, 0xFF, 0x31, 0x04, 0x07, 0x08, 0x2A, 0x08, 0x02, 0x00, 0x33, 0x07, 0x08, 0x00, 0x19, 0x08, 
  0x07, 0x00, 0x42, 0x09, 0x00, 0x00, 0x19, 0x0A, 0x09, 0x00, 0x26, 0x0C, 0x00, 0x00, 0x47, 0x0B, 
  0x08, 0x0C, 0x19, 0x0C, 0x0B, 0x00, 0x1D, 0x0C, 0x18, 0x00, 0x38, 0x0B, 0x08, 0x0C, 0x19, 0x0D, 
  0x0B, 0x00, 0x2F, 0x0D, 0x00, 0x00, 0x2A, 0x0E, 0x03, 0x00, 0x33, 0x0B, 0x0E, 0x00, 0x1C, 0x0B, 
  0x04, 0x00, 0x27, 0x0E, 0x00, 0x00, 0x3A, 0x0A, 0x0D, 0x0E, 0x1A, 0x0D, 0x00, 0x00, 0x2F, 0x0D, 
  0x00, 0x00, 0x2A, 0x0F, 0x04, 0x00, 0x33, 0x0E, 0x0F, 0x00, 0x1C, 0x0E, 0x04, 0x00, 0x2A, 0x0F, 
  0x05, 0x00, 0x3A, 0x0A, 0x0F, 0x0D, 0x1A, 0x06, 0x00, 0x00, 0x2A, 0x0F, 0x06, 0x00, 0x30, 0x0F, 
  0x0D, 0x00, 0x2A, 0x10, 0x07, 0x00, 0x33, 0x0F, 0x10, 0x00, 0x01, 0x0F, 0x00, 0x00, 0x47, 0x0C, 
  0x08, 0x0C, 0x1A, 0xE9, 0xFF, 0xFF, 0x2A, 0x0C, 0x08, 0x00, 0x33, 0x0B, 0x0C, 0x00, 0x19, 0x0C, 
  0x0B, 0x00, 0x2A, 0x0D, 0x08, 0x00, 0x33, 0x0B, 0x0D, 0x00, 0x19, 0x0D, 0x0B, 0x00, 0x2A, 0x0E, 
  0x08, 0x00, 0x33, 0x0B, 0x0E, 0x00, 0x19, 0x0E, 0x0B, 0x00, 0x2A, 0x0F, 0x09, 0x00, 0x30, 0x0F, 
  0x00, 0x00, 0x43, 0x0B, 0x00, 0x00, 0x2A, 0x10, 0x0A, 0x00, 0x30, 0x10, 0x0B, 0x00, 0x43, 0x0F, 
  0x00, 0x00, 0x30, 0x0D, 0x0F, 0x00, 0x44, 0x0B, 0x00, 0x00, 0x26, 0x10, 0x00, 0x00, 0x2F, 0x10, 
  0x00, 0x00, 0x3E, 0x0F, 0x00, 0x00, 0x2A, 0x11, 0x0B, 0x00, 0x30, 0x11, 0x0F, 0x00, 0x42, 0x10, 
  0x00, 0x00, 0x2A, 0x11, 0x0C, 0x00, 0x31, 0x11, 0x0D, 0x10, 0x43, 0x0F, 0x00, 0x00, 0x2A, 0x11, 
  0x0D, 0x00, 0x31, 0x11, 0x0C, 0x0F, 0x43, 0x10, 0x00, 0x00, 0x2A, 0x11, 0x09, 0x00, 0x30, 0x11, 
  0x00, 0x00, 0x43, 0x0F, 0x00, 0x00, 0x2A, 0x12, 0x0E, 0x00, 0x31, 0x12, 0x0F, 0x0C, 0x43, 0x11, 
  0x00, 0x00, 0x2A, 0x12, 0x0D, 0x00, 0x31, 0x12, 0x0E, 0x06, 0x43, 0x0F, 0x00, 0x00, 0x2A, 0x13, 
  0x0B, 0x00, 0x29, 0x14, 0x00, 0x00, 0x30, 0x13, 0x14, 0x00, 0x44, 0x12, 0x00, 0x00, 0x2A, 0x14, 
  0x0F, 0x00, 0x31, 0x14, 0x0C, 0x12, 0x2F, 0x0E, 0x00, 0x00, 0x43, 0x13, 0x00, 0x00, 0x2A, 0x14, 
  0x09, 0x00, 0x30, 0x14, 0x0A, 0x00, 0x43, 0x12, 0x00, 0x00, 0x2A, 0x15, 0x10, 0x00, 0x31, 0x15, 
  0x0C, 0x12, 0x43, 0x14, 0x00, 0x00, 0x2A, 0x15, 0x11, 0x00, 0x31, 0x15, 0x0B, 0x10, 0x31, 0x11, 
  0x0F, 0x13, 0x30, 0x14, 0x0E, 0x00, 0x43, 0x12, 0x00, 0x00, 0x03, 0x12, 0x00, 0x00, 0x87, 0x44, 
  0x01, 0x06, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x03, 0x01, 0x0E, 0x00, 0x0E, 0x00, 
  0x0E, 0x00, 0x03, 0x01, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x03, 0x01, 
  0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x02, 
  0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xFF, 0x05, 0x01, 0x14, 0x00, 0x14, 0xBF, 0xFF, 0x05, 0x02, 
  0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xFE, 0x05, 0x02, 0x13, 0x00, 0x13, 0xBF, 0xFE, 0x05, 0x03, 
  0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x07, 0xBF, 0xFC, 0x03, 0x00, 0x03, 0x05, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0xCF, 0x04, 0x6F, 0x64, 0x64, 0x3F, 0xDA, 0x83, 0x6E, 0xCF, 0x06, 0x66, 0x72, 0x65, 
  0x65, 0x7A, 0x65, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0A, 0x01, 0x01, 0x01, 0x0E, 0x43, 0xCE, 
  0x06, 0x66, 0x72, 0x65, 0x65, 0x7A, 0x65, 0xDA, 0x05, 0xDA, 0x39, 0xDA, 0x81, 0x3C, 0xDA, 0x80, 
  0xBF, 0xDA, 0x70, 0xDA, 0x72, 0xDA, 0x3A, 0xDA, 0x53, 0xDA, 0x17, 0xDA, 0x84, 0xDF, 0xDA, 0x81, 
  0x69, 0xDA, 0x80, 0x8E, 0xDA, 0x80, 0x88, 0xDA, 0x81, 0x1D, 0xDA, 0x6F, 0x2C, 0x01, 0x00, 0x00, 
  0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x19, 0x03, 0x02, 0x00, 
  0x2A, 0x04, 0x01, 0x00, 0x23, 0x02, 0x03, 0x04, 0x1C, 0x02, 0x07, 0x00, 0x30, 0x01, 0x00, 0x00, 
  0x2A, 0x05, 0x02, 0x00, 0x33, 0x04, 0x05, 0x00, 0x2F, 0x04, 0x00, 0x00, 0x2A, 0x05, 0x03, 0x00, 
  0x34, 0x05, 0x00, 0x00, 0x2A, 0x05, 0x04, 0x00, 0x23, 0x04, 0x03, 0x05, 0x1C, 0x04, 0x07, 0x00, 
  0x30, 0x01, 0x00, 0x00, 0x2A, 0x06, 0x02, 0x00, 0x33, 0x05, 0x06, 0x00, 0x2F, 0x05, 0x00, 0x00, 
  0x2A, 0x06, 0x03, 0x00, 0x34, 0x06, 0x00, 0x00, 0x2A, 0x06, 0x05, 0x00, 0x23, 0x05, 0x03, 0x06, 
  0x1C, 0x05, 0x17, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x07, 0x06, 0x00, 0x33, 0x06, 0x07, 0x00, 
  0x19, 0x07, 0x06, 0x00, 0x1C, 0x07, 0x09, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x2A, 0x08, 0x07, 0x00, 
  0x33, 0x06, 0x08, 0x00, 0x30, 0x06, 0x00, 0x00, 0x2A, 0x09, 0x08, 0x00, 0x33, 0x08, 0x09, 0x00, 
  0x2F, 0x08, 0x00, 0x00, 0x34, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x08, 0x09, 0x00, 
  0x33, 0x06, 0x08, 0x00, 0x30, 0x01, 0x06, 0x00, 0x2A, 0x09, 0x02, 0x00, 0x33, 0x08, 0x09, 0x00, 
  0x32, 0x08, 0x00, 0x00, 0x2A, 0x06, 0x0A, 0x00, 0x34, 0x06, 0x00, 0x00, 0x2A, 0x07, 0x0B, 0x00, 
  0x23, 0x06, 0x03, 0x07, 0x1C, 0x06, 0x0A, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x08, 0x09, 0x00, 
  0x33, 0x07, 0x08, 0x00, 0x30, 0x01, 0x07, 0x00, 0x2A, 0x09, 0x02, 0x00, 0x33, 0x08, 0x09, 0x00, 
  0x32, 0x08, 0x00, 0x00, 0x2A, 0x07, 0x0A, 0x00, 0x34, 0x07, 0x00, 0x00, 0x2A, 0x08, 0x0C, 0x00, 
  0x23, 0x07, 0x03, 0x08, 0x1C, 0x07, 0x04, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x08, 0x0D, 0x00, 
  0x34, 0x08, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x87, 0x24, 0x01, 0x05, 0x09, 0x00, 0x09, 0x00, 
  0x09, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 
  0x0C, 0x00, 0x0C, 0x00, 0x0C, 0xBF, 0xFF, 0x03, 0x00, 0x03, 0x00, 0x03, 0x02, 0x19, 0x00, 0x19, 
  0x00, 0x19, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0xBF, 0xFE, 0x03, 0x00, 0x03, 0x00, 0x03, 0x03, 
  0x17, 0x00, 0x17, 0x00, 0x17, 0x00, 0x0C, 0x00, 0x0C, 0x01, 0x1D, 0x00, 0x1D, 0x00, 0x1D, 0x00, 
  0x16, 0x00, 0x16, 0x00, 0x16, 0x00, 0x0E, 0x00, 0x0E, 0x01, 0x23, 0x00, 0x23, 0x00, 0x23, 0x00, 
  0x17, 0x00, 0x17, 0x00, 0x17, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0xBF, 0xFB, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x06, 0x22, 0x00, 0x22, 0x00, 0x22, 0x00, 0x16, 0x00, 0x16, 0x00, 0x16, 0x00, 0x0D, 
  0x00, 0x0D, 0x00, 0x0D, 0xBF, 0xFA, 0x03, 0x00, 0x03, 0x00, 0x03, 0x07, 0x0D, 0x00, 0x0D, 0x00, 
  0x0D, 0xBF, 0xF9, 0x03, 0xCF, 0x0B, 0x6A, 0x61, 0x6E, 0x65, 0x74, 0x2F, 0x62, 0x75, 0x69, 0x6C, 
  0x64, 0xDA, 0x83, 0x93, 0xCF, 0x08, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x65, 0x64, 0x3F, 0xDA, 0x81, 
  0x9D, 0xCF, 0x02, 0x2F, 0x3D, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x06, 0x02, 0x02, 0x02, 0x02, 
  0x08, 0xCE, 0x02, 0x2F, 0x3D, 0xDA, 0x05, 0xDA, 0x83, 0x21, 0xDA, 0x81, 0xA1, 0x2C, 0x02, 0x00, 
  0x00, 0x2A, 0x04, 0x00, 0x00, 0x31, 0x04, 0x00, 0x01, 0x43, 0x03, 0x00, 0x00, 0x2A, 0x05, 0x01, 
  0x00, 0x31, 0x05, 0x00, 0x03, 0x43, 0x04, 0x00, 0x00, 0x03, 0x04, 0x00, 0x00, 0x80, 0x88, 0x01, 
  0x00, 0x35, 0x00, 0x35, 0x00, 0x35, 0x00, 0x35, 0x00, 0x35, 0x00, 0x35, 0x00, 0x35, 0xCF, 0x0B, 
  0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2F, 0x66, 0x69, 0x6E, 0x64, 0xDA, 0x80, 0xCB, 0xCF, 0x05, 
  0x65, 0x72, 0x72, 0x6F, 0x72, 0xD7, 0xCD, 0x00, 0x08, 0x00, 0x02, 0x01, 0x01, 0x01, 0x01, 0x00, 
  0x01, 0xCE, 0x05, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x01, 0x00, 0x00, 0x00, 0xCF, 0x04, 0x62, 0x6E, 
  0x6F, 0x74, 0xD7, 0xCD, 0x00, 0x08, 0x00, 0x13, 0x01, 0x01, 0x01, 0x01, 0x00, 0x02, 0xCE, 0x04, 
  0x62, 0x6E, 0x6F, 0x74, 0x11, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xCF, 0x03, 0x74, 0x72, 
  0x79, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0E, 0x02, 0x02, 0x02, 0x0D, 0x3B, 0xCE, 0x03, 0x74, 
  0x72, 0x79, 0xDA, 0x05, 0xDA, 0x22, 0xDA, 0x23, 0xDA, 0x24, 0xDA, 0x81, 0xFE, 0xDA, 0x28, 0xDA, 
  0x29, 0xDA, 0x85, 0x31, 0xDA, 0x80, 0xF7, 0xDA, 0x26, 0xDA, 0x70, 0xDA, 0x2F, 0xDA, 0x2E, 0xDA, 
  0x81, 0x8D, 0x2C, 0x02, 0x00, 0x00, 0x3B, 0x03, 0x01, 0x00, 0x3B, 0x04, 0x03, 0x00, 0x19, 0x05, 
  0x04, 0x00, 0x3B, 0x04, 0x03, 0x01, 0x19, 0x06, 0x04, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 
  0x04, 0x00, 0x19, 0x04, 0x03, 0x00, 0x2A, 0x07, 0x00, 0x00, 0x33, 0x03, 0x07, 0x00, 0x19, 0x07, 
  0x03, 0x00, 0x44, 0x03, 0x00, 0x00, 0x2A, 0x09, 0x01, 0x00, 0x31, 0x09, 0x03, 0x00, 0x43, 0x08, 
  0x00, 0x00, 0x2A, 0x09, 0x02, 0x00, 0x2A, 0x0A, 0x03, 0x00, 0x31, 0x09, 0x08, 0x0A, 0x43, 0x03, 
  0x00, 0x00, 0x2A, 0x09, 0x04, 0x00, 0x30, 0x09, 0x04, 0x00, 0x43, 0x08, 0x00, 0x00, 0x31, 0x04, 
  0x03, 0x07, 0x2F, 0x08, 0x00, 0x00, 0x44, 0x09, 0x00, 0x00, 0x2A, 0x08, 0x05, 0x00, 0x30, 0x08, 
  0x04, 0x00, 0x43, 0x03, 0x00, 0x00, 0x2A, 0x0A, 0x06, 0x00, 0x2A, 0x0B, 0x07, 0x00, 0x31, 0x0A, 
  0x03, 0x0B, 0x43, 0x08, 0x00, 0x00, 0x2A, 0x0A, 0x08, 0x00, 0x31, 0x0A, 0x05, 0x07, 0x43, 0x03, 
  0x00, 0x00, 0x1C, 0x06, 0x06, 0x00, 0x2A, 0x0C, 0x08, 0x00, 0x31, 0x0C, 0x06, 0x04, 0x43, 0x0B, 
  0x00, 0x00, 0x19, 0x0A, 0x0B, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x26, 0x0A, 0x00, 0x00, 0x29, 0x0B, 
  0x01, 0x00, 0x30, 0x01, 0x0B, 0x00, 0x2A, 0x0C, 0x09, 0x00, 0x33, 0x0B, 0x0C, 0x00, 0x2A, 0x0D, 
  0x0A, 0x00, 0x31, 0x0D, 0x03, 0x0A, 0x32, 0x0B, 0x00, 0x00, 0x43, 0x0C, 0x00, 0x00, 0x2A, 0x0A, 
  0x0B, 0x00, 0x31, 0x0A, 0x08, 0x0C, 0x2F, 0x07, 0x00, 0x00, 0x43, 0x03, 0x00, 0x00, 0x2A, 0x0A, 
  0x0C, 0x00, 0x31, 0x0A, 0x09, 0x03, 0x43, 0x08, 0x00, 0x00, 0x03, 0x08, 0x00, 0x00, 0x80, 0xE1, 
  0x01, 0x07, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x0B, 0x00, 0x0B, 0xBF, 
  0xFF, 0x03, 0x02, 0x0B, 0x00, 0x0B, 0xBF, 0xFE, 0x03, 0x03, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x03, 0x1D, 0x00, 0x25, 0x00, 0x25, 0x00, 
  0x25, 0x00, 0x1D, 0x00, 0x1D, 0x00, 0x1D, 0x00, 0x37, 0x00, 0x37, 0x00, 0x37, 0x00, 0x37, 0xBF, 
  0xFD, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xCF, 0x07, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 
  0x3F, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 0x02, 0x07, 0xCE, 0x07, 0x62, 
  0x75, 0x66, 0x66, 0x65, 0x72, 0x3F, 0xDA, 0x05, 0xDA, 0x39, 0xDA, 0x81, 0x1D, 0x2C, 0x01, 0x00, 
  0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2A, 0x04, 0x01, 
  0x00, 0x23, 0x03, 0x02, 0x04, 0x03, 0x03, 0x00, 0x00, 0x5D, 0x01, 0x00, 0x30, 0x00, 0x30, 0x00, 
  0x30, 0x00, 0x2D, 0x00, 0x2D, 0x00, 0x2D, 0xCF, 0x08, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 
  0x3D, 0xD7, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x03, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x02, 
  0x05, 0xCE, 0x08, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0x3D, 0xDA, 0x05, 0xDA, 0x85, 0x31, 
  0xDA, 0x82, 0xD2, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x30, 0x02, 0x00, 0x00, 0x2A, 
  0x02, 0x01, 0x00, 0x34, 0x02, 0x00, 0x00, 0x82, 0xC1, 0x01, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0xCF, 0x11, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2F, 0x63, 0x61, 0x6E, 0x2D, 0x72, 0x65, 
  0x73, 0x75, 0x6D, 0x65, 0x3F, 0xDA, 0x80, 0xFF, 0xDA, 0x84, 0x57, 0xD7, 0xCD, 0x00, 0x99, 0x00, 
  0x00, 0x06, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x02, 0x07, 0xCE, 0x04, 0x76, 0x61, 0x72, 
  0x2D, 0xDA, 0x05, 0xDA, 0x81, 0x91, 0xDA, 0x65, 0x2C, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 
  0x2A, 0x05, 0x01, 0x00, 0x31, 0x04, 0x00, 0x05, 0x32, 0x01, 0x00, 0x00, 0x43, 0x03, 0x00, 0x00, 
  0x03, 0x03, 0x00, 0x00, 0x3D, 0x01, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0xCF, 0x10, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 0x73, 0x74, 0x61, 0x63, 0x6B, 0x74, 
  0x72, 0x61, 0x63, 0x65, 0xDA, 0x7F, 0xCF, 0x0F, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x73, 0x65, 0x65, 
  0x64, 0x72, 0x61, 0x6E, 0x64, 0x6F, 0x6D, 0xD8, 0x0F, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x73, 0x65, 
  0x65, 0x64, 0x72, 0x61, 0x6E, 0x64, 0x6F, 0x6D, 0xCF, 0x05, 0x6C, 0x61, 0x62, 0x65, 0x6C, 0xD7, 
  0xCD, 0x00, 0x99, 0x00, 0x00, 0x07, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x04, 0x0D, 0xCE, 
  0x05, 0x6C, 0x61, 0x62, 0x65, 0x6C, 0xDA, 0x05, 0xDA, 0x26, 0xD6, 0x00, 0xDA, 0x85, 0x44, 0xDA, 
  0x2F, 0x2C, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x31, 0x04, 0x00, 
  0x05, 0x43, 0x03, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x32, 0x01, 0x00, 0x00, 0x2A, 0x05, 0x02, 
  0x00, 0x33, 0x04, 0x05, 0x00, 0x2A, 0x06, 0x03, 0x00, 0x31, 0x06, 0x03, 0x04, 0x43, 0x05, 0x00, 
  0x00, 0x03, 0x05, 0x00, 0x00, 0x81, 0x57, 0x01, 0x04, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x02, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xFE, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0xDA, 0x84, 0x97, 0xDA, 0x24, 0xCF, 0x07, 0x70, 0x72, 0x65, 0x77, 0x61, 0x6C, 0x6B, 0xD7, 
  0xCD, 0x02, 0xBA, 0x00, 0x00, 0x06, 0x02, 0x02, 0x02, 0x01, 0x07, 0x01, 0xCE, 0x07, 0x70, 0x72, 
  0x65, 0x77, 0x61, 0x6C, 0x6B, 0xDA, 0x05, 0xDA, 0x81, 0x3F, 0x2C, 0x02, 0x00, 0x00, 0x2E, 0x03, 
  0x00, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x33, 0x04, 0x00, 0x00, 0x30, 0x03, 0x04, 0x00, 0x2A, 0x05, 
  0x00, 0x00, 0x34, 0x05, 0x00, 0x00, 0xCD, 0x00, 0xD0, 0x00, 0x00, 0x02, 0x01, 0x01, 0x01, 0x00, 
  0x04, 0x01, 0xDA, 0x05, 0x2B, 0x01, 0x00, 0x00, 0x30, 0x01, 0x00, 0x00, 0x2B, 0x01, 0x00, 0x02, 
  0x34, 0x01, 0x00, 0x00, 0xBF, 0xFF, 0x84, 0x61, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x84, 
  0x5E, 0x01, 0x03, 0x09, 0x00, 0x20, 0x00, 0x20, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x05, 0x00, 
  0x00, 0x00, 0xCF, 0x08, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0xDA, 0x84, 0x81, 0xCF, 
  0x09, 0x6E, 0x65, 0x74, 0x2F, 0x63, 0x68, 0x75, 0x6E, 0x6B, 0xD8, 0x09, 0x6E, 0x65, 0x74, 0x2F, 
  0x63, 0x68, 0x75, 0x6E, 0x6B, 0xCF, 0x0B, 0x6F, 0x73, 0x2F, 0x72, 0x65, 0x61, 0x64, 0x6C, 0x69, 
  0x6E, 0x6B, 0xD8, 0x0B, 0x6F, 0x73, 0x2F, 0x72, 0x65, 0x61, 0x64, 0x6C, 0x69, 0x6E, 0x6B, 0xCF, 
  0x0C, 0x61, 0x6C, 0x6C, 0x2D, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0xDA, 0x84, 0x80, 
  0xCF, 0x09, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x61, 0x63, 0x6F, 0x73, 0xD8, 0x09, 0x6D, 0x61, 0x74, 
  0x68, 0x2F, 0x61, 0x63, 0x6F, 0x73, 0xCF, 0x07, 0x75, 0x6E, 0x74, 0x72, 0x61, 0x63, 0x65, 0xD8, 
  0x07, 0x75, 0x6E, 0x74, 0x72, 0x61, 0x63, 0x65, 0xDA, 0x61, 0xDA, 0x60, 0xDA, 0x43, 0xDA, 0x42, 
  0xCF, 0x0B, 0x6F, 0x73, 0x2F, 0x72, 0x65, 0x61, 0x6C, 0x70, 0x61, 0x74, 0x68, 0xD8, 0x0B, 0x6F, 
  0x73, 0x2F, 0x72, 0x65, 0x61, 0x6C, 0x70, 0x61, 0x74, 0x68, 0xCF, 0x12, 0x62, 0x75, 0x66, 0x66, 
  0x65, 0x72, 0x2F, 0x70, 0x75, 0x73, 0x68, 0x2D, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0xDA, 0x6B, 
  0xCF, 0x0B, 0x65, 0x76, 0x61, 0x6C, 0x2D, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0xDA, 0x84, 0x38, 
  0xCF, 0x09, 0x75, 0x6E, 0x6D, 0x61, 0x72, 0x73, 0x68, 0x61, 0x6C, 0xD8, 0x09, 0x75, 0x6E, 0x6D, 
  0x61, 0x72, 0x73, 0x68, 0x61, 0x6C, 0xCF, 0x02, 0x25, 0x3D, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 
  0x06, 0x02, 0x02, 0x02, 0x02, 0x08, 0xCE, 0x02, 0x25, 0x3D, 0xDA, 0x05, 0xD7, 0xCD, 0x00, 0x08, 
  0x00, 0x1E, 0x02, 0x02, 0x02, 0x02, 0x00, 0x02, 0xCE, 0x01, 0x25, 0x0D, 0x00, 0x00, 0x01, 0x03, 
  0x00, 0x00, 0x00, 0xDA, 0x81, 0xA1, 0x2C, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x31, 0x04, 
  0x00, 0x01, 0x43, 0x03, 0x00, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x31, 0x05, 0x00, 0x03, 0x43, 0x04, 
  0x00, 0x00, 0x03, 0x04, 0x00, 0x00, 0x80, 0x89, 0x01, 0x00, 0x35, 0x00, 0x35, 0x00, 0x35, 0x00, 
  0x35, 0x00, 0x35, 0x00, 0x35, 0x00, 0x35, 0xDA, 0x84, 0x4D, 0xD7, 0xCD, 0x00, 0x99, 0x00, 0x00, 
  0x04, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x02, 0x06, 0xCE, 0x08, 0x64, 0x65, 0x66, 0x6D, 
  0x61, 0x63, 0x72, 0x6F, 0xDA, 0x05, 0xDA, 0x35, 0xDA, 0x74, 0x2C, 0x02, 0x00, 0x00, 0x2A, 0x03, 
  0x00, 0x00, 0x30, 0x00, 0x03, 0x00, 0x32, 0x01, 0x00, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x34, 0x03, 
  0x00, 0x00, 0x29, 0x01, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xDA, 0x31, 
  0xD7, 0xCD, 0x02, 0xBA, 0x00, 0x00, 0x09, 0x03, 0x02, 0x03, 0x04, 0x16, 0x01, 0xCE, 0x06, 0x69, 
  0x66, 0x2D, 0x6C, 0x65, 0x74, 0xDA, 0x05, 0xDA, 0x82, 0x0B, 0xCE, 0x1B, 0x65, 0x78, 0x70, 0x65, 
  0x63, 0x74, 0x65, 0x64, 0x20, 0x61, 0x74, 0x20, 0x6C, 0x65, 0x61, 0x73, 0x74, 0x20, 0x31, 0x20, 
  0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0xDA, 0x83, 0x6E, 0xCE, 0x23, 0x65, 0x78, 0x70, 0x65, 
  0x63, 0x74, 0x65, 0x64, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x76, 0x65, 0x6E, 0x20, 0x6E, 0x75, 0x6D, 
  0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x2C, 
  0x03, 0x00, 0x00, 0x3D, 0x04, 0x00, 0x00, 0x19, 0x05, 0x04, 0x00, 0x2F, 0x05, 0x00, 0x00, 0x2A, 
  0x07, 0x00, 0x00, 0x33, 0x06, 0x07, 0x00, 0x1C, 0x06, 0x04, 0x00, 0x2A, 0x07, 0x01, 0x00, 0x01, 
  0x07, 0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x2F, 0x05, 0x00, 0x00, 0x2A, 0x07, 0x02, 0x00, 0x33, 
  0x06, 0x07, 0x00, 0x1C, 0x06, 0x04, 0x00, 0x2A, 0x07, 0x03, 0x00, 0x01, 0x07, 0x00, 0x00, 0x1A, 
  0x01, 0x00, 0x00, 0x2E, 0x06, 0x00, 0x00, 0x19, 0x07, 0x06, 0x00, 0x29, 0x08, 0x00, 0x00, 0x2F, 
  0x08, 0x00, 0x00, 0x34, 0x07, 0x00, 0x00, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x0C, 0x01, 0x01, 0x01, 
  0x06, 0x46, 0x01, 0xDA, 0x82, 0x7E, 0xDA, 0x05, 0xDA, 0x81, 0x63, 0xDA, 0x22, 0xDA, 0x26, 0xDA, 
  0x81, 0x65, 0xDA, 0x2E, 0xDA, 0x2F, 0x2C, 0x01, 0x00, 0x00, 0x2B, 0x03, 0x00, 0x05, 0x45, 0x02, 
  0x00, 0x03, 0x1C, 0x02, 0x03, 0x00, 0x2B, 0x03, 0x00, 0x01, 0x03, 0x03, 0x00, 0x00, 0x2B, 0x04, 
  0x00, 0x00, 0x38, 0x03, 0x04, 0x00, 0x19, 0x04, 0x03, 0x00, 0x29, 0x05, 0x01, 0x00, 0x06, 0x03, 
  0x05, 0x00, 0x2B, 0x06, 0x00, 0x00, 0x38, 0x05, 0x06, 0x03, 0x19, 0x03, 0x05, 0x00, 0x2F, 0x04, 
  0x00, 0x00, 0x2A, 0x06, 0x00, 0x00, 0x33, 0x05, 0x06, 0x00, 0x19, 0x06, 0x05, 0x00, 0x1C, 0x06, 
  0x03, 0x00, 0x19, 0x05, 0x04, 0x00, 0x1A, 0x04, 0x00, 0x00, 0x2A, 0x08, 0x01, 0x00, 0x33, 0x07, 
  0x08, 0x00, 0x19, 0x05, 0x07, 0x00, 0x19, 0x07, 0x05, 0x00, 0x1C, 0x06, 0x13, 0x00, 0x2A, 0x05, 
  0x02, 0x00, 0x31, 0x05, 0x07, 0x03, 0x2A, 0x08, 0x03, 0x00, 0x33, 0x05, 0x08, 0x00, 0x29, 0x09, 
  0x02, 0x00, 0x06, 0x08, 0x09, 0x00, 0x2F, 0x08, 0x00, 0x00, 0x33, 0x09, 0x01, 0x00, 0x2A, 0x08, 
  0x04, 0x00, 0x31, 0x08, 0x07, 0x09, 0x2B, 0x08, 0x00, 0x02, 0x2F, 0x08, 0x00, 0x00, 0x2A, 0x0A, 
  0x03, 0x00, 0x33, 0x08, 0x0A, 0x00, 0x2A, 0x09, 0x05, 0x00, 0x31, 0x09, 0x05, 0x08, 0x2A, 0x09, 
  0x03, 0x00, 0x34, 0x09, 0x00, 0x00, 0x2A, 0x05, 0x02, 0x00, 0x31, 0x05, 0x07, 0x03, 0x2A, 0x08, 
  0x03, 0x00, 0x33, 0x05, 0x08, 0x00, 0x2A, 0x08, 0x02, 0x00, 0x31, 0x08, 0x04, 0x07, 0x2A, 0x09, 
  0x03, 0x00, 0x33, 0x08, 0x09, 0x00, 0x29, 0x0A, 0x02, 0x00, 0x06, 0x09, 0x0A, 0x00, 0x2F, 0x09, 
  0x00, 0x00, 0x33, 0x0A, 0x01, 0x00, 0x2A, 0x09, 0x05, 0x00, 0x31, 0x09, 0x08, 0x0A, 0x2A, 0x0B, 
  0x03, 0x00, 0x33, 0x09, 0x0B, 0x00, 0x2A, 0x08, 0x04, 0x00, 0x31, 0x08, 0x07, 0x09, 0x2B, 0x08, 
  0x00, 0x02, 0x2F, 0x08, 0x00, 0x00, 0x2A, 0x0A, 0x03, 0x00, 0x33, 0x08, 0x0A, 0x00, 0x2A, 0x09, 
  0x05, 0x00, 0x31, 0x09, 0x05, 0x08, 0x2A, 0x09, 0x03, 0x00, 0x34, 0x09, 0x00, 0x00, 0xBF, 0xFF, 
  0x82, 0x4F, 0x03, 0x01, 0x09, 0x00, 0x09, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x03, 0x11, 0x00, 
  0x11, 0x00, 0x09, 0x01, 0x1E, 0x00, 0x1E, 0x00, 0x11, 0x00, 0x11, 0x00, 0x09, 0x01, 0x12, 0x00, 
  0x12, 0x00, 0x12, 0x00, 0x09, 0x01, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x1D, 0x00, 0x1D, 0x00, 
  0x12, 0x00, 0x09, 0x01, 0x09, 0x03, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x01, 0x26, 0x00, 
  0x26, 0x00, 0x21, 0x00, 0x21, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 
  0x12, 0xBF, 0xFE, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x05, 0x12, 0x00, 0x12, 0x00, 0x12, 
  0x00, 0x12, 0x03, 0x20, 0x00, 0x20, 0x00, 0x20, 0x00, 0x20, 0x01, 0x25, 0x00, 0x25, 0x00, 0x20, 
  0x00, 0x20, 0xBF, 0xFE, 0x19, 0x00, 0x19, 0x00, 0x19, 0x00, 0x19, 0xBF, 0xFF, 0x12, 0x00, 0x12, 
  0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0xBF, 0xFE, 0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 
  0x0B, 0x82, 0x47, 0x01, 0x05, 0x0C, 0x00, 0x03, 0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x03, 
  0x00, 0x13, 0x00, 0x13, 0x00, 0x03, 0x01, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x03, 0x00, 0x12, 
  0x00, 0x12, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x15, 0x03, 0x00, 0x03, 0x00, 0x03, 0x27, 0x00, 
  0x00, 0x00, 0xCF, 0x04, 0x6E, 0x61, 0x74, 0x3F, 0xDA, 0x82, 0x3D, 0xCF, 0x0A, 0x70, 0x61, 0x72, 
  0x73, 0x65, 0x72, 0x2F, 0x6E, 0x65, 0x77, 0xDA, 0x80, 0xEE, 0xCF, 0x0C, 0x66, 0x69, 0x62, 0x65, 
  0x72, 0x2F, 0x73, 0x65, 0x74, 0x65, 0x6E, 0x76, 0xDA, 0x80, 0xFE, 0xCF, 0x05, 0x64, 0x65, 0x65, 
  0x70, 0x3D, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x02, 0x02, 0x02, 0x02, 0x07, 0xCE, 0x05, 
  0x64, 0x65, 0x65, 0x70, 0x3D, 0xDA, 0x05, 0xDA, 0x82, 0x2D, 0xDA, 0x81, 0x62, 0x2C, 0x02, 0x00, 
  0x00, 0x30, 0x00, 0x01, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 0x2F, 0x03, 0x00, 
  0x00, 0x2A, 0x04, 0x01, 0x00, 0x34, 0x04, 0x00, 0x00, 0x87, 0x1E, 0x01, 0x04, 0x08, 0x00, 0x08, 
  0x00, 0x08, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x10, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x72, 
  0x6E, 0x67, 0x2D, 0x75, 0x6E, 0x69, 0x66, 0x6F, 0x72, 0x6D, 0xD8, 0x10, 0x6D, 0x61, 0x74, 0x68, 
  0x2F, 0x72, 0x6E, 0x67, 0x2D, 0x75, 0x6E, 0x69, 0x66, 0x6F, 0x72, 0x6D, 0xCF, 0x09, 0x62, 0x61, 
  0x64, 0x2D, 0x70, 0x61, 0x72, 0x73, 0x65, 0xDA, 0x80, 0xEC, 0xCF, 0x0D, 0x66, 0x69, 0x62, 0x65, 
  0x72, 0x2F, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0xDA, 0x50, 0xCF, 0x06, 0x65, 0x70, 0x72, 
  0x69, 0x6E, 0x74, 0xDA, 0x80, 0x83, 0xCF, 0x0B, 0x69, 0x64, 0x65, 0x6D, 0x70, 0x6F, 0x74, 0x65, 
  0x6E, 0x74, 0x3F, 0xDA, 0x81, 0x63, 0xCF, 0x09, 0x66, 0x69, 0x6C, 0x65, 0x2F, 0x6F, 0x70, 0x65, 
  0x6E, 0xDA, 0x80, 0xD8, 0xCF, 0x0A, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x2F, 0x74, 0x79, 0x70, 0x65, 
  0xDA, 0x82, 0x18, 0xCF, 0x11, 0x74, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x63, 0x6F, 0x70, 0x79, 
  0x2D, 0x62, 0x79, 0x74, 0x65, 0x73, 0xD8, 0x11, 0x74, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x63, 
  0x6F, 0x70, 0x79, 0x2D, 0x62, 0x79, 0x74, 0x65, 0x73, 0xDA, 0x81, 0x92, 0xD7, 0xCD, 0x00, 0x98, 
  0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 0x02, 0x09, 0xCE, 0x02, 0x2D, 0x2D, 0xDA, 0x05, 0xDA, 0x81, 
  0xA9, 0xDA, 0x81, 0xA1, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x29, 0x04, 0x01, 0x00, 
  0x31, 0x03, 0x00, 0x04, 0x43, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x31, 0x04, 0x00, 0x02, 
  0x43, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x80, 0x84, 0x01, 0x00, 0x2F, 0x00, 0x2F, 0x00, 
  0x2F, 0x00, 0x2F, 0x00, 0x2F, 0x00, 0x2F, 0x00, 0x2F, 0x00, 0x2F, 0xCF, 0x0D, 0x70, 0x61, 0x72, 
  0x73, 0x65, 0x72, 0x2F, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0xDA, 0x80, 0xF6, 0xCF, 0x0A, 0x6D, 
  0x61, 0x74, 0x68, 0x2F, 0x6C, 0x6F, 0x67, 0x31, 0x70, 0xD8, 0x0A, 0x6D, 0x61, 0x74, 0x68, 0x2F, 
  0x6C, 0x6F, 0x67, 0x31, 0x70, 0xCF, 0x06, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x65, 0xC8, 0x69, 0x57, 
  0x14, 0x8B, 0x0A, 0xBF, 0x05, 0x40, 0xCF, 0x13, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x2D, 
  0x70, 0x65, 0x67, 0x2D, 0x67, 0x72, 0x61, 0x6D, 0x6D, 0x61, 0x72, 0xD3, 0x10, 0xD0, 0x01, 0x41, 
  0xD2, 0x03, 0x00, 0xDA, 0x47, 0xD0, 0x01, 0x61, 0x01, 0xD0, 0x01, 0x44, 0xD2, 0x03, 0x00, 0xDA, 
  0x47, 0xD0, 0x01, 0x64, 0x01, 0xDA, 0x85, 0xCA, 0xD2, 0x02, 0x00, 0xDA, 0x83, 0x15, 0xCE, 0x02, 
  0x30, 0x39, 0xD0, 0x01, 0x77, 0xD2, 0x04, 0x00, 0xDA, 0x83, 0x15, 0xCE, 0x02, 0x61, 0x7A, 0xCE, 
  0x02, 0x41, 0x5A, 0xDA, 0x85, 0xCC, 0xD0, 0x02, 0x64, 0x2B, 0xD2, 0x02, 0x00, 0xDA, 0x85, 0x12, 
  0xDA, 0x85, 0xCA, 0xD0, 0x02, 0x73, 0x2B, 0xD2, 0x02, 0x00, 0xDA, 0x85, 0x12, 0xD0, 0x01, 0x73, 
  0xD0, 0x02, 0x61, 0x2B, 0xD2, 0x02, 0x00, 0xDA, 0x85, 0x12, 0xDA, 0x85, 0xC7, 0xD0, 0x02, 0x61, 
  0x2A, 0xD2, 0x02, 0x00, 0xCF, 0x03, 0x61, 0x6E, 0x79, 0xDA, 0x85, 0xC7, 0xD0, 0x02, 0x73, 0x2A, 
  0xD2, 0x02, 0x00, 0xDA, 0x85, 0xDA, 0xDA, 0x85, 0xD5, 0xDA, 0x85, 0xC7, 0xD2, 0x03, 0x00, 0xDA, 
  0x83, 0x15, 0xDA, 0x85, 0xCF, 0xDA, 0x85, 0xD0, 0xD0, 0x02, 0x64, 0x2A, 0xD2, 0x02, 0x00, 0xDA, 
  0x85, 0xDA, 0xDA, 0x85, 0xCA, 0xD0, 0x02, 0x77, 0x2A, 0xD2, 0x02, 0x00, 0xDA, 0x85, 0xDA, 0xDA, 
  0x85, 0xCE, 0xDA, 0x85, 0xD5, 0xD2, 0x02, 0x00, 0xDA, 0x81, 0xA1, 0xCE, 0x06, 0x20, 0x09, 0x0D, 
  0x0A, 0x00, 0x0C, 0xD0, 0x01, 0x57, 0xD2, 0x03, 0x00, 0xDA, 0x47, 0xDA, 0x85, 0xCE, 0x01, 0xD0, 
  0x02, 0x77, 0x2B, 0xD2, 0x02, 0x00, 0xDA, 0x85, 0x12, 0xDA, 0x85, 0xCE, 0xD0, 0x01, 0x53, 0xD2, 
  0x03, 0x00, 0xDA, 0x47, 0xDA, 0x85, 0xD5, 0x01, 0xCF, 0x0C, 0x66, 0x6C, 0x61, 0x74, 0x74, 0x65, 
  0x6E, 0x2D, 0x69, 0x6E, 0x74, 0x6F, 0xDA, 0x81, 0xD9, 0xCF, 0x05, 0x66, 0x69, 0x72, 0x73, 0x74, 
  0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x04, 0x01, 0x01, 0x01, 0x00, 0x04, 0xCE, 0x05, 0x66, 0x69, 
  0x72, 0x73, 0x74, 0xDA, 0x05, 0x2C, 0x01, 0x00, 0x00, 0x29, 0x03, 0x00, 0x00, 0x39, 0x02, 0x00, 
  0x03, 0x03, 0x02, 0x00, 0x00, 0x82, 0x94, 0x01, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x09, 
  0x64, 0x65, 0x65, 0x70, 0x2D, 0x6E, 0x6F, 0x74, 0x3D, 0xDA, 0x82, 0x2D, 0xCF, 0x09, 0x6D, 0x61, 
  0x74, 0x68, 0x2F, 0x63, 0x62, 0x72, 0x74, 0xD8, 0x09, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x63, 0x62, 
  0x72, 0x74, 0xCF, 0x0C, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 0x66, 0x62, 0x72, 0x65, 0x61, 0x6B, 
  0xDA, 0x83, 0xFA, 0xCF, 0x0D, 0x6F, 0x73, 0x2F, 0x63, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x72, 0x61, 
  0x6E, 0x64, 0xD8, 0x0D, 0x6F, 0x73, 0x2F, 0x63, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x72, 0x61, 0x6E, 
  0x64, 0xDA, 0x44, 0x01, 0xCF, 0x0D, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x69, 0x6E, 0x73, 
  0x65, 0x72, 0x74, 0xD8, 0x0D, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x69, 0x6E, 0x73, 0x65, 
  0x72, 0x74, 0xCF, 0x0B, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 0x62, 0x72, 0x65, 0x61, 0x6B, 0xD8, 
  0x0B, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 0x62, 0x72, 0x65, 0x61, 0x6B, 0xCF, 0x0A, 0x63, 0x66, 
  0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x3F, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x01, 
  0x01, 0x01, 0x02, 0x07, 0xCE, 0x0A, 0x63, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x3F, 
  0xDA, 0x05, 0xDA, 0x39, 0xD0, 0x09, 0x63, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2C, 
  0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x2A, 
  0x04, 0x01, 0x00, 0x23, 0x03, 0x02, 0x04, 0x03, 0x03, 0x00, 0x00, 0x60, 0x01, 0x00, 0x33, 0x00, 
  0x33, 0x00, 0x33, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0xCF, 0x07, 0x6F, 0x73, 0x2F, 0x64, 0x61, 
  0x74, 0x65, 0xD8, 0x07, 0x6F, 0x73, 0x2F, 0x64, 0x61, 0x74, 0x65, 0xCF, 0x09, 0x77, 0x69, 0x74, 
  0x68, 0x2D, 0x76, 0x61, 0x72, 0x73, 0xD7, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x16, 0x01, 0x01, 0xCD, 
  0x7F, 0xFF, 0xFF, 0xFF, 0x10, 0x80, 0x91, 0xCE, 0x09, 0x77, 0x69, 0x74, 0x68, 0x2D, 0x76, 0x61, 
  0x72, 0x73, 0xDA, 0x05, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 0x00, 0x06, 
  0xCE, 0x05, 0x65, 0x76, 0x65, 0x6E, 0x3F, 0xDA, 0x05, 0x2C, 0x01, 0x00, 0x00, 0x29, 0x03, 0x02, 
  0x00, 0x0C, 0x02, 0x00, 0x03, 0x29, 0x04, 0x00, 0x00, 0x23, 0x03, 0x04, 0x02, 0x03, 0x03, 0x00, 
  0x00, 0x52, 0x01, 0x00, 0x2C, 0x00, 0x2C, 0x00, 0x27, 0x00, 0x27, 0x00, 0x27, 0xCE, 0x28, 0x65, 
  0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x65, 0x76, 0x65, 0x6E, 0x20, 0x6E, 0x75, 0x6D, 
  0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 
  0x74, 0x6F, 0x20, 0x76, 0x61, 0x72, 0x73, 0xDA, 0x22, 0xDA, 0x52, 0xDA, 0x26, 0xDA, 0x81, 0xA1, 
  0xDA, 0x23, 0xDA, 0x24, 0xDA, 0x25, 0xDA, 0x28, 0xDA, 0x29, 0xDA, 0x2A, 0xDA, 0x2B, 0xDA, 0x2D, 
  0xDA, 0x2E, 0xDA, 0x2F, 0x2C, 0x02, 0x00, 0x00, 0x3D, 0x03, 0x00, 0x00, 0x19, 0x04, 0x03, 0x00, 
  0x2F, 0x04, 0x00, 0x00, 0x2A, 0x06, 0x00, 0x00, 0x33, 0x05, 0x06, 0x00, 0x1C, 0x05, 0x02, 0x00, 
  0x1A, 0x03, 0x00, 0x00, 0x2A, 0x06, 0x01, 0x00, 0x01, 0x06, 0x00, 0x00, 0x3E, 0x05, 0x00, 0x00, 
  0x19, 0x06, 0x05, 0x00, 0x29, 0x05, 0x00, 0x00, 0x19, 0x07, 0x04, 0x00, 0x21, 0x08, 0x05, 0x07, 
  0x1C, 0x08, 0x0A, 0x00, 0x19, 0x09, 0x05, 0x00, 0x2A, 0x0B, 0x02, 0x00, 0x33, 0x0A, 0x0B, 0x00, 
  0x30, 0x06, 0x0A, 0x00, 0x2A, 0x0C, 0x03, 0x00, 0x33, 0x0B, 0x0C, 0x00, 0x29, 0x0A, 0x02, 0x00, 
  0x06, 0x05, 0x05, 0x0A, 0x1A, 0xF6, 0xFF, 0xFF, 0x19, 0x05, 0x06, 0x00, 0x3E, 0x07, 0x00, 0x00, 
  0x19, 0x08, 0x07, 0x00, 0x29, 0x07, 0x00, 0x00, 0x19, 0x09, 0x04, 0x00, 0x21, 0x0A, 0x07, 0x09, 
  0x1C, 0x0A, 0x11, 0x00, 0x19, 0x0B, 0x07, 0x00, 0x29, 0x0D, 0x02, 0x00, 0x0B, 0x0C, 0x0B, 0x0D, 
  0x2F, 0x0C, 0x00, 0x00, 0x33, 0x0D, 0x05, 0x00, 0x2F, 0x0B, 0x00, 0x00, 0x33, 0x0C, 0x00, 0x00, 
  0x2A, 0x0E, 0x04, 0x00, 0x31, 0x0E, 0x0D, 0x0C, 0x43, 0x0C, 0x00, 0x00, 0x30, 0x08, 0x0C, 0x00, 
  0x2A, 0x0E, 0x03, 0x00, 0x33, 0x0D, 0x0E, 0x00, 0x29, 0x0C, 0x02, 0x00, 0x06, 0x07, 0x07, 0x0C, 
  0x1A, 0xEF, 0xFF, 0xFF, 0x19, 0x07, 0x08, 0x00, 0x3E, 0x09, 0x00, 0x00, 0x19, 0x0A, 0x09, 0x00, 
  0x29, 0x09, 0x00, 0x00, 0x19, 0x0B, 0x04, 0x00, 0x21, 0x0C, 0x09, 0x0B, 0x1C, 0x0C, 0x11, 0x00, 
  0x19, 0x0D, 0x09, 0x00, 0x2F, 0x0D, 0x00, 0x00, 0x33, 0x0E, 0x00, 0x00, 0x29, 0x10, 0x01, 0x00, 
  0x06, 0x0F, 0x0D, 0x10, 0x2F, 0x0F, 0x00, 0x00, 0x33, 0x10, 0x00, 0x00, 0x2A, 0x0F, 0x05, 0x00, 
  0x31, 0x0F, 0x0E, 0x10, 0x43, 0x0E, 0x00, 0x00, 0x30, 0x0A, 0x0E, 0x00, 0x2A, 0x10, 0x03, 0x00, 
  0x33, 0x0F, 0x10, 0x00, 0x29, 0x0E, 0x02, 0x00, 0x06, 0x09, 0x09, 0x0E, 0x1A, 0xEF, 0xFF, 0xFF, 
  0x19, 0x09, 0x0A, 0x00, 0x3E, 0x0B, 0x00, 0x00, 0x19, 0x0C, 0x0B, 0x00, 0x29, 0x0B, 0x00, 0x00, 
  0x19, 0x0D, 0x04, 0x00, 0x21, 0x0E, 0x0B, 0x0D, 0x1C, 0x0E, 0x11, 0x00, 0x19, 0x0F, 0x0B, 0x00, 
  0x2F, 0x0F, 0x00, 0x00, 0x33, 0x10, 0x00, 0x00, 0x29, 0x12, 0x02, 0x00, 0x0B, 0x11, 0x0F, 0x12, 
  0x2F, 0x11, 0x00, 0x00, 0x33, 0x12, 0x05, 0x00, 0x2A, 0x11, 0x05, 0x00, 0x31, 0x11, 0x10, 0x12, 
  0x43, 0x10, 0x00, 0x00, 0x30, 0x0C, 0x10, 0x00, 0x2A, 0x12, 0x03, 0x00, 0x33, 0x11, 0x12, 0x00, 
  0x29, 0x10, 0x02, 0x00, 0x06, 0x0B, 0x0B, 0x10, 0x1A, 0xEF, 0xFF, 0xFF, 0x19, 0x0B, 0x0C, 0x00, 
  0x2A, 0x0E, 0x02, 0x00, 0x33, 0x0D, 0x0E, 0x00, 0x19, 0x0E, 0x0D, 0x00, 0x2A, 0x0F, 0x02, 0x00, 
  0x33, 0x0D, 0x0F, 0x00, 0x19, 0x0F, 0x0D, 0x00, 0x2A, 0x10, 0x02, 0x00, 0x33, 0x0D, 0x10, 0x00, 
  0x19, 0x10, 0x0D, 0x00, 0x44, 0x0D, 0x00, 0x00, 0x2A, 0x12, 0x06, 0x00, 0x30, 0x12, 0x0D, 0x00, 
  0x32, 0x09, 0x00, 0x00, 0x32, 0x01, 0x00, 0x00, 0x43, 0x11, 0x00, 0x00, 0x2A, 0x12, 0x07, 0x00, 
  0x2A, 0x13, 0x08, 0x00, 0x31, 0x12, 0x11, 0x13, 0x43, 0x0D, 0x00, 0x00, 0x2A, 0x12, 0x04, 0x00, 
  0x31, 0x12, 0x0F, 0x0D, 0x43, 0x11, 0x00, 0x00, 0x2A, 0x12, 0x09, 0x00, 0x30, 0x12, 0x0F, 0x00, 
  0x43, 0x0D, 0x00, 0x00, 0x2A, 0x13, 0x04, 0x00, 0x31, 0x13, 0x0E, 0x0D, 0x43, 0x12, 0x00, 0x00, 
  0x2A, 0x13, 0x0A, 0x00, 0x30, 0x13, 0x0F, 0x00, 0x43, 0x0D, 0x00, 0x00, 0x2A, 0x14, 0x0B, 0x00, 
  0x2A, 0x15, 0x0C, 0x00, 0x31, 0x14, 0x0D, 0x15, 0x43, 0x13, 0x00, 0x00, 0x2A, 0x14, 0x0D, 0x00, 
  0x31, 0x14, 0x0E, 0x0F, 0x43, 0x0D, 0x00, 0x00, 0x2A, 0x15, 0x0E, 0x00, 0x31, 0x15, 0x13, 0x0E, 
  0x2F, 0x0D, 0x00, 0x00, 0x43, 0x14, 0x00, 0x00, 0x2A, 0x13, 0x0F, 0x00, 0x2F, 0x13, 0x00, 0x00, 
  0x32, 0x07, 0x00, 0x00, 0x30, 0x11, 0x12, 0x00, 0x32, 0x0B, 0x00, 0x00, 0x2F, 0x14, 0x00, 0x00, 
  0x43, 0x0D, 0x00, 0x00, 0x03, 0x0D, 0x00, 0x00, 0x84, 0x87, 0x01, 0x04, 0x0C, 0x00, 0x03, 0x01, 
  0x0B, 0x00, 0x0B, 0x00, 0x0B, 0x00, 0x03, 0x00, 0x03, 0x00, 0x17, 0x00, 0x17, 0x01, 0x0D, 0x00, 
  0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x27, 0x00, 0x27, 0x00, 
  0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x03, 0x01, 0x10, 0x00, 
  0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x36, 0x00, 0x36, 0x00, 
  0x30, 0x00, 0x30, 0x00, 0x3F, 0x00, 0x3F, 0x00, 0x2A, 0x00, 0x2A, 0x00, 0x2A, 0x00, 0x10, 0x00, 
  0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x03, 0x01, 0x0F, 0x00, 0x0F, 0x00, 
  0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x2F, 0x00, 0x2F, 0x00, 0x3E, 0x00, 
  0x3E, 0x00, 0x38, 0x00, 0x38, 0x00, 0x29, 0x00, 0x29, 0x00, 0x29, 0x00, 0x0F, 0x00, 0x0F, 0x00, 
  0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x03, 0x01, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 
  0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x33, 0x00, 0x33, 0x00, 0x42, 0x00, 0x42, 0x00, 
  0x3C, 0x00, 0x3C, 0x00, 0x2D, 0x00, 0x2D, 0x00, 0x2D, 0x00, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 
  0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xCF, 0x04, 0x73, 0x70, 0x69, 
  0x74, 0xDA, 0x84, 0x3D, 0xCF, 0x05, 0x66, 0x6C, 0x75, 0x73, 0x68, 0xDA, 0x83, 0x96, 0xCF, 0x02, 
  0x2B, 0x3D, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x06, 0x02, 0x02, 0x02, 0x02, 0x08, 0xCE, 0x02, 
  0x2B, 0x3D, 0xDA, 0x05, 0xDA, 0x81, 0x99, 0xDA, 0x81, 0xA1, 0x2C, 0x02, 0x00, 0x00, 0x2A, 0x04, 
  0x00, 0x00, 0x31, 0x04, 0x00, 0x01, 0x43, 0x03, 0x00, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x31, 0x05, 
  0x00, 0x03, 0x43, 0x04, 0x00, 0x00, 0x03, 0x04, 0x00, 0x00, 0x80, 0x85, 0x01, 0x00, 0x31, 0x00, 
  0x31, 0x00, 0x31, 0x00, 0x31, 0x00, 0x31, 0x00, 0x31, 0x00, 0x31, 0xCF, 0x09, 0x70, 0x65, 0x67, 
  0x2F, 0x6D, 0x61, 0x74, 0x63, 0x68, 0xD8, 0x09, 0x70, 0x65, 0x67, 0x2F, 0x6D, 0x61, 0x74, 0x63, 
  0x68, 0xCF, 0x04, 0x62, 0x61, 0x6E, 0x64, 0xD7, 0xCD, 0x00, 0x09, 0x00, 0x0D, 0x06, 0x00, 0x00, 
  0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x13, 0xCE, 0x04, 0x62, 0x61, 0x6E, 0x64, 0x3D, 0x01, 0x00, 
  0x00, 0x24, 0x02, 0x01, 0x00, 0x1C, 0x02, 0x03, 0x00, 0x29, 0x03, 0xFF, 0xFF, 0x03, 0x03, 0x00, 
  0x00, 0x24, 0x02, 0x01, 0x01, 0x1C, 0x02, 0x05, 0x00, 0x29, 0x03, 0xFF, 0xFF, 0x3B, 0x04, 0x00, 
  0x00, 0x0E, 0x03, 0x03, 0x04, 0x03, 0x03, 0x00, 0x00, 0x3B, 0x03, 0x00, 0x00, 0x29, 0x05, 0x01, 
  0x00, 0x38, 0x04, 0x00, 0x05, 0x0E, 0x03, 0x03, 0x04, 0x05, 0x05, 0x05, 0x01, 0x23, 0x02, 0x05, 
  0x01, 0x1C, 0x02, 0xFC, 0xFF, 0x03, 0x03, 0x00, 0x00, 0xCF, 0x0C, 0x70, 0x61, 0x72, 0x73, 0x65, 
  0x72, 0x2F, 0x66, 0x6C, 0x75, 0x73, 0x68, 0xDA, 0x80, 0xF1, 0xCF, 0x0E, 0x66, 0x69, 0x62, 0x65, 
  0x72, 0x2F, 0x6D, 0x61, 0x78, 0x73, 0x74, 0x61, 0x63, 0x6B, 0xD8, 0x0E, 0x66, 0x69, 0x62, 0x65, 
  0x72, 0x2F, 0x6D, 0x61, 0x78, 0x73, 0x74, 0x61, 0x63, 0x6B, 0xCF, 0x07, 0x6F, 0x73, 0x2F, 0x73, 
  0x74, 0x61, 0x74, 0xDA, 0x80, 0xBC, 0xCF, 0x05, 0x65, 0x76, 0x65, 0x6E, 0x3F, 0xDA, 0x86, 0x02, 
  0xCF, 0x07, 0x72, 0x65, 0x76, 0x65, 0x72, 0x73, 0x65, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0C, 
  0x01, 0x01, 0x01, 0x02, 0x15, 0xCE, 0x07, 0x72, 0x65, 0x76, 0x65, 0x72, 0x73, 0x65, 0xDA, 0x05, 
  0xDA, 0x55, 0xDA, 0x52, 0x2C, 0x01, 0x00, 0x00, 0x3D, 0x02, 0x00, 0x00, 0x19, 0x03, 0x02, 0x00, 
  0x29, 0x05, 0x01, 0x00, 0x07, 0x04, 0x03, 0x05, 0x19, 0x05, 0x04, 0x00, 0x2F, 0x03, 0x00, 0x00, 
  0x2A, 0x07, 0x00, 0x00, 0x33, 0x06, 0x07, 0x00, 0x19, 0x07, 0x06, 0x00, 0x29, 0x09, 0x00, 0x00, 
  0x45, 0x08, 0x05, 0x09, 0x1C, 0x08, 0x08, 0x00, 0x38, 0x09, 0x00, 0x05, 0x30, 0x07, 0x09, 0x00, 
  0x2A, 0x0B, 0x01, 0x00, 0x33, 0x0A, 0x0B, 0x00, 0x29, 0x09, 0x01, 0x00, 0x07, 0x05, 0x05, 0x09, 
  0x1A, 0xF7, 0xFF, 0xFF, 0x03, 0x07, 0x00, 0x00, 0x84, 0xA8, 0x01, 0x03, 0x0C, 0x00, 0x03, 0x01, 
  0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x03, 0x01, 0x0A, 0x00, 
  0x0A, 0x00, 0x03, 0x01, 0x1A, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 0xBF, 
  0xFE, 0x03, 0xBF, 0xFA, 0x01, 0xCF, 0x0A, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x68, 0x79, 0x70, 0x6F, 
  0x74, 0xD8, 0x0A, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x68, 0x79, 0x70, 0x6F, 0x74, 0xCF, 0x0A, 0x6D, 
  0x61, 0x74, 0x68, 0x2F, 0x74, 0x72, 0x75, 0x6E, 0x63, 0xD8, 0x0A, 0x6D, 0x61, 0x74, 0x68, 0x2F, 
  0x74, 0x72, 0x75, 0x6E, 0x63, 0xDA, 0x81, 0xB3, 0xDA, 0x80, 0xFA, 0xCF, 0x03, 0x64, 0x6F, 0x63, 
  0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x01, 0x00, 0x01, 0x02, 0x08, 0xCE, 0x03, 0x64, 0x6F, 
  0x63, 0xDA, 0x05, 0xDA, 0x82, 0x16, 0xDA, 0x84, 0x8E, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x03, 0x00, 
  0x00, 0x30, 0x03, 0x00, 0x00, 0x43, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x30, 0x04, 0x02, 
  0x00, 0x43, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x86, 0x8C, 0x01, 0x06, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x0F, 0x70, 0x61, 0x72, 0x73, 
  0x65, 0x72, 0x2F, 0x68, 0x61, 0x73, 0x2D, 0x6D, 0x6F, 0x72, 0x65, 0xDA, 0x80, 0xF4, 0xCF, 0x0A, 
  0x6D, 0x61, 0x74, 0x68, 0x2F, 0x72, 0x6F, 0x75, 0x6E, 0x64, 0xD8, 0x0A, 0x6D, 0x61, 0x74, 0x68, 
  0x2F, 0x72, 0x6F, 0x75, 0x6E, 0x64, 0xCF, 0x08, 0x6F, 0x73, 0x2F, 0x6C, 0x73, 0x74, 0x61, 0x74, 
  0xD8, 0x08, 0x6F, 0x73, 0x2F, 0x6C, 0x73, 0x74, 0x61, 0x74, 0xCF, 0x0C, 0x73, 0x74, 0x72, 0x69, 
  0x6E, 0x67, 0x2F, 0x62, 0x79, 0x74, 0x65, 0x73, 0xD8, 0x0C, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 
  0x2F, 0x62, 0x79, 0x74, 0x65, 0x73, 0xCF, 0x07, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x3F, 0xDA, 
  0x80, 0xCA, 0xCF, 0x05, 0x74, 0x72, 0x75, 0x65, 0x3F, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x04, 
  0x01, 0x01, 0x01, 0x00, 0x04, 0xCE, 0x05, 0x74, 0x72, 0x75, 0x65, 0x3F, 0xDA, 0x05, 0x2C, 0x01, 
  0x00, 0x00, 0x27, 0x03, 0x00, 0x00, 0x23, 0x02, 0x00, 0x03, 0x03, 0x02, 0x00, 0x00, 0x70, 0x01, 
  0x00, 0x27, 0x00, 0x27, 0x00, 0x27, 0xCF, 0x0C, 0x74, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x73, 
  0x6C, 0x69, 0x63, 0x65, 0xD8, 0x0C, 0x74, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x73, 0x6C, 0x69, 
  0x63, 0x65, 0xCF, 0x0B, 0x61, 0x63, 0x63, 0x75, 0x6D, 0x75, 0x6C, 0x61, 0x74, 0x65, 0x32, 0xD7, 
  0xCD, 0x00, 0x98, 0x00, 0x00, 0x0D, 0x02, 0x02, 0x02, 0x02, 0x24, 0xCE, 0x0B, 0x61, 0x63, 0x63, 
  0x75, 0x6D, 0x75, 0x6C, 0x61, 0x74, 0x65, 0x32, 0xDA, 0x05, 0xDA, 0x55, 0xDA, 0x52, 0x2C, 0x02, 
  0x00, 0x00, 0x26, 0x04, 0x00, 0x00, 0x47, 0x03, 0x01, 0x04, 0x19, 0x04, 0x03, 0x00, 0x3D, 0x05, 
  0x01, 0x00, 0x2F, 0x05, 0x00, 0x00, 0x2A, 0x07, 0x00, 0x00, 0x33, 0x06, 0x07, 0x00, 0x19, 0x05, 
  0x06, 0x00, 0x26, 0x08, 0x00, 0x00, 0x23, 0x07, 0x08, 0x04, 0x1C, 0x07, 0x03, 0x00, 0x03, 0x05, 
  0x00, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x38, 0x07, 0x01, 0x04, 0x19, 0x08, 0x07, 0x00, 0x30, 0x05, 
  0x08, 0x00, 0x2A, 0x0A, 0x01, 0x00, 0x33, 0x09, 0x0A, 0x00, 0x47, 0x04, 0x01, 0x04, 0x26, 0x0B, 
  0x00, 0x00, 0x23, 0x0A, 0x0B, 0x04, 0x1B, 0x0A, 0x03, 0x00, 0x27, 0x0A, 0x00, 0x00, 0x1A, 0x02, 
  0x00, 0x00, 0x28, 0x0A, 0x00, 0x00, 0x1C, 0x0A, 0x09, 0x00, 0x38, 0x0B, 0x01, 0x04, 0x30, 0x08, 
  0x0B, 0x00, 0x33, 0x08, 0x00, 0x00, 0x30, 0x05, 0x08, 0x00, 0x2A, 0x0C, 0x01, 0x00, 0x33, 0x0B, 
  0x0C, 0x00, 0x47, 0x04, 0x01, 0x04, 0x1A, 0xF2, 0xFF, 0xFF, 0x03, 0x05, 0x00, 0x00, 0x83, 0x32, 
  0x01, 0x03, 0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x17, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 
  0x03, 0x01, 0x07, 0x00, 0x07, 0x00, 0x03, 0x00, 0x11, 0x00, 0x03, 0x01, 0x0C, 0x00, 0x03, 0x01, 
  0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x0A, 0x01, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 
  0x0A, 0x00, 0x0A, 0x00, 0x03, 0x01, 0x15, 0x00, 0x0E, 0x00, 0x0E, 0x01, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x01, 0x0C, 0xBF, 0xFD, 0x03, 0xBF, 0xF7, 0x01, 0xCF, 0x0A, 0x6D, 0x61, 0x74, 0x68, 0x2F, 
  0x61, 0x74, 0x61, 0x6E, 0x68, 0xD8, 0x0A, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x61, 0x74, 0x61, 0x6E, 
  0x68, 0xCF, 0x04, 0x73, 0x6F, 0x72, 0x74, 0xDA, 0x5E, 0xCF, 0x0D, 0x74, 0x61, 0x72, 0x72, 0x61, 
  0x79, 0x2F, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0xD8, 0x0D, 0x74, 0x61, 0x72, 0x72, 0x61, 0x79, 
  0x2F, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0xCF, 0x08, 0x6F, 0x73, 0x2F, 0x63, 0x68, 0x6D, 0x6F, 
  0x64, 0xD8, 0x08, 0x6F, 0x73, 0x2F, 0x63, 0x68, 0x6D, 0x6F, 0x64, 0xCF, 0x04, 0x6D, 0x65, 0x61, 
  0x6E, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 0x01, 0x07, 0xCE, 0x04, 0x6D, 
  0x65, 0x61, 0x6E, 0xDA, 0x05, 0xDA, 0x81, 0xF4, 0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 
  0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 0x3D, 0x03, 0x00, 0x00, 0x0B, 0x04, 0x02, 0x03, 
  0x03, 0x04, 0x00, 0x00, 0x82, 0x3B, 0x01, 0x03, 0x06, 0x00, 0x06, 0x00, 0x06, 0x00, 0x0F, 0x00, 
  0x03, 0x00, 0x03, 0xCF, 0x0A, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x62, 0x69, 0x74, 0xD8, 
  0x0A, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x62, 0x69, 0x74, 0xCF, 0x09, 0x77, 0x69, 0x74, 
  0x68, 0x2D, 0x64, 0x79, 0x6E, 0x73, 0xD7, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x0C, 0x01, 0x01, 0xCD, 
  0x7F, 0xFF, 0xFF, 0xFF, 0x06, 0x27, 0xCE, 0x09, 0x77, 0x69, 0x74, 0x68, 0x2D, 0x64, 0x79, 0x6E, 
  0x73, 0xDA, 0x05, 0xDA, 0x84, 0x73, 0xDA, 0x52, 0xDA, 0x23, 0xDA, 0x24, 0xDA, 0x83, 0xD1, 0xDA, 
  0x28, 0x2C, 0x02, 0x00, 0x00, 0x3E, 0x03, 0x00, 0x00, 0x19, 0x04, 0x03, 0x00, 0x29, 0x03, 0x00, 
  0x00, 0x3D, 0x05, 0x00, 0x00, 0x19, 0x06, 0x05, 0x00, 0x21, 0x05, 0x03, 0x06, 0x1C, 0x05, 0x11, 
  0x00, 0x19, 0x07, 0x03, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x33, 0x08, 0x00, 0x00, 0x29, 0x0A, 0x01, 
  0x00, 0x06, 0x09, 0x07, 0x0A, 0x2F, 0x09, 0x00, 0x00, 0x33, 0x0A, 0x00, 0x00, 0x2A, 0x0B, 0x00, 
  0x00, 0x31, 0x0B, 0x08, 0x0A, 0x43, 0x09, 0x00, 0x00, 0x30, 0x04, 0x09, 0x00, 0x2A, 0x0A, 0x01, 
  0x00, 0x33, 0x08, 0x0A, 0x00, 0x29, 0x08, 0x02, 0x00, 0x06, 0x03, 0x03, 0x08, 0x1A, 0xEF, 0xFF, 
  0xFF, 0x19, 0x03, 0x04, 0x00, 0x44, 0x05, 0x00, 0x00, 0x2A, 0x07, 0x02, 0x00, 0x30, 0x07, 0x05, 
  0x00, 0x32, 0x03, 0x00, 0x00, 0x32, 0x01, 0x00, 0x00, 0x43, 0x06, 0x00, 0x00, 0x2A, 0x07, 0x03, 
  0x00, 0x2A, 0x08, 0x04, 0x00, 0x31, 0x07, 0x06, 0x08, 0x43, 0x05, 0x00, 0x00, 0x2A, 0x07, 0x05, 
  0x00, 0x30, 0x07, 0x05, 0x00, 0x43, 0x06, 0x00, 0x00, 0x03, 0x06, 0x00, 0x00, 0x84, 0x7C, 0x01, 
  0x07, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x17, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x01, 0x11, 0x00, 0x11, 0x00, 0x29, 0x00, 0x29, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x07, 0x00, 0x07, 
  0x00, 0x07, 0xBF, 0xFF, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0xBF, 
  0xFF, 0x03, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x06, 
  0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0xDA, 0x80, 0x8E, 0xCF, 0x09, 0x66, 0x69, 0x6C, 0x65, 0x2F, 
  0x74, 0x65, 0x6D, 0x70, 0xD8, 0x09, 0x66, 0x69, 0x6C, 0x65, 0x2F, 0x74, 0x65, 0x6D, 0x70, 0xCF, 
  0x08, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x72, 0x6E, 0x67, 0xD8, 0x08, 0x6D, 0x61, 0x74, 0x68, 0x2F, 
  0x72, 0x6E, 0x67, 0xCF, 0x11, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x62, 0x69, 0x74, 0x2D, 
  0x74, 0x6F, 0x67, 0x67, 0x6C, 0x65, 0xD8, 0x11, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x62, 
  0x69, 0x74, 0x2D, 0x74, 0x6F, 0x67, 0x67, 0x6C, 0x65, 0xCF, 0x09, 0x75, 0x70, 0x64, 0x61, 0x74, 
  0x65, 0x2D, 0x69, 0x6E, 0xD7, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x11, 0x03, 0x03, 0xCD, 0x7F, 0xFF, 
  0xFF, 0xFF, 0x02, 0x2B, 0xCE, 0x09, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x2D, 0x69, 0x6E, 0xDA, 
  0x05, 0xDA, 0x06, 0xDA, 0x07, 0x2C, 0x04, 0x00, 0x00, 0x19, 0x05, 0x00, 0x00, 0x3D, 0x06, 0x01, 
  0x00, 0x29, 0x08, 0x01, 0x00, 0x07, 0x07, 0x06, 0x08, 0x19, 0x06, 0x07, 0x00, 0x29, 0x09, 0x00, 
  0x00, 0x21, 0x08, 0x06, 0x09, 0x1C, 0x08, 0x04, 0x00, 0x2A, 0x09, 0x00, 0x00, 0x01, 0x09, 0x00, 
  0x00, 0x1A, 0x01, 0x00, 0x00, 0x29, 0x08, 0x00, 0x00, 0x19, 0x09, 0x06, 0x00, 0x21, 0x0A, 0x08, 
  0x09, 0x1C, 0x0A, 0x13, 0x00, 0x19, 0x0B, 0x08, 0x00, 0x39, 0x0C, 0x01, 0x0B, 0x19, 0x0D, 0x0C, 
  0x00, 0x39, 0x0C, 0x05, 0x0D, 0x19, 0x0E, 0x0C, 0x00, 0x26, 0x0F, 0x00, 0x00, 0x23, 0x0C, 0x0F, 
  0x0E, 0x1C, 0x0C, 0x07, 0x00, 0x2A, 0x10, 0x01, 0x00, 0x33, 0x0F, 0x10, 0x00, 0x19, 0x10, 0x0F, 
  0x00, 0x3A, 0x05, 0x0D, 0x10, 0x19, 0x05, 0x10, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x05, 0x0E, 
  0x00, 0x29, 0x0C, 0x01, 0x00, 0x06, 0x08, 0x08, 0x0C, 0x1A, 0xED, 0xFF, 0xFF, 0x39, 0x08, 0x01, 
  0x06, 0x19, 0x09, 0x08, 0x00, 0x39, 0x0A, 0x05, 0x09, 0x19, 0x0B, 0x0A, 0x00, 0x2F, 0x0B, 0x00, 
  0x00, 0x32, 0x03, 0x00, 0x00, 0x33, 0x0C, 0x02, 0x00, 0x3A, 0x05, 0x09, 0x0C, 0x03, 0x00, 0x00, 
  0x00, 0x84, 0xD1, 0x01, 0x06, 0x03, 0x01, 0x11, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x03, 0x01, 0x07, 
  0x00, 0x07, 0x00, 0x03, 0x00, 0x13, 0x00, 0x13, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x01, 0x0C, 0x00, 0x05, 0x01, 0x0C, 0x00, 0x05, 0x01, 0x09, 0x00, 0x09, 
  0x00, 0x05, 0x01, 0x12, 0x00, 0x12, 0x00, 0x07, 0x01, 0x09, 0x01, 0x09, 0xBF, 0xFD, 0x05, 0x04, 
  0x07, 0xBF, 0xF9, 0x03, 0x00, 0x03, 0x00, 0x03, 0x08, 0x11, 0x00, 0x03, 0x01, 0x11, 0x00, 0x03, 
  0x01, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 0x03, 0xBF, 0xED, 0x01, 0xCF, 0x09, 0x70, 0x61, 0x72, 
  0x74, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x0F, 0x02, 0x02, 0x02, 
  0x06, 0x2C, 0xCE, 0x09, 0x70, 0x61, 0x72, 0x74, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0xDA, 0x05, 0xDA, 
  0x82, 0x64, 0xDA, 0x55, 0xDA, 0x81, 0x1E, 0xDA, 0x81, 0x1F, 0xDA, 0x70, 0xDA, 0x52, 0x2C, 0x02, 
  0x00, 0x00, 0x29, 0x03, 0x00, 0x00, 0x19, 0x04, 0x00, 0x00, 0x3D, 0x05, 0x01, 0x00, 0x19, 0x06, 
  0x05, 0x00, 0x0B, 0x07, 0x06, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x2A, 0x09, 0x00, 0x00, 0x33, 0x08, 
  0x09, 0x00, 0x2F, 0x08, 0x00, 0x00, 0x2A, 0x09, 0x01, 0x00, 0x33, 0x07, 0x09, 0x00, 0x19, 0x08, 
  0x07, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 0x0B, 0x02, 0x00, 0x33, 0x0A, 0x0B, 0x00, 0x1C, 0x0A, 
  0x03, 0x00, 0x2A, 0x09, 0x03, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x2A, 0x09, 0x04, 0x00, 0x19, 0x0A, 
  0x09, 0x00, 0x46, 0x0B, 0x04, 0x06, 0x1C, 0x0B, 0x09, 0x00, 0x31, 0x01, 0x03, 0x04, 0x33, 0x0C, 
  0x0A, 0x00, 0x30, 0x08, 0x0C, 0x00, 0x2A, 0x0E, 0x05, 0x00, 0x33, 0x0D, 0x0E, 0x00, 0x19, 0x03, 
  0x04, 0x00, 0x06, 0x04, 0x04, 0x00, 0x1A, 0xF7, 0xFF, 0xFF, 0x23, 0x0B, 0x03, 0x06, 0x1B, 0x0B, 
  0x03, 0x00, 0x27, 0x0B, 0x00, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x28, 0x0B, 0x00, 0x00, 0x1C, 0x0B, 
  0x07, 0x00, 0x30, 0x01, 0x03, 0x00, 0x33, 0x0C, 0x0A, 0x00, 0x30, 0x08, 0x0C, 0x00, 0x2A, 0x0E, 
  0x05, 0x00, 0x33, 0x0D, 0x0E, 0x00, 0x1A, 0x01, 0x00, 0x00, 0x03, 0x08, 0x00, 0x00, 0x85, 0x7B, 
  0x01, 0x04, 0x03, 0x00, 0x0D, 0x01, 0x0C, 0x00, 0x03, 0x01, 0x22, 0x00, 0x17, 0x00, 0x17, 0x00, 
  0x17, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x03, 0x01, 0x13, 0x00, 0x13, 0x00, 0x13, 0x00, 
  0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x03, 0x01, 0x0A, 0x00, 0x03, 0x01, 0x15, 0x00, 
  0x15, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x05, 0x01, 0x05, 0xBF, 0xFD, 0x03, 0x04, 0x07, 
  0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x03, 0x00, 0x24, 0x00, 0x24, 0x00, 0x14, 
  0x00, 0x14, 0x00, 0x14, 0x00, 0x03, 0xBF, 0xF4, 0x01, 0xCF, 0x05, 0x6D, 0x61, 0x63, 0x65, 0x78, 
  0xDA, 0x82, 0x2F, 0xCF, 0x12, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x68, 0x61, 0x73, 0x2D, 
  0x73, 0x75, 0x66, 0x66, 0x69, 0x78, 0x3F, 0xDA, 0x80, 0xB5, 0xCF, 0x04, 0x63, 0x61, 0x73, 0x65, 
  0xD7, 0xCD, 0x02, 0xBB, 0x00, 0x00, 0x0C, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x05, 0x1D, 
  0x01, 0xCE, 0x04, 0x63, 0x61, 0x73, 0x65, 0xDA, 0x05, 0xDA, 0x81, 0x63, 0xDA, 0x22, 0xDA, 0x26, 
  0xDA, 0x81, 0x65, 0xDA, 0x2F, 0x2C, 0x02, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x04, 0x00, 
  0x00, 0x33, 0x03, 0x04, 0x00, 0x19, 0x04, 0x03, 0x00, 0x1C, 0x04, 0x03, 0x00, 0x19, 0x05, 0x00, 
  0x00, 0x1A, 0x04, 0x00, 0x00, 0x2A, 0x07, 0x01, 0x00, 0x33, 0x06, 0x07, 0x00, 0x19, 0x05, 0x06, 
  0x00, 0x19, 0x06, 0x05, 0x00, 0x2E, 0x07, 0x00, 0x00, 0x19, 0x08, 0x07, 0x00, 0x1C, 0x04, 0x04, 
  0x00, 0x29, 0x09, 0x00, 0x00, 0x2F, 0x09, 0x00, 0x00, 0x34, 0x08, 0x00, 0x00, 0x2A, 0x09, 0x02, 
  0x00, 0x31, 0x09, 0x06, 0x00, 0x2A, 0x0A, 0x03, 0x00, 0x33, 0x09, 0x0A, 0x00, 0x29, 0x0A, 0x00, 
  0x00, 0x2F, 0x0A, 0x00, 0x00, 0x33, 0x0A, 0x08, 0x00, 0x2A, 0x0B, 0x04, 0x00, 0x31, 0x0B, 0x09, 
  0x0A, 0x2A, 0x0B, 0x03, 0x00, 0x34, 0x0B, 0x00, 0x00, 0xCD, 0x00, 0xD8, 0x00, 0x00, 0x0A, 0x01, 
  0x01, 0x01, 0x03, 0x23, 0x01, 0xDA, 0x82, 0x7E, 0xDA, 0x05, 0xDA, 0x85, 0x31, 0xDA, 0x81, 0x65, 
  0xDA, 0x2E, 0x2C, 0x01, 0x00, 0x00, 0x2B, 0x03, 0x00, 0x01, 0x3D, 0x02, 0x03, 0x00, 0x07, 0x03, 
  0x02, 0x00, 0x19, 0x02, 0x03, 0x00, 0x29, 0x05, 0x00, 0x00, 0x23, 0x04, 0x02, 0x05, 0x1C, 0x04, 
  0x02, 0x00, 0x04, 0x00, 0x00, 0x00, 0x29, 0x06, 0x01, 0x00, 0x23, 0x05, 0x02, 0x06, 0x1C, 0x05, 
  0x04, 0x00, 0x2B, 0x07, 0x00, 0x01, 0x38, 0x06, 0x07, 0x00, 0x03, 0x06, 0x00, 0x00, 0x2B, 0x07, 
  0x00, 0x01, 0x38, 0x06, 0x07, 0x00, 0x2A, 0x07, 0x00, 0x00, 0x2B, 0x08, 0x00, 0x06, 0x31, 0x07, 
  0x08, 0x06, 0x2A, 0x08, 0x01, 0x00, 0x33, 0x07, 0x08, 0x00, 0x29, 0x08, 0x01, 0x00, 0x06, 0x06, 
  0x00, 0x08, 0x2B, 0x09, 0x00, 0x01, 0x38, 0x08, 0x09, 0x06, 0x29, 0x09, 0x02, 0x00, 0x06, 0x06, 
  0x00, 0x09, 0x2F, 0x06, 0x00, 0x00, 0x33, 0x09, 0x01, 0x00, 0x2A, 0x06, 0x02, 0x00, 0x31, 0x06, 
  0x07, 0x08, 0x2F, 0x09, 0x00, 0x00, 0x2A, 0x06, 0x01, 0x00, 0x34, 0x06, 0x00, 0x00, 0xBF, 0xFF, 
  0x80, 0xC4, 0x03, 0x01, 0x15, 0x00, 0x15, 0x00, 0x12, 0x00, 0x05, 0x01, 0x09, 0x00, 0x09, 0x00, 
  0x05, 0x00, 0x05, 0x01, 0x0B, 0x00, 0x0B, 0x00, 0x07, 0x00, 0x19, 0x00, 0x19, 0x00, 0x19, 0x01, 
  0x21, 0x00, 0x21, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x01, 0x1A, 0x00, 
  0x1A, 0x00, 0x10, 0x00, 0x10, 0x01, 0x15, 0x00, 0x15, 0x00, 0x10, 0x00, 0x10, 0xBF, 0xFE, 0x09, 
  0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x09, 0x80, 0xBD, 0x01, 0x05, 0x0C, 0x00, 0x0C, 0x00, 
  0x0C, 0x00, 0x03, 0x01, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x00, 0x1D, 0x00, 0x1D, 0x00, 0x0C, 0x00, 
  0x03, 0x01, 0x03, 0x00, 0x03, 0x07, 0x03, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x02, 0x0C, 0x00, 
  0x0C, 0x00, 0x0C, 0x00, 0x0C, 0x01, 0x0C, 0x00, 0x0C, 0x00, 0x0C, 0xBF, 0xFE, 0x05, 0x00, 0x05, 
  0x00, 0x05, 0x00, 0x05, 0x42, 0x00, 0x00, 0x00, 0xCF, 0x02, 0x2A, 0x3D, 0xD7, 0xCD, 0x00, 0x98, 
  0x00, 0x00, 0x06, 0x02, 0x02, 0x02, 0x02, 0x08, 0xCE, 0x02, 0x2A, 0x3D, 0xDA, 0x05, 0xDA, 0x82, 
  0x55, 0xDA, 0x81, 0xA1, 0x2C, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x31, 0x04, 0x00, 0x01, 
  0x43, 0x03, 0x00, 0x00, 0x2A, 0x05, 0x01, 0x00, 0x31, 0x05, 0x00, 0x03, 0x43, 0x04, 0x00, 0x00, 
  0x03, 0x04, 0x00, 0x00, 0x80, 0x87, 0x01, 0x00, 0x35, 0x00, 0x35, 0x00, 0x35, 0x00, 0x35, 0x00, 
  0x35, 0x00, 0x35, 0x00, 0x35, 0xCF, 0x05, 0x6A, 0x75, 0x78, 0x74, 0x2A, 0xD7, 0xCD, 0x02, 0xBB, 
  0x00, 0x00, 0x03, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x00, 0x03, 0x01, 0xCE, 0x05, 0x6A, 
  0x75, 0x78, 0x74, 0x2A, 0xDA, 0x05, 0x2C, 0x01, 0x00, 0x00, 0x2E, 0x02, 0x00, 0x00, 0x03, 0x02, 
  0x00, 0x00, 0xCD, 0x00, 0xD1, 0x00, 0x00, 0x08, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x02, 
  0x16, 0x01, 0xDA, 0x05, 0xDA, 0x52, 0xDA, 0x70, 0x3E, 0x01, 0x00, 0x00, 0x19, 0x02, 0x01, 0x00, 
  0x2B, 0x04, 0x00, 0x00, 0x26, 0x05, 0x00, 0x00, 0x47, 0x03, 0x04, 0x05, 0x19, 0x04, 0x03, 0x00, 
  0x1D, 0x04, 0x0C, 0x00, 0x2B, 0x05, 0x00, 0x00, 0x38, 0x03, 0x05, 0x04, 0x19, 0x05, 0x03, 0x00, 
  0x32, 0x00, 0x00, 0x00, 0x33, 0x03, 0x05, 0x00, 0x30, 0x02, 0x03, 0x00, 0x2A, 0x07, 0x00, 0x00, 
  0x33, 0x06, 0x07, 0x00, 0x2B, 0x03, 0x00, 0x00, 0x47, 0x04, 0x03, 0x04, 0x1A, 0xF5, 0xFF, 0xFF, 
  0x29, 0x03, 0x00, 0x00, 0x30, 0x02, 0x03, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x34, 0x03, 0x00, 0x00, 
  0xBF, 0xFF, 0x83, 0xE5, 0x05, 0x00, 0x05, 0x01, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 
  0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x01, 0x17, 0x00, 0x17, 0x00, 0x07, 0x00, 0x07, 0x00, 
  0x07, 0xBF, 0xFF, 0x05, 0x00, 0x05, 0x00, 0x05, 0x02, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 
  0x83, 0xE0, 0x01, 0x04, 0x03, 0x00, 0x03, 0x01, 0x00, 0x00, 0x00, 0xDA, 0x84, 0x5C, 0xDA, 0x84, 
  0x49, 0xCF, 0x06, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x3F, 0xDA, 0x82, 0x97, 0xCF, 0x08, 0x6D, 0x61, 
  0x74, 0x68, 0x2F, 0x6C, 0x6F, 0x67, 0xD8, 0x08, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x6C, 0x6F, 0x67, 
  0xCF, 0x06, 0x6E, 0x61, 0x74, 0x69, 0x76, 0x65, 0xDA, 0x81, 0x10, 0xCF, 0x05, 0x65, 0x70, 0x72, 
  0x69, 0x6E, 0xD8, 0x05, 0x65, 0x70, 0x72, 0x69, 0x6E, 0xDA, 0x63, 0xDA, 0x62, 0xCF, 0x0C, 0x64, 
  0x65, 0x62, 0x75, 0x67, 0x67, 0x65, 0x72, 0x2D, 0x65, 0x6E, 0x76, 0xDA, 0x83, 0xA2, 0xCF, 0x04, 
  0x65, 0x61, 0x63, 0x68, 0xD7, 0xCD, 0x00, 0x99, 0x00, 0x00, 0x05, 0x02, 0x02, 0xCD, 0x7F, 0xFF, 
  0xFF, 0xFF, 0x01, 0x04, 0xCE, 0x04, 0x65, 0x61, 0x63, 0x68, 0xDA, 0x05, 0xDA, 0x81, 0xB9, 0x2C, 
  0x03, 0x00, 0x00, 0x31, 0x00, 0x01, 0x02, 0x2A, 0x04, 0x00, 0x00, 0x34, 0x04, 0x00, 0x00, 0x81, 
  0xF0, 0x01, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x09, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x61, 
  0x74, 0x61, 0x6E, 0xD8, 0x09, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x61, 0x74, 0x61, 0x6E, 0xDA, 0x84, 
  0x96, 0xD7, 0xCD, 0x00, 0x08, 0x00, 0x04, 0x02, 0x01, 0x00, 0x01, 0x00, 0x02, 0xCE, 0x05, 0x79, 
  0x69, 0x65, 0x6C, 0x64, 0x36, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0xCF, 0x11, 0x62, 0x75, 
  0x66, 0x66, 0x65, 0x72, 0x2F, 0x6E, 0x65, 0x77, 0x2D, 0x66, 0x69, 0x6C, 0x6C, 0x65, 0x64, 0xD8, 
  0x11, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x6E, 0x65, 0x77, 0x2D, 0x66, 0x69, 0x6C, 0x6C, 
  0x65, 0x64, 0xCF, 0x06, 0x73, 0x74, 0x64, 0x6F, 0x75, 0x74, 0xDA, 0x84, 0x62, 0xCF, 0x08, 0x6D, 
  0x61, 0x74, 0x68, 0x2F, 0x65, 0x72, 0x66, 0xD8, 0x08, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x65, 0x72, 
  0x66, 0xCF, 0x0B, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x73, 0x6C, 0x69, 0x63, 0x65, 0xDA, 0x81, 
  0x28, 0xCF, 0x09, 0x6E, 0x65, 0x74, 0x2F, 0x63, 0x6C, 0x6F, 0x73, 0x65, 0xD8, 0x09, 0x6E, 0x65, 
  0x74, 0x2F, 0x63, 0x6C, 0x6F, 0x73, 0x65, 0xDA, 0x84, 0x59, 0xD7, 0xCD, 0x00, 0xB9, 0x00, 0x00, 
  0x05, 0x00, 0x00, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x02, 0x0A, 0x01, 0xCE, 0x03, 0x75, 0x73, 0x65, 
  0xDA, 0x05, 0xDA, 0x80, 0xBF, 0xDA, 0x2F, 0x2C, 0x01, 0x00, 0x00, 0x2E, 0x02, 0x00, 0x00, 0x30, 
  0x02, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x2F, 
  0x04, 0x00, 0x00, 0x32, 0x03, 0x00, 0x00, 0x43, 0x02, 0x00, 0x00, 0x03, 0x02, 0x00, 0x00, 0xCD, 
  0x00, 0x90, 0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 0x04, 0x0A, 0xDA, 0x05, 0xDA, 0x6F, 0xDA, 0x84, 
  0x49, 0xDA, 0x83, 0x8F, 0xDA, 0x67, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x33, 0x01, 
  0x02, 0x00, 0x2A, 0x03, 0x01, 0x00, 0x2A, 0x04, 0x02, 0x00, 0x31, 0x03, 0x01, 0x04, 0x2A, 0x03, 
  0x03, 0x00, 0x2F, 0x03, 0x00, 0x00, 0x43, 0x02, 0x00, 0x00, 0x03, 0x02, 0x00, 0x00, 0x89, 0x6A, 
  0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 
  0x0F, 0x00, 0x0F, 0x89, 0x66, 0x01, 0x04, 0x0F, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 0x0A, 0x6C, 0x6F, 0x61, 0x64, 0x2D, 0x69, 
  0x6D, 0x61, 0x67, 0x65, 0xD7, 0xDC, 0x37, 0xCF, 0x05, 0x65, 0x61, 0x63, 0x68, 0x70, 0xD7, 0xCD, 
  0x00, 0x99, 0x00, 0x00, 0x05, 0x02, 0x02, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x01, 0x06, 0xCE, 0x05, 
  0x65, 0x61, 0x63, 0x68, 0x70, 0xDA, 0x05, 0xDA, 0x81, 0xB5, 0x2C, 0x03, 0x00, 0x00, 0x27, 0x04, 
  0x00, 0x00, 0x31, 0x00, 0x01, 0x04, 0x2F, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x34, 0x04, 
  0x00, 0x00, 0x81, 0xEB, 0x01, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xCF, 
  0x03, 0x6D, 0x6F, 0x64, 0xD7, 0xCD, 0x00, 0x08, 0x00, 0x1D, 0x02, 0x02, 0x02, 0x02, 0x00, 0x02, 
  0xCE, 0x03, 0x6D, 0x6F, 0x64, 0x0C, 0x00, 0x00, 0x01, 0x03, 0x00, 0x00, 0x00, 0xCF, 0x08, 0x6D, 
  0x61, 0x74, 0x68, 0x2F, 0x63, 0x6F, 0x73, 0xD8, 0x08, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x63, 0x6F, 
  0x73, 0xCF, 0x0A, 0x66, 0x69, 0x6E, 0x64, 0x2D, 0x69, 0x6E, 0x64, 0x65, 0x78, 0xDA, 0x81, 0x21, 
  0xCF, 0x04, 0x65, 0x76, 0x61, 0x6C, 0xDA, 0x84, 0xDC, 0xCF, 0x05, 0x63, 0x6F, 0x75, 0x6E, 0x74, 
  0xD7, 0xCD, 0x00, 0x98, 0x00, 0x00, 0x08, 0x02, 0x02, 0x02, 0x00, 0x11, 0xCE, 0x05, 0x63, 0x6F, 
  0x75, 0x6E, 0x74, 0xDA, 0x05, 0x2C, 0x02, 0x00, 0x00, 0x29, 0x03, 0x00, 0x00, 0x26, 0x05, 0x00, 
  0x00, 0x47, 0x04, 0x01, 0x05, 0x19, 0x05, 0x04, 0x00, 0x1D, 0x05, 0x0B, 0x00, 0x38, 0x04, 0x01, 
  0x05, 0x19, 0x06, 0x04, 0x00, 0x2F, 0x06, 0x00, 0x00, 0x33, 0x04, 0x00, 0x00, 0x1C, 0x04, 0x04, 
  0x00, 0x29, 0x07, 0x01, 0x00, 0x06, 0x03, 0x03, 0x07, 0x1A, 0x01, 0x00, 0x00, 0x47, 0x05, 0x01, 
  0x05, 0x1A, 0xF6, 0xFF, 0xFF, 0x03, 0x03, 0x00, 0x00, 0x83, 0x6B, 0x01, 0x04, 0x03, 0x01, 0x03, 
  0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x09, 0x00, 0x09, 0x00, 0x05, 
  0x01, 0x07, 0x00, 0x07, 0xBF, 0xFF, 0x05, 0xBF, 0xFF, 0x03, 0x00, 0x03, 0xBF, 0xFB, 0x01, 0xCF, 
  0x06, 0x6D, 0x61, 0x63, 0x65, 0x78, 0x31, 0xDA, 0x82, 0x27, 0xCF, 0x02, 0x2B, 0x2B, 0xD7, 0xCD, 
  0x00, 0x98, 0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 0x02, 0x09, 0xCE, 0x02, 0x2B, 0x2B, 0xDA, 0x05, 
  0xDA, 0x81, 0x99, 0xDA, 0x81, 0xA1, 0x2C, 0x01, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x29, 0x04, 
  0x01, 0x00, 0x31, 0x03, 0x00, 0x04, 0x43, 0x02, 0x00, 0x00, 0x2A, 0x04, 0x01, 0x00, 0x31, 0x04, 
  0x00, 0x02, 0x43, 0x03, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x80, 0x83, 0x01, 0x00, 0x2F, 0x00, 
  0x2F, 0x00, 0x2F, 0x00, 0x2F, 0x00, 0x2F, 0x00, 0x2F, 0x00, 0x2F, 0x00, 0x2F, 0xCF, 0x03, 0x61, 
  0x73, 0x6D, 0xD8, 0x03, 0x61, 0x73, 0x6D, 0xCF, 0x01, 0x25, 0xDA, 0x85, 0xA5, 0xCF, 0x0A, 0x63, 
  0x6F, 0x6D, 0x70, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0xDA, 0x85, 0x0E, 0xCF, 0x05, 0x70, 0x72, 
  0x69, 0x6E, 0x66, 0xDA, 0x83, 0xC9, 0xCF, 0x07, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x3F, 0xD7, 
  0xCD, 0x00, 0x98, 0x00, 0x00, 0x05, 0x01, 0x01, 0x01, 0x02, 0x07, 0xCE, 0x07, 0x6E, 0x75, 0x6D, 
  0x62, 0x65, 0x72, 0x3F, 0xDA, 0x05, 0xDA, 0x39, 0xD0, 0x06, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 
  0x2C, 0x01, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x00, 0x2A, 0x03, 0x00, 0x00, 0x33, 0x02, 0x03, 0x00, 
  0x2A, 0x04, 0x01, 0x00, 0x23, 0x03, 0x02, 0x04, 0x03, 0x03, 0x00, 0x00, 0x58, 0x01, 0x00, 0x30, 
  0x00, 0x30, 0x00, 0x30, 0x00, 0x2D, 0x00, 0x2D, 0x00, 0x2D, 0xCF, 0x08, 0x6B, 0x65, 0x79, 0x77, 
  0x6F, 0x72, 0x64, 0x3F, 0xDA, 0x4E, 0xCF, 0x04, 0x77, 0x69, 0x74, 0x68, 0xD7, 0xCD, 0x00, 0x99, 
  0x00, 0x00, 0x09, 0x01, 0x01, 0xCD, 0x7F, 0xFF, 0xFF, 0xFF, 0x04, 0x18, 0xCE, 0x04, 0x77, 0x69, 
  0x74, 0x68, 0xDA, 0x05, 0xDA, 0x26, 0xDA, 0x20, 0xDA, 0x30, 0xDA, 0x2F, 0x3B, 0x02, 0x00, 0x00, 
  0x19, 0x03, 0x02, 0x00, 0x3B, 0x02, 0x00, 0x01, 0x19, 0x04, 0x02, 0x00, 0x3B, 0x02, 0x00, 0x02, 
  0x19, 0x05, 0x02, 0x00, 0x2C, 0x00, 0x00, 0x00, 0x2A, 0x06, 0x00, 0x00, 0x31, 0x06, 0x03, 0x04, 
  0x43, 0x02, 0x00, 0x00, 0x1C, 0x05, 0x03, 0x00, 0x19, 0x06, 0x05, 0x00, 0x1A, 0x02, 0x00, 0x00, 
  0x2A, 0x06, 0x01, 0x00, 0x30, 0x06, 0x03, 0x00, 0x43, 0x06, 0x00, 0x00, 0x2F, 0x06, 0x00, 0x00, 
  0x32, 0x01, 0x00, 0x00, 0x2A, 0x08, 0x02, 0x00, 0x33, 0x07, 0x08, 0x00, 0x2A, 0x08, 0x03, 0x00, 
  0x31, 0x08, 0x02, 0x07, 0x43, 0x06, 0x00, 0x00, 0x03, 0x06, 0x00, 0x00, 0x81, 0x64, 0x01, 0x00, 
  0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x06, 0x03, 0x00, 0x03, 0x00, 
  0x03, 0x02, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x15, 0x00, 0x14, 0x00, 0x14, 0x00, 0x07, 0x00, 
  0x07, 0x00, 0x07, 0x00, 0x07, 0xBF, 0xFE, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xDA, 0x84, 
  0x56, 0xDA, 0x74, 0xCF, 0x0B, 0x6E, 0x65, 0x74, 0x2F, 0x63, 0x6F, 0x6E, 0x6E, 0x65, 0x63, 0x74, 
  0xD8, 0x0B, 0x6E, 0x65, 0x74, 0x2F, 0x63, 0x6F, 0x6E, 0x6E, 0x65, 0x63, 0x74, 0xDA, 0x85, 0xA1, 
  0x2C, 0x01, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x30, 0x00, 0x02, 0x00, 0x2A, 0x02, 0x01, 0x00, 
  0x34, 0x02, 0x00, 0x00, 0x88, 0x8B, 0x01, 0x03, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x2F, 
  0x00, 0x00, 0x00, 0x2A, 0x02, 0x00, 0x00, 0x33, 0x01, 0x02, 0x00, 0x2F, 0x01, 0x00, 0x00, 0x2A, 
  0x02, 0x01, 0x00, 0x34, 0x02, 0x00, 0x00, 0x89, 0x2D, 0x25, 0x00, 0x25, 0x00, 0x25, 0x00, 0x19, 
  0x00, 0x19, 0x00, 0x19, 0xCE, 0x0C, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x20, 0x74, 0x79, 0x70, 
  0x65, 0x20, 0xCE, 0x08, 0x20, 0x75, 0x6E, 0x6B, 0x6E, 0x6F, 0x77, 0x6E, 0x2C, 0x03, 0x00, 0x00, 
  0x2F, 0x00, 0x00, 0x00, 0x2A, 0x05, 0x00, 0x00, 0x33, 0x04, 0x05, 0x00, 0x3B, 0x05, 0x04, 0x00, 
  0x19, 0x06, 0x05, 0x00, 0x3B, 0x05, 0x04, 0x01, 0x19, 0x07, 0x05, 0x00, 0x1C, 0x06, 0x02, 0x00, 
  0x1A, 0x02, 0x00, 0x00, 0x01, 0x07, 0x00, 0x00, 0x2A, 0x08, 0x01, 0x00, 0x2F, 0x08, 0x00, 0x00, 
  0x33, 0x08, 0x02, 0x00, 0x1C, 0x08, 0x03, 0x00, 0x26, 0x05, 0x00, 0x00, 0x1A, 0x04, 0x00, 0x00, 
  0x2A, 0x0A, 0x02, 0x00, 0x38, 0x09, 0x0A, 0x06, 0x19, 0x05, 0x09, 0x00, 0x19, 0x08, 0x05, 0x00, 
  0x1C, 0x08, 0x02, 0x00, 0x03, 0x08, 0x00, 0x00, 0x2F, 0x06, 0x00, 0x00, 0x2A, 0x09, 0x03, 0x00, 
  0x33, 0x05, 0x09, 0x00, 0x1C, 0x05, 0x08, 0x00, 0x2A, 0x09, 0x04, 0x00, 0x2A, 0x0A, 0x05, 0x00, 
  0x31, 0x09, 0x06, 0x0A, 0x2A, 0x0A, 0x06, 0x00, 0x33, 0x09, 0x0A, 0x00, 0x01, 0x09, 0x00, 0x00, 
  0x04, 0x00, 0x00, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x2A, 0x0B, 0x07, 0x00, 0x33, 0x0A, 0x0B, 0x00, 
  0x1C, 0x0A, 0x06, 0x00, 0x2F, 0x07, 0x00, 0x00, 0x2A, 0x0C, 0x08, 0x00, 0x33, 0x0B, 0x0C, 0x00, 
  0x19, 0x09, 0x0B, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x19, 0x09, 0x07, 0x00, 0x19, 0x0A, 0x09, 0x00, 
  0x1C, 0x0A, 0x02, 0x00, 0x1A, 0x07, 0x00, 0x00, 0x2A, 0x09, 0x09, 0x00, 0x2A, 0x0B, 0x0A, 0x00, 
  0x31, 0x09, 0x07, 0x0B, 0x2A, 0x0B, 0x06, 0x00, 0x33, 0x09, 0x0B, 0x00, 0x01, 0x09, 0x00, 0x00, 
  0x30, 0x06, 0x01, 0x00, 0x33, 0x09, 0x0A, 0x00, 0x19, 0x0B, 0x09, 0x00, 0x2A, 0x09, 0x02, 0x00, 
  0x3A, 0x09, 0x06, 0x0B, 0x03, 0x0B, 0x00, 0x00, 0x89, 0x2F, 0x01, 0x02, 0x1C, 0x00, 0x1C, 0x00, 
  0x1C, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x01, 0x03, 0x00, 0x03, 0x00, 0x14, 0x01, 
  0x1A, 0x00, 0x1A, 0x00, 0x1A, 0x00, 0x12, 0x00, 0x12, 0x00, 0x12, 0x00, 0x29, 0x00, 0x29, 0x00, 
  0x12, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0x02, 0x09, 0x00, 0x09, 0x00, 0x09, 0x00, 0x05, 0x01, 
  0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x07, 0x00, 0x07, 0x02, 0x19, 0x00, 
  0x19, 0x00, 0x19, 0x00, 0x15, 0x00, 0x2D, 0x00, 0x2D, 0x00, 0x2D, 0x00, 0x15, 0x00, 0x15, 0x00, 
  0x15, 0x00, 0x09, 0x01, 0x09, 0x00, 0x09, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x1F, 0x00, 
  0x1F, 0x00, 0x18, 0x01, 0x12, 0x00, 0x12, 0x00, 0x09, 0x01, 0x09, 0x00, 0x09, 0xBF, 0xFC, 0x07, 
  0x2C, 0x02, 0x00, 0x00, 0x32, 0x01, 0x00, 0x00, 0x2A, 0x04, 0x00, 0x00, 0x33, 0x03, 0x04, 0x00, 
  0x31, 0x00, 0x01, 0x03, 0x2A, 0x04, 0x01, 0x00, 0x34, 0x04, 0x00, 0x00, 0x89, 0x3E, 0x01, 0x05, 
  0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xDA, 0x81, 0x83, 0xDA, 0x84, 
  0xE6, 0xDA, 0x84, 0xE4, 0xDA, 0x80, 0x84, 0xDA, 0x85, 0x23, 0xDA, 0x84, 0xD9, 0xDA, 0x84, 0xD7, 
  0xDA, 0x74, 0xDA, 0x84, 0x56, 0xDA, 0x86, 0x49, 0xDA, 0x86, 0x47, 0xDA, 0x82, 0x79, 0xDA, 0x82, 
  0x78, 0xDA, 0x81, 0x18, 0xDA, 0x3E, 0xDA, 0x81, 0xCE, 0xDA, 0x81, 0xCD, 0xDA, 0x84, 0xC6, 0xDA, 
  0x84, 0xBF, 0xDA, 0x83, 0x96, 0xDA, 0x86, 0x06, 0xDA, 0x82, 0x97, 0xDA, 0x86, 0x55, 0xDA, 0x84, 
  0x64, 0xDA, 0x83, 0x7A, 0xDA, 0x84, 0xB3, 0xDA, 0x84, 0xB2, 0xDA, 0x80, 0xC6, 0xDA, 0x84, 0xBC, 
  0xDA, 0x82, 0xFB, 0xDA, 0x82, 0xF9, 0xDA, 0x86, 0x8C, 0xDA, 0x86, 0x8A, 0xDA, 0x81, 0x1E, 0xDA, 
  0x83, 0x5B, 0xDA, 0x81, 0xB2, 0xDA, 0x84, 0x65, 0xDA, 0x85, 0x9D, 0xDA, 0x85, 0x9C, 0xDA, 0x81, 
  0xDA, 0xDA, 0x81, 0xD6, 0xDA, 0x83, 0x21, 0xDA, 0x83, 0x1F, 0xDA, 0x83, 0x2D, 0xDA, 0x84, 0xF7, 
  0xDA, 0x81, 0x69, 0xDA, 0x81, 0x67, 0xDA, 0x82, 0x55, 0xDA, 0x82, 0x53, 0xDA, 0x82, 0x81, 0xDA, 
  0x82, 0x80, 0xDA, 0x59, 0xDA, 0x82, 0x9C, 0xDA, 0x80, 0xB7, 0xDA, 0x82, 0x46, 0xDA, 0x84, 0xB1, 
  0xDA, 0x84, 0xB0, 0xDA, 0x84, 0xA7, 0xDA, 0x84, 0xA5, 0xDA, 0x81, 0x99, 0xDA, 0x84, 0x9A, 0xDA, 
  0x85, 0x50, 0xDA, 0x85, 0x4D, 0xDA, 0x86, 0x62, 0xDA, 0x84, 0x96, 0xDA, 0x83, 0xC9, 0xDA, 0x86, 
  0x84, 0xDA, 0x86, 0x5A, 0xDA, 0x86, 0x59, 0xDA, 0x83, 0x50, 0xDA, 0x83, 0x4E, 0xDA, 0x84, 0x80, 
  0xDA, 0x85, 0x97, 0xDA, 0x85, 0xB4, 0xDA, 0x85, 0xB3, 0xDA, 0x82, 0x6E, 0xDA, 0x82, 0x6D, 0xDA, 
  0x83, 0x44, 0xDA, 0x83, 0x43, 0xDA, 0x84, 0xDC, 0xDA, 0x86, 0x78, 0xDA, 0x82, 0xAA, 0xDA, 0x82, 
  0xA9, 0xDA, 0x80, 0xD0, 0xDA, 0x83, 0x14, 0xDA, 0x81, 0x6E, 0xDA, 0x81, 0x6C, 0xDA, 0x83, 0xC7, 
  0xDA, 0x84, 0x9D, 0xDA, 0x85, 0x16, 0xDA, 0x85, 0x14, 0xDA, 0x85, 0x6B, 0xDA, 0x85, 0x68, 0xDA, 
  0x80, 0x83, 0xDA, 0x85, 0xB7, 0xDA, 0x81, 0x17, 0xDA, 0x82, 0x76, 0xDA, 0x85, 0x3E, 0xDA, 0x85, 
  0x3C, 0xDA, 0x86, 0x41, 0xDA, 0x86, 0x40, 0xDA, 0x83, 0x95, 0xDA, 0x84, 0xC7, 0xDA, 0x80, 0xDB, 
  0xDA, 0x85, 0x49, 0xDA, 0x85, 0x84, 0xDA, 0x85, 0x82, 0xDA, 0x81, 0xB0, 0xDA, 0x82, 0x48, 0xDA, 
  0x81, 0x5A, 0xDA, 0x81, 0x59, 0xDA, 0x80, 0xCD, 0xDA, 0x83, 0x0D, 0xDA, 0x82, 0x72, 0xDA, 0x82, 
  0x6F, 0xDA, 0x84, 0xFC, 0xDA, 0x84, 0xFA, 0xDA, 0x85, 0x58, 0xDA, 0x85, 0x57, 0xDA, 0x85, 0x7B, 
  0xDA, 0x85, 0x79, 0xDA, 0x28, 0xDA, 0x82, 0x86, 0xDA, 0x82, 0xA0, 0xDA, 0x82, 0x8E, 0xDA, 0x85, 
  0xBE, 0xDA, 0x81, 0x92, 0xDA, 0x86, 0x51, 0xDA, 0x86, 0x4F, 0xDA, 0x3B, 0xDA, 0x36, 0xDA, 0x30, 
  0xDA, 0x81, 0x45, 0xDA, 0x81, 0x74, 0xDA, 0x81, 0x71, 0xDA, 0x85, 0x2E, 0xDA, 0x85, 0x2C, 0xDA, 
  0x82, 0x18, 0xDA, 0x85, 0xBA, 0xDA, 0x80, 0xFA, 0xDA, 0x81, 0xB3, 0xDA, 0x82, 0x04, 0xDA, 0x82, 
  0x01, 0xDA, 0x84, 0xFF, 0xDA, 0x84, 0xFD, 0xDA, 0x0F, 0xDA, 0x0D, 0xDA, 0x80, 0xEC, 0xDA, 0x85, 
  0xB5, 0xDA, 0x2D, 0xDA, 0x81, 0x46, 0xDA, 0x84, 0x6F, 0xDA, 0x84, 0x6D, 0xDA, 0x85, 0x05, 0xDA, 
  0x85, 0x04, 0xDA, 0x85, 0x40, 0xDA, 0x85, 0x3F, 0xDA, 0x86, 0x71, 0xDA, 0x86, 0x6F, 0xDA, 0x81, 
  0x08, 0xDA, 0x82, 0x3F, 0xDA, 0x70, 0xDA, 0x84, 0x9E, 0xDA, 0x82, 0xD3, 0xDA, 0x82, 0xCF, 0xDA, 
  0x81, 0xAC, 0xDA, 0x82, 0xDD, 0xDA, 0x86, 0x34, 0xDA, 0x86, 0x33, 0xDA, 0x82, 0xD6, 0xDA, 0x82, 
  0xD4, 0xDA, 0x84, 0x79, 0xDA, 0x84, 0x77, 0xDA, 0x82, 0x58, 0xDA, 0x82, 0x56, 0xDA, 0x83, 0x04, 
  0xDA, 0x83, 0x03, 0xDA, 0x85, 0xFC, 0xDA, 0x85, 0xF9, 0xDA, 0x85, 0xA8, 0xDA, 0x84, 0x4D, 0xDA, 
  0x86, 0x22, 0xDA, 0x86, 0x21, 0xDA, 0x82, 0x1A, 0xDA, 0x84, 0x99, 0xDA, 0x85, 0x74, 0xDA, 0x85, 
  0x72, 0xDA, 0x80, 0xBC, 0xDA, 0x86, 0x12, 0xDA, 0x81, 0x58, 0xDA, 0x81, 0x54, 0xDA, 0x82, 0xA3, 
  0xDA, 0x82, 0xA1, 0xDA, 0x84, 0x51, 0xDA, 0x84, 0x90, 0xDA, 0x86, 0x88, 0xDA, 0x86, 0x85, 0xDA, 
  0x81, 0x31, 0xDA, 0x81, 0x2F, 0xDA, 0x82, 0xE7, 0xDA, 0x82, 0xE5, 0xDA, 0x82, 0x2C, 0xDA, 0x82, 
  0xBC, 0xDA, 0x85, 0x31, 0xDA, 0x2A, 0xDA, 0x81, 0xD9, 0xDA, 0x85, 0xEB, 0xDA, 0x86, 0x0E, 0xDA, 
  0x86, 0x0C, 0xDA, 0x85, 0x78, 0xDA, 0x85, 0x76, 0xDA, 0x84, 0x3D, 0xDA, 0x86, 0x05, 0xDA, 0x84, 
  0x3C, 0xDA, 0x85, 0x28, 0xDA, 0x83, 0x79, 0xDA, 0x83, 0x77, 0xDA, 0x82, 0xF8, 0xDA, 0x82, 0xF6, 
  0xDA, 0x81, 0x7D, 0xDA, 0x81, 0x7B, 0xDA, 0x84, 0xBE, 0xDA, 0x84, 0x5D, 0xDA, 0x84, 0xEE, 0xDA, 
  0x84, 0xEC, 0xDA, 0x81, 0x5E, 0xDA, 0x81, 0x5B, 0xDA, 0x81, 0x9D, 0xDA, 0x85, 0x71, 0xDA, 0x81, 
  0xA6, 0xDA, 0x83, 0x36, 0xDA, 0x84, 0x38, 0xDA, 0x85, 0x9F, 0xDA, 0x81, 0x50, 0xDA, 0x81, 0x4E, 
  0xDA, 0x84, 0xE9, 0xDA, 0x84, 0xE7, 0xDA, 0x82, 0xA7, 0xDA, 0x82, 0xA6, 0xDA, 0x85, 0x8E, 0xDA, 
  0x85, 0x8B, 0xDA, 0x85, 0x96, 0xDA, 0x85, 0x95, 0xDA, 0x85, 0xA6, 0xDA, 0x85, 0xA2, 0xDA, 0x81, 
  0x15, 0xDA, 0x83, 0x5D, 0xDA, 0x5E, 0xDA, 0x86, 0x30, 0xDA, 0x83, 0x08, 0xDA, 0x83, 0x07, 0xDA, 
  0x83, 0x33, 0xDA, 0x83, 0x32, 0xDA, 0x56, 0xDA, 0x81, 0xCC, 0xDA, 0x86, 0x04, 0xDA, 0x85, 0xFF, 
  0xDA, 0x81, 0xDF, 0xDA, 0x81, 0xDE, 0xDA, 0x84, 0xF1, 0xDA, 0x84, 0xEF, 0xDA, 0x81, 0x0A, 0xDA, 
  0x82, 0x87, 0xDA, 0x85, 0x0A, 0xDA, 0x85, 0x09, 0xDA, 0x84, 0x34, 0xDA, 0x85, 0x13, 0xDA, 0x85, 
  0x91, 0xDA, 0x85, 0x8F, 0xDA, 0x80, 0x91, 0xDA, 0x85, 0x08, 0xDA, 0x81, 0x42, 0xDA, 0x81, 0x35, 
  0xDA, 0x81, 0xF1, 0xDA, 0x81, 0xF0, 0xDA, 0x82, 0xED, 0xDA, 0x82, 0xEB, 0xDA, 0x81, 0x40, 0xDA, 
  0x83, 0x0C, 0xDA, 0x17, 0xDA, 0x15, 0xDA, 0x82, 0xEF, 0xDA, 0x82, 0xEE, 0xDA, 0x84, 0xDF, 0xDA, 
  0x84, 0xDD, 0xDA, 0x81, 0x3B, 0xDA, 0x85, 0x1F, 0xDA, 0x80, 0xD8, 0xDA, 0x85, 0xB9, 0xDA, 0x83, 
  0x42, 0xDA, 0x83, 0x41, 0xDA, 0x84, 0x67, 0xDA, 0x84, 0x66, 0xDA, 0x82, 0x75, 0xDA, 0x82, 0x73, 
  0xDA, 0x81, 0x86, 0xDA, 0x81, 0x85, 0xDA, 0x82, 0xF2, 0xDA, 0x82, 0xF0, 0xDA, 0x80, 0xDA, 0xDA, 
  0x82, 0x77, 0xDA, 0x86, 0x3F, 0xDA, 0x86, 0x3E, 0xDA, 0x83, 0x6B, 0xDA, 0x83, 0x6A, 0xDA, 0x82, 
  0x0B, 0xDA, 0x84, 0xAA, 0xDA, 0x85, 0x0F, 0xDA, 0x85, 0x0B, 0xDA, 0x83, 0xA2, 0xDA, 0x86, 0x5B, 
  0xDA, 0x6D, 0xDA, 0x82, 0x45, 0xDA, 0x85, 0x6F, 0xDA, 0x85, 0x6D, 0xDA, 0x81, 0xFB, 0xDA, 0x81, 
  0xFA, 0xDA, 0x82, 0x2D, 0xDA, 0x85, 0xEF, 0xDA, 0x83, 0x1C, 0xDA, 0x83, 0x1B, 0xDA, 0x81, 0xED, 
  0xDA, 0x81, 0xE6, 0xDA, 0x53, 0xDA, 0x84, 0xD4, 0xDA, 0x82, 0x06, 0xDA, 0x82, 0x05, 0xDA, 0x85, 
  0x19, 0xDA, 0x85, 0x17, 0xDA, 0x86, 0x4E, 0xDA, 0x86, 0x4C, 0xDA, 0x81, 0x2E, 0xDA, 0x81, 0x2D, 
  0xDA, 0x83, 0x70, 0xDA, 0x81, 0x8D, 0xDA, 0x82, 0xAE, 0xDA, 0x84, 0xBB, 0xDA, 0x81, 0x28, 0xDA, 
  0x86, 0x68, 0xDA, 0x82, 0xB0, 0xDA, 0x82, 0xAB, 0xDA, 0x84, 0x72, 0xDA, 0x84, 0x70, 0xDA, 0x41, 
  0xDA, 0x82, 0x00, 0xDA, 0x81, 0x63, 0xDA, 0x85, 0xB8, 0xDA, 0x82, 0x7B, 0xDA, 0x82, 0x7A, 0xDA, 
  0x82, 0x7F, 0xDA, 0x82, 0x7C, 0xDA, 0x85, 0x1C, 0xDA, 0x85, 0x1A, 0xDA, 0x82, 0xBE, 0xDA, 0x82, 
  0xBD, 0xDA, 0x84, 0xA9, 0xDA, 0x84, 0xA8, 0xDA, 0x86, 0x3C, 0xDA, 0x86, 0x3A, 0xDA, 0x80, 0xCB, 
  0xDA, 0x85, 0x75, 0xDA, 0x84, 0x2C, 0xDA, 0x84, 0xA4, 0xDA, 0x84, 0x8E, 0xDA, 0x84, 0x7C, 0xDA, 
  0x86, 0x43, 0xDA, 0x86, 0x42, 0xDA, 0x83, 0x13, 0xDA, 0x83, 0x12, 0xDA, 0x52, 0xDA, 0x81, 0x56, 
  0xDA, 0x83, 0x0F, 0xDA, 0x83, 0x0E, 0xDA, 0x83, 0x93, 0xDA, 0x85, 0x70, 0xDA, 0x83, 0x11, 0xDA, 
  0x83, 0x10, 0xDA, 0x85, 0xB2, 0xDA, 0x85, 0xB0, 0xDA, 0x84, 0xF5, 0xDA, 0x84, 0xF4, 0xDA, 0x86, 
  0x6A, 0xDA, 0x86, 0x69, 0xDA, 0x83, 0x2E, 0xDA, 0x83, 0x24, 0xDA, 0x81, 0x7F, 0xDA, 0x81, 0x7E, 
  0xDA, 0x84, 0x49, 0xDA, 0x84, 0x5C, 0xDA, 0x85, 0x94, 0xDA, 0x85, 0x93, 0xDA, 0x81, 0x2A, 0xDA, 
  0x81, 0x25, 0xDA, 0x84, 0xBA, 0xDA, 0x84, 0xB8, 0xDA, 0x82, 0x3E, 0xDA, 0x82, 0x10, 0xDA, 0x81, 
  0x29, 0xDA, 0x83, 0x5A, 0xDA, 0x83, 0x4D, 0xDA, 0x83, 0x4C, 0xDA, 0x82, 0xE0, 0xDA, 0x82, 0xDF, 
  0xDA, 0x83, 0x72, 0xDA, 0x83, 0x71, 0xDA, 0x86, 0x39, 0xDA, 0x86, 0x38, 0xDA, 0x81, 0x82, 0xDA, 
  0x81, 0x80, 0xDA, 0x82, 0xB4, 0xDA, 0x82, 0xB3, 0xDA, 0x81, 0x07, 0xDA, 0x82, 0xD7, 0xDA, 0x81, 
  0x00, 0xDA, 0x85, 0x5A, 0xDA, 0x82, 0xCA, 0xDA, 0x82, 0xC8, 0xDA, 0x82, 0x03, 0xDA, 0x85, 0x5B, 
  0xDA, 0x85, 0xC5, 0xDA, 0x85, 0xC4, 0xDA, 0x81, 0x44, 0xDA, 0x81, 0x43, 0xDA, 0x82, 0x6C, 0xDA, 
  0x82, 0x6A, 0xDA, 0x83, 0x58, 0xDA, 0x83, 0x57, 0xDA, 0x08, 0xDA, 0x01, 0xDA, 0x82, 0x2F, 0xDA, 
  0x86, 0x4A, 0xDA, 0x86, 0x6C, 0xDA, 0x84, 0x59, 0xDA, 0x82, 0xBA, 0xDA, 0x82, 0xB9, 0xDA, 0x86, 
  0x16, 0xDA, 0x86, 0x14, 0xDA, 0x84, 0xAD, 0xDA, 0x84, 0xAC, 0xDA, 0x83, 0x3A, 0xDA, 0x83, 0x38, 
  0xDA, 0x81, 0x2C, 0xDA, 0x81, 0x2B, 0xDA, 0x81, 0x24, 0xDA, 0x81, 0x19, 0xDA, 0x86, 0x46, 0xDA, 
  0x86, 0x44, 0xDA, 0x55, 0xDA, 0x82, 0x62, 0xDA, 0x82, 0x0C, 0xDA, 0x82, 0x08, 0xDA, 0x85, 0xC3, 
  0xDA, 0x85, 0xC2, 0xDA, 0x85, 0x4C, 0xDA, 0x85, 0x4A, 0xDA, 0x84, 0xC9, 0xDA, 0x84, 0xC8, 0xDA, 
  0x84, 0xE2, 0xDA, 0x84, 0xE0, 0xDA, 0x81, 0xF9, 0xDA, 0x81, 0xF7, 0xDA, 0x86, 0x1D, 0xDA, 0x86, 
  0x1B, 0xDA, 0x80, 0xEF, 0xDA, 0x82, 0x52, 0xDA, 0x81, 0x4D, 0xDA, 0x81, 0x4C, 0xDA, 0x81, 0x76, 
  0xDA, 0x81, 0x75, 0xDA, 0x82, 0xC0, 0xDA, 0x82, 0xBF, 0xDA, 0x82, 0x9F, 0xDA, 0x82, 0xF5, 0xDA, 
  0x85, 0x7E, 0xDA, 0x85, 0x7C, 0xDA, 0x82, 0xEA, 0xDA, 0x82, 0xE9, 0xDA, 0x85, 0xFE, 0xDA, 0x85, 
  0xFD, 0xDA, 0x81, 0xC2, 0xDA, 0x81, 0xC1, 0xDA, 0x86, 0x8E, 0xDA, 0x86, 0x8D, 0xDA, 0x81, 0xF4, 
  0xDA, 0x81, 0xF2, 0xDA, 0x85, 0xBC, 0xDA, 0x85, 0xBB, 0xDA, 0x81, 0xE2, 0xDA, 0x81, 0xE0, 0xDA, 
  0x00, 0xDA, 0x84, 0x68, 0xDA, 0x6B, 0xDA, 0x85, 0x9E, 0xDA, 0x84, 0xD1, 0xDA, 0x84, 0xD0, 0xDA, 
  0x85, 0xF4, 0xDA, 0x85, 0xF3, 0xDA, 0x85, 0x5F, 0xDA, 0x85, 0x5E, 0xDA, 0x85, 0x22, 0xDA, 0x85, 
  0x21, 0xDA, 0x84, 0xAF, 0xDA, 0x84, 0xAE, 0xDA, 0x81, 0xEB, 0xDA, 0x82, 0xE2, 0xDA, 0x81, 0x6B, 
  0xDA, 0x81, 0x6A, 0xDA, 0x82, 0xB8, 0xDA, 0x82, 0xB7, 0xDA, 0x85, 0x56, 0xDA, 0x85, 0x55, 0xDA, 
  0x81, 0x5D, 0xDA, 0x85, 0x26, 0xDA, 0x82, 0xCC, 0xDA, 0x82, 0xCB, 0xDA, 0x83, 0x74, 0xDA, 0x83, 
  0x73, 0xDA, 0x13, 0xDA, 0x11, 0xDA, 0x84, 0xA2, 0xDA, 0x84, 0xA1, 0xDA, 0x80, 0xE6, 0xDA, 0x82, 
  0xA4, 0xDA, 0x81, 0xF6, 0xDA, 0x81, 0xF5, 0xDA, 0x82, 0x3D, 0xDA, 0x85, 0xAD, 0xDA, 0x80, 0xF1, 
  0xDA, 0x86, 0x0F, 0xDA, 0x85, 0x9B, 0xDA, 0x85, 0x9A, 0xDA, 0x86, 0x2A, 0xDA, 0x86, 0x29, 0xDA, 
  0x86, 0x64, 0xDA, 0x86, 0x63, 0xDA, 0x83, 0x54, 0xDA, 0x83, 0x53, 0xDA, 0x85, 0x63, 0xDA, 0x85, 
  0x62, 0xDA, 0x83, 0x06, 0xDA, 0x83, 0x05, 0xDA, 0x83, 0x0B, 0xDA, 0x83, 0x09, 0xDA, 0x85, 0x46, 
  0xDA, 0x85, 0x45, 0xDA, 0x80, 0xF5, 0xDA, 0x82, 0x42, 0xDA, 0x85, 0x87, 0xDA, 0x84, 0x57, 0xDA, 
  0x85, 0x02, 0xDA, 0x85, 0x00, 0xDA, 0x83, 0x3C, 0xDA, 0x83, 0x3B, 0xDA, 0x83, 0x7E, 0xDA, 0x85, 
  0x20, 0xDA, 0x85, 0x2B, 0xDA, 0x84, 0x54, 0xDA, 0x80, 0xE7, 0xDA, 0x82, 0x5F, 0xDA, 0x81, 0x0E, 
  0xDA, 0x83, 0x5C, 0xDA, 0x81, 0xCB, 0xDA, 0x81, 0xCA, 0xDA, 0x80, 0xFB, 0xDA, 0x81, 0xCF, 0xDA, 
  0x80, 0xF6, 0xDA, 0x85, 0xBF, 0xDA, 0x84, 0x6A, 0xDA, 0x84, 0x69, 0xDA, 0x85, 0x61, 0xDA, 0x85, 
  0x60, 0xDA, 0x83, 0xA8, 0xDA, 0x84, 0xD3, 0xDA, 0x86, 0x28, 0xDA, 0x86, 0x26, 0xDA, 0x85, 0x38, 
  0xDA, 0x85, 0x37, 0xDA, 0x7F, 0xDA, 0x85, 0x88, 0xDA, 0x39, 0xDA, 0x82, 0xE8, 0xDA, 0x85, 0x3A, 
  0xDA, 0x85, 0x39, 0xDA, 0x82, 0x51, 0xDA, 0x82, 0x4F, 0xDA, 0x83, 0x35, 0xDA, 0x83, 0x34, 0xDA, 
  0x82, 0xCE, 0xDA, 0x82, 0xCD, 0xDA, 0x84, 0xA0, 0xDA, 0x84, 0x55, 0xDA, 0x82, 0xC7, 0xDA, 0x82, 
  0xC5, 0xDA, 0x83, 0x48, 0xDA, 0x83, 0x47, 0xDA, 0x83, 0x30, 0xDA, 0x83, 0x2F, 0xDA, 0x82, 0xDC, 
  0xDA, 0x82, 0xDA, 0xDA, 0x83, 0x69, 0xDA, 0x83, 0x68, 0xDA, 0x81, 0xFF, 0xDA, 0x81, 0xFC, 0xDA, 
  0x80, 0xF4, 0xDA, 0x86, 0x1E, 0xDA, 0x81, 0x23, 0xDA, 0x81, 0xE3, 0xDA, 0x83, 0x23, 0xDA, 0x83, 
  0x22, 0xDA, 0x85, 0x11, 0xDA, 0x85, 0x10, 0xDA, 0x86, 0x02, 0xDA, 0x86, 0x13, 0xDA, 0x81, 0x70, 
  0xDA, 0x81, 0x6F, 0xDA, 0x83, 0x6E, 0xDA, 0x85, 0x6C, 0xDA, 0x22, 0xDA, 0x82, 0xDE, 0xDA, 0x81, 
  0xE5, 0xDA, 0x81, 0xE4, 0xDA, 0x86, 0x37, 0xDA, 0x86, 0x35, 0xDA, 0x85, 0xF6, 0xDA, 0x85, 0xF5, 
  0xDA, 0x84, 0xD6, 0xDA, 0x84, 0xD5, 0xDA, 0x80, 0x8E, 0xDA, 0x86, 0x3D, 0xDA, 0x83, 0x02, 0xDA, 
  0x83, 0x01, 0xDA, 0x80, 0xB5, 0xDA, 0x86, 0x4B, 0xDA, 0x82, 0x5D, 0xDA, 0x84, 0xF2, 0xDA, 0x85, 
  0xA1, 0xDA, 0x85, 0xA0, 0xDA, 0x81, 0xC0, 0xDA, 0x81, 0x57, 0xDA, 0x80, 0x96, 0xDA, 0x82, 0x47, 
  0xDA, 0x07, 0xDA, 0x82, 0xE1, 0xDA, 0x85, 0x5D, 0xDA, 0x85, 0x5C, 0xDA, 0x81, 0xC9, 0xDA, 0x81, 
  0xC7, 0xDA, 0x80, 0xF2, 0xDA, 0x84, 0xF3, 0xDA, 0x82, 0xD9, 0xDA, 0x82, 0xD8, 0xDA, 0x81, 0x62, 
  0xDA, 0x83, 0x37, 0xDA, 0x86, 0x7F, 0xDA, 0x86, 0x7D, 0xDA, 0x86, 0x18, 0xDA, 0x86, 0x17, 0xDA, 
  0x81, 0x52, 0xDA, 0x81, 0x51, 0xDA, 0x82, 0x91, 0xDA, 0x84, 0xAB, 0xDA, 0x82, 0x41, 0xDA, 0x82, 
  0x40, 0xDA, 0x83, 0x1A, 0xDA, 0x83, 0x15, 0xDA, 0x84, 0x8D, 0xDA, 0x85, 0x29, 0xDA, 0x86, 0x32, 
  0xDA, 0x86, 0x31, 0xDA, 0x80, 0xBF, 0xDA, 0x84, 0x8F, 0xDA, 0x85, 0x44, 0xDA, 0x85, 0x41, 0xDA, 
  0x81, 0xD5, 0xDA, 0x81, 0xD3, 0xDA, 0x82, 0x83, 0xDA, 0x82, 0x82, 0xDA, 0x81, 0x65, 0xDA, 0x81, 
  0xB4, 0xDA, 0x82, 0x61, 0xDA, 0x82, 0x60, 0xDA, 0x82, 0x39, 0xDA, 0x84, 0xD2, 0xDA, 0x80, 0xF3, 
  0xDA, 0x84, 0x75, 0xDA, 0x82, 0x8B, 0xDA, 0x82, 0x8A, 0xDA, 0x84, 0x93, 0xDA, 0x84, 0x91, 0xDA, 
  0x81, 0x78, 0xDA, 0x81, 0x77, 0xDA, 0x81, 0x66, 0xDA, 0x81, 0x5F, 0xDA, 0x84, 0x7B, 0xDA, 0x84, 
  0x7A, 0xDA, 0x81, 0x0C, 0xDA, 0x81, 0x53, 0xDA, 0x82, 0x89, 0xDA, 0x82, 0x88, 0xDA, 0x81, 0x49, 
  0xDA, 0x81, 0x47, 0xDA, 0x82, 0x3C, 0xDA, 0x83, 0x59, 0xDA, 0x86, 0x67, 0xDA, 0x86, 0x66, 0xDA, 
  0x81, 0x21, 0xDA, 0x86, 0x77, 0xDA, 0x82, 0xF4, 0xDA, 0x82, 0xF3, 0xDA, 0x83, 0xB0, 0xDA, 0x85, 
  0x03, 0xDA, 0x85, 0x81, 0xDA, 0x85, 0x7F, 0xDA, 0x85, 0xC1, 0xDA, 0x85, 0xC0, 0xDA, 0x1B, 0xDA, 
  0x19, 0xDA, 0x84, 0x6C, 0xDA, 0x84, 0x6B, 0xDA, 0x82, 0x15, 0xDA, 0x85, 0x59, 0xDA, 0x80, 0xEE, 
  0xDA, 0x85, 0xAE, 0xDA, 0x86, 0x0B, 0xDA, 0x86, 0x0A, 0xDA, 0x86, 0x8F, 0xDA, 0x86, 0x6D, 0xDA, 
  0x86, 0x20, 0xDA, 0x86, 0x1F, 0xDA, 0x83, 0x3E, 0xDA, 0x83, 0x3D, 0xDA, 0x83, 0x60, 0xDA, 0x83, 
  0x5E, 0xDA, 0x82, 0x4B, 0xDA, 0x82, 0x49, 0xDA, 0x82, 0xE4, 0xDA, 0x82, 0xE3, 0xDA, 0x83, 0x40, 
  0xDA, 0x83, 0x3F, 0xDA, 0x83, 0x63, 0xDA, 0x83, 0x61, 0xDA, 0x83, 0x92, 0xDA, 0x85, 0x3B, 0xDA, 
  0x80, 0xFF, 0xDA, 0x85, 0x85, 0xDA, 0x81, 0xC4, 0xDA, 0x81, 0xC3, 0xDA, 0x82, 0xC2, 0xDA, 0x82, 
  0xC1, 0xDA, 0x83, 0x65, 0xDA, 0x83, 0x64, 0xDA, 0x82, 0x85, 0xDA, 0x81, 0x95, 0xDA, 0x82, 0xC4, 
  0xDA, 0x82, 0xC3, 0xDA, 0x85, 0x25, 0xDA, 0x85, 0x24, 0xDA, 0x82, 0xB6, 0xDA, 0x82, 0xB5, 0xDA, 
  0x85, 0x34, 0xDA, 0x85, 0x32, 0xDA, 0x81, 0xD2, 0xDA, 0x81, 0xD0, 0xDA, 0x69, 0xDA, 0x82, 0xA8, 
  0xDA, 0x84, 0xF9, 0xDA, 0x84, 0xF8, 0xDA, 0x86, 0x1A, 0xDA, 0x86, 0x19, 0xDA, 0x85, 0xEE, 0xDA, 
  0x85, 0xEC, 0xDA, 0x86, 0x11, 0xDA, 0x86, 0x10, 0xDA, 0x84, 0x9C, 0xDA, 0x84, 0x9B, 0xDA, 0x80, 
  0xCA, 0xDA, 0x86, 0x25, 0xDA, 0x80, 0xC3, 0xDA, 0x82, 0x07, 0xDA, 0x85, 0xF1, 0xDA, 0x85, 0xF0, 
  0xDA, 0x81, 0xDD, 0xDA, 0x81, 0xDB, 0xDA, 0x86, 0x54, 0xDA, 0x86, 0x52, 0xDA, 0x82, 0x31, 0xDA, 
  0x83, 0x31, 0xDA, 0x81, 0x4B, 0xDA, 0x81, 0x4A, 0xDA, 0x29, 0xDA, 0x83, 0x00, 0xDA, 0x81, 0xEF, 
  0xDA, 0x81, 0xEE, 0xDA, 0x84, 0xB7, 0xDA, 0x84, 0xB4, 0xDA, 0x82, 0x64, 0xDA, 0x82, 0x63, 0xDA, 
  0x82, 0xFF, 0xDA, 0x82, 0xFD, 0xDA, 0x82, 0x9B, 0xDA, 0x84, 0xCA, 0xDA, 0x50, 0xDA, 0x85, 0xB6, 
  0xDA, 0x83, 0x1E, 0xDA, 0x83, 0x1D, 0xDA, 0x85, 0xA5, 0xDA, 0x86, 0x82, 0xDA, 0x82, 0x0F, 0xDA, 
  0x82, 0x0D, 0xDA, 0x6F, 0xDA, 0x82, 0xA5, 0xDA, 0x81, 0x3F, 0xDA, 0x82, 0xFC, 0xDA, 0x83, 0x56, 
  0xDA, 0x83, 0x55, 0xDA, 0x32, 0xDA, 0x1D, 0xDA, 0x83, 0x67, 0xDA, 0x83, 0x66, 0xDA, 0x81, 0xA9, 
  0xDA, 0x85, 0x64, 0xDA, 0x4E, 0xDA, 0x86, 0x89, 0xDA, 0x82, 0x4E, 0xDA, 0x82, 0x4C, 0xDA, 0x83, 
  0xFA, 0xDA, 0x85, 0xF2, 0xDA, 0x84, 0xCF, 0xDA, 0x84, 0xCE, 0xDA, 0x84, 0x98, 0xDA, 0x84, 0x94, 
  0xDA, 0x86, 0x09, 0xDA, 0x86, 0x07, 0xDA, 0x84, 0x81, 0xDA, 0x85, 0x92, 0xDA, 0x86, 0x74, 0xDA, 
  0x86, 0x72, 0xDA, 0x82, 0x66, 0xDA, 0x82, 0x65, 0xDA, 0x85, 0x1E, 0xDA, 0x85, 0x1D, 0xDA, 0x86, 
  0x57, 0xDA, 0x86, 0x56, 0xDA, 0x86, 0x7B, 0xDA, 0x86, 0x79, 0xDA, 0x82, 0x44, 0xDA, 0x82, 0x43, 
  0xDA, 0x82, 0x38, 0xDA, 0x84, 0xF6, 0xDA, 0x86, 0x2F, 0xDA, 0x86, 0x2E, 0xDA, 0x85, 0x07, 0xDA, 
  0x85, 0x06, 0xDA, 0x86, 0x24, 0xDA, 0x86, 0x23, 0xDA, 0x81, 0x7A, 0xDA, 0x81, 0x79, 0xDA, 0x83, 
  0x52, 0xDA, 0x83, 0x51, 0xDA, 0x84, 0xCD, 0xDA, 0x84, 0xCB, 0xDA, 0x85, 0xF8, 0xDA, 0x85, 0xF7, 
  0xDA, 0x81, 0x10, 0xDA, 0x86, 0x58, 0xDA, 0x85, 0x48, 0xDA, 0x85, 0x47, 0xDA, 0x85, 0x0E, 0xDA, 
  0x86, 0x83, 0xDA, 0x85, 0xAC, 0xDA, 0x31, 0xDA, 0x84, 0x62, 0xDA, 0x86, 0x65, 0xDA, 0x24, 0xDA, 
  0x84, 0x97, 0xDA, 0x83, 0x76, 0xDA, 0x83, 0x75, 0xDA, 0x83, 0xC6, 0xDA, 0x84, 0x76, 0xDA, 0x82, 
  0x27, 0xDA, 0x86, 0x7C, 0xDA, 0x82, 0x26, 0xDA, 0x84, 0x73, 0xDA, 0x85, 0x36, 0xDA, 0x85, 0x35, 
  0xDA, 0x83, 0x4B, 0xDA, 0x83, 0x49, 0xDA, 0x83, 0x46, 0xDA, 0x83, 0x45, 0xDA, 0x81, 0x1F, 0xDA, 
  0x85, 0x27, 0xDA, 0x86, 0x76, 0xDA, 0x86, 0x75, 0xDA, 0x80, 0xFE, 0xDA, 0x85, 0xAF, 0xDA, 0x86, 
  0x60, 0xDA, 0x86, 0x5F, 0xDA, 0x7D, 0xDA, 0x84, 0x74, 0xDA, 0x84, 0xEB, 0xDA, 0x84, 0xEA, 0xDA, 
  0x85, 0x67, 0xDA, 0x85, 0x65, 0xDA, 0x82, 0x69, 0xDA, 0x82, 0x67, 0xDA, 0x85, 0x99, 0xDA, 0x85, 
  0x98, 0xDA, 0x82, 0x2A, 0xDA, 0x85, 0x12, 0xDA, 0x80, 0xC1, 0xDA, 0x84, 0xE3, 0xDA, 0x81, 0xC6, 
  0xDA, 0x81, 0xC5, 0xDA, 0x51, 0xDA, 0x85, 0x2F, 0xDA, 0x83, 0x18, 0xDA, 0x84, 0xA3, 0xDA, 0x84, 
  0x48, 0xDA, 0x85, 0x54, 0xDA, 0x82, 0x8D, 0xDA, 0x82, 0x8C, 0xDA, 0x86, 0x5E, 0xDA, 0x86, 0x5C, 
  0xDA, 0x81, 0x34, 0xDA, 0x81, 0x32, 0xDA, 0x85, 0x53, 0xDA, 0x85, 0x51, 0xDA, 0x82, 0x5E, 0xDA, 
  0x82, 0x59, 0xDA, 0x82, 0xB2, 0xDA, 0x82, 0xB1, 0xDA, 0x86, 0x81, 0xDA, 0x86, 0x80, 0xDA, 0x86, 
  0x2D, 0xDA, 0x86, 0x2B, 0xDA, 0x85, 0x8A, 0xDA, 0x85, 0x89, 0xDA, 0x82, 0x41, 0x2C, 0x01, 0x00, 
  0x00, 0x2A, 0x02, 0x00, 0x00, 0x30, 0x00, 0x02, 0x00, 0x2A, 0x02, 0x01, 0x00, 0x34, 0x02, 0x00, 
  0x00, 0x88, 0x85, 0x01, 0x04, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00, 0x03, 0xDA, 0x09, 0xCE, 0x71, 
  0x28, 0x6D, 0x61, 0x6B, 0x65, 0x2D, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x20, 0x65, 0x6E, 0x76, 0x29, 
  0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6D, 0x61, 0x67, 
  0x65, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 
  0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x65, 0x64, 0x20, 0x62, 
  0x79, 0x20, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x2E, 0x20, 0x20, 0x52, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x20, 0x73, 0x6F, 
  0x75, 0x72, 0x63, 0x65, 0x20, 0x61, 0x73, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 
  0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x88, 0x85, 0x01, 0xDA, 0x81, 0x25, 0xD3, 0x03, 
  0xDA, 0x03, 0xDA, 0x81, 0x2A, 0xDA, 0x09, 0xCE, 0x80, 0x8D, 0x28, 0x73, 0x6F, 0x72, 0x74, 0x65, 
  0x64, 0x2D, 0x62, 0x79, 0x20, 0x66, 0x20, 0x69, 0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x73, 0x6F, 0x72, 0x74, 0x65, 
  0x64, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 0x6F, 0x6D, 
  0x70, 0x61, 0x72, 0x65, 0x73, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x62, 
  0x79, 0x20, 0x69, 0x6E, 0x76, 0x6F, 0x6B, 0x69, 0x6E, 0x67, 0x20, 0x20, 0x61, 0x20, 0x66, 0x75, 
  0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x6F, 0x6E, 0x20, 0x65, 0x61, 0x63, 0x68, 0x20, 0x65, 
  0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x61, 
  0x72, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6C, 0x74, 0x20, 
  0x77, 0x69, 0x74, 0x68, 0x20, 0x3C, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x83, 0x0C, 
  0x01, 0xDA, 0x81, 0x19, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x81, 0x24, 0xDA, 0x09, 0xCE, 0x42, 0x28, 
  0x74, 0x61, 0x6B, 0x65, 0x2D, 0x75, 0x6E, 0x74, 0x69, 0x6C, 0x20, 0x70, 0x72, 0x65, 0x64, 0x20, 
  0x69, 0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x53, 0x61, 0x6D, 0x65, 0x20, 0x61, 0x73, 0x20, 0x28, 0x74, 
  0x61, 0x6B, 0x65, 0x2D, 0x77, 0x68, 0x69, 0x6C, 0x65, 0x20, 0x28, 0x63, 0x6F, 0x6D, 0x70, 0x6C, 
  0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x70, 0x72, 0x65, 0x64, 0x29, 0x20, 0x69, 0x6E, 0x64, 0x29, 
  0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x83, 0xB5, 0x01, 0xDA, 0x81, 0x2B, 0xD3, 0x02, 
  0xDA, 0x03, 0xDA, 0x81, 0x2C, 0xDA, 0x09, 0xCE, 0x81, 0x28, 0x28, 0x62, 0x75, 0x66, 0x66, 0x65, 
  0x72, 0x2F, 0x73, 0x6C, 0x69, 0x63, 0x65, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x26, 0x6F, 
  0x70, 0x74, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x65, 0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x54, 
  0x61, 0x6B, 0x65, 0x73, 0x20, 0x61, 0x20, 0x73, 0x6C, 0x69, 0x63, 0x65, 0x20, 0x6F, 0x66, 0x20, 
  0x61, 0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6E, 0x63, 0x65, 0x20, 
  0x66, 0x72, 0x6F, 0x6D, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x65, 0x6E, 
  0x64, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x69, 0x73, 0x20, 
  0x68, 0x61, 0x6C, 0x66, 0x20, 0x6F, 0x70, 0x65, 0x6E, 0x2C, 0x20, 0x5B, 0x73, 0x74, 0x61, 0x72, 
  0x74, 0x2C, 0x20, 0x65, 0x6E, 0x64, 0x29, 0x2E, 0x20, 0x49, 0x6E, 0x64, 0x65, 0x78, 0x65, 0x73, 
  0x20, 0x63, 0x61, 0x6E, 0x20, 0x61, 0x6C, 0x73, 0x6F, 0x20, 0x62, 0x65, 0x20, 0x6E, 0x65, 0x67, 
  0x61, 0x74, 0x69, 0x76, 0x65, 0x2C, 0x20, 0x69, 0x6E, 0x64, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6E, 
  0x67, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x69, 0x6E, 0x67, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x65, 0x6E, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 
  0x6E, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 
  0x20, 0x42, 0x79, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x2C, 0x20, 0x73, 0x74, 0x61, 
  0x72, 0x74, 0x20, 0x69, 0x73, 0x20, 0x30, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x65, 0x6E, 0x64, 0x20, 
  0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x20, 0x6F, 0x66, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0x20, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 
  0x72, 0x2E, 0xDA, 0x81, 0x2D, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x81, 0x2E, 0xDA, 0x09, 0xCE, 0x81, 
  0x37, 0x28, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x63, 0x6F, 0x6E, 0x63, 0x61, 0x74, 0x20, 0x61, 
  0x72, 0x72, 0x20, 0x26, 0x20, 0x70, 0x61, 0x72, 0x74, 0x73, 0x29, 0x0A, 0x0A, 0x43, 0x6F, 0x6E, 
  0x63, 0x61, 0x74, 0x65, 0x6E, 0x61, 0x74, 0x65, 0x73, 0x20, 0x61, 0x20, 0x76, 0x61, 0x72, 0x69, 
  0x61, 0x64, 0x69, 0x63, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x61, 
  0x72, 0x72, 0x61, 0x79, 0x73, 0x20, 0x28, 0x61, 0x6E, 0x64, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 
  0x73, 0x29, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 
  0x74, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 
  0x20, 0x6D, 0x75, 0x73, 0x74, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0x20, 
  0x49, 0x66, 0x20, 0x61, 0x6E, 0x79, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 
  0x72, 0x74, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x73, 0x20, 0x6F, 
  0x72, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x73, 0x2C, 0x20, 0x74, 0x68, 0x65, 0x69, 0x72, 0x20, 
  0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 
  0x20, 0x69, 0x6E, 0x73, 0x65, 0x72, 0x74, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0x20, 0x4F, 0x74, 0x68, 0x65, 0x72, 0x77, 
  0x69, 0x73, 0x65, 0x2C, 0x20, 0x65, 0x61, 0x63, 0x68, 0x20, 0x70, 0x61, 0x72, 0x74, 0x20, 0x69, 
  0x6E, 0x20, 0x70, 0x61, 0x72, 0x74, 0x73, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 
  0x61, 0x70, 0x70, 0x65, 0x6E, 0x64, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x72, 0x72, 0x20, 
  0x69, 0x6E, 0x20, 0x6F, 0x72, 0x64, 0x65, 0x72, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x61, 0x72, 
  0x72, 0x61, 0x79, 0x20, 0x61, 0x72, 0x72, 0x2E, 0xDA, 0x81, 0x2F, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 
  0x81, 0x31, 0xDA, 0x09, 0xCE, 0x21, 0x28, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x3F, 0x20, 0x78, 
  0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x61, 0x20, 
  0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x62, 0x01, 
  0xDA, 0x81, 0x32, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x81, 0x34, 0xDA, 0x09, 0xCE, 0x70, 0x28, 0x63, 
  0x6F, 0x6D, 0x70, 0x20, 0x26, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x29, 
  0x0A, 0x0A, 0x54, 0x61, 0x6B, 0x65, 0x73, 0x20, 0x6D, 0x75, 0x6C, 0x74, 0x69, 0x70, 0x6C, 0x65, 
  0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x72, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 
  0x6E, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6F, 
  0x6D, 0x70, 0x6F, 0x73, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 
  0x6F, 0x73, 0x65, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x2E, 0xDA, 0x0B, 
  0xD2, 0x03, 0x00, 0xDA, 0x05, 0x82, 0x6B, 0x01, 0xDA, 0x81, 0x35, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 
  0x81, 0x42, 0xDA, 0x09, 0xCE, 0x80, 0xDE, 0x28, 0x61, 0x73, 0x3F, 0x2D, 0x3E, 0x20, 0x78, 0x20, 
  0x61, 0x73, 0x20, 0x26, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x73, 0x29, 0x0A, 0x0A, 0x54, 0x68, 0x72, 
  0x65, 0x61, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x73, 0x20, 0x74, 0x6F, 0x67, 0x65, 0x74, 0x68, 
  0x65, 0x72, 0x2C, 0x20, 0x72, 0x65, 0x70, 0x6C, 0x61, 0x63, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x73, 
  0x20, 0x69, 0x6E, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x73, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x70, 0x72, 0x65, 0x76, 0x69, 0x6F, 0x75, 0x73, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x2E, 0x20, 
  0x54, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x69, 0x73, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x78, 0x2E, 0x20, 0x49, 0x66, 
  0x20, 0x61, 0x6E, 0x79, 0x20, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x6D, 0x65, 0x64, 0x69, 0x61, 
  0x74, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x66, 0x61, 
  0x6C, 0x73, 0x65, 0x79, 0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x6E, 0x69, 0x6C, 
  0x3B, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x2C, 0x20, 0x72, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x20, 0x6C, 0x61, 0x73, 0x74, 0x20, 0x76, 
  0x61, 0x6C, 0x75, 0x65, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x84, 0x6F, 0x01, 0xDA, 
  0x35, 0xCB, 0xDA, 0x81, 0x43, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x81, 0x44, 0xDA, 0x09, 0xCE, 0x5B, 
  0x28, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x62, 0x69, 0x74, 0x2D, 0x63, 0x6C, 0x65, 0x61, 
  0x72, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x29, 0x0A, 
  0x0A, 0x43, 0x6C, 0x65, 0x61, 0x72, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x69, 0x74, 0x20, 
  0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x62, 0x69, 0x74, 
  0x2D, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0xDA, 0x81, 0x45, 0xD3, 0x04, 
  0xDA, 0x03, 0xDA, 0x30, 0xDA, 0x09, 0xCE, 0x80, 0x91, 0x28, 0x64, 0x65, 0x66, 0x65, 0x72, 0x20, 
  0x66, 0x6F, 0x72, 0x6D, 0x20, 0x26, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x29, 0x0A, 0x0A, 0x52, 0x75, 
  0x6E, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x20, 0x75, 0x6E, 0x63, 0x6F, 0x6E, 0x64, 0x69, 0x74, 0x69, 
  0x6F, 0x6E, 0x61, 0x6C, 0x6C, 0x79, 0x20, 0x61, 0x66, 0x74, 0x65, 0x72, 0x20, 0x62, 0x6F, 0x64, 
  0x79, 0x2C, 0x20, 0x65, 0x76, 0x65, 0x6E, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 
  0x6F, 0x64, 0x79, 0x20, 0x74, 0x68, 0x72, 0x6F, 0x77, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x72, 
  0x72, 0x6F, 0x72, 0x2E, 0x20, 0x20, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x61, 0x6C, 0x73, 0x6F, 0x20, 
  0x72, 0x75, 0x6E, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x20, 0x69, 0x66, 0x20, 0x61, 0x20, 0x75, 0x73, 
  0x65, 0x72, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0x20, 0x30, 0x2D, 0x34, 0x20, 0x69, 0x73, 
  0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x64, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 
  0x05, 0x81, 0x2A, 0x01, 0xDA, 0x35, 0xCB, 0xDA, 0x81, 0x46, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x2D, 
  0xDA, 0x09, 0xCE, 0x81, 0x53, 0x28, 0x70, 0x72, 0x6F, 0x70, 0x61, 0x67, 0x61, 0x74, 0x65, 0x20, 
  0x78, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x29, 0x0A, 0x0A, 0x50, 0x72, 0x6F, 0x70, 0x61, 0x67, 
  0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0x20, 0x66, 0x72, 0x6F, 
  0x6D, 0x20, 0x61, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2E, 0x20, 
  0x54, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6C, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x73, 0x74, 
  0x61, 0x63, 0x6B, 0x20, 0x74, 0x72, 0x61, 0x63, 0x65, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 
  0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x69, 0x6E, 0x63, 0x6C, 0x75, 0x64, 0x65, 0x20, 0x66, 0x72, 
  0x61, 0x6D, 0x65, 0x73, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2E, 
  0x20, 0x49, 0x66, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x69, 0x6E, 0x20, 
  0x61, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 0x61, 0x6E, 
  0x20, 0x62, 0x65, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6D, 0x65, 0x64, 0x2C, 0x20, 0x72, 0x65, 0x73, 
  0x75, 0x6D, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 
  0x74, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x66, 0x69, 0x72, 
  0x73, 0x74, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6D, 0x65, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2E, 
  0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x63, 
  0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x72, 0x65, 
  0x2D, 0x72, 0x61, 0x69, 0x73, 0x65, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 
  0x77, 0x69, 0x74, 0x68, 0x6F, 0x75, 0x74, 0x20, 0x6C, 0x6F, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x6F, 0x72, 0x69, 0x67, 0x69, 0x6E, 0x61, 0x6C, 0x20, 0x73, 0x74, 0x61, 0x63, 
  0x6B, 0x20, 0x74, 0x72, 0x61, 0x63, 0x65, 0x2E, 0xDA, 0x80, 0x8C, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 
  0x80, 0x8B, 0xDA, 0x09, 0xCE, 0x3E, 0x54, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x6D, 0x61, 0x70, 0x70, 
  0x69, 0x6E, 0x67, 0x20, 0x6C, 0x6F, 0x61, 0x64, 0x65, 0x64, 0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 
  0x65, 0x20, 0x69, 0x64, 0x65, 0x6E, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x73, 0x20, 0x74, 0x6F, 
  0x20, 0x74, 0x68, 0x65, 0x69, 0x72, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 
  0x6E, 0x74, 0x73, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x88, 0xED, 0x01, 0xDA, 0x81, 
  0x47, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x81, 0x49, 0xDA, 0x09, 0xCE, 0x27, 0x28, 0x70, 0x6F, 0x73, 
  0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 
  0x20, 0x69, 0x73, 0x20, 0x67, 0x72, 0x65, 0x61, 0x74, 0x65, 0x72, 0x20, 0x74, 0x68, 0x61, 0x6E, 
  0x20, 0x30, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x55, 0x01, 0xDA, 0x81, 0x4A, 0xD3, 
  0x02, 0xDA, 0x03, 0xDA, 0x81, 0x4B, 0xDA, 0x09, 0xCE, 0x2C, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 
  0x73, 0x71, 0x72, 0x74, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x71, 0x75, 0x61, 0x72, 0x65, 0x20, 0x72, 0x6F, 0x6F, 0x74, 
  0x20, 0x6F, 0x66, 0x20, 0x78, 0x2E, 0xDA, 0x81, 0x4C, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x81, 0x4D, 
  0xDA, 0x09, 0xCE, 0x18, 0x54, 0x68, 0x65, 0x20, 0x73, 0x74, 0x61, 0x6E, 0x64, 0x61, 0x72, 0x64, 
  0x20, 0x69, 0x6E, 0x70, 0x75, 0x74, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x2E, 0xDA, 0x81, 0x4E, 0xD3, 
  0x03, 0xDA, 0x03, 0xDA, 0x81, 0x50, 0xDA, 0x09, 0xCE, 0x56, 0x28, 0x66, 0x72, 0x65, 0x71, 0x75, 
  0x65, 0x6E, 0x63, 0x69, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x6F, 
  0x63, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x63, 0x65, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x65, 0x61, 
  0x63, 0x68, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x69, 0x6E, 
  0x64, 0x65, 0x78, 0x65, 0x64, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x2E, 
  0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x85, 0x38, 0x01, 0xDA, 0x81, 0x51, 0xD3, 0x02, 0xDA, 
  0x03, 0xDA, 0x81, 0x52, 0xDA, 0x09, 0xCE, 0x5C, 0x28, 0x73, 0x6C, 0x69, 0x63, 0x65, 0x20, 0x78, 
  0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x65, 0x6E, 0x64, 0x29, 
  0x0A, 0x0A, 0x45, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x20, 0x61, 0x20, 0x73, 0x75, 0x62, 0x2D, 
  0x72, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x64, 0x65, 
  0x78, 0x65, 0x64, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 
  0x72, 0x65, 0x20, 0x6F, 0x72, 0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 
  0x6E, 0x63, 0x65, 0x2E, 0xDA, 0x81, 0x53, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x81, 0x0C, 0xDA, 0x09, 
  0xCE, 0x80, 0x81, 0x28, 0x6F, 0x73, 0x2F, 0x65, 0x78, 0x69, 0x74, 0x20, 0x26, 0x6F, 0x70, 0x74, 
  0x20, 0x78, 0x29, 0x0A, 0x0A, 0x45, 0x78, 0x69, 0x74, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x6A, 
  0x61, 0x6E, 0x65, 0x74, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x78, 0x69, 
  0x74, 0x20, 0x63, 0x6F, 0x64, 0x65, 0x20, 0x65, 0x71, 0x75, 0x61, 0x6C, 0x20, 0x74, 0x6F, 0x20, 
  0x78, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x61, 
  0x6E, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x2C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 
  0x78, 0x69, 0x74, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 
  0x65, 0x71, 0x75, 0x61, 0x6C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x68, 0x61, 0x73, 0x68, 0x20, 0x6F, 
  0x66, 0x20, 0x78, 0x2E, 0xDA, 0x81, 0x54, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 0x81, 0x58, 0xDA, 0x09, 
  0xCE, 0x78, 0x28, 0x73, 0x65, 0x71, 0x20, 0x68, 0x65, 0x61, 0x64, 0x20, 0x26, 0x20, 0x62, 0x6F, 
  0x64, 0x79, 0x29, 0x0A, 0x0A, 0x53, 0x69, 0x6D, 0x69, 0x6C, 0x61, 0x72, 0x20, 0x74, 0x6F, 0x20, 
  0x6C, 0x6F, 0x6F, 0x70, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x61, 0x63, 0x63, 0x75, 0x6D, 0x75, 
  0x6C, 0x61, 0x74, 0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x20, 0x62, 
  0x6F, 0x64, 0x79, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 
  0x79, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 
  0x61, 0x74, 0x2E, 0x20, 0x20, 0x53, 0x65, 0x65, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x20, 0x66, 0x6F, 
  0x72, 0x20, 0x64, 0x65, 0x74, 0x61, 0x69, 0x6C, 0x73, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 
  0x05, 0x82, 0x22, 0x01, 0xDA, 0x35, 0xCB, 0xDA, 0x80, 0x86, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x80, 
  0x85, 0xDA, 0x09, 0xCE, 0x44, 0x28, 0x62, 0x61, 0x64, 0x2D, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 
  0x65, 0x20, 0x6D, 0x73, 0x67, 0x20, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x66, 0x20, 0x77, 0x68, 0x65, 
  0x72, 0x65, 0x29, 0x0A, 0x0A, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x20, 0x68, 0x61, 0x6E, 
  0x64, 0x6C, 0x65, 0x72, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x61, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x69, 
  0x6C, 0x65, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 
  0x87, 0xC6, 0x01, 0xDA, 0x81, 0x59, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x81, 0x5A, 0xDA, 0x09, 0xCE, 
  0x73, 0x28, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x2F, 0x73, 0x65, 0x74, 0x6D, 0x61, 0x70, 0x20, 0x74, 
  0x75, 0x70, 0x20, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0x63, 0x6F, 0x6C, 0x75, 0x6D, 0x6E, 0x29, 0x0A, 
  0x0A, 0x53, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x6D, 
  0x61, 0x70, 0x20, 0x6D, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x20, 0x6F, 0x6E, 0x20, 0x61, 
  0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x2E, 0x20, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0x61, 0x6E, 0x64, 
  0x20, 0x63, 0x6F, 0x6C, 0x75, 0x6D, 0x6E, 0x20, 0x69, 0x6E, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 
  0x20, 0x73, 0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x62, 0x65, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 
  0x65, 0x72, 0x73, 0x2E, 0xDA, 0x81, 0x5B, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x81, 0x5E, 0xDA, 0x09, 
  0xCE, 0x31, 0x28, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x74, 0x6F, 0x20, 0x26, 0x6F, 0x70, 
  0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 
  0x20, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x70, 0x72, 0x6F, 0x6D, 0x70, 0x74, 0x20, 0x70, 0x6F, 0x69, 
  0x6E, 0x74, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x81, 0x5F, 0x01, 0xDA, 0x81, 0x5F, 
  0xD3, 0x04, 0xDA, 0x03, 0xDA, 0x81, 0x66, 0xDA, 0x09, 0xCE, 0x80, 0x84, 0x28, 0x6F, 0x72, 0x20, 
  0x26, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x73, 0x29, 0x0A, 0x0A, 0x45, 0x76, 0x61, 0x6C, 0x75, 0x61, 
  0x74, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x61, 0x73, 0x74, 0x20, 
  0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x69, 0x66, 0x20, 0x61, 0x6C, 0x6C, 0x20, 
  0x70, 0x72, 0x65, 0x63, 0x65, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 
  0x74, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x66, 0x61, 0x6C, 0x73, 0x65, 0x79, 0x2C, 0x20, 0x6F, 
  0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x20, 0x20, 0x65, 0x76, 0x61, 0x6C, 0x75, 0x61, 
  0x74, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 
  0x20, 0x74, 0x72, 0x75, 0x74, 0x68, 0x79, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 
  0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x81, 0x0D, 0x01, 0xDA, 0x35, 0xCB, 0xDA, 0x81, 0x67, 
  0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x81, 0x69, 0xDA, 0x09, 0xCE, 0x77, 0x28, 0x6B, 0x76, 0x73, 0x20, 
  0x64, 0x69, 0x63, 0x74, 0x29, 0x0A, 0x0A, 0x54, 0x61, 0x6B, 0x65, 0x73, 0x20, 0x61, 0x20, 0x74, 
  0x61, 0x62, 0x6C, 0x65, 0x20, 0x6F, 0x72, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x20, 0x61, 
  0x6E, 0x64, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x61, 
  0x72, 0x72, 0x61, 0x79, 0x20, 0x6F, 0x66, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x76, 0x61, 0x6C, 0x75, 
  0x65, 0x20, 0x70, 0x61, 0x69, 0x72, 0x73, 0x20, 0x20, 0x6C, 0x69, 0x6B, 0x65, 0x20, 0x40, 0x5B, 
  0x6B, 0x20, 0x76, 0x20, 0x6B, 0x20, 0x76, 0x20, 0x2E, 0x2E, 0x2E, 0x5D, 0x2E, 0x20, 0x52, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x61, 0x72, 0x72, 0x61, 
  0x79, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x85, 0x66, 0x01, 0xDA, 0x81, 0x6A, 0xD3, 
  0x02, 0xDA, 0x03, 0xDA, 0x81, 0x6B, 0xDA, 0x09, 0xCE, 0x80, 0x80, 0x28, 0x6F, 0x73, 0x2F, 0x74, 
  0x69, 0x6D, 0x65, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 
  0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x20, 0x65, 0x78, 0x70, 0x72, 0x65, 
  0x73, 0x73, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x75, 0x6D, 0x62, 
  0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x73, 0x65, 0x63, 0x6F, 0x6E, 0x64, 0x73, 0x20, 0x73, 0x69, 
  0x6E, 0x63, 0x65, 0x20, 0x4A, 0x61, 0x6E, 0x75, 0x61, 0x72, 0x79, 0x20, 0x31, 0x2C, 0x20, 0x31, 
  0x39, 0x37, 0x30, 0x2C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x55, 0x6E, 0x69, 0x78, 0x20, 0x65, 0x70, 
  0x6F, 0x63, 0x68, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x72, 
  0x65, 0x61, 0x6C, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x2E, 0xDA, 0x81, 0x6C, 0xD3, 0x03, 
  0xDA, 0x03, 0xDA, 0x81, 0x6E, 0xDA, 0x09, 0xCE, 0x41, 0x28, 0x64, 0x69, 0x73, 0x74, 0x69, 0x6E, 
  0x63, 0x74, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 
  0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x64, 0x65, 0x64, 0x75, 0x70, 0x6C, 0x69, 0x63, 0x61, 0x74, 0x65, 0x64, 0x20, 0x76, 0x61, 0x6C, 
  0x75, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x78, 0x73, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 
  0x05, 0x85, 0x4E, 0x01, 0xDA, 0x81, 0x6F, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x81, 0x70, 0xDA, 0x09, 
  0xCE, 0x80, 0xD3, 0x28, 0x67, 0x63, 0x73, 0x65, 0x74, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x76, 0x61, 
  0x6C, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6C, 0x29, 0x0A, 0x0A, 0x53, 0x65, 0x74, 
  0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x6E, 0x75, 0x6D, 0x62, 
  0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x61, 
  0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x20, 0x62, 0x65, 0x66, 0x6F, 0x72, 0x65, 0x20, 0x72, 
  0x75, 0x6E, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x67, 0x61, 0x72, 0x62, 0x61, 0x67, 0x65, 0x20, 0x63, 
  0x6F, 0x6C, 0x6C, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0x20, 0x4C, 0x6F, 0x77, 0x20, 0x76, 
  0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x76, 
  0x61, 0x6C, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x73, 0x6C, 0x6F, 0x77, 0x65, 
  0x72, 0x20, 0x62, 0x75, 0x74, 0x20, 0x75, 0x73, 0x65, 0x20, 0x6C, 0x65, 0x73, 0x73, 0x20, 0x6D, 
  0x65, 0x6D, 0x6F, 0x72, 0x79, 0x2E, 0x20, 0x48, 0x69, 0x67, 0x68, 0x20, 0x76, 0x61, 0x6C, 0x75, 
  0x65, 0x73, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x66, 0x61, 0x73, 0x74, 0x65, 
  0x72, 0x20, 0x62, 0x75, 0x74, 0x20, 0x75, 0x73, 0x65, 0x20, 0x6D, 0x6F, 0x72, 0x65, 0x20, 0x6D, 
  0x65, 0x6D, 0x6F, 0x72, 0x79, 0x2E, 0xDA, 0x81, 0x71, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x81, 0x74, 
  0xDA, 0x09, 0xCE, 0x37, 0x28, 0x61, 0x73, 0x73, 0x65, 0x72, 0x74, 0x20, 0x78, 0x20, 0x26, 0x6F, 
  0x70, 0x74, 0x20, 0x65, 0x72, 0x72, 0x29, 0x0A, 0x0A, 0x54, 0x68, 0x72, 0x6F, 0x77, 0x20, 0x61, 
  0x6E, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 
  0x6E, 0x6F, 0x74, 0x20, 0x74, 0x72, 0x75, 0x74, 0x68, 0x79, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 
  0xDA, 0x05, 0x80, 0x8B, 0x01, 0xDA, 0x81, 0x75, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x81, 0x76, 0xDA, 
  0x09, 0xCE, 0x80, 0xAE, 0x28, 0x74, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x73, 0x77, 0x61, 0x70, 
  0x2D, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x73, 0x72, 0x63, 0x20, 0x73, 0x69, 0x6E, 0x64, 0x65, 
  0x78, 0x20, 0x64, 0x73, 0x74, 0x20, 0x64, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x26, 0x6F, 0x70, 
  0x74, 0x20, 0x63, 0x6F, 0x75, 0x6E, 0x74, 0x29, 0x0A, 0x0A, 0x53, 0x77, 0x61, 0x70, 0x20, 0x63, 
  0x6F, 0x75, 0x6E, 0x74, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x28, 0x64, 
  0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x20, 0x31, 0x29, 0x20, 0x62, 0x65, 0x74, 0x77, 0x65, 0x65, 
  0x6E, 0x20, 0x73, 0x72, 0x63, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x66, 0x72, 0x6F, 0x6D, 
  0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x73, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x61, 0x6E, 
  0x64, 0x20, 0x64, 0x73, 0x74, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x61, 0x74, 0x20, 0x70, 
  0x6F, 0x73, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x6D, 
  0x65, 0x6D, 0x6F, 0x72, 0x79, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x6F, 0x76, 0x65, 0x72, 0x6C, 0x61, 
  0x70, 0x2E, 0xDA, 0x81, 0x77, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x81, 0x78, 0xDA, 0x09, 0xCE, 0x80, 
  0xC0, 0x28, 0x65, 0x6E, 0x76, 0x2D, 0x6C, 0x6F, 0x6F, 0x6B, 0x75, 0x70, 0x20, 0x65, 0x6E, 0x76, 
  0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x73, 0x20, 0x61, 0x20, 0x66, 0x6F, 0x72, 
  0x77, 0x61, 0x72, 0x64, 0x20, 0x6C, 0x6F, 0x6F, 0x6B, 0x75, 0x70, 0x20, 0x74, 0x61, 0x62, 0x6C, 
  0x65, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x75, 0x6E, 0x6D, 0x61, 0x72, 0x73, 0x68, 0x61, 0x6C, 0x6C, 
  0x69, 0x6E, 0x67, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x6E, 0x76, 0x69, 
  0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0x20, 0x54, 0x6F, 0x20, 0x63, 0x72, 0x65, 0x61, 
  0x74, 0x65, 0x20, 0x61, 0x20, 0x72, 0x65, 0x76, 0x65, 0x72, 0x73, 0x65, 0x20, 0x6C, 0x6F, 0x6F, 
  0x6B, 0x75, 0x70, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2C, 0x20, 0x75, 0x73, 0x65, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x69, 0x6E, 0x76, 0x65, 0x72, 0x74, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 
  0x6F, 0x6E, 0x20, 0x74, 0x6F, 0x20, 0x73, 0x77, 0x61, 0x70, 0x20, 0x6B, 0x65, 0x79, 0x73, 0x20, 
  0x61, 0x6E, 0x64, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x65, 0x64, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 
  0x2E, 0xDA, 0x81, 0x79, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x81, 0x7A, 0xDA, 0x09, 0xCE, 0x2A, 0x28, 
  0x6D, 0x61, 0x74, 0x68, 0x2F, 0x65, 0x78, 0x70, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x6F, 
  0x77, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x2E, 0xDA, 0x81, 0x7B, 0xD3, 0x02, 0xDA, 0x03, 
  0xDA, 0x81, 0x7D, 0xDA, 0x09, 0xCE, 0x40, 0x28, 0x3E, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 
  0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x73, 0x20, 0x69, 0x73, 0x20, 
  0x69, 0x6E, 0x20, 0x64, 0x65, 0x73, 0x63, 0x65, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x6F, 0x72, 
  0x64, 0x65, 0x72, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x62, 
  0x6F, 0x6F, 0x6C, 0x65, 0x61, 0x6E, 0x2E, 0xDA, 0x81, 0x7E, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x81, 
  0x7F, 0xDA, 0x09, 0xCE, 0x53, 0x28, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x70, 0x65, 0x65, 0x6B, 
  0x20, 0x61, 0x72, 0x72, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x6C, 0x61, 0x73, 0x74, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 
  0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0x20, 0x44, 0x6F, 
  0x65, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x79, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0xDA, 0x81, 0x80, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 
  0x81, 0x82, 0xDA, 0x09, 0xCE, 0x80, 0xBC, 0x28, 0x69, 0x6E, 0x76, 0x65, 0x72, 0x74, 0x20, 0x64, 
  0x73, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x74, 0x61, 
  0x62, 0x6C, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x77, 0x68, 0x65, 0x72, 0x65, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x6B, 0x65, 0x79, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x73, 0x73, 0x6F, 
  0x63, 0x69, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 
  0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x20, 0x20, 0x61, 0x72, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6B, 0x65, 
  0x79, 0x73, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x6D, 0x75, 0x6C, 0x74, 0x69, 0x70, 0x6C, 0x65, 0x20, 
  0x6B, 0x65, 0x79, 0x73, 0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 
  0x6D, 0x65, 0x20, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2C, 0x20, 0x6F, 0x6E, 0x65, 0x20, 0x6B, 
  0x65, 0x79, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x69, 0x67, 0x6E, 0x6F, 0x72, 
  0x65, 0x64, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x84, 0xB3, 0x01, 0xDA, 0x81, 0x83, 
  0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x86, 0x94, 0xDA, 0x09, 0xCE, 0x80, 0xB6, 0x28, 0x72, 0x65, 0x71, 
  0x75, 0x69, 0x72, 0x65, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x26, 0x20, 0x61, 0x72, 0x67, 0x73, 
  0x29, 0x0A, 0x0A, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x20, 0x61, 0x20, 0x6D, 0x6F, 0x64, 
  0x75, 0x6C, 0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x67, 0x69, 0x76, 
  0x65, 0x6E, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x2E, 0x20, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x73, 0x65, 
  0x61, 0x72, 0x63, 0x68, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x70, 0x61, 0x74, 0x68, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 
  0x2F, 0x70, 0x61, 0x74, 0x68, 0x73, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 
  0x65, 0x6E, 0x74, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x65, 0x64, 0x20, 0x66, 0x72, 
  0x6F, 0x6D, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x6E, 0x64, 
  0x20, 0x72, 0x75, 0x6E, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 
  0x65, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x89, 0x3E, 0x01, 0xDA, 0x81, 0x85, 0xD3, 
  0x02, 0xDA, 0x03, 0xDA, 0x81, 0x86, 0xDA, 0x09, 0xCE, 0x80, 0xF7, 0x28, 0x6F, 0x73, 0x2F, 0x6D, 
  0x6B, 0x64, 0x69, 0x72, 0x20, 0x70, 0x61, 0x74, 0x68, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 
  0x74, 0x65, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6F, 
  0x72, 0x79, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x77, 0x69, 0x6C, 
  0x6C, 0x20, 0x62, 0x65, 0x20, 0x72, 0x65, 0x6C, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x74, 0x6F, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x64, 0x69, 0x72, 
  0x65, 0x63, 0x74, 0x6F, 0x72, 0x79, 0x20, 0x69, 0x66, 0x20, 0x72, 0x65, 0x6C, 0x61, 0x74, 0x69, 
  0x76, 0x65, 0x2C, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x20, 0x69, 0x74, 
  0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x62, 0x73, 0x6F, 
  0x6C, 0x75, 0x74, 0x65, 0x20, 0x70, 0x61, 0x74, 0x68, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x73, 0x20, 0x74, 0x72, 0x75, 0x65, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 
  0x69, 0x72, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x79, 0x20, 0x77, 0x61, 0x73, 0x20, 0x63, 0x72, 0x65, 
  0x61, 0x74, 0x65, 0x64, 0x2C, 0x20, 0x66, 0x61, 0x6C, 0x73, 0x65, 0x20, 0x69, 0x66, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x79, 0x20, 0x61, 0x6C, 0x72, 
  0x65, 0x61, 0x64, 0x79, 0x20, 0x65, 0x78, 0x69, 0x73, 0x74, 0x73, 0x2C, 0x20, 0x61, 0x6E, 0x64, 
  0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x73, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 
  0x65, 0x2E, 0xDA, 0x81, 0x57, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 0x81, 0xC0, 0xDA, 0x09, 0xCE, 0x88, 
  0x96, 0x28, 0x6C, 0x6F, 0x6F, 0x70, 0x20, 0x68, 0x65, 0x61, 0x64, 0x20, 0x26, 0x20, 0x62, 0x6F, 
  0x64, 0x79, 0x29, 0x0A, 0x0A, 0x41, 0x20, 0x67, 0x65, 0x6E, 0x65, 0x72, 0x61, 0x6C, 0x20, 0x70, 
  0x75, 0x72, 0x70, 0x6F, 0x73, 0x65, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x20, 0x6D, 0x61, 0x63, 0x72, 
  0x6F, 0x2E, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x20, 0x69, 0x73, 
  0x20, 0x73, 0x69, 0x6D, 0x69, 0x6C, 0x61, 0x72, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x43, 0x6F, 0x6D, 0x6D, 0x6F, 0x6E, 0x20, 0x4C, 0x69, 0x73, 0x70, 0x20, 0x20, 0x6C, 0x6F, 0x6F, 
  0x70, 0x20, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x2C, 0x20, 0x61, 0x6C, 0x74, 0x68, 0x6F, 0x75, 0x67, 
  0x68, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x6C, 0x79, 0x20, 
  0x6D, 0x75, 0x63, 0x68, 0x20, 0x73, 0x6D, 0x61, 0x6C, 0x6C, 0x65, 0x72, 0x20, 0x69, 0x6E, 0x20, 
  0x73, 0x63, 0x6F, 0x70, 0x65, 0x2E, 0x20, 0x20, 0x54, 0x68, 0x65, 0x20, 0x68, 0x65, 0x61, 0x64, 
  0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x20, 0x73, 0x68, 0x6F, 
  0x75, 0x6C, 0x64, 0x20, 0x62, 0x65, 0x20, 0x61, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x20, 0x74, 
  0x68, 0x61, 0x74, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x73, 
  0x65, 0x71, 0x75, 0x65, 0x6E, 0x63, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x20, 0x65, 0x69, 0x74, 0x68, 
  0x65, 0x72, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x20, 0x6F, 0x72, 0x20, 0x63, 
  0x6F, 0x6E, 0x64, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x73, 0x2E, 0x20, 0x41, 0x20, 0x62, 
  0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x73, 0x65, 0x71, 0x75, 
  0x65, 0x6E, 0x63, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x72, 0x65, 0x65, 0x20, 0x76, 0x61, 
  0x6C, 0x75, 0x65, 0x73, 0x20, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x64, 0x65, 0x66, 0x69, 0x6E, 
  0x65, 0x20, 0x73, 0x6F, 0x6D, 0x65, 0x74, 0x68, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x6F, 0x20, 0x6C, 
  0x6F, 0x6F, 0x70, 0x20, 0x6F, 0x76, 0x65, 0x72, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x79, 0x20, 0x61, 
  0x72, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x74, 0x65, 0x64, 0x20, 0x6C, 0x69, 0x6B, 
  0x65, 0x3A, 0x0A, 0x0A, 0x20, 0x20, 0x09, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x3A, 
  0x76, 0x65, 0x72, 0x62, 0x20, 0x6F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x2F, 0x65, 0x78, 0x70, 0x72, 
  0x65, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x0A, 0x0A, 0x20, 0x20, 0x57, 0x68, 0x65, 0x72, 0x65, 0x20, 
  0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x62, 0x69, 0x6E, 
  0x64, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x73, 0x20, 0x70, 0x61, 0x73, 0x73, 0x65, 0x64, 0x20, 0x74, 
  0x6F, 0x20, 0x64, 0x65, 0x66, 0x2C, 0x20, 0x3A, 0x76, 0x65, 0x72, 0x62, 0x20, 0x69, 0x73, 0x20, 
  0x6F, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x20, 0x73, 0x65, 0x74, 0x20, 0x6F, 0x66, 0x20, 
  0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 0x73, 0x2C, 0x20, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x6F, 
  0x62, 0x6A, 0x65, 0x63, 0x74, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6E, 0x79, 0x20, 0x65, 0x78, 0x70, 
  0x72, 0x65, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x61, 0x76, 0x61, 
  0x69, 0x6C, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x76, 0x65, 0x72, 0x62, 0x73, 0x20, 0x61, 0x72, 0x65, 
  0x3A, 0x0A, 0x0A, 0x20, 0x20, 0x09, 0x3A, 0x69, 0x74, 0x65, 0x72, 0x61, 0x74, 0x65, 0x20, 0x2D, 
  0x20, 0x72, 0x65, 0x70, 0x65, 0x61, 0x74, 0x65, 0x64, 0x6C, 0x79, 0x20, 0x65, 0x76, 0x61, 0x6C, 
  0x75, 0x61, 0x74, 0x65, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x20, 0x74, 0x6F, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x20, 
  0x77, 0x68, 0x69, 0x6C, 0x65, 0x20, 0x69, 0x74, 0x20, 0x69, 0x73, 0x20, 0x74, 0x72, 0x75, 0x74, 
  0x68, 0x79, 0x2E, 0x0A, 0x20, 0x20, 0x09, 0x3A, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x2D, 0x20, 
  0x6C, 0x6F, 0x6F, 0x70, 0x20, 0x6F, 0x76, 0x65, 0x72, 0x20, 0x61, 0x20, 0x72, 0x61, 0x6E, 0x67, 
  0x65, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x6F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x20, 0x73, 0x68, 
  0x6F, 0x75, 0x6C, 0x64, 0x20, 0x62, 0x65, 0x20, 0x74, 0x77, 0x6F, 0x20, 0x65, 0x6C, 0x65, 0x6D, 
  0x65, 0x6E, 0x74, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61, 
  0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x65, 0x6E, 0x64, 0x20, 
  0x76, 0x61, 0x6C, 0x75, 0x65, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x61, 0x6E, 0x20, 0x6F, 0x70, 
  0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x20, 0x70, 0x6F, 0x73, 0x69, 0x74, 0x69, 0x76, 0x65, 0x20, 
  0x73, 0x74, 0x65, 0x70, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x20, 
  0x69, 0x73, 0x20, 0x68, 0x61, 0x6C, 0x66, 0x20, 0x6F, 0x70, 0x65, 0x6E, 0x2C, 0x20, 0x5B, 0x73, 
  0x74, 0x61, 0x72, 0x74, 0x2C, 0x20, 0x65, 0x6E, 0x64, 0x29, 0x2E, 0x0A, 0x20, 0x20, 0x09, 0x3A, 
  0x72, 0x61, 0x6E, 0x67, 0x65, 0x2D, 0x74, 0x6F, 0x20, 0x2D, 0x20, 0x73, 0x61, 0x6D, 0x65, 0x20, 
  0x61, 0x73, 0x20, 0x3A, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x69, 0x73, 0x20, 0x69, 0x6E, 0x63, 0x6C, 
  0x75, 0x73, 0x69, 0x76, 0x65, 0x20, 0x5B, 0x73, 0x74, 0x61, 0x72, 0x74, 0x2C, 0x20, 0x65, 0x6E, 
  0x64, 0x5D, 0x2E, 0x0A, 0x20, 0x20, 0x09, 0x3A, 0x64, 0x6F, 0x77, 0x6E, 0x20, 0x2D, 0x20, 0x6C, 
  0x6F, 0x6F, 0x70, 0x20, 0x6F, 0x76, 0x65, 0x72, 0x20, 0x61, 0x20, 0x72, 0x61, 0x6E, 0x67, 0x65, 
  0x2C, 0x20, 0x73, 0x74, 0x65, 0x70, 0x70, 0x69, 0x6E, 0x67, 0x20, 0x64, 0x6F, 0x77, 0x6E, 0x77, 
  0x61, 0x72, 0x64, 0x73, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x6F, 0x62, 0x6A, 0x65, 0x63, 0x74, 
  0x20, 0x73, 0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x62, 0x65, 0x20, 0x74, 0x77, 0x6F, 0x20, 0x65, 
  0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x20, 0x20, 0x77, 0x69, 
  0x74, 0x68, 0x20, 0x61, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x28, 
  0x65, 0x78, 0x63, 0x6C, 0x75, 0x73, 0x69, 0x76, 0x65, 0x29, 0x20, 0x65, 0x6E, 0x64, 0x20, 0x76, 
  0x61, 0x6C, 0x75, 0x65, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x61, 0x6E, 0x20, 0x6F, 0x70, 0x74, 
  0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x20, 0x28, 0x70, 0x6F, 0x73, 0x69, 0x74, 0x69, 0x76, 0x65, 0x21, 
  0x29, 0x20, 0x73, 0x74, 0x65, 0x70, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x2E, 0x0A, 0x20, 0x20, 0x09, 
  0x3A, 0x64, 0x6F, 0x77, 0x6E, 0x2D, 0x74, 0x6F, 0x20, 0x2D, 0x20, 0x73, 0x61, 0x6D, 0x65, 0x20, 
  0x3A, 0x61, 0x73, 0x20, 0x64, 0x6F, 0x77, 0x6E, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x69, 0x73, 0x20, 0x69, 0x6E, 0x63, 0x6C, 0x75, 
  0x73, 0x69, 0x76, 0x65, 0x20, 0x5B, 0x73, 0x74, 0x61, 0x72, 0x74, 0x2C, 0x20, 0x65, 0x6E, 0x64, 
  0x5D, 0x2E, 0x0A, 0x20, 0x20, 0x09, 0x3A, 0x6B, 0x65, 0x79, 0x73, 0x20, 0x2D, 0x20, 0x69, 0x74, 
  0x65, 0x72, 0x61, 0x74, 0x65, 0x20, 0x6F, 0x76, 0x65, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6B, 
  0x65, 0x79, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 
  0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x2E, 0x0A, 0x20, 0x20, 0x09, 0x3A, 0x70, 0x61, 0x69, 
  0x72, 0x73, 0x20, 0x2D, 0x20, 0x69, 0x74, 0x65, 0x72, 0x61, 0x74, 0x65, 0x20, 0x6F, 0x76, 0x65, 
  0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6B, 0x65, 0x79, 0x73, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 
  0x20, 0x70, 0x61, 0x69, 0x72, 0x73, 0x20, 0x61, 0x73, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x73, 
  0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 
  0x74, 0x75, 0x72, 0x65, 0x2E, 0x0A, 0x20, 0x20, 0x09, 0x3A, 0x69, 0x6E, 0x20, 0x2D, 0x20, 0x69, 
  0x74, 0x65, 0x72, 0x61, 0x74, 0x65, 0x20, 0x6F, 0x76, 0x65, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x64, 0x61, 0x74, 0x61, 
  0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x2E, 0x0A, 0x20, 0x20, 0x09, 0x3A, 
  0x67, 0x65, 0x6E, 0x65, 0x72, 0x61, 0x74, 0x65, 0x20, 0x2D, 0x20, 0x69, 0x74, 0x65, 0x72, 0x61, 
  0x74, 0x65, 0x20, 0x6F, 0x76, 0x65, 0x72, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x79, 
  0x69, 0x65, 0x6C, 0x64, 0x65, 0x64, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x61, 0x20, 0x66, 0x69, 
  0x62, 0x65, 0x72, 0x2E, 0x20, 0x43, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x70, 0x61, 0x69, 0x72, 
  0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x67, 0x65, 0x6E, 0x65, 
  0x72, 0x61, 0x74, 0x6F, 0x72, 0x20, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 
  0x66, 0x6F, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x64, 0x75, 0x63, 0x65, 0x72, 
  0x2F, 0x63, 0x6F, 0x6E, 0x73, 0x75, 0x6D, 0x65, 0x72, 0x20, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 
  0x6E, 0x2E, 0x0A, 0x0A, 0x20, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x20, 0x61, 0x6C, 0x73, 0x6F, 0x20, 
  0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x73, 0x20, 0x63, 0x6F, 0x6E, 0x64, 0x69, 0x74, 0x69, 0x6F, 
  0x6E, 0x61, 0x6C, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x72, 0x65, 0x66, 0x69, 0x6E, 0x65, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x69, 0x6E, 0x67, 0x20, 0x66, 0x75, 0x72, 0x74, 0x68, 
  0x65, 0x72, 0x2E, 0x20, 0x43, 0x6F, 0x6E, 0x64, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x73, 
  0x20, 0x61, 0x72, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x6F, 0x72, 
  0x6D, 0x3A, 0x0A, 0x0A, 0x20, 0x20, 0x09, 0x3A, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x72, 
  0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x0A, 0x0A, 0x20, 0x20, 0x77, 0x68, 0x65, 
  0x72, 0x65, 0x20, 0x3A, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 
  0x6F, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x20, 0x73, 0x65, 0x74, 0x20, 0x6F, 0x66, 0x20, 
  0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 0x73, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x61, 0x72, 
  0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x69, 0x73, 0x20, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 
  0x64, 0x20, 0x64, 0x65, 0x70, 0x65, 0x6E, 0x64, 0x65, 0x6E, 0x74, 0x2E, 0x20, 0x20, 0x3A, 0x6D, 
  0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x72, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x6F, 
  0x6E, 0x65, 0x20, 0x6F, 0x66, 0x3A, 0x0A, 0x0A, 0x20, 0x20, 0x09, 0x3A, 0x77, 0x68, 0x69, 0x6C, 
  0x65, 0x20, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x2D, 0x20, 0x62, 
  0x72, 0x65, 0x61, 0x6B, 0x73, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 
  0x6F, 0x6F, 0x70, 0x20, 0x69, 0x66, 0x20, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6F, 
  0x6E, 0x20, 0x69, 0x73, 0x20, 0x66, 0x61, 0x6C, 0x73, 0x65, 0x79, 0x2E, 0x0A, 0x20, 0x20, 0x09, 
  0x3A, 0x75, 0x6E, 0x74, 0x69, 0x6C, 0x20, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6F, 
  0x6E, 0x20, 0x2D, 0x20, 0x62, 0x72, 0x65, 0x61, 0x6B, 0x73, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x20, 0x69, 0x66, 0x20, 0x65, 0x78, 0x70, 0x72, 
  0x65, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x69, 0x73, 0x20, 0x74, 0x72, 0x75, 0x74, 0x68, 0x79, 
  0x2E, 0x0A, 0x20, 0x20, 0x09, 0x3A, 0x6C, 0x65, 0x74, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 
  0x67, 0x73, 0x20, 0x2D, 0x20, 0x64, 0x65, 0x66, 0x69, 0x6E, 0x65, 0x73, 0x20, 0x62, 0x69, 0x6E, 
  0x64, 0x69, 0x6E, 0x67, 0x73, 0x20, 0x69, 0x6E, 0x73, 0x69, 0x64, 0x65, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x20, 0x61, 0x73, 0x20, 0x70, 0x61, 0x73, 0x73, 0x65, 0x64, 0x20, 
  0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x65, 0x74, 0x20, 0x6D, 0x61, 0x63, 0x72, 0x6F, 
  0x2E, 0x0A, 0x20, 0x20, 0x09, 0x3A, 0x62, 0x65, 0x66, 0x6F, 0x72, 0x65, 0x20, 0x66, 0x6F, 0x72, 
  0x6D, 0x20, 0x2D, 0x20, 0x65, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0x73, 0x20, 0x61, 0x20, 
  0x66, 0x6F, 0x72, 0x6D, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x61, 0x20, 0x73, 0x69, 0x64, 0x65, 0x20, 
  0x65, 0x66, 0x66, 0x65, 0x63, 0x74, 0x20, 0x62, 0x65, 0x66, 0x6F, 0x72, 0x65, 0x20, 0x6F, 0x66, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x78, 0x74, 0x20, 0x69, 0x6E, 0x6E, 0x65, 0x72, 0x20, 
  0x6C, 0x6F, 0x6F, 0x70, 0x2E, 0x0A, 0x20, 0x20, 0x09, 0x3A, 0x61, 0x66, 0x74, 0x65, 0x72, 0x20, 
  0x66, 0x6F, 0x72, 0x6D, 0x20, 0x2D, 0x20, 0x73, 0x61, 0x6D, 0x65, 0x20, 0x61, 0x73, 0x20, 0x3A, 
  0x62, 0x65, 0x66, 0x6F, 0x72, 0x65, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x73, 0x69, 0x64, 0x65, 0x20, 0x65, 0x66, 0x66, 0x65, 0x63, 0x74, 0x20, 0x68, 0x61, 0x70, 0x70, 
  0x65, 0x6E, 0x73, 0x20, 0x61, 0x66, 0x74, 0x65, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 
  0x78, 0x74, 0x20, 0x69, 0x6E, 0x6E, 0x65, 0x72, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x2E, 0x0A, 0x20, 
  0x20, 0x09, 0x3A, 0x72, 0x65, 0x70, 0x65, 0x61, 0x74, 0x20, 0x6E, 0x20, 0x2D, 0x20, 0x72, 0x65, 
  0x70, 0x65, 0x61, 0x74, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x78, 0x74, 0x20, 0x69, 
  0x6E, 0x6E, 0x65, 0x72, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x20, 0x6E, 0x20, 0x74, 0x69, 0x6D, 0x65, 
  0x73, 0x2E, 0x0A, 0x20, 0x20, 0x09, 0x3A, 0x77, 0x68, 0x65, 0x6E, 0x20, 0x63, 0x6F, 0x6E, 0x64, 
  0x69, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x2D, 0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x20, 0x65, 0x76, 0x61, 
  0x6C, 0x75, 0x61, 0x74, 0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x20, 
  0x62, 0x6F, 0x64, 0x79, 0x20, 0x77, 0x68, 0x65, 0x6E, 0x20, 0x63, 0x6F, 0x6E, 0x64, 0x69, 0x74, 
  0x69, 0x6F, 0x6E, 0x20, 0x69, 0x73, 0x20, 0x74, 0x72, 0x75, 0x65, 0x2E, 0x0A, 0x0A, 0x20, 0x20, 
  0x54, 0x68, 0x65, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x20, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x20, 0x61, 
  0x6C, 0x77, 0x61, 0x79, 0x73, 0x20, 0x65, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0x73, 0x20, 
  0x74, 0x6F, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x81, 0xF5, 
  0x01, 0xDA, 0x35, 0xCB, 0xDA, 0x81, 0xC1, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x81, 0xC2, 0xDA, 0x09, 
  0xCE, 0x78, 0x28, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x6A, 0x6F, 0x69, 0x6E, 0x20, 0x70, 
  0x61, 0x72, 0x74, 0x73, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x73, 0x65, 0x70, 0x29, 0x0A, 0x0A, 
  0x4A, 0x6F, 0x69, 0x6E, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x6F, 
  0x66, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x73, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x6F, 
  0x6E, 0x65, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2C, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 
  0x6E, 0x61, 0x6C, 0x6C, 0x79, 0x20, 0x73, 0x65, 0x70, 0x61, 0x72, 0x61, 0x74, 0x65, 0x64, 0x20, 
  0x62, 0x79, 0x20, 0x61, 0x20, 0x73, 0x65, 0x70, 0x61, 0x72, 0x61, 0x74, 0x6F, 0x72, 0x20, 0x73, 
  0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x73, 0x65, 0x70, 0x2E, 0xDA, 0x81, 0xC3, 0xD3, 0x02, 0xDA, 
  0x03, 0xDA, 0x81, 0xC4, 0xDA, 0x09, 0xCE, 0x21, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x67, 0x61, 
  0x6D, 0x6D, 0x61, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 
  0x67, 0x61, 0x6D, 0x6D, 0x61, 0x28, 0x78, 0x29, 0x2E, 0xDA, 0x81, 0xC5, 0xD3, 0x02, 0xDA, 0x03, 
  0xDA, 0x81, 0xC6, 0xDA, 0x09, 0xCE, 0x28, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x61, 0x73, 0x69, 
  0x6E, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x61, 0x72, 0x63, 0x73, 0x69, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x2E, 0xDA, 
  0x81, 0xC7, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x81, 0xC9, 0xDA, 0x09, 0xCE, 0x22, 0x28, 0x66, 0x69, 
  0x62, 0x65, 0x72, 0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 
  0x66, 0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2E, 0xDA, 
  0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x59, 0x01, 0xDA, 0x81, 0xCA, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 
  0x81, 0xCB, 0xDA, 0x09, 0xCE, 0x80, 0xA4, 0x28, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x72, 
  0x65, 0x70, 0x6C, 0x61, 0x63, 0x65, 0x2D, 0x61, 0x6C, 0x6C, 0x20, 0x70, 0x61, 0x74, 0x74, 0x20, 
  0x73, 0x75, 0x62, 0x73, 0x74, 0x20, 0x73, 0x74, 0x72, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x70, 0x6C, 
  0x61, 0x63, 0x65, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x69, 0x6E, 0x73, 0x74, 0x61, 0x6E, 0x63, 0x65, 
  0x73, 0x20, 0x6F, 0x66, 0x20, 0x70, 0x61, 0x74, 0x74, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x73, 
  0x75, 0x62, 0x73, 0x74, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x72, 0x69, 
  0x6E, 0x67, 0x20, 0x73, 0x74, 0x72, 0x2E, 0x20, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x72, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x73, 0x74, 0x72, 0x69, 
  0x6E, 0x67, 0x20, 0x69, 0x66, 0x20, 0x70, 0x61, 0x74, 0x74, 0x20, 0x69, 0x73, 0x20, 0x66, 0x6F, 
  0x75, 0x6E, 0x64, 0x2C, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x20, 0x72, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x73, 0x74, 0x72, 0x2E, 0xDA, 0x81, 0xCC, 0xD3, 0x03, 
  0xDA, 0x03, 0xDA, 0x56, 0xDA, 0x09, 0xCE, 0x38, 0x28, 0x6B, 0x65, 0x79, 0x73, 0x20, 0x78, 0x29, 
  0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6B, 0x65, 0x79, 0x73, 0x20, 0x6F, 
  0x66, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x73, 0x73, 0x6F, 0x63, 0x69, 0x61, 0x74, 0x69, 0x76, 0x65, 
  0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x2E, 
  0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x85, 0x1A, 0x01, 0xDA, 0x81, 0xCD, 0xD3, 0x02, 0xDA, 
  0x03, 0xDA, 0x81, 0xCE, 0xDA, 0x09, 0xCE, 0x80, 0xB8, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x72, 
  0x6E, 0x67, 0x2D, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x72, 0x6E, 0x67, 0x20, 0x6E, 0x20, 
  0x26, 0x6F, 0x70, 0x74, 0x20, 0x62, 0x75, 0x66, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 0x6E, 
  0x20, 0x72, 0x61, 0x6E, 0x64, 0x6F, 0x6D, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x61, 0x6E, 
  0x64, 0x20, 0x70, 0x75, 0x74, 0x20, 0x74, 0x68, 0x65, 0x6D, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 
  0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0x20, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x73, 0x20, 
  0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x69, 0x66, 0x20, 
  0x6E, 0x6F, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 
  0x76, 0x69, 0x64, 0x65, 0x64, 0x2C, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 
  0x20, 0x61, 0x70, 0x70, 0x65, 0x6E, 0x64, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0x20, 0x52, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 
  0x2E, 0xDA, 0x81, 0xCF, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x80, 0xFB, 0xDA, 0x09, 0xCE, 0x81, 0x1C, 
  0x28, 0x67, 0x65, 0x74, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x70, 0x72, 
  0x6F, 0x6D, 0x70, 0x74, 0x20, 0x62, 0x75, 0x66, 0x20, 0x65, 0x6E, 0x76, 0x29, 0x0A, 0x0A, 0x52, 
  0x65, 0x61, 0x64, 0x73, 0x20, 0x61, 0x20, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x69, 
  0x6E, 0x70, 0x75, 0x74, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x62, 0x75, 0x66, 0x66, 
  0x65, 0x72, 0x2C, 0x20, 0x69, 0x6E, 0x63, 0x6C, 0x75, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x6E, 0x65, 0x77, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0x63, 0x68, 0x61, 0x72, 0x61, 0x63, 
  0x74, 0x65, 0x72, 0x2C, 0x20, 0x75, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x20, 0x70, 0x72, 0x6F, 
  0x6D, 0x70, 0x74, 0x2E, 0x20, 0x41, 0x6E, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 
  0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x61, 0x62, 
  0x6C, 0x65, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x76, 0x69, 0x64, 
  0x65, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x61, 0x75, 0x74, 0x6F, 0x2D, 0x63, 0x6F, 0x6D, 0x70, 
  0x6C, 0x65, 0x74, 0x65, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 
  0x72, 0x2E, 0x20, 0x55, 0x73, 0x65, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x66, 0x75, 0x6E, 0x63, 
  0x74, 0x69, 0x6F, 0x6E, 0x20, 0x74, 0x6F, 0x20, 0x69, 0x6D, 0x70, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 
  0x74, 0x20, 0x61, 0x20, 0x73, 0x69, 0x6D, 0x70, 0x6C, 0x65, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x72, 
  0x66, 0x61, 0x63, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x61, 0x20, 0x74, 0x65, 0x72, 0x6D, 0x69, 
  0x6E, 0x61, 0x6C, 0x20, 0x70, 0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x2E, 0xDA, 0x81, 0xD0, 0xD3, 
  0x03, 0xDA, 0x03, 0xDA, 0x81, 0xD2, 0xDA, 0x09, 0xCE, 0x80, 0xA3, 0x28, 0x6B, 0x65, 0x65, 0x70, 
  0x20, 0x70, 0x72, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x47, 0x69, 0x76, 0x65, 
  0x6E, 0x20, 0x61, 0x20, 0x70, 0x72, 0x65, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x2C, 0x20, 0x74, 
  0x61, 0x6B, 0x65, 0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 
  0x73, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 
  0x6F, 0x72, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x20, 0x77, 0x68, 
  0x69, 0x63, 0x68, 0x20, 0x28, 0x70, 0x72, 0x65, 0x64, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 
  0x74, 0x29, 0x20, 0x69, 0x73, 0x20, 0x74, 0x72, 0x75, 0x74, 0x68, 0x79, 0x2E, 0x20, 0x52, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x61, 0x72, 0x72, 0x61, 
  0x79, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x72, 0x75, 0x74, 0x68, 0x79, 0x20, 0x70, 0x72, 0x65, 0x64, 
  0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6C, 0x74, 0x73, 0x2E, 0xDA, 0x0B, 
  0xD2, 0x03, 0x00, 0xDA, 0x05, 0x83, 0x75, 0x01, 0xDA, 0x81, 0xD3, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 
  0x81, 0xD5, 0xDA, 0x09, 0xCE, 0x80, 0xF8, 0x28, 0x66, 0x69, 0x6E, 0x64, 0x20, 0x70, 0x72, 0x65, 
  0x64, 0x20, 0x69, 0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x46, 0x69, 0x6E, 0x64, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x69, 0x6E, 0x20, 
  0x61, 0x6E, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x65, 0x64, 0x20, 0x63, 0x6F, 0x6C, 0x6C, 0x65, 
  0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x73, 0x61, 0x74, 0x69, 0x73, 
  0x66, 0x69, 0x65, 0x73, 0x20, 0x61, 0x20, 0x70, 0x72, 0x65, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 
  0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x20, 0x6E, 0x69, 0x6C, 0x20, 0x69, 
  0x66, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x2E, 0x20, 0x4E, 0x6F, 0x74, 
  0x65, 0x20, 0x74, 0x68, 0x65, 0x72, 0x65, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x6F, 0x20, 0x77, 0x61, 
  0x79, 0x20, 0x74, 0x6F, 0x20, 0x64, 0x69, 0x66, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x74, 0x69, 0x61, 
  0x74, 0x65, 0x20, 0x61, 0x20, 0x6E, 0x69, 0x6C, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x65, 0x64, 0x20, 0x63, 0x6F, 0x6C, 0x6C, 0x65, 0x63, 
  0x74, 0x69, 0x6F, 0x6E, 0x20, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x61, 0x20, 0x6E, 0x6F, 0x74, 0x20, 
  0x66, 0x6F, 0x75, 0x6E, 0x64, 0x2E, 0x20, 0x43, 0x6F, 0x6E, 0x73, 0x69, 0x64, 0x65, 0x72, 0x20, 
  0x66, 0x69, 0x6E, 0x64, 0x2D, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 
  0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x73, 0x73, 0x75, 0x65, 0x2E, 0xDA, 
  0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x83, 0xA2, 0x01, 0xDA, 0x81, 0xD6, 0xD3, 0x03, 0xDA, 0x03, 
  0xDA, 0x81, 0xDA, 0xDA, 0x09, 0xCE, 0x75, 0x28, 0x66, 0x6C, 0x61, 0x74, 0x74, 0x65, 0x6E, 0x20, 
  0x78, 0x73, 0x29, 0x0A, 0x0A, 0x54, 0x61, 0x6B, 0x65, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x73, 
  0x74, 0x65, 0x64, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x28, 0x74, 0x72, 0x65, 0x65, 0x29, 
  0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x64, 0x65, 0x70, 0x74, 0x68, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x74, 0x72, 
  0x61, 0x76, 0x65, 0x72, 0x73, 0x61, 0x6C, 0x20, 0x6F, 0x66, 0x20, 0x20, 0x74, 0x68, 0x61, 0x74, 
  0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 
  0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 
  0x00, 0xDA, 0x05, 0x85, 0x60, 0x01, 0xDA, 0x81, 0xDB, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 0x81, 0xDD, 
  0xDA, 0x09, 0xCE, 0x2D, 0x28, 0x63, 0x6F, 0x6D, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x26, 0x29, 0x0A, 
  0x0A, 0x49, 0x67, 0x6E, 0x6F, 0x72, 0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x6F, 0x64, 
  0x79, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6F, 0x6D, 0x6D, 0x65, 0x6E, 0x74, 
  0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x80, 0x9B, 0x01, 0xDA, 0x35, 0xCB, 0xDA, 0x81, 
  0xDE, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x81, 0xDF, 0xDA, 0x09, 0xCE, 0x80, 0x8A, 0x28, 0x6F, 0x73, 
  0x2F, 0x74, 0x6F, 0x75, 0x63, 0x68, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x26, 0x6F, 0x70, 0x74, 
  0x20, 0x61, 0x63, 0x74, 0x69, 0x6D, 0x65, 0x20, 0x6D, 0x6F, 0x64, 0x74, 0x69, 0x6D, 0x65, 0x29, 
  0x0A, 0x0A, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x63, 0x63, 
  0x65, 0x73, 0x73, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x6D, 0x6F, 0x64, 
  0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x73, 0x20, 
  0x66, 0x6F, 0x72, 0x20, 0x61, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x2E, 0x20, 0x42, 0x79, 0x20, 0x64, 
  0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x2C, 0x20, 0x73, 0x65, 0x74, 0x73, 0x20, 0x74, 0x69, 0x6D, 
  0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 
  0x74, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x2E, 0xDA, 0x81, 0xE0, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 0x81, 
  0xE2, 0xDA, 0x09, 0xCE, 0x49, 0x28, 0x64, 0x65, 0x66, 0x6E, 0x2D, 0x20, 0x6E, 0x61, 0x6D, 0x65, 
  0x20, 0x26, 0x20, 0x6D, 0x6F, 0x72, 0x65, 0x29, 0x0A, 0x0A, 0x44, 0x65, 0x66, 0x69, 0x6E, 0x65, 
  0x20, 0x61, 0x20, 0x70, 0x72, 0x69, 0x76, 0x61, 0x74, 0x65, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 
  0x69, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x6E, 0x6F, 
  0x74, 0x20, 0x62, 0x65, 0x20, 0x65, 0x78, 0x70, 0x6F, 0x72, 0x74, 0x65, 0x64, 0x2E, 0xDA, 0x0B, 
  0xD2, 0x03, 0x00, 0xDA, 0x05, 0x33, 0x01, 0xDA, 0x35, 0xCB, 0xDA, 0x81, 0xE3, 0xD3, 0x03, 0xDA, 
  0x03, 0xDA, 0x81, 0x23, 0xDA, 0x09, 0xCE, 0x1C, 0x28, 0x6E, 0x69, 0x6C, 0x3F, 0x20, 0x78, 0x29, 
  0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 
  0x6E, 0x69, 0x6C, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x72, 0x01, 0xDA, 0x81, 0xE4, 
  0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x81, 0xE5, 0xDA, 0x09, 0xCE, 0x82, 0x8E, 0x28, 0x74, 0x68, 0x72, 
  0x65, 0x61, 0x64, 0x2F, 0x6E, 0x65, 0x77, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x20, 0x26, 0x6F, 0x70, 
  0x74, 0x20, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x20, 0x66, 0x6C, 0x61, 0x67, 0x73, 
  0x29, 0x0A, 0x0A, 0x53, 0x74, 0x61, 0x72, 0x74, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x74, 
  0x68, 0x72, 0x65, 0x61, 0x64, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 
  0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x69, 0x6D, 0x6D, 0x65, 0x64, 0x69, 0x61, 0x74, 0x65, 0x6C, 
  0x79, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x20, 0x69, 
  0x73, 0x20, 0x70, 0x72, 0x6F, 0x76, 0x69, 0x64, 0x65, 0x64, 0x2C, 0x20, 0x74, 0x68, 0x61, 0x74, 
  0x20, 0x69, 0x73, 0x20, 0x68, 0x6F, 0x77, 0x20, 0x6D, 0x61, 0x6E, 0x79, 0x20, 0x6D, 0x65, 0x73, 
  0x73, 0x61, 0x67, 0x65, 0x73, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x73, 0x74, 0x6F, 
  0x72, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x68, 0x72, 0x65, 0x61, 
  0x64, 0x27, 0x73, 0x20, 0x6D, 0x61, 0x69, 0x6C, 0x62, 0x6F, 0x78, 0x20, 0x62, 0x65, 0x66, 0x6F, 
  0x72, 0x65, 0x20, 0x62, 0x6C, 0x6F, 0x63, 0x6B, 0x69, 0x6E, 0x67, 0x20, 0x73, 0x65, 0x6E, 0x64, 
  0x65, 0x72, 0x73, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 
  0x79, 0x20, 0x6D, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x62, 0x65, 0x74, 0x77, 0x65, 0x65, 
  0x6E, 0x20, 0x31, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x36, 0x35, 0x35, 0x33, 0x35, 0x20, 0x69, 0x6E, 
  0x63, 0x6C, 0x75, 0x73, 0x69, 0x76, 0x65, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x64, 0x65, 0x66, 
  0x61, 0x75, 0x6C, 0x74, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x31, 0x30, 0x2E, 0x20, 0x43, 0x61, 0x6E, 
  0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x6C, 0x79, 0x20, 0x70, 0x72, 0x6F, 0x76, 
  0x69, 0x64, 0x65, 0x20, 0x66, 0x6C, 0x61, 0x67, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x6E, 0x65, 0x77, 0x20, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x20, 0x2D, 0x20, 0x73, 0x75, 
  0x70, 0x70, 0x6F, 0x72, 0x74, 0x65, 0x64, 0x20, 0x66, 0x6C, 0x61, 0x67, 0x73, 0x20, 0x61, 0x72, 
  0x65, 0x3A, 0x0A, 0x09, 0x3A, 0x68, 0x20, 0x2D, 0x20, 0x53, 0x74, 0x61, 0x72, 0x74, 0x20, 0x61, 
  0x20, 0x68, 0x65, 0x61, 0x76, 0x79, 0x77, 0x65, 0x69, 0x67, 0x68, 0x74, 0x20, 0x74, 0x68, 0x72, 
  0x65, 0x61, 0x64, 0x2E, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x6C, 0x6F, 0x61, 0x64, 0x73, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x63, 0x6F, 0x72, 0x65, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 
  0x6D, 0x65, 0x6E, 0x74, 0x20, 0x62, 0x79, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x2C, 
  0x20, 0x73, 0x6F, 0x20, 0x6D, 0x61, 0x79, 0x20, 0x75, 0x73, 0x65, 0x20, 0x6D, 0x6F, 0x72, 0x65, 
  0x20, 0x6D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x20, 0x69, 0x6E, 0x69, 0x74, 0x69, 0x61, 0x6C, 0x6C, 
  0x79, 0x2E, 0x20, 0x4D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x20, 0x6D, 0x61, 0x79, 0x20, 
  0x63, 0x6F, 0x6D, 0x70, 0x72, 0x65, 0x73, 0x73, 0x20, 0x62, 0x65, 0x74, 0x74, 0x65, 0x72, 0x2C, 
  0x20, 0x74, 0x68, 0x6F, 0x75, 0x67, 0x68, 0x2E, 0x0A, 0x09, 0x3A, 0x61, 0x20, 0x2D, 0x20, 0x41, 
  0x6C, 0x6C, 0x6F, 0x77, 0x20, 0x73, 0x65, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x6F, 0x76, 0x65, 
  0x72, 0x20, 0x72, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x65, 0x64, 0x20, 0x61, 0x62, 0x73, 
  0x74, 0x72, 0x61, 0x63, 0x74, 0x20, 0x74, 0x79, 0x70, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x0A, 0x09, 0x3A, 
  0x63, 0x20, 0x2D, 0x20, 0x53, 0x65, 0x6E, 0x64, 0x20, 0x6F, 0x76, 0x65, 0x72, 0x20, 0x63, 0x66, 
  0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 
  0x69, 0x6F, 0x6E, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x74, 
  0x68, 0x72, 0x65, 0x61, 0x64, 0x2E, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 
  0x20, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 
  0x65, 0x77, 0x20, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x2E, 0xDA, 0x81, 0xE6, 0xD3, 0x03, 0xDA, 
  0x03, 0xDA, 0x81, 0xED, 0xDA, 0x09, 0xCE, 0x44, 0x28, 0x64, 0x6F, 0x63, 0x2D, 0x66, 0x6F, 0x72, 
  0x6D, 0x61, 0x74, 0x20, 0x74, 0x65, 0x78, 0x74, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x77, 0x69, 
  0x64, 0x74, 0x68, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x20, 0x74, 
  0x65, 0x78, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x77, 0x72, 0x61, 0x70, 0x20, 0x61, 0x74, 0x20, 0x61, 
  0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x6C, 0x69, 0x6E, 0x65, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 
  0x00, 0xDA, 0x05, 0x86, 0x39, 0x01, 0xDA, 0x81, 0xEE, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x81, 0xEF, 
  0xDA, 0x09, 0xCE, 0x47, 0x28, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 0x75, 0x6E, 0x66, 0x62, 0x72, 
  0x65, 0x61, 0x6B, 0x20, 0x66, 0x75, 0x6E, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x70, 0x63, 0x29, 
  0x0A, 0x0A, 0x55, 0x6E, 0x73, 0x65, 0x74, 0x20, 0x61, 0x20, 0x62, 0x72, 0x65, 0x61, 0x6B, 0x70, 
  0x6F, 0x69, 0x6E, 0x74, 0x20, 0x73, 0x65, 0x74, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x64, 0x65, 
  0x62, 0x75, 0x67, 0x2F, 0x66, 0x62, 0x72, 0x65, 0x61, 0x6B, 0x2E, 0xDA, 0x81, 0xF0, 0xD3, 0x02, 
  0xDA, 0x03, 0xDA, 0x81, 0xF1, 0xDA, 0x09, 0xCE, 0x5A, 0x28, 0x6F, 0x73, 0x2F, 0x63, 0x64, 0x20, 
  0x70, 0x61, 0x74, 0x68, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x63, 0x75, 
  0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x79, 0x20, 
  0x74, 0x6F, 0x20, 0x70, 0x61, 0x74, 0x68, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x6E, 0x69, 0x6C, 0x20, 0x6F, 0x6E, 0x20, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x2C, 
  0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x73, 0x20, 0x6F, 0x6E, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x75, 
  0x72, 0x65, 0x2E, 0xDA, 0x81, 0xF2, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x81, 0xF4, 0xDA, 0x09, 0xCE, 
  0x3B, 0x28, 0x73, 0x75, 0x6D, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x75, 0x6D, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x73, 
  0x2E, 0x20, 0x49, 0x66, 0x20, 0x78, 0x73, 0x20, 0x69, 0x73, 0x20, 0x65, 0x6D, 0x70, 0x74, 0x79, 
  0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x30, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 
  0x00, 0xDA, 0x05, 0x82, 0x34, 0x01, 0xDA, 0x81, 0xF5, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x81, 0xF6, 
  0xDA, 0x09, 0xCE, 0x80, 0xB8, 0x28, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x2F, 0x63, 0x6C, 0x6F, 
  0x73, 0x65, 0x20, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x29, 0x0A, 0x0A, 0x43, 0x6C, 0x6F, 0x73, 
  0x65, 0x20, 0x61, 0x20, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x2C, 0x20, 0x75, 0x6E, 0x62, 0x6C, 
  0x6F, 0x63, 0x6B, 0x69, 0x6E, 0x67, 0x20, 0x69, 0x74, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x65, 0x6E, 
  0x64, 0x69, 0x6E, 0x67, 0x20, 0x63, 0x6F, 0x6D, 0x6D, 0x75, 0x6E, 0x69, 0x63, 0x61, 0x74, 0x69, 
  0x6F, 0x6E, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x69, 0x74, 0x2E, 0x20, 0x4E, 0x6F, 0x74, 0x65, 
  0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 0x6C, 0x6F, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x20, 
  0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x20, 0x69, 0x73, 0x20, 0x69, 0x64, 0x65, 0x6D, 0x70, 0x6F, 
  0x74, 0x65, 0x6E, 0x74, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x64, 0x6F, 0x65, 0x73, 0x20, 0x6E, 0x6F, 
  0x74, 0x20, 0x63, 0x61, 0x6E, 0x63, 0x65, 0x6C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x68, 0x72, 
  0x65, 0x61, 0x64, 0x27, 0x73, 0x20, 0x6F, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 
  0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0xDA, 0x81, 0xF7, 
  0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x81, 0xF9, 0xDA, 0x09, 0xCE, 0x42, 0x28, 0x64, 0x72, 0x6F, 0x70, 
  0x2D, 0x75, 0x6E, 0x74, 0x69, 0x6C, 0x20, 0x70, 0x72, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x64, 0x29, 
  0x0A, 0x0A, 0x53, 0x61, 0x6D, 0x65, 0x20, 0x61, 0x73, 0x20, 0x28, 0x64, 0x72, 0x6F, 0x70, 0x2D, 
  0x77, 0x68, 0x69, 0x6C, 0x65, 0x20, 0x28, 0x63, 0x6F, 0x6D, 0x70, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 
  0x74, 0x20, 0x70, 0x72, 0x65, 0x64, 0x29, 0x20, 0x69, 0x6E, 0x64, 0x29, 0x2E, 0xDA, 0x0B, 0xD2, 
  0x03, 0x00, 0xDA, 0x05, 0x83, 0xD0, 0x01, 0xDA, 0x81, 0xFA, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x81, 
  0xFB, 0xDA, 0x09, 0xCE, 0x80, 0xF5, 0x28, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2F, 0x6E, 0x65, 0x77, 
  0x20, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 
  0x74, 0x65, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x65, 0x6D, 0x70, 0x74, 0x79, 0x20, 
  0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x70, 0x72, 0x65, 0x2D, 0x61, 
  0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x64, 0x20, 0x6D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x20, 
  0x66, 0x6F, 0x72, 0x20, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x20, 0x65, 0x6E, 0x74, 
  0x72, 0x69, 0x65, 0x73, 0x2E, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x6D, 0x65, 0x61, 0x6E, 0x73, 
  0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x66, 0x20, 0x6F, 0x6E, 0x65, 0x20, 0x6B, 0x6E, 0x6F, 
  0x77, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 
  0x20, 0x65, 0x6E, 0x74, 0x72, 0x69, 0x65, 0x73, 0x20, 0x67, 0x6F, 0x69, 0x6E, 0x67, 0x20, 0x74, 
  0x6F, 0x20, 0x67, 0x6F, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 
  0x6F, 0x6E, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x2C, 0x20, 0x65, 0x78, 0x74, 
  0x72, 0x61, 0x20, 0x6D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 
  0x74, 0x69, 0x6F, 0x6E, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x61, 0x76, 0x6F, 0x69, 
  0x64, 0x65, 0x64, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x6E, 0x65, 0x77, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0xDA, 0x81, 0xFC, 0xD3, 0x04, 
  0xDA, 0x03, 0xDA, 0x81, 0xFF, 0xDA, 0x09, 0xCE, 0x80, 0xD4, 0x28, 0x70, 0x72, 0x6F, 0x74, 0x65, 
  0x63, 0x74, 0x20, 0x26, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x29, 0x0A, 0x0A, 0x45, 0x76, 0x61, 0x6C, 
  0x75, 0x61, 0x74, 0x65, 0x20, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x73, 
  0x2C, 0x20, 0x77, 0x68, 0x69, 0x6C, 0x65, 0x20, 0x63, 0x61, 0x70, 0x74, 0x75, 0x72, 0x69, 0x6E, 
  0x67, 0x20, 0x61, 0x6E, 0x79, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x73, 0x2E, 0x20, 0x45, 0x76, 
  0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x74, 0x75, 0x70, 
  0x6C, 0x65, 0x20, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x77, 0x6F, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 
  0x6E, 0x74, 0x73, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x65, 
  0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x69, 0x73, 0x20, 0x74, 0x72, 0x75, 0x65, 0x20, 0x69, 
  0x66, 0x20, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x66, 0x75, 0x6C, 0x2C, 0x20, 0x66, 0x61, 
  0x6C, 0x73, 0x65, 0x20, 0x69, 0x66, 0x20, 0x61, 0x6E, 0x20, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 
  0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x63, 0x6F, 0x6E, 0x64, 
  0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x76, 
  0x61, 0x6C, 0x75, 0x65, 0x20, 0x6F, 0x72, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x2E, 0xDA, 0x0B, 
  0xD2, 0x03, 0x00, 0xDA, 0x05, 0x80, 0xF1, 0x01, 0xDA, 0x35, 0xCB, 0xDA, 0x82, 0x00, 0xD3, 0x03, 
  0xDA, 0x03, 0xDA, 0x41, 0xDA, 0x09, 0xCE, 0x80, 0x88, 0x41, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 
  0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x20, 0x63, 0x6F, 0x6D, 0x62, 0x69, 0x6E, 0x61, 
  0x74, 0x69, 0x6F, 0x6E, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x6D, 0x61, 0x72, 0x73, 0x68, 0x61, 
  0x6C, 0x20, 0x74, 0x6F, 0x20, 0x6D, 0x61, 0x72, 0x73, 0x68, 0x61, 0x6C, 0x20, 0x63, 0x6F, 0x64, 
  0x65, 0x20, 0x28, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x73, 0x29, 0x2C, 0x20, 0x73, 0x75, 0x63, 0x68, 
  0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x20, 0x28, 0x6D, 0x61, 0x6B, 0x65, 0x2D, 0x69, 0x6D, 0x61, 
  0x67, 0x65, 0x20, 0x78, 0x29, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6D, 
  0x65, 0x20, 0x61, 0x73, 0x20, 0x28, 0x6D, 0x61, 0x72, 0x73, 0x68, 0x61, 0x6C, 0x20, 0x78, 0x20, 
  0x6D, 0x61, 0x6B, 0x65, 0x2D, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x2D, 0x64, 0x69, 0x63, 0x74, 0x29, 
  0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x88, 0x76, 0x01, 0xDA, 0x82, 0x01, 0xD3, 0x03, 
  0xDA, 0x03, 0xDA, 0x82, 0x04, 0xDA, 0x09, 0xCE, 0x6E, 0x28, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x66, 
  0x20, 0x66, 0x6D, 0x74, 0x20, 0x26, 0x20, 0x61, 0x72, 0x67, 0x73, 0x29, 0x0A, 0x0A, 0x41, 0x20, 
  0x63, 0x6F, 0x6D, 0x62, 0x69, 0x6E, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x6F, 0x66, 0x20, 0x65, 
  0x72, 0x72, 0x6F, 0x72, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 
  0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x2E, 0x20, 0x45, 0x71, 0x75, 0x69, 0x76, 0x61, 0x6C, 0x65, 
  0x6E, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x28, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x28, 0x73, 0x74, 
  0x72, 0x69, 0x6E, 0x67, 0x2F, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x20, 0x66, 0x6D, 0x74, 0x20, 
  0x3B, 0x61, 0x72, 0x67, 0x73, 0x29, 0x29, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x80, 0x90, 
  0x01, 0xDA, 0x82, 0x05, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x82, 0x06, 0xDA, 0x09, 0xCE, 0x81, 0x1C, 
  0x28, 0x66, 0x69, 0x6C, 0x65, 0x2F, 0x70, 0x6F, 0x70, 0x65, 0x6E, 0x20, 0x70, 0x61, 0x74, 0x68, 
  0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x6D, 0x6F, 0x64, 0x65, 0x29, 0x0A, 0x0A, 0x4F, 0x70, 0x65, 
  0x6E, 0x20, 0x61, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x73, 
  0x20, 0x62, 0x61, 0x63, 0x6B, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x61, 0x20, 0x70, 0x72, 0x6F, 
  0x63, 0x65, 0x73, 0x73, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x6D, 
  0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x6F, 0x70, 0x65, 0x6E, 0x65, 0x64, 0x20, 0x69, 0x6E, 
  0x20, 0x65, 0x69, 0x74, 0x68, 0x65, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x3A, 0x72, 0x20, 0x28, 
  0x72, 0x65, 0x61, 0x64, 0x29, 0x20, 0x6F, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x3A, 0x77, 0x20, 
  0x28, 0x77, 0x72, 0x69, 0x74, 0x65, 0x29, 0x20, 0x6D, 0x6F, 0x64, 0x65, 0x2E, 0x20, 0x49, 0x6E, 
  0x20, 0x3A, 0x72, 0x20, 0x6D, 0x6F, 0x64, 0x65, 0x2C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 
  0x64, 0x6F, 0x75, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x63, 
  0x65, 0x73, 0x73, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x72, 0x65, 0x61, 0x64, 0x20, 
  0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x2E, 0x20, 0x49, 
  0x6E, 0x20, 0x3A, 0x77, 0x20, 0x6D, 0x6F, 0x64, 0x65, 0x2C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 
  0x74, 0x64, 0x69, 0x6E, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x63, 
  0x65, 0x73, 0x73, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x77, 0x72, 0x69, 0x74, 0x74, 
  0x65, 0x6E, 0x20, 0x74, 0x6F, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x2E, 0xDA, 0x82, 0x07, 0xD3, 
  0x03, 0xDA, 0x03, 0xDA, 0x80, 0xC3, 0xDA, 0x09, 0xCE, 0x80, 0x89, 0x28, 0x66, 0x69, 0x6C, 0x74, 
  0x65, 0x72, 0x20, 0x70, 0x72, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x47, 0x69, 
  0x76, 0x65, 0x6E, 0x20, 0x61, 0x20, 0x70, 0x72, 0x65, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x2C, 
  0x20, 0x74, 0x61, 0x6B, 0x65, 0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 
  0x6E, 0x74, 0x73, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 
  0x79, 0x20, 0x6F, 0x72, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x20, 
  0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x28, 0x70, 0x72, 0x65, 0x64, 0x20, 0x65, 0x6C, 0x65, 0x6D, 
  0x65, 0x6E, 0x74, 0x29, 0x20, 0x69, 0x73, 0x20, 0x74, 0x72, 0x75, 0x74, 0x68, 0x79, 0x2E, 0x20, 
  0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x61, 0x72, 
  0x72, 0x61, 0x79, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x83, 0x61, 0x01, 0xDA, 0x82, 
  0x08, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x82, 0x0C, 0xDA, 0x09, 0xCE, 0x31, 0x28, 0x70, 0x61, 0x72, 
  0x74, 0x69, 0x61, 0x6C, 0x20, 0x66, 0x20, 0x26, 0x20, 0x6D, 0x6F, 0x72, 0x65, 0x29, 0x0A, 0x0A, 
  0x50, 0x61, 0x72, 0x74, 0x69, 0x61, 0x6C, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 
  0x20, 0x61, 0x70, 0x70, 0x6C, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0xDA, 0x0B, 0xD2, 
  0x03, 0x00, 0xDA, 0x05, 0x84, 0x99, 0x01, 0xDA, 0x82, 0x0D, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x82, 
  0x0F, 0xDA, 0x09, 0xCE, 0x23, 0x28, 0x6F, 0x6E, 0x65, 0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 
  0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 0x65, 0x71, 0x75, 
  0x61, 0x6C, 0x20, 0x74, 0x6F, 0x20, 0x31, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x57, 
  0x01, 0xDA, 0x82, 0x10, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 0x82, 0x3E, 0xDA, 0x09, 0xCE, 0x80, 0xFF, 
  0x28, 0x73, 0x68, 0x6F, 0x72, 0x74, 0x2D, 0x66, 0x6E, 0x20, 0x61, 0x72, 0x67, 0x29, 0x0A, 0x0A, 
  0x66, 0x6E, 0x20, 0x73, 0x68, 0x6F, 0x72, 0x74, 0x68, 0x61, 0x6E, 0x64, 0x2E, 0x0A, 0x0A, 0x20, 
  0x20, 0x75, 0x73, 0x61, 0x67, 0x65, 0x3A, 0x0A, 0x0A, 0x20, 0x20, 0x09, 0x28, 0x73, 0x68, 0x6F, 
  0x72, 0x74, 0x2D, 0x66, 0x6E, 0x20, 0x28, 0x2B, 0x20, 0x24, 0x20, 0x24, 0x29, 0x29, 0x20, 0x2D, 
  0x20, 0x41, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x61, 0x74, 
  0x20, 0x64, 0x6F, 0x75, 0x62, 0x6C, 0x65, 0x27, 0x73, 0x20, 0x69, 0x74, 0x73, 0x20, 0x61, 0x72, 
  0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x2E, 0x0A, 0x20, 0x20, 0x09, 0x28, 0x73, 0x68, 0x6F, 
  0x72, 0x74, 0x2D, 0x66, 0x6E, 0x20, 0x28, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x24, 0x30, 
  0x20, 0x24, 0x31, 0x29, 0x29, 0x20, 0x2D, 0x20, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x69, 0x6E, 
  0x67, 0x20, 0x6D, 0x75, 0x6C, 0x74, 0x69, 0x70, 0x6C, 0x65, 0x20, 0x61, 0x72, 0x67, 0x73, 0x0A, 
  0x20, 0x20, 0x09, 0x7C, 0x28, 0x2B, 0x20, 0x24, 0x20, 0x24, 0x29, 0x20, 0x2D, 0x20, 0x75, 0x73, 
  0x65, 0x20, 0x70, 0x69, 0x70, 0x65, 0x20, 0x72, 0x65, 0x61, 0x64, 0x65, 0x72, 0x20, 0x6D, 0x61, 
  0x63, 0x72, 0x6F, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x74, 0x65, 0x72, 0x73, 0x65, 0x20, 0x66, 0x75, 
  0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x6C, 0x69, 0x74, 0x65, 0x72, 0x61, 0x6C, 0x73, 0x0A, 
  0x20, 0x20, 0x09, 0x7C, 0x28, 0x2B, 0x20, 0x24, 0x26, 0x29, 0x20, 0x2D, 0x20, 0x76, 0x61, 0x72, 
  0x69, 0x61, 0x64, 0x69, 0x63, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0xDA, 
  0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x87, 0x62, 0x01, 0xDA, 0x35, 0xCB, 0xDA, 0x82, 0x3F, 0xD3, 
  0x02, 0xDA, 0x03, 0xDA, 0x81, 0x08, 0xDA, 0x09, 0xCE, 0x81, 0x11, 0x28, 0x66, 0x69, 0x6C, 0x65, 
  0x2F, 0x63, 0x6C, 0x6F, 0x73, 0x65, 0x20, 0x66, 0x29, 0x0A, 0x0A, 0x43, 0x6C, 0x6F, 0x73, 0x65, 
  0x20, 0x61, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x72, 0x65, 0x6C, 0x65, 
  0x61, 0x73, 0x65, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x72, 0x65, 0x6C, 0x61, 0x74, 0x65, 0x64, 0x20, 
  0x72, 0x65, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x73, 0x2E, 0x20, 0x57, 0x68, 0x65, 0x6E, 0x20, 
  0x79, 0x6F, 0x75, 0x20, 0x61, 0x72, 0x65, 0x20, 0x64, 0x6F, 0x6E, 0x65, 0x20, 0x72, 0x65, 0x61, 
  0x64, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x2C, 0x20, 0x63, 0x6C, 0x6F, 
  0x73, 0x65, 0x20, 0x69, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x70, 0x72, 0x65, 0x76, 0x65, 0x6E, 0x74, 
  0x20, 0x61, 0x20, 0x72, 0x65, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x20, 0x6C, 0x65, 0x61, 0x6B, 
  0x20, 0x61, 0x6E, 0x64, 0x20, 0x6C, 0x65, 0x74, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x20, 0x70, 
  0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x65, 0x73, 0x20, 0x72, 0x65, 0x61, 0x64, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 
  0x69, 0x6C, 0x65, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6C, 
  0x74, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x2F, 0x70, 0x6F, 0x70, 0x65, 
  0x6E, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x2C, 0x20, 0x63, 0x6C, 0x6F, 0x73, 0x65, 0x20, 0x77, 0x61, 
  0x69, 0x74, 0x73, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x72, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x20, 
  0x65, 0x78, 0x69, 0x74, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x2E, 0xDA, 0x82, 0x40, 0xD3, 
  0x02, 0xDA, 0x03, 0xDA, 0x82, 0x41, 0xDA, 0x09, 0xCE, 0x81, 0x6E, 0x28, 0x6D, 0x61, 0x72, 0x73, 
  0x68, 0x61, 0x6C, 0x20, 0x78, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x72, 0x65, 0x76, 0x65, 0x72, 
  0x73, 0x65, 0x2D, 0x6C, 0x6F, 0x6F, 0x6B, 0x75, 0x70, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 
  0x29, 0x0A, 0x0A, 0x4D, 0x61, 0x72, 0x73, 0x68, 0x61, 0x6C, 0x20, 0x61, 0x20, 0x76, 0x61, 0x6C, 
  0x75, 0x65, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 
  0x20, 0x61, 0x6E, 0x64, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x62, 0x75, 0x66, 0x66, 
  0x65, 0x72, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x61, 0x74, 0x65, 0x72, 
  0x20, 0x62, 0x65, 0x20, 0x75, 0x6E, 0x6D, 0x61, 0x72, 0x73, 0x68, 0x61, 0x6C, 0x6C, 0x65, 0x64, 
  0x20, 0x74, 0x6F, 0x20, 0x72, 0x65, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x69, 0x6E, 0x69, 0x74, 0x69, 0x61, 0x6C, 0x20, 0x76, 0x61, 0x6C, 0x75, 
  0x65, 0x2E, 0x20, 0x4F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x6C, 0x79, 0x2C, 0x20, 0x6F, 
  0x6E, 0x65, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x70, 0x61, 0x73, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x61, 
  0x20, 0x72, 0x65, 0x76, 0x65, 0x72, 0x73, 0x65, 0x20, 0x6C, 0x6F, 0x6F, 0x6B, 0x75, 0x70, 0x20, 
  0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x6D, 0x61, 0x72, 
  0x73, 0x68, 0x61, 0x6C, 0x20, 0x61, 0x6C, 0x69, 0x61, 0x73, 0x65, 0x64, 0x20, 0x76, 0x61, 0x6C, 
  0x75, 0x65, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x61, 0x72, 0x65, 0x20, 0x66, 0x6F, 0x75, 
  0x6E, 0x64, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2E, 
  0x20, 0x54, 0x68, 0x65, 0x6E, 0x20, 0x61, 0x20, 0x66, 0x6F, 0x72, 0x77, 0x61, 0x72, 0x64, 0x6C, 
  0x6F, 0x6F, 0x6B, 0x75, 0x70, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x63, 0x61, 0x6E, 0x20, 
  0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x72, 0x65, 0x63, 0x6F, 0x76, 
  0x65, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6F, 0x72, 0x69, 0x67, 0x69, 0x6E, 0x61, 0x6C, 0x20, 
  0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x77, 0x68, 0x65, 0x6E, 0x20, 0x75, 0x6E, 0x6D, 0x61, 0x72, 
  0x73, 0x68, 0x61, 0x6C, 0x6C, 0x69, 0x6E, 0x67, 0x2E, 0xDA, 0x82, 0x42, 0xD3, 0x02, 0xDA, 0x03, 
  0xDA, 0x80, 0xF5, 0xDA, 0x09, 0xCE, 0x80, 0xA0, 0x28, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 
  0x70, 0x72, 0x6F, 0x64, 0x75, 0x63, 0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x29, 0x0A, 
  0x0A, 0x44, 0x65, 0x71, 0x75, 0x65, 0x75, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x78, 
  0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 
  0x61, 0x72, 0x73, 0x65, 0x20, 0x71, 0x75, 0x65, 0x75, 0x65, 0x2E, 0x20, 0x57, 0x69, 0x6C, 0x6C, 
  0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x6E, 0x69, 0x6C, 0x20, 0x69, 0x66, 0x20, 0x6E, 
  0x6F, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x64, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 
  0x61, 0x72, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x71, 0x75, 0x65, 0x75, 0x65, 
  0x2C, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x20, 0x77, 0x69, 0x6C, 0x6C, 
  0x20, 0x64, 0x65, 0x71, 0x75, 0x65, 0x75, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x78, 
  0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2E, 0xDA, 0x82, 0x43, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 
  0x82, 0x44, 0xDA, 0x09, 0xCE, 0x34, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x65, 0x78, 0x70, 0x6D, 
  0x31, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x65, 0x20, 
  0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x6F, 0x77, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 
  0x78, 0x20, 0x6D, 0x69, 0x6E, 0x75, 0x73, 0x20, 0x31, 0x2E, 0xDA, 0x82, 0x45, 0xD3, 0x02, 0xDA, 
  0x03, 0xDA, 0x6D, 0xDA, 0x09, 0xCE, 0x80, 0x82, 0x28, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 
  0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x66, 0x6F, 
  0x72, 0x6D, 0x61, 0x74, 0x20, 0x26, 0x20, 0x61, 0x72, 0x67, 0x73, 0x29, 0x0A, 0x0A, 0x53, 0x6E, 
  0x70, 0x72, 0x69, 0x6E, 0x74, 0x66, 0x20, 0x6C, 0x69, 0x6B, 0x65, 0x20, 0x66, 0x75, 0x6E, 0x63, 
  0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x69, 0x74, 0x79, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x70, 0x72, 
  0x69, 0x6E, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x69, 0x6E, 
  0x74, 0x6F, 0x20, 0x61, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0x20, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 
  0x65, 0x64, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0xDA, 0x82, 0x46, 0xD3, 0x02, 0xDA, 
  0x03, 0xDA, 0x80, 0xB7, 0xDA, 0x09, 0xCE, 0x82, 0x3D, 0x28, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 
  0x2F, 0x65, 0x78, 0x70, 0x61, 0x6E, 0x64, 0x2D, 0x70, 0x61, 0x74, 0x68, 0x20, 0x70, 0x61, 0x74, 
  0x68, 0x20, 0x74, 0x65, 0x6D, 0x70, 0x6C, 0x61, 0x74, 0x65, 0x29, 0x0A, 0x0A, 0x45, 0x78, 0x70, 
  0x61, 0x6E, 0x64, 0x73, 0x20, 0x61, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x74, 0x65, 0x6D, 0x70, 
  0x6C, 0x61, 0x74, 0x65, 0x20, 0x61, 0x73, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x20, 0x69, 0x6E, 
  0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2F, 0x70, 0x61, 0x74, 0x68, 0x73, 0x20, 0x66, 0x6F, 
  0x72, 0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2F, 0x66, 0x69, 0x6E, 0x64, 0x2E, 0x20, 0x54, 
  0x68, 0x69, 0x73, 0x20, 0x74, 0x61, 0x6B, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x70, 
  0x61, 0x74, 0x68, 0x20, 0x28, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 
  0x74, 0x20, 0x74, 0x6F, 0x20, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x29, 0x20, 0x61, 0x6E, 
  0x64, 0x20, 0x61, 0x20, 0x74, 0x65, 0x6D, 0x70, 0x6C, 0x61, 0x74, 0x65, 0x20, 0x73, 0x74, 0x72, 
  0x69, 0x6E, 0x67, 0x2C, 0x20, 0x74, 0x65, 0x6D, 0x70, 0x6C, 0x61, 0x74, 0x65, 0x2C, 0x20, 0x74, 
  0x6F, 0x20, 0x65, 0x78, 0x70, 0x61, 0x6E, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x74, 
  0x68, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x74, 0x68, 0x61, 0x74, 
  0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x66, 0x6F, 0x72, 
  0x20, 0x69, 0x6D, 0x70, 0x6F, 0x72, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x73, 
  0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x72, 0x65, 0x70, 0x6C, 0x61, 0x63, 0x65, 0x6D, 0x65, 0x6E, 
  0x74, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x61, 0x73, 0x20, 0x66, 0x6F, 0x6C, 0x6C, 0x6F, 0x77, 
  0x73, 0x3A, 0x0A, 0x0A, 0x09, 0x3A, 0x61, 0x6C, 0x6C, 0x3A, 0x09, 0x74, 0x68, 0x65, 0x20, 0x76, 
  0x61, 0x6C, 0x75, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x76, 0x65, 0x72, 
  0x62, 0x61, 0x74, 0x69, 0x6D, 0x0A, 0x09, 0x3A, 0x63, 0x75, 0x72, 0x3A, 0x09, 0x74, 0x68, 0x65, 
  0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x2C, 0x20, 0x6F, 
  0x72, 0x20, 0x28, 0x64, 0x79, 0x6E, 0x20, 0x3A, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x2D, 
  0x66, 0x69, 0x6C, 0x65, 0x29, 0x0A, 0x09, 0x3A, 0x64, 0x69, 0x72, 0x3A, 0x09, 0x74, 0x68, 0x65, 
  0x20, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x79, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x61, 
  0x69, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 
  0x74, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x0A, 0x09, 0x3A, 0x6E, 0x61, 0x6D, 0x65, 0x3A, 0x09, 0x74, 
  0x68, 0x65, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x6F, 0x6E, 0x65, 0x6E, 
  0x74, 0x20, 0x6F, 0x66, 0x20, 0x70, 0x61, 0x74, 0x68, 0x2C, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 
  0x65, 0x78, 0x74, 0x65, 0x6E, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x69, 0x66, 0x20, 0x67, 0x69, 0x76, 
  0x65, 0x6E, 0x0A, 0x09, 0x3A, 0x6E, 0x61, 0x74, 0x69, 0x76, 0x65, 0x3A, 0x09, 0x74, 0x68, 0x65, 
  0x20, 0x65, 0x78, 0x74, 0x65, 0x6E, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 
  0x74, 0x6F, 0x20, 0x6C, 0x6F, 0x61, 0x64, 0x20, 0x6E, 0x61, 0x74, 0x69, 0x76, 0x65, 0x73, 0x2C, 
  0x20, 0x2E, 0x73, 0x6F, 0x20, 0x6F, 0x72, 0x20, 0x2E, 0x64, 0x6C, 0x6C, 0x0A, 0x09, 0x3A, 0x73, 
  0x79, 0x73, 0x3A, 0x09, 0x74, 0x68, 0x65, 0x20, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x20, 0x70, 
  0x61, 0x74, 0x68, 0x2C, 0x20, 0x6F, 0x72, 0x20, 0x28, 0x64, 0x79, 0x6E, 0x20, 0x3A, 0x73, 0x79, 
  0x73, 0x70, 0x61, 0x74, 0x68, 0x29, 0xDA, 0x82, 0x47, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x80, 0x96, 
  0xDA, 0x09, 0xCE, 0x40, 0x28, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x68, 0x61, 0x73, 0x2D, 
  0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x3F, 0x20, 0x70, 0x66, 0x78, 0x20, 0x73, 0x74, 0x72, 0x29, 
  0x0A, 0x0A, 0x54, 0x65, 0x73, 0x74, 0x73, 0x20, 0x77, 0x68, 0x65, 0x74, 0x68, 0x65, 0x72, 0x20, 
  0x73, 0x74, 0x72, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x73, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 
  0x70, 0x66, 0x78, 0x2E, 0xDA, 0x82, 0x48, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x81, 0xB0, 0xDA, 0x09, 
  0xCE, 0x81, 0x69, 0x28, 0x6E, 0x65, 0x78, 0x74, 0x20, 0x64, 0x73, 0x20, 0x26, 0x6F, 0x70, 0x74, 
  0x20, 0x6B, 0x65, 0x79, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x6E, 0x65, 0x78, 0x74, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x64, 0x61, 
  0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x2E, 0x20, 0x43, 0x61, 
  0x6E, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x69, 0x74, 0x65, 
  0x72, 0x61, 0x74, 0x65, 0x20, 0x74, 0x68, 0x72, 0x6F, 0x75, 0x67, 0x68, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x6B, 0x65, 0x79, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 
  0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x6E, 0x20, 
  0x75, 0x6E, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x6F, 0x72, 0x64, 0x65, 
  0x72, 0x2E, 0x20, 0x4B, 0x65, 0x79, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x67, 0x75, 0x61, 0x72, 
  0x61, 0x6E, 0x74, 0x65, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x62, 0x65, 0x20, 0x73, 0x65, 0x65, 
  0x6E, 0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x20, 0x6F, 0x6E, 0x63, 0x65, 0x20, 0x70, 0x65, 0x72, 0x20, 
  0x69, 0x74, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 
  0x79, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 
  0x20, 0x69, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x6D, 0x75, 0x74, 0x61, 0x74, 0x65, 0x64, 0x20, 
  0x64, 0x75, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x69, 0x74, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 
  0x2E, 0x20, 0x49, 0x66, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x2C, 
  0x20, 0x6E, 0x65, 0x78, 0x74, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x6B, 0x65, 0x79, 0x2E, 0x20, 0x49, 0x66, 0x20, 
  0x6E, 0x65, 0x78, 0x74, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 
  0x2C, 0x20, 0x74, 0x68, 0x65, 0x72, 0x65, 0x20, 0x61, 0x72, 0x65, 0x20, 0x6E, 0x6F, 0x20, 0x6D, 
  0x6F, 0x72, 0x65, 0x20, 0x6B, 0x65, 0x79, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x69, 0x74, 0x65, 0x72, 
  0x61, 0x74, 0x65, 0x20, 0x74, 0x68, 0x72, 0x6F, 0x75, 0x67, 0x68, 0x2E, 0xDA, 0x82, 0x49, 0xD3, 
  0x04, 0xDA, 0x03, 0xDA, 0x82, 0x4B, 0xDA, 0x09, 0xCE, 0x80, 0x9A, 0x28, 0x65, 0x64, 0x65, 0x66, 
  0x65, 0x72, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x20, 0x26, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x29, 0x0A, 
  0x0A, 0x52, 0x75, 0x6E, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x20, 0x61, 0x66, 0x74, 0x65, 0x72, 0x20, 
  0x62, 0x6F, 0x64, 0x79, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x61, 0x73, 0x65, 
  0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x20, 0x74, 0x65, 0x72, 0x6D, 0x69, 
  0x6E, 0x61, 0x74, 0x65, 0x73, 0x20, 0x61, 0x62, 0x6E, 0x6F, 0x72, 0x6D, 0x61, 0x6C, 0x6C, 0x79, 
  0x20, 0x28, 0x61, 0x6E, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x6F, 0x72, 0x20, 0x75, 0x73, 
  0x65, 0x72, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0x20, 0x30, 0x2D, 0x34, 0x29, 0x2E, 0x20, 
  0x20, 0x4F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x20, 0x6C, 0x61, 0x73, 0x74, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x20, 0x69, 0x6E, 0x20, 
  0x62, 0x6F, 0x64, 0x79, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x81, 0x37, 0x01, 0xDA, 
  0x35, 0xCB, 0xDA, 0x82, 0x4C, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 0x82, 0x4E, 0xDA, 0x09, 0xCE, 0x80, 
  0xCE, 0x28, 0x69, 0x66, 0x2D, 0x77, 0x69, 0x74, 0x68, 0x20, 0x5B, 0x62, 0x69, 0x6E, 0x64, 0x69, 
  0x6E, 0x67, 0x20, 0x63, 0x74, 0x6F, 0x72, 0x20, 0x64, 0x74, 0x6F, 0x72, 0x5D, 0x20, 0x74, 0x72, 
  0x75, 0x74, 0x68, 0x79, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x66, 0x61, 0x6C, 0x73, 0x65, 0x79, 
  0x29, 0x0A, 0x0A, 0x53, 0x69, 0x6D, 0x69, 0x6C, 0x61, 0x72, 0x20, 0x74, 0x6F, 0x20, 0x77, 0x69, 
  0x74, 0x68, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x69, 0x66, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 
  0x6E, 0x67, 0x20, 0x69, 0x73, 0x20, 0x66, 0x61, 0x6C, 0x73, 0x65, 0x20, 0x6F, 0x72, 0x20, 0x6E, 
  0x69, 0x6C, 0x2C, 0x20, 0x65, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0x73, 0x20, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x66, 0x61, 0x6C, 0x73, 0x65, 0x79, 0x20, 0x70, 0x61, 0x74, 0x68, 0x2E, 0x20, 
  0x4F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x2C, 0x20, 0x65, 0x76, 0x61, 0x6C, 0x75, 
  0x61, 0x74, 0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x72, 0x75, 0x74, 0x68, 0x79, 0x20, 
  0x70, 0x61, 0x74, 0x68, 0x2E, 0x20, 0x49, 0x6E, 0x20, 0x62, 0x6F, 0x74, 0x68, 0x20, 0x63, 0x61, 
  0x73, 0x65, 0x73, 0x2C, 0x20, 0x20, 0x63, 0x74, 0x6F, 0x72, 0x20, 0x69, 0x73, 0x20, 0x62, 0x6F, 
  0x75, 0x6E, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x2E, 0xDA, 
  0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x81, 0x75, 0x01, 0xDA, 0x35, 0xCB, 0xDA, 0x82, 0x4F, 0xD3, 
  0x03, 0xDA, 0x03, 0xDA, 0x82, 0x51, 0xDA, 0x09, 0xCE, 0x1B, 0x28, 0x6E, 0x61, 0x6E, 0x3F, 0x20, 
  0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 
  0x73, 0x20, 0x4E, 0x61, 0x4E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x51, 0x01, 0xDA, 0x82, 
  0x52, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x80, 0xEF, 0xDA, 0x09, 0xCE, 0x80, 0xA3, 0x28, 0x62, 0x75, 
  0x66, 0x66, 0x65, 0x72, 0x2F, 0x63, 0x6C, 0x65, 0x61, 0x72, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 
  0x72, 0x29, 0x0A, 0x0A, 0x53, 0x65, 0x74, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x69, 0x7A, 
  0x65, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x74, 0x6F, 
  0x20, 0x30, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x65, 0x6D, 0x70, 0x74, 0x69, 0x65, 0x73, 0x20, 0x69, 
  0x74, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x72, 0x65, 
  0x74, 0x61, 0x69, 0x6E, 0x73, 0x20, 0x69, 0x74, 0x73, 0x20, 0x6D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 
  0x20, 0x73, 0x6F, 0x20, 0x69, 0x74, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x65, 0x66, 
  0x66, 0x69, 0x63, 0x69, 0x65, 0x6E, 0x74, 0x6C, 0x79, 0x20, 0x72, 0x65, 0x66, 0x69, 0x6C, 0x6C, 
  0x65, 0x64, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 
  0xDA, 0x82, 0x53, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x82, 0x55, 0xDA, 0x09, 0xCE, 0x4F, 0x28, 0x2A, 
  0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x64, 0x75, 0x63, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x61, 
  0x6C, 0x6C, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x78, 
  0x73, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x78, 0x73, 0x20, 0x69, 0x73, 0x20, 0x65, 0x6D, 0x70, 0x74, 
  0x79, 0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x31, 0x2E, 0xDA, 0x82, 0x56, 
  0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x82, 0x58, 0xDA, 0x09, 0xCE, 0x81, 0x30, 0x28, 0x67, 0x65, 0x74, 
  0x20, 0x64, 0x73, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x64, 0x66, 0x6C, 
  0x74, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 
  0x65, 0x20, 0x6D, 0x61, 0x70, 0x70, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x6B, 0x65, 0x79, 0x20, 
  0x69, 0x6E, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 
  0x65, 0x20, 0x64, 0x73, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 
  0x20, 0x64, 0x66, 0x6C, 0x74, 0x20, 0x6F, 0x72, 0x20, 0x6E, 0x69, 0x6C, 0x20, 0x69, 0x66, 0x20, 
  0x6E, 0x6F, 0x74, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x2E, 0x20, 0x53, 0x69, 0x6D, 0x69, 0x6C, 
  0x61, 0x72, 0x20, 0x74, 0x6F, 0x20, 0x69, 0x6E, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x77, 0x69, 
  0x6C, 0x6C, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x74, 0x68, 0x72, 0x6F, 0x77, 0x20, 0x61, 0x6E, 0x20, 
  0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6B, 0x65, 0x79, 
  0x20, 0x69, 0x73, 0x20, 0x69, 0x6E, 0x76, 0x61, 0x6C, 0x69, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 
  0x72, 0x65, 0x20, 0x75, 0x6E, 0x6C, 0x65, 0x73, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x61, 
  0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x20, 0x69, 0x73, 0x20, 
  0x61, 0x6E, 0x20, 0x61, 0x62, 0x73, 0x74, 0x72, 0x61, 0x63, 0x74, 0x20, 0x74, 0x79, 0x70, 0x65, 
  0x2E, 0x20, 0x49, 0x6E, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 0x61, 0x73, 0x65, 0x2C, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x61, 0x62, 0x73, 0x74, 0x72, 0x61, 0x63, 0x74, 0x20, 0x74, 0x79, 0x70, 
  0x65, 0x20, 0x67, 0x65, 0x74, 0x74, 0x65, 0x72, 0x20, 0x6D, 0x61, 0x79, 0x20, 0x74, 0x68, 0x72, 
  0x6F, 0x77, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x2E, 0xDA, 0x82, 0x59, 0xD3, 
  0x03, 0xDA, 0x03, 0xDA, 0x82, 0x5E, 0xDA, 0x09, 0xCE, 0x81, 0x4D, 0x28, 0x63, 0x6F, 0x6D, 0x70, 
  0x61, 0x72, 0x65, 0x20, 0x78, 0x20, 0x79, 0x29, 0x0A, 0x0A, 0x50, 0x6F, 0x6C, 0x79, 0x6D, 0x6F, 
  0x72, 0x70, 0x68, 0x69, 0x63, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0x2E, 0x20, 0x20, 
  0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x2D, 0x31, 0x2C, 0x30, 0x2C, 0x31, 0x20, 0x66, 
  0x6F, 0x72, 0x20, 0x78, 0x20, 0x3C, 0x20, 0x79, 0x2C, 0x20, 0x78, 0x20, 0x3D, 0x20, 0x79, 0x2C, 
  0x20, 0x78, 0x20, 0x3E, 0x20, 0x79, 0x20, 0x72, 0x65, 0x73, 0x70, 0x65, 0x63, 0x74, 0x69, 0x76, 
  0x65, 0x6C, 0x79, 0x2E, 0x20, 0x20, 0x20, 0x44, 0x69, 0x66, 0x66, 0x65, 0x72, 0x73, 0x20, 0x66, 
  0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x69, 0x6D, 0x69, 0x74, 0x69, 0x76, 
  0x65, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x61, 0x74, 0x6F, 0x72, 0x73, 0x20, 0x69, 0x6E, 
  0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x74, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x63, 
  0x68, 0x65, 0x63, 0x6B, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x20, 0x20, 0x73, 0x65, 0x65, 0x20, 0x77, 
  0x68, 0x65, 0x74, 0x68, 0x65, 0x72, 0x20, 0x65, 0x69, 0x74, 0x68, 0x65, 0x72, 0x20, 0x78, 0x20, 
  0x6F, 0x72, 0x20, 0x79, 0x20, 0x69, 0x6D, 0x70, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x61, 
  0x20, 0x27, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0x27, 0x20, 0x6D, 0x65, 0x74, 0x68, 0x6F, 
  0x64, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x20, 0x20, 0x63, 0x6F, 
  0x6D, 0x70, 0x61, 0x72, 0x65, 0x20, 0x78, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x79, 0x2E, 0x20, 0x20, 
  0x49, 0x66, 0x20, 0x73, 0x6F, 0x20, 0x69, 0x74, 0x20, 0x75, 0x73, 0x65, 0x73, 0x20, 0x74, 0x68, 
  0x61, 0x74, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0x20, 0x6D, 0x65, 0x74, 0x68, 0x6F, 
  0x64, 0x2E, 0x20, 0x20, 0x49, 0x66, 0x20, 0x6E, 0x6F, 0x74, 0x2C, 0x20, 0x69, 0x74, 0x20, 0x20, 
  0x20, 0x64, 0x65, 0x6C, 0x65, 0x67, 0x61, 0x74, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x70, 0x72, 0x69, 0x6D, 0x69, 0x74, 0x69, 0x76, 0x65, 0x20, 0x63, 0x6F, 0x6D, 0x70, 
  0x61, 0x72, 0x61, 0x74, 0x6F, 0x72, 0x73, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x82, 
  0xAA, 0x01, 0xDA, 0x82, 0x5F, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x80, 0xE7, 0xDA, 0x09, 0xCE, 0x80, 
  0xFD, 0x28, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x70, 
  0x61, 0x72, 0x73, 0x65, 0x72, 0x29, 0x0A, 0x0A, 0x49, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 
  0x61, 0x72, 0x73, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x2C, 0x20, 0x72, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 
  0x20, 0x61, 0x73, 0x73, 0x6F, 0x63, 0x69, 0x61, 0x74, 0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 
  0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x2E, 0x20, 0x4F, 0x74, 0x68, 
  0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 
  0x6E, 0x69, 0x6C, 0x2E, 0x20, 0x41, 0x6C, 0x73, 0x6F, 0x20, 0x66, 0x6C, 0x75, 0x73, 0x68, 0x65, 
  0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x20, 0x73, 0x74, 0x61, 
  0x74, 0x65, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x20, 0x71, 0x75, 
  0x65, 0x75, 0x65, 0x2C, 0x20, 0x73, 0x6F, 0x20, 0x62, 0x65, 0x20, 0x73, 0x75, 0x72, 0x65, 0x20, 
  0x74, 0x6F, 0x20, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x20, 0x65, 0x76, 0x65, 0x72, 0x79, 0x74, 
  0x68, 0x69, 0x6E, 0x67, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x71, 0x75, 0x65, 0x75, 
  0x65, 0x20, 0x62, 0x65, 0x66, 0x6F, 0x72, 0x65, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x69, 0x6E, 0x67, 
  0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x2E, 0xDA, 0x82, 
  0x60, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x82, 0x61, 0xDA, 0x09, 0xCE, 0x81, 0xEA, 0x28, 0x6F, 0x73, 
  0x2F, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x20, 0x61, 0x72, 0x67, 0x73, 0x20, 0x26, 0x6F, 
  0x70, 0x74, 0x73, 0x20, 0x66, 0x6C, 0x61, 0x67, 0x73, 0x20, 0x65, 0x6E, 0x76, 0x29, 0x0A, 0x0A, 
  0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x20, 0x61, 0x20, 0x70, 0x72, 0x6F, 0x67, 0x72, 0x61, 
  0x6D, 0x20, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x20, 
  0x61, 0x6E, 0x64, 0x20, 0x70, 0x61, 0x73, 0x73, 0x20, 0x69, 0x74, 0x20, 0x73, 0x74, 0x72, 0x69, 
  0x6E, 0x67, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x2E, 0x20, 0x46, 0x6C, 
  0x61, 0x67, 0x73, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 
  0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x73, 0x20, 0x68, 
  0x6F, 0x77, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x20, 0x77, 
  0x69, 0x6C, 0x6C, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x2E, 0x0A, 0x0A, 0x09, 0x3A, 
  0x65, 0x20, 0x2D, 0x20, 0x65, 0x6E, 0x61, 0x62, 0x6C, 0x65, 0x73, 0x20, 0x70, 0x61, 0x73, 0x73, 
  0x69, 0x6E, 0x67, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 
  0x6E, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x67, 0x72, 0x61, 
  0x6D, 0x2E, 0x20, 0x57, 0x69, 0x74, 0x68, 0x6F, 0x75, 0x74, 0x20, 0x3A, 0x65, 0x2C, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 
  0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x69, 0x73, 0x20, 0x69, 0x6E, 0x68, 0x65, 0x72, 0x69, 
  0x74, 0x65, 0x64, 0x2E, 0x0A, 0x09, 0x3A, 0x70, 0x20, 0x2D, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x77, 
  0x73, 0x20, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x50, 0x41, 0x54, 0x48, 0x20, 0x66, 0x6F, 0x72, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x69, 0x6E, 0x61, 0x72, 0x79, 0x20, 0x74, 0x6F, 0x20, 0x65, 
  0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x2E, 0x20, 0x57, 0x69, 0x74, 0x68, 0x6F, 0x75, 0x74, 0x20, 
  0x74, 0x68, 0x69, 0x73, 0x20, 0x66, 0x6C, 0x61, 0x67, 0x2C, 0x20, 0x62, 0x69, 0x6E, 0x61, 0x72, 
  0x69, 0x65, 0x73, 0x20, 0x6D, 0x75, 0x73, 0x74, 0x20, 0x75, 0x73, 0x65, 0x20, 0x61, 0x62, 0x73, 
  0x6F, 0x6C, 0x75, 0x74, 0x65, 0x20, 0x70, 0x61, 0x74, 0x68, 0x73, 0x2E, 0x0A, 0x0A, 0x65, 0x6E, 
  0x76, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x6F, 0x72, 0x20, 
  0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x20, 0x6D, 0x61, 0x70, 0x70, 0x69, 0x6E, 0x67, 0x20, 0x65, 
  0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x61, 0x72, 0x69, 0x61, 
  0x62, 0x6C, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x2E, 0x20, 
  0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x78, 0x69, 0x74, 
  0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 
  0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x2E, 0xDA, 0x82, 0x62, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x55, 
  0xDA, 0x09, 0xCE, 0x80, 0xA6, 0x28, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x6E, 0x65, 0x77, 0x20, 
  0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 
  0x65, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x65, 0x6D, 0x70, 0x74, 0x79, 0x20, 0x61, 
  0x72, 0x72, 0x61, 0x79, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61, 0x20, 0x70, 0x72, 0x65, 0x2D, 
  0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x64, 0x20, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 
  0x74, 0x79, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6D, 0x65, 0x20, 0x61, 0x73, 0x20, 
  0x28, 0x61, 0x72, 0x72, 0x61, 0x79, 0x29, 0x20, 0x62, 0x75, 0x74, 0x20, 0x63, 0x61, 0x6E, 0x20, 
  0x62, 0x65, 0x20, 0x6D, 0x6F, 0x72, 0x65, 0x20, 0x65, 0x66, 0x66, 0x69, 0x63, 0x69, 0x65, 0x6E, 
  0x74, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x61, 0x78, 0x69, 0x6D, 0x75, 0x6D, 
  0x20, 0x73, 0x69, 0x7A, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 
  0x79, 0x20, 0x69, 0x73, 0x20, 0x6B, 0x6E, 0x6F, 0x77, 0x6E, 0x2E, 0xDA, 0x82, 0x63, 0xD3, 0x02, 
  0xDA, 0x03, 0xDA, 0x82, 0x64, 0xDA, 0x09, 0xCE, 0x51, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x63, 
  0x65, 0x69, 0x6C, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x73, 0x6D, 0x61, 0x6C, 0x6C, 0x65, 0x73, 0x74, 0x20, 0x69, 0x6E, 0x74, 
  0x65, 0x67, 0x65, 0x72, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 
  0x72, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x6C, 0x65, 
  0x73, 0x73, 0x20, 0x74, 0x68, 0x61, 0x6E, 0x20, 0x78, 0x2E, 0xDA, 0x82, 0x65, 0xD3, 0x02, 0xDA, 
  0x03, 0xDA, 0x82, 0x66, 0xDA, 0x09, 0xCE, 0x80, 0x9C, 0x28, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 
  0x75, 0x6E, 0x62, 0x72, 0x65, 0x61, 0x6B, 0x20, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x20, 0x6C, 
  0x69, 0x6E, 0x65, 0x20, 0x63, 0x6F, 0x6C, 0x75, 0x6D, 0x6E, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x6D, 
  0x6F, 0x76, 0x65, 0x20, 0x61, 0x20, 0x62, 0x72, 0x65, 0x61, 0x6B, 0x70, 0x6F, 0x69, 0x6E, 0x74, 
  0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61, 0x20, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x20, 0x6B, 
  0x65, 0x79, 0x20, 0x61, 0x74, 0x20, 0x61, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x6C, 0x69, 
  0x6E, 0x65, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x63, 0x6F, 0x6C, 0x75, 0x6D, 0x6E, 0x2E, 0x20, 0x57, 
  0x69, 0x6C, 0x6C, 0x20, 0x74, 0x68, 0x72, 0x6F, 0x77, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x72, 0x72, 
  0x6F, 0x72, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x72, 0x65, 0x61, 0x6B, 0x70, 
  0x6F, 0x69, 0x6E, 0x74, 0x20, 0x63, 0x61, 0x6E, 0x6E, 0x6F, 0x74, 0x20, 0x62, 0x65, 0x20, 0x66, 
  0x6F, 0x75, 0x6E, 0x64, 0x2E, 0xDA, 0x82, 0x67, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 0x82, 0x69, 0xDA, 
  0x09, 0xCE, 0x80, 0x86, 0x28, 0x61, 0x6E, 0x64, 0x20, 0x26, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x73, 
  0x29, 0x0A, 0x0A, 0x45, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x6C, 0x61, 0x73, 0x74, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 
  0x74, 0x20, 0x69, 0x66, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x70, 0x72, 0x65, 0x63, 0x65, 0x64, 0x69, 
  0x6E, 0x67, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 
  0x74, 0x72, 0x75, 0x74, 0x68, 0x79, 0x2C, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 
  0x65, 0x20, 0x20, 0x65, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x66, 0x61, 0x6C, 0x73, 0x65, 0x79, 
  0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 
  0x05, 0x80, 0xFB, 0x01, 0xDA, 0x35, 0xCB, 0xDA, 0x82, 0x6A, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x82, 
  0x6C, 0xDA, 0x09, 0xCE, 0x55, 0x28, 0x64, 0x72, 0x6F, 0x70, 0x20, 0x6E, 0x20, 0x69, 0x6E, 0x64, 
  0x29, 0x0A, 0x0A, 0x44, 0x72, 0x6F, 0x70, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x6E, 0x20, 
  0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x6E, 0x20, 0x69, 
  0x6E, 0x64, 0x65, 0x78, 0x65, 0x64, 0x20, 0x74, 0x79, 0x70, 0x65, 0x2E, 0x20, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x65, 0x64, 
  0x20, 0x69, 0x6E, 0x73, 0x74, 0x61, 0x6E, 0x63, 0x65, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 
  0x05, 0x83, 0xC5, 0x01, 0xDA, 0x47, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 0x46, 0xDA, 0x09, 0xCE, 0x50, 
  0x28, 0x69, 0x66, 0x2D, 0x6E, 0x6F, 0x74, 0x20, 0x63, 0x6F, 0x6E, 0x64, 0x69, 0x74, 0x69, 0x6F, 
  0x6E, 0x20, 0x74, 0x68, 0x65, 0x6E, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x65, 0x6C, 0x73, 0x65, 
  0x29, 0x0A, 0x0A, 0x53, 0x68, 0x6F, 0x72, 0x74, 0x68, 0x61, 0x6E, 0x64, 0x20, 0x66, 0x6F, 0x72, 
  0x20, 0x28, 0x69, 0x66, 0x20, 0x28, 0x6E, 0x6F, 0x74, 0x20, 0x63, 0x6F, 0x6E, 0x64, 0x69, 0x74, 
  0x69, 0x6F, 0x6E, 0x29, 0x20, 0x65, 0x6C, 0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 0x6E, 0x29, 0x2E, 
  0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x80, 0x9F, 0x01, 0xDA, 0x35, 0xCB, 0xDA, 0x82, 0x6D, 
  0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x82, 0x6E, 0xDA, 0x09, 0xCE, 0x0D, 0x54, 0x68, 0x65, 0x20, 0x76, 
  0x61, 0x6C, 0x75, 0x65, 0x20, 0x70, 0x69, 0x2E, 0xDA, 0x82, 0x6F, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 
  0x82, 0x72, 0xDA, 0x09, 0xCE, 0x26, 0x28, 0x62, 0x6F, 0x6F, 0x6C, 0x65, 0x61, 0x6E, 0x3F, 0x20, 
  0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 
  0x73, 0x20, 0x61, 0x20, 0x62, 0x6F, 0x6F, 0x6C, 0x65, 0x61, 0x6E, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 
  0x00, 0xDA, 0x05, 0x65, 0x01, 0xDA, 0x82, 0x73, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x82, 0x75, 0xDA, 
  0x09, 0xCE, 0x80, 0xA1, 0x28, 0x72, 0x65, 0x64, 0x75, 0x63, 0x65, 0x32, 0x20, 0x66, 0x20, 0x69, 
  0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x54, 0x68, 0x65, 0x20, 0x32, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 
  0x65, 0x6E, 0x74, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x6F, 0x66, 0x20, 0x72, 
  0x65, 0x64, 0x75, 0x63, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x64, 0x6F, 0x65, 0x73, 0x20, 
  0x6E, 0x6F, 0x74, 0x20, 0x74, 0x61, 0x6B, 0x65, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x69, 0x74, 
  0x69, 0x61, 0x6C, 0x69, 0x7A, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 
  0x2E, 0x20, 0x20, 0x49, 0x6E, 0x73, 0x74, 0x65, 0x61, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 
  0x69, 0x72, 0x73, 0x74, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x6F, 0x66, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x69, 0x73, 0x20, 0x75, 0x73, 0x65, 
  0x64, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x69, 0x6E, 0x69, 0x74, 0x69, 0x61, 0x6C, 0x69, 0x7A, 0x61, 
  0x74, 0x69, 0x6F, 0x6E, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x83, 0x1A, 0x01, 0xDA, 
  0x82, 0x76, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x81, 0x17, 0xDA, 0x09, 0xCE, 0x80, 0xAD, 0x41, 0x20, 
  0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x20, 0x63, 0x6F, 
  0x6D, 0x62, 0x69, 0x6E, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x75, 
  0x6E, 0x6D, 0x61, 0x72, 0x73, 0x68, 0x61, 0x6C, 0x20, 0x74, 0x6F, 0x20, 0x75, 0x6E, 0x6D, 0x61, 
  0x72, 0x73, 0x68, 0x61, 0x6C, 0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 
  0x6E, 0x63, 0x65, 0x73, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20, 0x20, 0x62, 0x79, 
  0x20, 0x6D, 0x61, 0x6B, 0x65, 0x2D, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x2C, 0x20, 0x73, 0x75, 0x63, 
  0x68, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x28, 0x6C, 0x6F, 0x61, 0x64, 0x2D, 0x69, 0x6D, 0x61, 
  0x67, 0x65, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x29, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x73, 0x61, 0x6D, 0x65, 0x20, 0x61, 0x73, 0x20, 0x28, 0x75, 0x6E, 0x6D, 0x61, 0x72, 0x73, 
  0x68, 0x61, 0x6C, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x6C, 0x6F, 0x61, 0x64, 0x2D, 0x69, 
  0x6D, 0x61, 0x67, 0x65, 0x2D, 0x64, 0x69, 0x63, 0x74, 0x29, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 
  0xDA, 0x05, 0x88, 0x7B, 0x01, 0xDA, 0x82, 0x77, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x80, 0xDA, 0xDA, 
  0x09, 0xCE, 0x59, 0x28, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2F, 0x73, 0x65, 0x74, 0x70, 0x72, 0x6F, 
  0x74, 0x6F, 0x20, 0x74, 0x61, 0x62, 0x20, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0x29, 0x0A, 0x0A, 0x53, 
  0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0x74, 0x79, 0x70, 0x65, 
  0x20, 0x6F, 0x66, 0x20, 0x61, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0x20, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6F, 0x72, 0x69, 0x67, 0x69, 0x6E, 0x61, 
  0x6C, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x74, 0x61, 0x62, 0x2E, 0xDA, 0x82, 0x78, 0xD3, 
  0x02, 0xDA, 0x03, 0xDA, 0x82, 0x79, 0xDA, 0x09, 0xCE, 0x81, 0x4E, 0x28, 0x6F, 0x73, 0x2F, 0x70, 
  0x65, 0x72, 0x6D, 0x2D, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x69, 0x6E, 0x74, 0x29, 0x0A, 
  0x0A, 0x43, 0x6F, 0x6E, 0x76, 0x65, 0x72, 0x74, 0x20, 0x61, 0x20, 0x55, 0x6E, 0x69, 0x78, 0x20, 
  0x6F, 0x63, 0x74, 0x61, 0x6C, 0x20, 0x70, 0x65, 0x72, 0x6D, 0x69, 0x73, 0x73, 0x69, 0x6F, 0x6E, 
  0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x61, 0x20, 0x70, 0x65, 
  0x72, 0x6D, 0x69, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 
  0x20, 0x61, 0x73, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 
  0x6F, 0x73, 0x2F, 0x73, 0x74, 0x61, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x68, 0x75, 0x6D, 
  0x61, 0x6E, 0x20, 0x72, 0x65, 0x61, 0x64, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x73, 0x74, 0x72, 0x69, 
  0x6E, 0x67, 0x2C, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x66, 0x6F, 0x6C, 0x6C, 0x6F, 0x77, 0x73, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x74, 0x69, 0x6E, 0x67, 0x20, 
  0x6F, 0x66, 0x20, 0x75, 0x6E, 0x69, 0x78, 0x20, 0x74, 0x6F, 0x6F, 0x6C, 0x73, 0x20, 0x6C, 0x69, 
  0x6B, 0x65, 0x20, 0x6C, 0x73, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x73, 0x20, 0x61, 0x20, 0x39, 
  0x20, 0x63, 0x68, 0x61, 0x72, 0x61, 0x63, 0x74, 0x65, 0x72, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 
  0x67, 0x20, 0x6F, 0x66, 0x20, 0x72, 0x2C, 0x20, 0x77, 0x2C, 0x20, 0x78, 0x20, 0x61, 0x6E, 0x64, 
  0x20, 0x2D, 0x20, 0x63, 0x68, 0x61, 0x72, 0x61, 0x63, 0x74, 0x65, 0x72, 0x73, 0x2E, 0x20, 0x44, 
  0x6F, 0x65, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x69, 0x6E, 0x63, 0x6C, 0x75, 0x64, 0x65, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x2F, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6F, 
  0x72, 0x79, 0x2F, 0x73, 0x79, 0x6D, 0x6C, 0x69, 0x6E, 0x6B, 0x20, 0x63, 0x68, 0x61, 0x72, 0x61, 
  0x63, 0x74, 0x65, 0x72, 0x20, 0x61, 0x73, 0x20, 0x72, 0x65, 0x6E, 0x64, 0x65, 0x72, 0x65, 0x64, 
  0x20, 0x62, 0x79, 0x20, 0x60, 0x6C, 0x73, 0x60, 0x2E, 0xDA, 0x82, 0x7A, 0xD3, 0x02, 0xDA, 0x03, 
  0xDA, 0x82, 0x7B, 0xDA, 0x09, 0xCE, 0x80, 0x9E, 0x28, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 
  0x74, 0x72, 0x69, 0x6D, 0x72, 0x20, 0x73, 0x74, 0x72, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x73, 
  0x65, 0x74, 0x29, 0x0A, 0x0A, 0x54, 0x72, 0x69, 0x6D, 0x20, 0x74, 0x72, 0x61, 0x69, 0x6C, 0x69, 
  0x6E, 0x67, 0x20, 0x77, 0x68, 0x69, 0x74, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20, 0x66, 0x72, 
  0x6F, 0x6D, 0x20, 0x61, 0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6E, 
  0x63, 0x65, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 
  0x65, 0x6E, 0x74, 0x20, 0x73, 0x65, 0x74, 0x20, 0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x76, 0x69, 
  0x64, 0x65, 0x64, 0x2C, 0x20, 0x63, 0x6F, 0x6E, 0x73, 0x69, 0x64, 0x65, 0x72, 0x20, 0x6F, 0x6E, 
  0x6C, 0x79, 0x20, 0x63, 0x68, 0x61, 0x72, 0x61, 0x63, 0x74, 0x65, 0x72, 0x73, 0x20, 0x69, 0x6E, 
  0x20, 0x73, 0x65, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x62, 0x65, 0x20, 0x77, 0x68, 0x69, 0x74, 0x65, 
  0x73, 0x70, 0x61, 0x63, 0x65, 0x2E, 0xDA, 0x82, 0x7C, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 0x82, 0x7F, 
  0xDA, 0x09, 0xCE, 0x81, 0x0A, 0x28, 0x63, 0x6F, 0x6E, 0x64, 0x20, 0x26, 0x20, 0x70, 0x61, 0x69, 
  0x72, 0x73, 0x29, 0x0A, 0x0A, 0x45, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0x73, 0x20, 0x63, 
  0x6F, 0x6E, 0x64, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6E, 
  0x74, 0x69, 0x61, 0x6C, 0x6C, 0x79, 0x20, 0x75, 0x6E, 0x74, 0x69, 0x6C, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x74, 0x72, 0x75, 0x65, 0x20, 0x63, 0x6F, 0x6E, 0x64, 
  0x69, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x20, 0x69, 0x73, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x2C, 
  0x20, 0x61, 0x6E, 0x64, 0x20, 0x74, 0x68, 0x65, 0x6E, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 
  0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6F, 0x72, 0x72, 0x65, 0x73, 0x70, 0x6F, 0x6E, 
  0x64, 0x69, 0x6E, 0x67, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x74, 0x68, 
  0x65, 0x72, 0x65, 0x20, 0x61, 0x72, 0x65, 0x20, 0x61, 0x6E, 0x20, 0x20, 0x6F, 0x64, 0x64, 0x20, 
  0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x73, 0x2C, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x61, 0x73, 0x74, 0x20, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 
  0x73, 0x69, 0x6F, 0x6E, 0x20, 0x69, 0x73, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x64, 
  0x20, 0x69, 0x66, 0x20, 0x6E, 0x6F, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x73, 0x20, 0x20, 0x61, 0x72, 
  0x65, 0x20, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x74, 0x68, 
  0x65, 0x72, 0x65, 0x20, 0x61, 0x72, 0x65, 0x20, 0x6E, 0x6F, 0x20, 0x6D, 0x61, 0x74, 0x63, 0x68, 
  0x65, 0x73, 0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0xDA, 
  0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x80, 0xAE, 0x01, 0xDA, 0x35, 0xCB, 0xDA, 0x82, 0x80, 0xD3, 
  0x02, 0xDA, 0x03, 0xDA, 0x82, 0x81, 0xDA, 0x09, 0xCE, 0x3D, 0x28, 0x65, 0x70, 0x72, 0x69, 0x6E, 
  0x66, 0x20, 0x66, 0x6D, 0x74, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x4C, 0x69, 0x6B, 
  0x65, 0x20, 0x65, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x66, 0x20, 0x62, 0x75, 0x74, 0x20, 0x77, 0x69, 
  0x74, 0x68, 0x20, 0x6E, 0x6F, 0x20, 0x74, 0x72, 0x61, 0x69, 0x6C, 0x69, 0x6E, 0x67, 0x20, 0x6E, 
  0x65, 0x77, 0x6C, 0x69, 0x6E, 0x65, 0x2E, 0xDA, 0x82, 0x82, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x82, 
  0x83, 0xDA, 0x09, 0xCE, 0x47, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x61, 0x74, 0x61, 0x6E, 0x32, 
  0x20, 0x79, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x61, 0x72, 0x63, 0x74, 0x61, 0x6E, 0x67, 0x65, 0x6E, 0x74, 0x20, 0x6F, 0x66, 0x20, 
  0x79, 0x2F, 0x78, 0x2E, 0x20, 0x57, 0x6F, 0x72, 0x6B, 0x73, 0x20, 0x65, 0x76, 0x65, 0x6E, 0x20, 
  0x77, 0x68, 0x65, 0x6E, 0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 0x30, 0x2E, 0xDA, 0x81, 0x95, 0xD3, 
  0x04, 0xDA, 0x03, 0xDA, 0x82, 0x85, 0xDA, 0x09, 0xCE, 0x5E, 0x28, 0x77, 0x68, 0x65, 0x6E, 0x20, 
  0x63, 0x6F, 0x6E, 0x64, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x26, 0x20, 0x62, 0x6F, 0x64, 0x79, 
  0x29, 0x0A, 0x0A, 0x45, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x62, 0x6F, 0x64, 0x79, 0x20, 0x77, 0x68, 0x65, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 
  0x6F, 0x6E, 0x64, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x69, 0x73, 0x20, 0x74, 0x72, 0x75, 0x65, 
  0x2E, 0x20, 0x4F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x20, 0x72, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x80, 
  0xA4, 0x01, 0xDA, 0x35, 0xCB, 0xDA, 0x82, 0x86, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x28, 0xDA, 0x09, 
  0xCE, 0x81, 0x62, 0x28, 0x72, 0x65, 0x73, 0x75, 0x6D, 0x65, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 
  0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x73, 0x75, 0x6D, 0x65, 
  0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x6F, 0x72, 0x20, 0x73, 0x75, 0x73, 0x70, 0x65, 0x6E, 
  0x64, 0x65, 0x64, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x6F, 0x70, 
  0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x6C, 0x79, 0x20, 0x70, 0x61, 0x73, 0x73, 0x20, 0x69, 0x6E, 
  0x20, 0x61, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 
  0x62, 0x65, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x6C, 0x61, 0x73, 0x74, 0x20, 0x79, 0x69, 0x65, 0x6C, 0x64, 0x20, 0x69, 0x6E, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x61, 0x73, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x20, 0x70, 
  0x65, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2C, 0x20, 0x6F, 0x72, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x6F, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x69, 0x73, 0x70, 0x61, 0x74, 0x63, 0x68, 0x20, 0x66, 0x75, 
  0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x61, 
  0x73, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x66, 0x69, 0x62, 0x65, 
  0x72, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x65, 0x69, 0x74, 0x68, 0x65, 
  0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x72, 0x65, 0x73, 
  0x75, 0x6C, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 
  0x27, 0x73, 0x20, 0x64, 0x69, 0x73, 0x70, 0x61, 0x74, 0x63, 0x68, 0x20, 0x66, 0x75, 0x6E, 0x63, 
  0x74, 0x69, 0x6F, 0x6E, 0x2C, 0x20, 0x6F, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x61, 0x6C, 
  0x75, 0x65, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x78, 0x74, 
  0x20, 0x79, 0x69, 0x65, 0x6C, 0x64, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x20, 0x69, 0x6E, 0x20, 0x66, 
  0x69, 0x62, 0x65, 0x72, 0x2E, 0xDA, 0x82, 0x87, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x81, 0x0A, 0xDA, 
  0x09, 0xCE, 0x81, 0x9C, 0x28, 0x66, 0x69, 0x6C, 0x65, 0x2F, 0x72, 0x65, 0x61, 0x64, 0x20, 0x66, 
  0x20, 0x77, 0x68, 0x61, 0x74, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x62, 0x75, 0x66, 0x29, 0x0A, 
  0x0A, 0x52, 0x65, 0x61, 0x64, 0x20, 0x61, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 
  0x66, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x61, 0x20, 0x66, 
  0x69, 0x6C, 0x65, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 
  0x72, 0x2E, 0x20, 0x41, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x63, 0x61, 0x6E, 0x20, 
  0x62, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x76, 0x69, 0x64, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 0x61, 
  0x6E, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x20, 0x66, 0x6F, 0x75, 0x72, 0x74, 
  0x68, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x2C, 0x20, 0x6F, 0x74, 0x68, 0x65, 
  0x72, 0x77, 0x69, 0x73, 0x65, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x62, 0x75, 0x66, 0x66, 
  0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x2E, 0x20, 0x27, 
  0x77, 0x68, 0x61, 0x74, 0x27, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x65, 0x69, 0x74, 0x68, 0x65, 0x72, 
  0x20, 0x62, 0x65, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x6F, 
  0x72, 0x20, 0x61, 0x20, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 0x2E, 0x20, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 
  0x77, 0x69, 0x74, 0x68, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 
  0x74, 0x73, 0x2E, 0x20, 0x56, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x27, 
  0x77, 0x68, 0x61, 0x74, 0x27, 0x3A, 0x0A, 0x0A, 0x09, 0x3A, 0x61, 0x6C, 0x6C, 0x20, 0x2D, 0x20, 
  0x72, 0x65, 0x61, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x77, 0x68, 0x6F, 0x6C, 0x65, 0x20, 0x66, 
  0x69, 0x6C, 0x65, 0x0A, 0x09, 0x3A, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0x2D, 0x20, 0x72, 0x65, 0x61, 
  0x64, 0x20, 0x75, 0x70, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x69, 0x6E, 0x63, 0x6C, 
  0x75, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x78, 0x74, 0x20, 0x6E, 
  0x65, 0x77, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0x63, 0x68, 0x61, 0x72, 0x61, 0x63, 0x74, 0x65, 0x72, 
  0x0A, 0x09, 0x6E, 0x20, 0x28, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x29, 0x20, 0x2D, 0x20, 
  0x72, 0x65, 0x61, 0x64, 0x20, 0x75, 0x70, 0x20, 0x74, 0x6F, 0x20, 0x6E, 0x20, 0x62, 0x79, 0x74, 
  0x65, 0x73, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 
  0xDA, 0x82, 0x88, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x82, 0x89, 0xDA, 0x09, 0xCE, 0x80, 0x93, 0x28, 
  0x70, 0x65, 0x67, 0x2F, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x20, 0x70, 0x65, 0x67, 0x29, 
  0x0A, 0x0A, 0x43, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x73, 0x20, 0x61, 0x20, 0x70, 0x65, 0x67, 
  0x20, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 
  0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x3C, 0x63, 
  0x6F, 0x72, 0x65, 0x2F, 0x70, 0x65, 0x67, 0x3E, 0x2E, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x77, 
  0x69, 0x6C, 0x6C, 0x20, 0x73, 0x70, 0x65, 0x65, 0x64, 0x20, 0x75, 0x70, 0x20, 0x6D, 0x61, 0x74, 
  0x63, 0x68, 0x69, 0x6E, 0x67, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6D, 
  0x65, 0x20, 0x70, 0x65, 0x67, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 
  0x65, 0x64, 0x20, 0x6D, 0x75, 0x6C, 0x74, 0x69, 0x70, 0x6C, 0x65, 0x20, 0x74, 0x69, 0x6D, 0x65, 
  0x73, 0x2E, 0xDA, 0x82, 0x8A, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x82, 0x8B, 0xDA, 0x09, 0xCE, 0x2B, 
  0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x70, 0x6F, 0x77, 0x20, 0x61, 0x20, 0x78, 0x29, 0x0A, 0x0A, 
  0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x61, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x70, 0x6F, 0x77, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x2E, 0xDA, 0x82, 0x8C, 0xD3, 0x02, 
  0xDA, 0x03, 0xDA, 0x82, 0x8D, 0xDA, 0x09, 0xCE, 0x80, 0xAB, 0x28, 0x64, 0x69, 0x73, 0x61, 0x73, 
  0x6D, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x61, 0x73, 0x73, 0x65, 0x6D, 0x62, 0x6C, 0x79, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 
  0x6F, 0x75, 0x6C, 0x64, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x62, 0x65, 0x20, 
  0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x67, 0x69, 0x76, 0x65, 
  0x6E, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0x0A, 0x66, 0x75, 0x6E, 0x63, 
  0x20, 0x6D, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x61, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 
  0x69, 0x6F, 0x6E, 0x2C, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x61, 0x20, 0x63, 0x20, 0x66, 0x75, 0x6E, 
  0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0x20, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x74, 0x68, 0x72, 0x6F, 
  0x77, 0x20, 0x6F, 0x6E, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x6F, 0x6E, 0x20, 0x61, 0x20, 
  0x62, 0x61, 0x64, 0x6C, 0x79, 0x0A, 0x74, 0x79, 0x70, 0x65, 0x64, 0x20, 0x61, 0x72, 0x67, 0x75, 
  0x6D, 0x65, 0x6E, 0x74, 0x2E, 0xDA, 0x82, 0x8E, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 0x82, 0xA0, 0xDA, 
  0x09, 0xCE, 0x82, 0xF6, 0x28, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x20, 0x78, 0x20, 0x26, 0x20, 0x63, 
  0x61, 0x73, 0x65, 0x73, 0x29, 0x0A, 0x0A, 0x50, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6E, 0x20, 0x6D, 
  0x61, 0x74, 0x63, 0x68, 0x69, 0x6E, 0x67, 0x2E, 0x20, 0x4D, 0x61, 0x74, 0x63, 0x68, 0x20, 0x61, 
  0x6E, 0x20, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x78, 0x20, 0x61, 
  0x67, 0x61, 0x69, 0x6E, 0x73, 0x74, 0x20, 0x20, 0x61, 0x6E, 0x79, 0x20, 0x6E, 0x75, 0x6D, 0x62, 
  0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x63, 0x61, 0x73, 0x65, 0x73, 0x2E, 0x20, 0x45, 0x61, 0x63, 
  0x68, 0x20, 0x63, 0x61, 0x73, 0x65, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x70, 0x61, 0x74, 0x74, 
  0x65, 0x72, 0x6E, 0x20, 0x74, 0x6F, 0x20, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x20, 0x61, 0x67, 0x61, 
  0x69, 0x6E, 0x73, 0x74, 0x2C, 0x20, 0x66, 0x6F, 0x6C, 0x6C, 0x6F, 0x77, 0x65, 0x64, 0x20, 0x20, 
  0x62, 0x79, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6F, 0x6E, 
  0x20, 0x74, 0x6F, 0x20, 0x65, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0x20, 0x74, 0x6F, 0x20, 
  0x69, 0x66, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 0x61, 0x73, 0x65, 0x20, 0x69, 0x73, 0x20, 
  0x6D, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64, 0x2E, 0x20, 0x41, 0x20, 0x70, 0x61, 0x74, 0x74, 0x65, 
  0x72, 0x6E, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x73, 0x20, 0x20, 0x61, 0x20, 0x73, 0x79, 
  0x6D, 0x62, 0x6F, 0x6C, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x20, 
  0x61, 0x6E, 0x79, 0x74, 0x68, 0x69, 0x6E, 0x67, 0x2C, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 
  0x67, 0x20, 0x78, 0x27, 0x73, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x74, 
  0x68, 0x61, 0x74, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x2E, 0x20, 0x41, 0x6E, 0x20, 0x61, 
  0x72, 0x72, 0x61, 0x79, 0x20, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x6D, 0x61, 0x74, 0x63, 0x68, 
  0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x20, 0x69, 0x66, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x6F, 0x66, 0x20, 
  0x69, 0x74, 0x27, 0x73, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x6D, 0x61, 
  0x74, 0x63, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6F, 0x72, 0x72, 0x65, 0x73, 0x70, 0x6F, 
  0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x69, 
  0x6E, 0x20, 0x20, 0x78, 0x2E, 0x20, 0x41, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x6F, 0x72, 
  0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x6D, 0x61, 0x74, 
  0x63, 0x68, 0x20, 0x69, 0x66, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 
  0x20, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x63, 0x6F, 0x72, 0x72, 0x65, 0x73, 0x70, 0x6F, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x20, 0x76, 
  0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x78, 0x2E, 0x20, 0x41, 0x20, 0x74, 0x75, 
  0x70, 0x6C, 0x65, 0x20, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6E, 0x20, 0x77, 0x69, 0x6C, 0x6C, 
  0x20, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x20, 0x69, 0x66, 0x20, 0x69, 0x74, 0x27, 0x73, 0x20, 0x66, 
  0x69, 0x72, 0x73, 0x74, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x6D, 0x61, 0x74, 
  0x63, 0x68, 0x65, 0x73, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x6F, 
  0x6C, 0x6C, 0x6F, 0x77, 0x69, 0x6E, 0x67, 0x20, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 
  0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x74, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20, 0x61, 0x73, 
  0x20, 0x70, 0x72, 0x65, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x73, 0x20, 0x61, 0x6E, 0x64, 0x20, 
  0x61, 0x72, 0x65, 0x20, 0x74, 0x72, 0x75, 0x65, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x6C, 0x61, 
  0x73, 0x74, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x61, 0x6C, 0x20, 0x63, 0x61, 0x73, 0x65, 0x20, 
  0x69, 0x73, 0x20, 0x20, 0x74, 0x68, 0x65, 0x20, 0x27, 0x5F, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 
  0x6C, 0x2C, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x77, 0x69, 
  0x6C, 0x64, 0x63, 0x61, 0x72, 0x64, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x77, 0x69, 0x6C, 0x6C, 
  0x20, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x20, 0x61, 0x6E, 0x79, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 
  0x20, 0x77, 0x69, 0x74, 0x68, 0x6F, 0x75, 0x74, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6E, 
  0x67, 0x20, 0x61, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x2E, 0x20, 0x20, 0x41, 0x6E, 
  0x79, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x70, 0x61, 
  0x74, 0x74, 0x65, 0x72, 0x6E, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x20, 
  0x6D, 0x61, 0x74, 0x63, 0x68, 0x20, 0x69, 0x66, 0x20, 0x69, 0x74, 0x20, 0x69, 0x73, 0x20, 0x65, 
  0x71, 0x75, 0x61, 0x6C, 0x20, 0x74, 0x6F, 0x20, 0x78, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 
  0x05, 0x85, 0xFE, 0x01, 0xDA, 0x35, 0xCB, 0xDA, 0x82, 0xA1, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x82, 
  0xA3, 0xDA, 0x09, 0xCE, 0x80, 0x92, 0x28, 0x62, 0x72, 0x73, 0x68, 0x69, 0x66, 0x74, 0x20, 0x78, 
  0x20, 0x26, 0x20, 0x73, 0x68, 0x69, 0x66, 0x74, 0x73, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x6F, 0x66, 
  0x20, 0x78, 0x20, 0x62, 0x69, 0x74, 0x20, 0x73, 0x68, 0x69, 0x66, 0x74, 0x65, 0x64, 0x20, 0x72, 
  0x69, 0x67, 0x68, 0x74, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x75, 0x6D, 0x20, 
  0x6F, 0x66, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x69, 0x6E, 
  0x20, 0x73, 0x68, 0x69, 0x66, 0x74, 0x73, 0x2E, 0x20, 0x78, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x65, 
  0x61, 0x63, 0x68, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x69, 0x6E, 0x20, 0x73, 
  0x68, 0x69, 0x66, 0x74, 0x20, 0x6D, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x61, 0x6E, 0x20, 
  0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x2E, 0xDA, 0x82, 0xA4, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 
  0x80, 0xE6, 0xDA, 0x09, 0xCE, 0x61, 0x28, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x77, 0x68, 
  0x65, 0x72, 0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 
  0x20, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x61, 0x6E, 0x64, 
  0x20, 0x63, 0x6F, 0x6C, 0x75, 0x6D, 0x6E, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 
  0x61, 0x72, 0x73, 0x65, 0x72, 0x27, 0x73, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x6E, 0x61, 0x6C, 
  0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x2E, 0xDA, 0x82, 0xA5, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x6F, 
  0xDA, 0x09, 0xCE, 0x80, 0xA7, 0x28, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x26, 0x20, 0x70, 
  0x61, 0x72, 0x74, 0x73, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x73, 0x20, 0x61, 
  0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x62, 0x79, 0x20, 0x63, 0x6F, 0x6E, 0x63, 0x61, 
  0x74, 0x65, 0x6E, 0x61, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 
  0x74, 0x6F, 0x67, 0x65, 0x74, 0x68, 0x65, 0x72, 0x2E, 0x20, 0x56, 0x61, 0x6C, 0x75, 0x65, 0x73, 
  0x20, 0x61, 0x72, 0x65, 0x20, 0x63, 0x6F, 0x6E, 0x76, 0x65, 0x72, 0x74, 0x65, 0x64, 0x20, 0x74, 
  0x6F, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x76, 0x69, 0x61, 0x20, 0x64, 0x65, 0x73, 0x63, 
  0x72, 0x69, 0x62, 0x65, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x79, 0x20, 0x61, 0x72, 0x65, 
  0x20, 0x6E, 0x6F, 0x74, 0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6E, 
  0x63, 0x65, 0x73, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x6E, 0x65, 0x77, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2E, 0xDA, 0x82, 0xA6, 0xD3, 
  0x02, 0xDA, 0x03, 0xDA, 0x82, 0xA7, 0xDA, 0x09, 0xCE, 0x69, 0x28, 0x61, 0x72, 0x72, 0x61, 0x79, 
  0x2F, 0x74, 0x72, 0x69, 0x6D, 0x20, 0x61, 0x72, 0x72, 0x29, 0x0A, 0x0A, 0x53, 0x65, 0x74, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x62, 0x61, 0x63, 0x6B, 0x69, 0x6E, 0x67, 0x20, 0x63, 0x61, 0x70, 0x61, 
  0x63, 0x69, 0x74, 0x79, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 
  0x20, 0x74, 0x6F, 0x20, 0x69, 0x74, 0x73, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 
  0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x61, 0x72, 0x72, 
  0x61, 0x79, 0x2E, 0xDA, 0x82, 0xA8, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x69, 0xDA, 0x09, 0xCE, 0x80, 
  0xA8, 0x28, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 
  0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x62, 0x75, 
  0x66, 0x66, 0x65, 0x72, 0x20, 0x62, 0x79, 0x20, 0x63, 0x6F, 0x6E, 0x63, 0x61, 0x74, 0x65, 0x6E, 
  0x61, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x67, 
  0x65, 0x74, 0x68, 0x65, 0x72, 0x2E, 0x20, 0x56, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x61, 0x72, 
  0x65, 0x20, 0x63, 0x6F, 0x6E, 0x76, 0x65, 0x72, 0x74, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x62, 
  0x79, 0x74, 0x65, 0x73, 0x20, 0x76, 0x69, 0x61, 0x20, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 
  0x65, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x79, 0x20, 0x61, 0x72, 0x65, 0x20, 0x6E, 0x6F, 
  0x74, 0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6E, 0x63, 0x65, 0x73, 
  0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 
  0x77, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0xDA, 0x82, 0xA9, 0xD3, 0x02, 0xDA, 0x03, 
  0xDA, 0x82, 0xAA, 0xDA, 0x09, 0xCE, 0x80, 0x8D, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x72, 0x6E, 
  0x67, 0x2D, 0x69, 0x6E, 0x74, 0x20, 0x72, 0x6E, 0x67, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x6D, 
  0x61, 0x78, 0x29, 0x0A, 0x0A, 0x45, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x20, 0x61, 0x20, 0x72, 
  0x61, 0x6E, 0x64, 0x6F, 0x6D, 0x20, 0x72, 0x61, 0x6E, 0x64, 0x6F, 0x6D, 0x20, 0x69, 0x6E, 0x74, 
  0x65, 0x67, 0x65, 0x72, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x61, 0x6E, 0x67, 
  0x65, 0x20, 0x5B, 0x30, 0x2C, 0x20, 0x6D, 0x61, 0x78, 0x5D, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x52, 0x4E, 0x47, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x6E, 0x6F, 0x20, 0x6D, 
  0x61, 0x78, 0x20, 0x69, 0x73, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x2C, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x20, 0x69, 0x73, 0x20, 0x32, 0x5E, 0x33, 0x31, 
  0x20, 0x2D, 0x20, 0x31, 0x2E, 0xDA, 0x82, 0xAB, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 0x82, 0xB0, 0xDA, 
  0x09, 0xCE, 0x80, 0xDC, 0x28, 0x2D, 0x3E, 0x3E, 0x20, 0x78, 0x20, 0x26, 0x20, 0x66, 0x6F, 0x72, 
  0x6D, 0x73, 0x29, 0x0A, 0x0A, 0x54, 0x68, 0x72, 0x65, 0x61, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x6D, 
  0x61, 0x63, 0x72, 0x6F, 0x2E, 0x20, 0x49, 0x6E, 0x73, 0x65, 0x72, 0x74, 0x73, 0x20, 0x78, 0x20, 
  0x61, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x61, 0x73, 0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 
  0x65, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x66, 
  0x6F, 0x72, 0x6D, 0x20, 0x20, 0x69, 0x6E, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x73, 0x2C, 0x20, 0x61, 
  0x6E, 0x64, 0x20, 0x69, 0x6E, 0x73, 0x65, 0x72, 0x74, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 
  0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x66, 0x6F, 
  0x72, 0x6D, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x63, 0x6F, 
  0x6E, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x20, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x73, 0x61, 0x6D, 0x65, 0x20, 0x6D, 0x61, 0x6E, 0x6E, 0x65, 0x72, 0x2C, 0x20, 0x61, 0x6E, 0x64, 
  0x20, 0x73, 0x6F, 0x20, 0x6F, 0x6E, 0x2E, 0x20, 0x55, 0x73, 0x65, 0x66, 0x75, 0x6C, 0x20, 0x66, 
  0x6F, 0x72, 0x20, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x70, 0x69, 
  0x70, 0x65, 0x6C, 0x69, 0x6E, 0x65, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x64, 0x61, 0x74, 0x61, 0x2E, 
  0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x84, 0x0F, 0x01, 0xDA, 0x35, 0xCB, 0xDA, 0x82, 0xB1, 
  0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x82, 0xB2, 0xDA, 0x09, 0xCE, 0x4D, 0x28, 0x6D, 0x61, 0x74, 0x68, 
  0x2F, 0x72, 0x61, 0x6E, 0x64, 0x6F, 0x6D, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 
  0x73, 0x20, 0x61, 0x20, 0x75, 0x6E, 0x69, 0x66, 0x6F, 0x72, 0x6D, 0x6C, 0x79, 0x20, 0x64, 0x69, 
  0x73, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x64, 0x20, 0x72, 0x61, 0x6E, 0x64, 0x6F, 0x6D, 
  0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x62, 0x65, 0x74, 0x77, 0x65, 0x65, 0x6E, 0x20, 
  0x30, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x31, 0x2E, 0xDA, 0x82, 0xB3, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 
  0x82, 0xB4, 0xDA, 0x09, 0xCE, 0x80, 0x86, 0x28, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x70, 0x6F, 
  0x70, 0x20, 0x61, 0x72, 0x72, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x6D, 0x6F, 0x76, 0x65, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x6C, 0x61, 0x73, 0x74, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 
  0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x61, 0x6E, 0x64, 
  0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x69, 0x74, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x69, 0x73, 0x20, 0x65, 0x6D, 0x70, 0x74, 
  0x79, 0x2C, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x6E, 
  0x69, 0x6C, 0x2E, 0x20, 0x4D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x69, 0x6E, 0x70, 0x75, 0x74, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0xDA, 0x82, 0xB5, 
  0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x82, 0xB6, 0xDA, 0x09, 0xCE, 0x80, 0xA7, 0x28, 0x6B, 0x65, 0x79, 
  0x77, 0x6F, 0x72, 0x64, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 
  0x74, 0x65, 0x73, 0x20, 0x61, 0x20, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 0x20, 0x62, 0x79, 
  0x20, 0x63, 0x6F, 0x6E, 0x63, 0x61, 0x74, 0x65, 0x6E, 0x61, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x76, 
  0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x67, 0x65, 0x74, 0x68, 0x65, 0x72, 0x2E, 0x20, 
  0x56, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x63, 0x6F, 0x6E, 0x76, 0x65, 
  0x72, 0x74, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x76, 0x69, 
  0x61, 0x20, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 
  0x65, 0x79, 0x20, 0x61, 0x72, 0x65, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 
  0x73, 0x65, 0x71, 0x75, 0x65, 0x6E, 0x63, 0x65, 0x73, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x6B, 0x65, 0x79, 0x77, 0x6F, 
  0x72, 0x64, 0x2E, 0xDA, 0x82, 0xB7, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x82, 0xB8, 0xDA, 0x09, 0xCE, 
  0x7E, 0x28, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x74, 0x72, 0x69, 0x6D, 0x20, 0x62, 0x75, 
  0x66, 0x66, 0x65, 0x72, 0x29, 0x0A, 0x0A, 0x53, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 
  0x61, 0x63, 0x6B, 0x69, 0x6E, 0x67, 0x20, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x20, 
  0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x74, 0x6F, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x6C, 0x65, 0x6E, 
  0x67, 0x74, 0x68, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 
  0x72, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 
  0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0xDA, 
  0x82, 0xBC, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x82, 0x2C, 0xDA, 0x09, 0xCE, 0x3B, 0x28, 0x70, 0x61, 
  0x69, 0x72, 0x73, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x73, 0x73, 
  0x6F, 0x63, 0x69, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 
  0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x85, 
  0x2E, 0x01, 0xDA, 0x82, 0xBD, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x82, 0xBE, 0xDA, 0x09, 0xCE, 0x81, 
  0x50, 0x28, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x65, 0x6E, 0x73, 0x75, 0x72, 0x65, 0x20, 0x61, 
  0x72, 0x72, 0x20, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x20, 0x67, 0x72, 0x6F, 0x77, 
  0x74, 0x68, 0x29, 0x0A, 0x0A, 0x45, 0x6E, 0x73, 0x75, 0x72, 0x65, 0x73, 0x20, 0x74, 0x68, 0x61, 
  0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x20, 0x62, 0x61, 0x63, 
  0x6B, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x69, 
  0x73, 0x20, 0x6C, 0x61, 0x72, 0x67, 0x65, 0x20, 0x65, 0x6E, 0x6F, 0x75, 0x67, 0x68, 0x20, 0x66, 
  0x6F, 0x72, 0x20, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x20, 0x69, 0x74, 0x65, 0x6D, 
  0x73, 0x20, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x72, 
  0x61, 0x74, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x67, 0x72, 0x6F, 0x77, 0x74, 0x68, 0x2E, 0x20, 0x43, 
  0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x67, 0x72, 0x6F, 0x77, 
  0x74, 0x68, 0x20, 0x6D, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 
  0x65, 0x72, 0x73, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x61, 0x63, 0x6B, 
  0x69, 0x6E, 0x67, 0x20, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x20, 0x69, 0x73, 0x20, 
  0x61, 0x6C, 0x72, 0x65, 0x61, 0x64, 0x79, 0x20, 0x65, 0x6E, 0x6F, 0x75, 0x67, 0x68, 0x2C, 0x20, 
  0x74, 0x68, 0x65, 0x6E, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 
  0x6F, 0x6E, 0x20, 0x64, 0x6F, 0x65, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x68, 0x69, 0x6E, 0x67, 0x2E, 
  0x20, 0x4F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x2C, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x62, 0x61, 0x63, 0x6B, 0x69, 0x6E, 0x67, 0x20, 0x6D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x20, 0x77, 
  0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x72, 0x65, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 
  0x65, 0x64, 0x20, 0x73, 0x6F, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x72, 0x65, 
  0x20, 0x69, 0x73, 0x20, 0x65, 0x6E, 0x6F, 0x75, 0x67, 0x68, 0x20, 0x73, 0x70, 0x61, 0x63, 0x65, 
  0x2E, 0xDA, 0x82, 0xBF, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x82, 0xC0, 0xDA, 0x09, 0xCE, 0x5E, 0x28, 
  0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x70, 0x6F, 0x70, 0x6E, 0x20, 0x62, 0x75, 0x66, 0x66, 
  0x65, 0x72, 0x20, 0x6E, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x6D, 0x6F, 0x76, 0x65, 0x73, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x6C, 0x61, 0x73, 0x74, 0x20, 0x6E, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 
  0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 
  0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x6F, 0x64, 
  0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0xDA, 0x82, 0xC1, 
  0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x82, 0xC2, 0xDA, 0x09, 0xCE, 0x81, 0x02, 0x28, 0x6F, 0x73, 0x2F, 
  0x77, 0x68, 0x69, 0x63, 0x68, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x6F, 0x70, 0x65, 0x72, 0x61, 0x74, 
  0x69, 0x6E, 0x67, 0x20, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x73, 0x20, 0x6F, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x3A, 0x0A, 0x0A, 0x09, 0x3A, 0x77, 
  0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x0A, 0x09, 0x3A, 0x6D, 0x61, 0x63, 0x6F, 0x73, 0x0A, 0x09, 
  0x3A, 0x77, 0x65, 0x62, 0x20, 0x2D, 0x20, 0x57, 0x65, 0x62, 0x20, 0x61, 0x73, 0x73, 0x65, 0x6D, 
  0x62, 0x6C, 0x79, 0x20, 0x28, 0x65, 0x6D, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x65, 0x6E, 0x29, 
  0x0A, 0x09, 0x3A, 0x6C, 0x69, 0x6E, 0x75, 0x78, 0x0A, 0x09, 0x3A, 0x66, 0x72, 0x65, 0x65, 0x62, 
  0x73, 0x64, 0x0A, 0x09, 0x3A, 0x6F, 0x70, 0x65, 0x6E, 0x62, 0x73, 0x64, 0x0A, 0x09, 0x3A, 0x6E, 
  0x65, 0x74, 0x62, 0x73, 0x64, 0x0A, 0x09, 0x3A, 0x70, 0x6F, 0x73, 0x69, 0x78, 0x20, 0x2D, 0x20, 
  0x41, 0x20, 0x50, 0x4F, 0x53, 0x49, 0x58, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x74, 0x69, 0x62, 
  0x6C, 0x65, 0x20, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x20, 0x28, 0x64, 0x65, 0x66, 0x61, 0x75, 
  0x6C, 0x74, 0x29, 0x0A, 0x0A, 0x4D, 0x61, 0x79, 0x20, 0x61, 0x6C, 0x73, 0x6F, 0x20, 0x72, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x20, 0x61, 0x20, 0x63, 0x75, 0x73, 0x74, 0x6F, 0x6D, 0x20, 0x6B, 0x65, 
  0x79, 0x77, 0x6F, 0x72, 0x64, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 
  0x61, 0x74, 0x20, 0x62, 0x75, 0x69, 0x6C, 0x64, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x2E, 0xDA, 0x82, 
  0xC3, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x82, 0xC4, 0xDA, 0x09, 0xCE, 0x70, 0x28, 0x66, 0x69, 0x62, 
  0x65, 0x72, 0x2F, 0x72, 0x6F, 0x6F, 0x74, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 
  0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x72, 0x6F, 
  0x6F, 0x74, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x72, 0x6F, 
  0x6F, 0x74, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x6F, 0x6C, 0x64, 0x65, 0x73, 0x74, 0x20, 0x61, 0x6E, 0x63, 0x65, 0x73, 0x74, 0x6F, 0x72, 0x20, 
  0x74, 0x68, 0x61, 0x74, 0x20, 0x64, 0x6F, 0x65, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x68, 0x61, 
  0x76, 0x65, 0x20, 0x61, 0x20, 0x70, 0x61, 0x72, 0x65, 0x6E, 0x74, 0x2E, 0xDA, 0x82, 0xC5, 0xD3, 
  0x03, 0xDA, 0x03, 0xDA, 0x82, 0xC7, 0xDA, 0x09, 0xCE, 0x20, 0x28, 0x66, 0x61, 0x6C, 0x73, 0x65, 
  0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 
  0x20, 0x69, 0x73, 0x20, 0x66, 0x61, 0x6C, 0x73, 0x65, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 
  0x05, 0x71, 0x01, 0xDA, 0x82, 0xC8, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x82, 0xCA, 0xDA, 0x09, 0xCE, 
  0x80, 0x8B, 0x28, 0x73, 0x6F, 0x72, 0x74, 0x2D, 0x62, 0x79, 0x20, 0x66, 0x20, 0x69, 0x6E, 0x64, 
  0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 
  0x20, 0x73, 0x6F, 0x72, 0x74, 0x65, 0x64, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x74, 0x68, 
  0x61, 0x74, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0x73, 0x20, 0x65, 0x6C, 0x65, 0x6D, 
  0x65, 0x6E, 0x74, 0x73, 0x20, 0x62, 0x79, 0x20, 0x69, 0x6E, 0x76, 0x6F, 0x6B, 0x69, 0x6E, 0x67, 
  0x20, 0x20, 0x61, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x6F, 0x6E, 0x20, 
  0x65, 0x61, 0x63, 0x68, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x61, 0x6E, 0x64, 
  0x20, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 
  0x65, 0x73, 0x75, 0x6C, 0x74, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x3C, 0x2E, 0xDA, 0x0B, 0xD2, 
  0x03, 0x00, 0xDA, 0x05, 0x83, 0x01, 0x01, 0xDA, 0x82, 0xCB, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x82, 
  0xCC, 0xDA, 0x09, 0xCE, 0x81, 0x69, 0x28, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x73, 0x70, 
  0x6C, 0x69, 0x74, 0x20, 0x64, 0x65, 0x6C, 0x69, 0x6D, 0x20, 0x73, 0x74, 0x72, 0x20, 0x26, 0x6F, 
  0x70, 0x74, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x6C, 0x69, 0x6D, 0x69, 0x74, 0x29, 0x0A, 
  0x0A, 0x53, 0x70, 0x6C, 0x69, 0x74, 0x73, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 
  0x20, 0x73, 0x74, 0x72, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x64, 0x65, 0x6C, 0x69, 0x6D, 0x69, 
  0x74, 0x65, 0x72, 0x20, 0x64, 0x65, 0x6C, 0x69, 0x6D, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x72, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x6F, 
  0x66, 0x20, 0x73, 0x75, 0x62, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x73, 0x2E, 0x20, 0x54, 0x68, 
  0x65, 0x20, 0x73, 0x75, 0x62, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x73, 0x20, 0x77, 0x69, 0x6C, 
  0x6C, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x64, 0x65, 0x6C, 0x69, 0x6D, 0x69, 0x74, 0x65, 0x72, 0x20, 0x64, 0x65, 0x6C, 0x69, 
  0x6D, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x64, 0x65, 0x6C, 0x69, 0x6D, 0x20, 0x69, 0x73, 0x20, 0x6E, 
  0x6F, 0x74, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x2C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x65, 0x64, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x77, 0x69, 0x6C, 
  0x6C, 0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x6F, 0x6E, 0x65, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 
  0x6E, 0x74, 0x2E, 0x20, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x73, 
  0x65, 0x61, 0x72, 0x63, 0x68, 0x69, 0x6E, 0x67, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x64, 0x65, 0x6C, 
  0x69, 0x6D, 0x20, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 
  0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x28, 0x69, 0x66, 0x20, 0x70, 0x72, 0x6F, 0x76, 0x69, 0x64, 
  0x65, 0x64, 0x29, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 
  0x75, 0x70, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x6D, 0x61, 0x78, 0x69, 0x6D, 0x75, 0x6D, 0x20, 
  0x6F, 0x66, 0x20, 0x6C, 0x69, 0x6D, 0x69, 0x74, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6C, 0x74, 0x73, 
  0x20, 0x28, 0x69, 0x66, 0x20, 0x70, 0x72, 0x6F, 0x76, 0x69, 0x64, 0x65, 0x64, 0x29, 0x2E, 0xDA, 
  0x81, 0xB4, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x81, 0x65, 0xDA, 0x09, 0xCE, 0x50, 0x28, 0x74, 0x75, 
  0x70, 0x6C, 0x65, 0x20, 0x26, 0x20, 0x69, 0x74, 0x65, 0x6D, 0x73, 0x29, 0x0A, 0x0A, 0x43, 0x72, 
  0x65, 0x61, 0x74, 0x65, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x74, 0x75, 0x70, 0x6C, 
  0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 0x73, 0x20, 
  0x69, 0x74, 0x65, 0x6D, 0x73, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x2E, 0xDA, 0x82, 0xCD, 
  0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x82, 0xCE, 0xDA, 0x09, 0xCE, 0x80, 0xCF, 0x28, 0x64, 0x65, 0x62, 
  0x75, 0x67, 0x2F, 0x61, 0x72, 0x67, 0x2D, 0x73, 0x74, 0x61, 0x63, 0x6B, 0x20, 0x66, 0x69, 0x62, 
  0x65, 0x72, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x73, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x76, 0x61, 
  0x6C, 0x75, 0x65, 0x73, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x6C, 0x79, 0x20, 0x6F, 
  0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x27, 0x73, 0x20, 0x61, 0x72, 
  0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x73, 0x74, 0x61, 0x63, 0x6B, 0x2E, 0x20, 0x4E, 0x6F, 
  0x72, 0x6D, 0x61, 0x6C, 0x6C, 0x79, 0x2C, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x73, 0x68, 0x6F, 
  0x75, 0x6C, 0x64, 0x20, 0x62, 0x65, 0x20, 0x65, 0x6D, 0x70, 0x74, 0x79, 0x20, 0x75, 0x6E, 0x6C, 
  0x65, 0x73, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x73, 0x69, 
  0x67, 0x6E, 0x61, 0x6C, 0x73, 0x20, 0x77, 0x68, 0x69, 0x6C, 0x65, 0x20, 0x70, 0x75, 0x73, 0x68, 
  0x69, 0x6E, 0x67, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x74, 0x6F, 
  0x20, 0x6D, 0x61, 0x6B, 0x65, 0x20, 0x61, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 
  0x20, 0x63, 0x61, 0x6C, 0x6C, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 
  0x20, 0x6E, 0x65, 0x77, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0xDA, 0x82, 0xCF, 0xD3, 0x03, 
  0xDA, 0x03, 0xDA, 0x82, 0xD3, 0xDA, 0x09, 0xCE, 0x5D, 0x28, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 
  0x65, 0x3C, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x45, 0x71, 0x75, 0x69, 0x76, 0x61, 
  0x6C, 0x65, 0x6E, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x27, 0x3C, 0x27, 0x20, 0x62, 0x75, 0x74, 0x20, 
  0x75, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0x20, 0x66, 0x75, 
  0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x69, 0x6E, 0x73, 0x74, 0x65, 0x61, 0x64, 0x20, 0x6F, 
  0x66, 0x20, 0x70, 0x72, 0x69, 0x6D, 0x69, 0x74, 0x69, 0x76, 0x65, 0x20, 0x63, 0x6F, 0x6D, 0x70, 
  0x61, 0x72, 0x61, 0x74, 0x6F, 0x72, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x82, 0xC6, 0x01, 
  0xDA, 0x82, 0xD4, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 0x82, 0xD6, 0xDA, 0x09, 0xCE, 0x3B, 0x28, 0x65, 
  0x61, 0x63, 0x68, 0x6B, 0x20, 0x78, 0x20, 0x64, 0x73, 0x20, 0x26, 0x20, 0x62, 0x6F, 0x64, 0x79, 
  0x29, 0x0A, 0x0A, 0x4C, 0x6F, 0x6F, 0x70, 0x20, 0x6F, 0x76, 0x65, 0x72, 0x20, 0x65, 0x61, 0x63, 
  0x68, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x69, 0x6E, 0x20, 0x64, 0x73, 0x2E, 0x20, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 
  0x81, 0xE6, 0x01, 0xDA, 0x35, 0xCB, 0xDA, 0x82, 0xD7, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x81, 0x07, 
  0xDA, 0x09, 0xCE, 0x83, 0xE9, 0x28, 0x72, 0x75, 0x6E, 0x2D, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x78, 
  0x74, 0x20, 0x6F, 0x70, 0x74, 0x73, 0x29, 0x0A, 0x0A, 0x52, 0x75, 0x6E, 0x20, 0x61, 0x20, 0x63, 
  0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0x2E, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x65, 0x76, 0x61, 
  0x6C, 0x75, 0x61, 0x74, 0x65, 0x73, 0x20, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6F, 
  0x6E, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 
  0x6D, 0x65, 0x6E, 0x74, 0x2C, 0x20, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x69, 0x73, 0x20, 0x65, 0x6E, 
  0x63, 0x61, 0x70, 0x73, 0x75, 0x6C, 0x61, 0x74, 0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 
  0x61, 0x72, 0x73, 0x69, 0x6E, 0x67, 0x2C, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x61, 0x74, 
  0x69, 0x6F, 0x6E, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x65, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 
  0x69, 0x6F, 0x6E, 0x2E, 0x20, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x28, 0x69, 
  0x6E, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x3A, 0x65, 
  0x78, 0x69, 0x74, 0x2D, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 
  0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x29, 0x20, 0x77, 0x68, 0x65, 0x6E, 0x20, 0x63, 0x6F, 0x6D, 0x70, 
  0x6C, 0x65, 0x74, 0x65, 0x2E, 0x20, 0x20, 0x6F, 0x70, 0x74, 0x73, 0x20, 0x69, 0x73, 0x20, 0x61, 
  0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x6F, 0x72, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 
  0x20, 0x6F, 0x66, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x2E, 0x20, 0x54, 0x68, 0x65, 
  0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x61, 0x73, 0x20, 
  0x66, 0x6F, 0x6C, 0x6C, 0x6F, 0x77, 0x73, 0x3A, 0x0A, 0x0A, 0x09, 0x20, 0x20, 0x3A, 0x63, 0x68, 
  0x75, 0x6E, 0x6B, 0x73, 0x20, 0x2D, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x62, 0x61, 0x63, 0x6B, 0x20, 
  0x74, 0x6F, 0x20, 0x72, 0x65, 0x61, 0x64, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x62, 
  0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x2D, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x20, 
  0x69, 0x73, 0x20, 0x67, 0x65, 0x74, 0x6C, 0x69, 0x6E, 0x65, 0x0A, 0x09, 0x20, 0x20, 0x3A, 0x6F, 
  0x6E, 0x2D, 0x70, 0x61, 0x72, 0x73, 0x65, 0x2D, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x2D, 0x20, 
  0x63, 0x61, 0x6C, 0x6C, 0x62, 0x61, 0x63, 0x6B, 0x20, 0x77, 0x68, 0x65, 0x6E, 0x20, 0x70, 0x61, 
  0x72, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x73, 0x20, 0x2D, 0x20, 0x64, 0x65, 
  0x66, 0x61, 0x75, 0x6C, 0x74, 0x20, 0x69, 0x73, 0x20, 0x62, 0x61, 0x64, 0x2D, 0x70, 0x61, 0x72, 
  0x73, 0x65, 0x0A, 0x09, 0x20, 0x20, 0x3A, 0x65, 0x6E, 0x76, 0x20, 0x2D, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x6F, 0x20, 
  0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x20, 0x61, 0x67, 0x61, 0x69, 0x6E, 0x73, 0x74, 0x20, 
  0x2D, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x65, 0x6E, 0x76, 0x0A, 0x09, 0x20, 0x20, 
  0x3A, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x20, 0x2D, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 
  0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x6F, 0x66, 0x20, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x20, 
  0x66, 0x6F, 0x72, 0x20, 0x62, 0x65, 0x74, 0x74, 0x65, 0x72, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 
  0x73, 0x20, 0x2D, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x20, 0x69, 0x73, 0x20, 0x22, 
  0x3C, 0x61, 0x6E, 0x6F, 0x6E, 0x79, 0x6D, 0x6F, 0x75, 0x73, 0x3E, 0x22, 0x0A, 0x09, 0x20, 0x20, 
  0x3A, 0x6F, 0x6E, 0x2D, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x2D, 0x65, 0x72, 0x72, 0x6F, 
  0x72, 0x20, 0x2D, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x62, 0x61, 0x63, 0x6B, 0x20, 0x77, 0x68, 0x65, 
  0x6E, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x66, 0x61, 
  0x69, 0x6C, 0x73, 0x20, 0x2D, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x20, 0x69, 0x73, 
  0x20, 0x62, 0x61, 0x64, 0x2D, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x0A, 0x09, 0x20, 0x20, 
  0x3A, 0x65, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x6F, 0x72, 0x20, 0x2D, 0x20, 0x63, 0x61, 0x6C, 
  0x6C, 0x62, 0x61, 0x63, 0x6B, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 
  0x74, 0x65, 0x73, 0x20, 0x74, 0x68, 0x75, 0x6E, 0x6B, 0x73, 0x2E, 0x20, 0x53, 0x69, 0x67, 0x6E, 
  0x61, 0x74, 0x75, 0x72, 0x65, 0x20, 0x69, 0x73, 0x20, 0x28, 0x65, 0x76, 0x61, 0x6C, 0x75, 0x61, 
  0x74, 0x6F, 0x72, 0x20, 0x74, 0x68, 0x75, 0x6E, 0x6B, 0x20, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 
  0x20, 0x65, 0x6E, 0x76, 0x20, 0x77, 0x68, 0x65, 0x72, 0x65, 0x29, 0x0A, 0x09, 0x20, 0x20, 0x3A, 
  0x6F, 0x6E, 0x2D, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x2D, 0x20, 0x63, 0x61, 0x6C, 0x6C, 
  0x62, 0x61, 0x63, 0x6B, 0x20, 0x77, 0x68, 0x65, 0x6E, 0x20, 0x61, 0x20, 0x76, 0x61, 0x6C, 0x75, 
  0x65, 0x20, 0x69, 0x73, 0x20, 0x65, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0x64, 0x20, 0x2D, 
  0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x20, 0x69, 0x73, 0x20, 0x64, 0x65, 0x62, 0x75, 
  0x67, 0x2F, 0x73, 0x74, 0x61, 0x63, 0x6B, 0x74, 0x72, 0x61, 0x63, 0x65, 0x0A, 0x09, 0x20, 0x20, 
  0x3A, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2D, 0x66, 0x6C, 0x61, 0x67, 0x73, 0x20, 0x2D, 0x20, 0x77, 
  0x68, 0x61, 0x74, 0x20, 0x66, 0x6C, 0x61, 0x67, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x77, 0x72, 0x61, 
  0x70, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x61, 0x74, 0x69, 0x6F, 
  0x6E, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x77, 0x69, 0x74, 0x68, 0x2E, 0x20, 0x44, 0x65, 
  0x66, 0x61, 0x75, 0x6C, 0x74, 0x20, 0x69, 0x73, 0x20, 0x3A, 0x69, 0x61, 0x2E, 0x0A, 0x09, 0x20, 
  0x20, 0x3A, 0x65, 0x78, 0x70, 0x61, 0x6E, 0x64, 0x65, 0x72, 0x20, 0x2D, 0x20, 0x61, 0x6E, 0x20, 
  0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 
  0x6E, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x73, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x65, 0x64, 
  0x20, 0x6F, 0x6E, 0x20, 0x65, 0x61, 0x63, 0x68, 0x20, 0x74, 0x6F, 0x70, 0x20, 0x6C, 0x65, 0x76, 
  0x65, 0x6C, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x20, 0x62, 0x65, 0x66, 0x6F, 0x72, 0x65, 0x20, 0x62, 
  0x65, 0x69, 0x6E, 0x67, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x64, 0x2E, 0xDA, 0x0B, 
  0xD2, 0x03, 0x00, 0xDA, 0x05, 0x87, 0xD5, 0x01, 0xDA, 0x82, 0xD8, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 
  0x82, 0xD9, 0xDA, 0x09, 0xCE, 0x40, 0x28, 0x74, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x6C, 0x65, 
  0x6E, 0x67, 0x74, 0x68, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x7C, 0x62, 0x75, 0x66, 0x66, 0x65, 
  0x72, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x74, 0x79, 0x70, 0x65, 0x64, 
  0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x6F, 0x72, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 
  0x20, 0x73, 0x69, 0x7A, 0x65, 0x2E, 0xDA, 0x82, 0xDA, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 0x82, 0xDC, 
  0xDA, 0x09, 0xCE, 0x45, 0x28, 0x64, 0x65, 0x66, 0x2D, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x26, 
  0x20, 0x6D, 0x6F, 0x72, 0x65, 0x29, 0x0A, 0x0A, 0x44, 0x65, 0x66, 0x69, 0x6E, 0x65, 0x20, 0x61, 
  0x20, 0x70, 0x72, 0x69, 0x76, 0x61, 0x74, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x74, 
  0x68, 0x61, 0x74, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x62, 0x65, 0x20, 
  0x65, 0x78, 0x70, 0x6F, 0x72, 0x74, 0x65, 0x64, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 
  0x38, 0x01, 0xDA, 0x35, 0xCB, 0xDA, 0x82, 0xDD, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x81, 0xAC, 0xDA, 
  0x09, 0xCE, 0x44, 0x28, 0x3E, 0x3D, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x43, 0x68, 
  0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x73, 0x20, 0x69, 0x73, 0x20, 0x69, 0x6E, 0x20, 
  0x6E, 0x6F, 0x6E, 0x2D, 0x61, 0x73, 0x63, 0x65, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x6F, 0x72, 
  0x64, 0x65, 0x72, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x62, 
  0x6F, 0x6F, 0x6C, 0x65, 0x61, 0x6E, 0x2E, 0xDA, 0x82, 0xDE, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x22, 
  0xDA, 0x09, 0xCE, 0x80, 0xD1, 0x28, 0x67, 0x65, 0x6E, 0x73, 0x79, 0x6D, 0x29, 0x0A, 0x0A, 0x52, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x73, 0x79, 0x6D, 
  0x62, 0x6F, 0x6C, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x73, 0x20, 0x75, 0x6E, 0x69, 0x71, 
  0x75, 0x65, 0x20, 0x61, 0x63, 0x72, 0x6F, 0x73, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x75, 
  0x6E, 0x74, 0x69, 0x6D, 0x65, 0x2E, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x6D, 0x65, 0x61, 0x6E, 
  0x73, 0x20, 0x69, 0x74, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x63, 0x6F, 
  0x6C, 0x6C, 0x69, 0x64, 0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61, 0x6E, 0x79, 0x20, 0x61, 
  0x6C, 0x72, 0x65, 0x61, 0x64, 0x79, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20, 0x73, 
  0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x73, 0x20, 0x64, 0x75, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x63, 0x6F, 
  0x6D, 0x70, 0x69, 0x6C, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x2C, 0x20, 0x73, 0x6F, 0x20, 0x69, 0x74, 
  0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x20, 
  0x6D, 0x61, 0x63, 0x72, 0x6F, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x67, 0x65, 0x6E, 0x65, 0x72, 0x61, 
  0x74, 0x65, 0x20, 0x61, 0x75, 0x74, 0x6F, 0x6D, 0x61, 0x74, 0x69, 0x63, 0x20, 0x62, 0x69, 0x6E, 
  0x64, 0x69, 0x6E, 0x67, 0x73, 0x2E, 0xDA, 0x82, 0xDF, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x82, 0xE0, 
  0xDA, 0x09, 0xCE, 0x82, 0x97, 0x28, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x73, 0x74, 0x61, 
  0x74, 0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x6B, 
  0x65, 0x79, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x72, 
  0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6E, 0x74, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x6F, 0x66, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x6E, 0x61, 0x6C, 0x20, 0x73, 0x74, 
  0x61, 0x74, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 
  0x72, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x61, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x69, 0x73, 0x20, 0x70, 
  0x61, 0x73, 0x73, 0x65, 0x64, 0x2C, 0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x20, 0x74, 0x68, 0x61, 0x74, 
  0x20, 0x69, 0x6E, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x61, 0x62, 0x6F, 
  0x75, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x20, 0x69, 0x73, 0x20, 
  0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x65, 0x64, 0x2E, 0x20, 0x41, 0x6C, 0x6C, 0x6F, 0x77, 0x65, 
  0x64, 0x20, 0x6B, 0x65, 0x79, 0x73, 0x20, 0x61, 0x72, 0x65, 0x3A, 0x0A, 0x0A, 0x09, 0x3A, 0x64, 
  0x65, 0x6C, 0x69, 0x6D, 0x69, 0x74, 0x65, 0x72, 0x73, 0x20, 0x2D, 0x20, 0x45, 0x61, 0x63, 0x68, 
  0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x72, 
  0x69, 0x6E, 0x67, 0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x61, 
  0x20, 0x6E, 0x65, 0x73, 0x74, 0x65, 0x64, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 
  0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x2E, 0x20, 0x46, 0x6F, 0x72, 0x20, 0x65, 0x78, 0x61, 0x6D, 
  0x70, 0x6C, 0x65, 0x2C, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 
  0x65, 0x72, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x20, 0x69, 0x73, 0x20, 0x27, 0x28, 0x5B, 0x22, 
  0x27, 0x2C, 0x20, 0x74, 0x68, 0x65, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 
  0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x69, 0x64, 
  0x64, 0x6C, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x70, 0x61, 0x72, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x61, 
  0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x69, 0x6E, 0x73, 0x69, 0x64, 0x65, 0x20, 0x6F, 
  0x66, 0x20, 0x73, 0x71, 0x75, 0x61, 0x72, 0x65, 0x20, 0x62, 0x72, 0x61, 0x63, 0x6B, 0x65, 0x74, 
  0x73, 0x20, 0x69, 0x6E, 0x73, 0x69, 0x64, 0x65, 0x20, 0x70, 0x61, 0x72, 0x65, 0x6E, 0x74, 0x68, 
  0x65, 0x73, 0x65, 0x73, 0x2E, 0x20, 0x43, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 
  0x64, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x75, 0x67, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x61, 0x20, 0x52, 
  0x45, 0x50, 0x4C, 0x20, 0x70, 0x72, 0x6F, 0x6D, 0x70, 0x74, 0x2E, 0x09, 0x3A, 0x66, 0x72, 0x61, 
  0x6D, 0x65, 0x73, 0x20, 0x2D, 0x20, 0x45, 0x61, 0x63, 0x68, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 
  0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x72, 0x65, 
  0x70, 0x72, 0x65, 0x73, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x61, 0x20, 0x27, 0x66, 0x72, 0x61, 0x6D, 
  0x65, 0x27, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 
  0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x2E, 0x20, 0x46, 0x72, 0x61, 0x6D, 0x65, 0x73, 0x20, 0x63, 
  0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x69, 
  0x6F, 0x6E, 0x20, 0x61, 0x62, 0x6F, 0x75, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x61, 
  0x72, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 
  0x73, 0x69, 0x6F, 0x6E, 0x20, 0x62, 0x65, 0x69, 0x6E, 0x67, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 
  0x64, 0x20, 0x61, 0x73, 0x20, 0x77, 0x65, 0x6C, 0x6C, 0x20, 0x61, 0x73, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x74, 0x79, 0x70, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x65, 0x78, 
  0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x73, 0x6F, 0x6D, 
  0x65, 0x20, 0x74, 0x79, 0x70, 0x65, 0x2D, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x20, 
  0x69, 0x6E, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0xDA, 0x82, 0xE1, 0xD3, 
  0x02, 0xDA, 0x03, 0xDA, 0x07, 0xDA, 0x09, 0xCE, 0x80, 0xD1, 0x28, 0x74, 0x61, 0x62, 0x6C, 0x65, 
  0x20, 0x26, 0x20, 0x6B, 0x76, 0x73, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x73, 
  0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x66, 0x72, 0x6F, 
  0x6D, 0x20, 0x61, 0x20, 0x76, 0x61, 0x72, 0x69, 0x61, 0x64, 0x69, 0x63, 0x20, 0x6E, 0x75, 0x6D, 
  0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x6B, 0x65, 0x79, 0x73, 0x20, 0x61, 0x6E, 0x64, 0x20, 
  0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x2E, 0x20, 0x6B, 0x76, 0x73, 0x20, 0x69, 0x73, 0x20, 0x61, 
  0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6E, 0x63, 0x65, 0x20, 0x6B, 0x31, 0x2C, 0x20, 0x76, 0x31, 
  0x2C, 0x20, 0x6B, 0x32, 0x2C, 0x20, 0x76, 0x32, 0x2C, 0x20, 0x6B, 0x33, 0x2C, 0x20, 0x76, 0x33, 
  0x2C, 0x20, 0x2E, 0x2E, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x6B, 0x76, 0x73, 0x20, 0x68, 0x61, 0x73, 
  0x20, 0x61, 0x6E, 0x20, 0x6F, 0x64, 0x64, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 
  0x66, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x2C, 0x20, 0x61, 0x6E, 0x20, 0x65, 
  0x72, 0x72, 0x6F, 0x72, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x74, 0x68, 0x72, 
  0x6F, 0x77, 0x6E, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x6E, 0x65, 0x77, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0xDA, 0x82, 0xE2, 0xD3, 0x02, 
  0xDA, 0x03, 0xDA, 0x81, 0xEB, 0xDA, 0x09, 0xCE, 0x80, 0xA6, 0x28, 0x62, 0x75, 0x66, 0x66, 0x65, 
  0x72, 0x2F, 0x70, 0x75, 0x73, 0x68, 0x2D, 0x62, 0x79, 0x74, 0x65, 0x20, 0x62, 0x75, 0x66, 0x66, 
  0x65, 0x72, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x41, 0x70, 0x70, 0x65, 0x6E, 0x64, 0x20, 0x61, 0x20, 
  0x62, 0x79, 0x74, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 
  0x2E, 0x20, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x65, 0x78, 0x70, 0x61, 0x6E, 0x64, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x61, 0x73, 0x20, 0x6E, 0x65, 0x63, 0x65, 
  0x73, 0x73, 0x61, 0x72, 0x79, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x62, 0x75, 0x66, 0x66, 
  0x65, 0x72, 0x2E, 0x20, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x74, 0x68, 0x72, 0x6F, 0x77, 0x20, 0x61, 
  0x6E, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 
  0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x6F, 0x76, 0x65, 0x72, 0x66, 0x6C, 0x6F, 0x77, 0x73, 0x2E, 
  0xDA, 0x4A, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x49, 0xDA, 0x09, 0xCE, 0x59, 0x28, 0x62, 0x6F, 0x72, 
  0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x62, 0x69, 0x74, 0x2D, 0x77, 0x69, 0x73, 0x65, 0x20, 0x6F, 0x72, 0x20, 
  0x6F, 0x66, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x69, 0x6E, 
  0x20, 0x78, 0x73, 0x2E, 0x20, 0x45, 0x61, 0x63, 0x68, 0x20, 0x78, 0x20, 0x69, 0x6E, 0x20, 0x78, 
  0x73, 0x20, 0x6D, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x74, 
  0x65, 0x67, 0x65, 0x72, 0x2E, 0xDA, 0x82, 0xE3, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x82, 0xE4, 0xDA, 
  0x09, 0xCE, 0x81, 0x2E, 0x28, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 0x6C, 0x69, 0x6E, 0x65, 0x61, 
  0x67, 0x65, 0x20, 0x66, 0x69, 0x62, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x6C, 0x6C, 
  0x20, 0x63, 0x68, 0x69, 0x6C, 0x64, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x73, 0x20, 0x66, 0x72, 
  0x6F, 0x6D, 0x20, 0x61, 0x20, 0x72, 0x6F, 0x6F, 0x74, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2E, 
  0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x69, 
  0x73, 0x20, 0x75, 0x73, 0x65, 0x66, 0x75, 0x6C, 0x20, 0x77, 0x68, 0x65, 0x6E, 0x20, 0x61, 0x20, 
  0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0x73, 0x20, 0x6F, 0x72, 
  0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x6E, 
  0x63, 0x65, 0x73, 0x74, 0x6F, 0x72, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2E, 0x20, 0x55, 0x73, 
  0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 
  0x6E, 0x2C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x68, 0x61, 0x6E, 
  0x64, 0x6C, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 
  0x63, 0x61, 0x6E, 0x20, 0x73, 0x65, 0x65, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x66, 0x69, 
  0x62, 0x65, 0x72, 0x20, 0x72, 0x61, 0x69, 0x73, 0x65, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 
  0x69, 0x67, 0x6E, 0x61, 0x6C, 0x2E, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x66, 0x75, 0x6E, 0x63, 
  0x74, 0x69, 0x6F, 0x6E, 0x20, 0x73, 0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x62, 0x65, 0x20, 0x75, 
  0x73, 0x65, 0x64, 0x20, 0x6D, 0x6F, 0x73, 0x74, 0x6C, 0x79, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x64, 
  0x65, 0x62, 0x75, 0x67, 0x67, 0x69, 0x6E, 0x67, 0x20, 0x70, 0x75, 0x72, 0x70, 0x6F, 0x73, 0x65, 
  0x73, 0x2E, 0xDA, 0x82, 0xE5, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x82, 0xE7, 0xDA, 0x09, 0xCE, 0x81, 
  0x5C, 0x28, 0x61, 0x70, 0x70, 0x6C, 0x79, 0x20, 0x66, 0x20, 0x26, 0x20, 0x61, 0x72, 0x67, 0x73, 
  0x29, 0x0A, 0x0A, 0x41, 0x70, 0x70, 0x6C, 0x69, 0x65, 0x73, 0x20, 0x61, 0x20, 0x66, 0x75, 0x6E, 
  0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x76, 0x61, 0x72, 0x69, 0x61, 
  0x62, 0x6C, 0x65, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x72, 
  0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x2E, 0x20, 0x45, 0x61, 0x63, 0x68, 0x20, 0x65, 0x6C, 
  0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x72, 0x67, 0x73, 0x20, 0x69, 0x73, 
  0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x67, 0x75, 
  0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x66, 0x2C, 0x20, 0x65, 0x78, 0x63, 0x65, 0x70, 
  0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x61, 0x73, 0x74, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 
  0x6E, 0x74, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x72, 0x67, 0x73, 0x2C, 0x20, 0x77, 0x68, 0x69, 0x63, 
  0x68, 0x20, 0x69, 0x73, 0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x74, 0x6F, 
  0x20, 0x62, 0x65, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2D, 0x6C, 0x69, 0x6B, 
  0x65, 0x2E, 0x20, 0x45, 0x61, 0x63, 0x68, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 
  0x69, 0x6E, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x6C, 0x61, 0x73, 0x74, 0x20, 0x61, 0x72, 0x67, 
  0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x6E, 0x20, 0x61, 0x6C, 
  0x73, 0x6F, 0x20, 0x70, 0x75, 0x73, 0x68, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 0x61, 0x6E, 0x20, 
  0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x66, 0x2E, 0x20, 0x46, 
  0x6F, 0x72, 0x20, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x3A, 0x0A, 0x0A, 0x09, 0x28, 0x61, 
  0x70, 0x70, 0x6C, 0x79, 0x20, 0x2B, 0x20, 0x31, 0x30, 0x30, 0x30, 0x20, 0x28, 0x72, 0x61, 0x6E, 
  0x67, 0x65, 0x20, 0x31, 0x30, 0x29, 0x29, 0x0A, 0x0A, 0x73, 0x75, 0x6D, 0x73, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x31, 0x30, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 
  0x65, 0x72, 0x73, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x31, 0x30, 0x30, 0x30, 0x2E, 0xDA, 0x82, 0xE8, 
  0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x39, 0xDA, 0x09, 0xCE, 0x80, 0xD9, 0x28, 0x74, 0x79, 0x70, 0x65, 
  0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x74, 0x79, 0x70, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x20, 0x61, 0x73, 0x20, 0x61, 0x20, 
  0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 0x2E, 0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 0x6F, 0x6E, 
  0x65, 0x20, 0x6F, 0x66, 0x0A, 0x09, 0x3A, 0x6E, 0x69, 0x6C, 0x0A, 0x09, 0x3A, 0x62, 0x6F, 0x6F, 
  0x6C, 0x65, 0x61, 0x6E, 0x0A, 0x09, 0x3A, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x0A, 0x09, 0x3A, 
  0x61, 0x72, 0x72, 0x61, 0x79, 0x0A, 0x09, 0x3A, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x0A, 0x09, 0x3A, 
  0x74, 0x61, 0x62, 0x6C, 0x65, 0x0A, 0x09, 0x3A, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x0A, 0x09, 
  0x3A, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x0A, 0x09, 0x3A, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 
  0x0A, 0x09, 0x3A, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x0A, 0x09, 0x3A, 0x6B, 0x65, 0x79, 0x77, 
  0x6F, 0x72, 0x64, 0x0A, 0x09, 0x3A, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x0A, 0x09, 
  0x3A, 0x63, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x0A, 0x0A, 0x6F, 0x72, 0x20, 0x61, 
  0x6E, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x20, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 0x20, 0x66, 
  0x6F, 0x72, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x62, 0x73, 0x74, 0x72, 0x61, 0x63, 0x74, 0x20, 0x74, 
  0x79, 0x70, 0x65, 0x2E, 0xDA, 0x82, 0xE9, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x82, 0xEA, 0xDA, 0x09, 
  0xCE, 0x80, 0xCA, 0x28, 0x6E, 0x65, 0x74, 0x2F, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x68, 
  0x6F, 0x73, 0x74, 0x20, 0x70, 0x6F, 0x72, 0x74, 0x20, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x72, 
  0x29, 0x0A, 0x0A, 0x53, 0x74, 0x61, 0x72, 0x74, 0x20, 0x61, 0x20, 0x54, 0x43, 0x50, 0x20, 0x73, 
  0x65, 0x72, 0x76, 0x65, 0x72, 0x2E, 0x20, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x72, 0x20, 0x69, 
  0x73, 0x20, 0x61, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x61, 
  0x74, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x65, 0x64, 
  0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x20, 0x6F, 
  0x6E, 0x20, 0x65, 0x61, 0x63, 0x68, 0x20, 0x63, 0x6F, 0x6E, 0x6E, 0x65, 0x63, 0x74, 0x69, 0x6F, 
  0x6E, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x2E, 
  0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x73, 
  0x74, 0x72, 0x65, 0x61, 0x6D, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x65, 
  0x69, 0x74, 0x68, 0x65, 0x72, 0x20, 0x72, 0x65, 0x61, 0x64, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x6E, 
  0x6F, 0x72, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0xDA, 0x82, 0xEB, 
  0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x82, 0xED, 0xDA, 0x09, 0xCE, 0x80, 0xF2, 0x28, 0x71, 0x75, 0x69, 
  0x74, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x29, 0x0A, 0x0A, 0x54, 
  0x72, 0x69, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x65, 0x78, 0x69, 0x74, 0x20, 0x66, 0x72, 0x6F, 
  0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x72, 0x65, 
  0x70, 0x6C, 0x20, 0x6F, 0x72, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0x2E, 0x20, 0x44, 
  0x6F, 0x65, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x61, 0x6C, 0x77, 0x61, 0x79, 0x73, 0x20, 0x65, 
  0x78, 0x69, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x70, 0x70, 0x6C, 0x69, 0x63, 0x61, 0x74, 
  0x69, 0x6F, 0x6E, 0x2E, 0x20, 0x20, 0x57, 0x6F, 0x72, 0x6B, 0x73, 0x20, 0x62, 0x79, 0x20, 0x73, 
  0x65, 0x74, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x3A, 0x65, 0x78, 0x69, 0x74, 
  0x20, 0x64, 0x79, 0x6E, 0x61, 0x6D, 0x69, 0x63, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 
  0x20, 0x74, 0x6F, 0x20, 0x74, 0x72, 0x75, 0x65, 0x2E, 0x20, 0x50, 0x61, 0x73, 0x73, 0x69, 0x6E, 
  0x67, 0x20, 0x61, 0x20, 0x6E, 0x6F, 0x6E, 0x2D, 0x6E, 0x69, 0x6C, 0x20, 0x76, 0x61, 0x6C, 0x75, 
  0x65, 0x20, 0x68, 0x65, 0x72, 0x65, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x63, 0x61, 0x75, 0x73, 
  0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6F, 0x75, 0x74, 0x65, 0x72, 0x20, 0x20, 0x72, 0x75, 0x6E, 
  0x2D, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x72, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2E, 0xDA, 0x0B, 
  0xD2, 0x03, 0x00, 0xDA, 0x05, 0x88, 0x3E, 0x01, 0xDA, 0x82, 0xEE, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 
  0x82, 0xEF, 0xDA, 0x09, 0xCE, 0x4C, 0x28, 0x6F, 0x73, 0x2F, 0x72, 0x6D, 0x64, 0x69, 0x72, 0x20, 
  0x70, 0x61, 0x74, 0x68, 0x29, 0x0A, 0x0A, 0x44, 0x65, 0x6C, 0x65, 0x74, 0x65, 0x20, 0x61, 0x20, 
  0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x79, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x64, 
  0x69, 0x72, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x79, 0x20, 0x6D, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 
  0x20, 0x65, 0x6D, 0x70, 0x74, 0x79, 0x20, 0x74, 0x6F, 0x20, 0x73, 0x75, 0x63, 0x63, 0x65, 0x65, 
  0x64, 0x2E, 0xDA, 0x82, 0xF0, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x82, 0xF2, 0xDA, 0x09, 0xCE, 0x22, 
  0x28, 0x65, 0x6D, 0x70, 0x74, 0x79, 0x3F, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 
  0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x73, 0x20, 0x69, 0x73, 0x20, 0x65, 0x6D, 0x70, 0x74, 
  0x79, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x73, 0x01, 0xDA, 0x82, 0xF3, 0xD3, 0x02, 
  0xDA, 0x03, 0xDA, 0x82, 0xF4, 0xDA, 0x09, 0xCE, 0x7F, 0x28, 0x6F, 0x73, 0x2F, 0x61, 0x72, 0x63, 
  0x68, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x74, 0x68, 0x65, 0x20, 0x49, 0x53, 
  0x41, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x6A, 0x61, 0x6E, 0x65, 0x74, 0x20, 0x77, 0x61, 0x73, 
  0x20, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x2E, 0x20, 0x52, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6F, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x3A, 0x0A, 0x0A, 
  0x09, 0x3A, 0x78, 0x38, 0x36, 0x0A, 0x09, 0x3A, 0x78, 0x38, 0x36, 0x2D, 0x36, 0x34, 0x0A, 0x09, 
  0x3A, 0x61, 0x72, 0x6D, 0x0A, 0x09, 0x3A, 0x61, 0x61, 0x72, 0x63, 0x68, 0x36, 0x34, 0x0A, 0x09, 
  0x3A, 0x73, 0x70, 0x61, 0x72, 0x63, 0x0A, 0x09, 0x3A, 0x77, 0x61, 0x73, 0x6D, 0x0A, 0x09, 0x3A, 
  0x75, 0x6E, 0x6B, 0x6E, 0x6F, 0x77, 0x6E, 0x0A, 0xDA, 0x82, 0xF5, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 
  0x82, 0x9F, 0xDA, 0x09, 0xCE, 0x17, 0x28, 0x69, 0x6E, 0x63, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x78, 0x20, 0x2B, 0x20, 0x31, 0x2E, 0xDA, 0x0B, 0xD2, 
  0x03, 0x00, 0xDA, 0x05, 0x80, 0x81, 0x01, 0xDA, 0x82, 0xF6, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x82, 
  0xF8, 0xDA, 0x09, 0xCE, 0x59, 0x28, 0x62, 0x78, 0x6F, 0x72, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 
  0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x69, 
  0x74, 0x2D, 0x77, 0x69, 0x73, 0x65, 0x20, 0x78, 0x6F, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x6C, 
  0x6C, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x78, 0x73, 0x2E, 0x20, 
  0x45, 0x61, 0x63, 0x68, 0x20, 0x69, 0x6E, 0x20, 0x78, 0x73, 0x20, 0x6D, 0x75, 0x73, 0x74, 0x20, 
  0x62, 0x65, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x2E, 0xDA, 0x82, 
  0xF9, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x82, 0xFB, 0xDA, 0x09, 0xCE, 0x5F, 0x28, 0x63, 0x6F, 0x6D, 
  0x70, 0x61, 0x72, 0x65, 0x3E, 0x3D, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x45, 0x71, 
  0x75, 0x69, 0x76, 0x61, 0x6C, 0x65, 0x6E, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x27, 0x3E, 0x3D, 0x27, 
  0x20, 0x62, 0x75, 0x74, 0x20, 0x75, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x61, 
  0x72, 0x65, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x69, 0x6E, 0x73, 0x74, 
  0x65, 0x61, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x70, 0x72, 0x69, 0x6D, 0x69, 0x74, 0x69, 0x76, 0x65, 
  0x20, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x61, 0x74, 0x6F, 0x72, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 
  0xDA, 0x05, 0x82, 0xD5, 0x01, 0xDA, 0x82, 0xFC, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x81, 0x3F, 0xDA, 
  0x09, 0xCE, 0x80, 0xAC, 0x28, 0x77, 0x61, 0x6C, 0x6B, 0x20, 0x66, 0x20, 0x66, 0x6F, 0x72, 0x6D, 
  0x29, 0x0A, 0x0A, 0x49, 0x74, 0x65, 0x72, 0x61, 0x74, 0x65, 0x20, 0x6F, 0x76, 0x65, 0x72, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x73, 
  0x74, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x61, 0x70, 0x70, 0x6C, 0x79, 0x20, 0x66, 0x20, 0x20, 0x74, 
  0x6F, 0x20, 0x74, 0x68, 0x65, 0x6D, 0x2E, 0x20, 0x43, 0x6F, 0x6C, 0x6C, 0x65, 0x63, 0x74, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6C, 0x74, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x61, 
  0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x2E, 
  0x20, 0x49, 0x66, 0x20, 0x61, 0x73, 0x74, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x61, 
  0x20, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2C, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x2C, 
  0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2C, 0x20, 0x6F, 0x72, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 
  0x2C, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x2E, 
  0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x84, 0x48, 0x01, 0xDA, 0x82, 0xFD, 0xD3, 0x04, 0xDA, 
  0x03, 0xDA, 0x82, 0xFF, 0xDA, 0x09, 0xCE, 0x65, 0x28, 0x77, 0x69, 0x74, 0x68, 0x2D, 0x73, 0x79, 
  0x6D, 0x73, 0x20, 0x73, 0x79, 0x6D, 0x73, 0x20, 0x26, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x29, 0x0A, 
  0x0A, 0x45, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0x73, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x20, 
  0x77, 0x69, 0x74, 0x68, 0x20, 0x65, 0x61, 0x63, 0x68, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 
  0x20, 0x69, 0x6E, 0x20, 0x73, 0x79, 0x6D, 0x73, 0x20, 0x62, 0x6F, 0x75, 0x6E, 0x64, 0x20, 0x74, 
  0x6F, 0x20, 0x61, 0x20, 0x67, 0x65, 0x6E, 0x65, 0x72, 0x61, 0x74, 0x65, 0x64, 0x2C, 0x20, 0x75, 
  0x6E, 0x69, 0x71, 0x75, 0x65, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x2E, 0xDA, 0x0B, 0xD2, 
  0x03, 0x00, 0xDA, 0x05, 0x81, 0x1F, 0x01, 0xDA, 0x35, 0xCB, 0xDA, 0x83, 0x00, 0xD3, 0x02, 0xDA, 
  0x03, 0xDA, 0x29, 0xDA, 0x09, 0xCE, 0x81, 0x91, 0x28, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2F, 0x73, 
  0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x66, 0x69, 0x62, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x20, 
  0x66, 0x69, 0x62, 0x65, 0x72, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 
  0x73, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x6F, 0x6E, 0x65, 0x20, 0x6F, 0x66, 
  0x3A, 0x0A, 0x0A, 0x09, 0x3A, 0x64, 0x65, 0x61, 0x64, 0x20, 0x2D, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x68, 0x61, 0x73, 0x20, 0x66, 0x69, 0x6E, 0x69, 0x73, 0x68, 
  0x65, 0x64, 0x0A, 0x09, 0x3A, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x2D, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x68, 0x61, 0x73, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 
  0x65, 0x64, 0x20, 0x6F, 0x75, 0x74, 0x0A, 0x09, 0x3A, 0x64, 0x65, 0x62, 0x75, 0x67, 0x20, 0x2D, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x73, 0x75, 
  0x73, 0x70, 0x65, 0x6E, 0x64, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x20, 0x64, 0x65, 0x62, 0x75, 0x67, 
  0x20, 0x6D, 0x6F, 0x64, 0x65, 0x0A, 0x09, 0x3A, 0x70, 0x65, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 
  0x2D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x68, 0x61, 0x73, 0x20, 
  0x62, 0x65, 0x65, 0x6E, 0x20, 0x79, 0x69, 0x65, 0x6C, 0x64, 0x65, 0x64, 0x0A, 0x09, 0x3A, 0x75, 
  0x73, 0x65, 0x72, 0x28, 0x30, 0x2D, 0x39, 0x29, 0x20, 0x2D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 
  0x69, 0x62, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x73, 0x75, 0x73, 0x70, 0x65, 0x6E, 0x64, 0x65, 
  0x64, 0x20, 0x62, 0x79, 0x20, 0x61, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x73, 0x69, 0x67, 0x6E, 
  0x61, 0x6C, 0x0A, 0x09, 0x3A, 0x61, 0x6C, 0x69, 0x76, 0x65, 0x20, 0x2D, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 
  0x74, 0x6C, 0x79, 0x20, 0x72, 0x75, 0x6E, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x6E, 0x64, 0x20, 
  0x63, 0x61, 0x6E, 0x6E, 0x6F, 0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6D, 0x65, 
  0x64, 0x0A, 0x09, 0x3A, 0x6E, 0x65, 0x77, 0x20, 0x2D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 
  0x62, 0x65, 0x72, 0x20, 0x68, 0x61, 0x73, 0x20, 0x6A, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x65, 
  0x6E, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x6E, 0x6F, 
  0x74, 0x20, 0x79, 0x65, 0x74, 0x20, 0x72, 0x75, 0x6E, 0xDA, 0x83, 0x01, 0xD3, 0x02, 0xDA, 0x03, 
  0xDA, 0x83, 0x02, 0xDA, 0x09, 0xCE, 0x31, 0x28, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x2F, 0x63, 
  0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x72, 0x75, 0x6E, 0x6E, 0x69, 0x6E, 0x67, 
  0x20, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x2E, 0xDA, 0x83, 0x03, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 
  0x83, 0x04, 0xDA, 0x09, 0xCE, 0x80, 0x90, 0x28, 0x66, 0x69, 0x6C, 0x65, 0x2F, 0x66, 0x6C, 0x75, 
  0x73, 0x68, 0x20, 0x66, 0x29, 0x0A, 0x0A, 0x46, 0x6C, 0x75, 0x73, 0x68, 0x20, 0x61, 0x6E, 0x79, 
  0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x65, 0x64, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 
  0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x73, 0x79, 0x73, 0x74, 
  0x65, 0x6D, 0x2E, 0x20, 0x49, 0x6E, 0x20, 0x6D, 0x6F, 0x73, 0x74, 0x20, 0x66, 0x69, 0x6C, 0x65, 
  0x73, 0x2C, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x62, 0x75, 
  0x66, 0x66, 0x65, 0x72, 0x65, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x65, 0x66, 0x66, 0x69, 0x63, 
  0x69, 0x65, 0x6E, 0x63, 0x79, 0x20, 0x72, 0x65, 0x61, 0x73, 0x6F, 0x6E, 0x73, 0x2E, 0x20, 0x52, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 
  0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x2E, 0xDA, 0x83, 0x05, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x83, 
  0x06, 0xDA, 0x09, 0xCE, 0x80, 0x83, 0x28, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x6E, 0x65, 
  0x77, 0x20, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 
  0x61, 0x74, 0x65, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x2C, 0x20, 0x65, 0x6D, 0x70, 0x74, 
  0x79, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x65, 0x6E, 
  0x6F, 0x75, 0x67, 0x68, 0x20, 0x62, 0x61, 0x63, 0x6B, 0x69, 0x6E, 0x67, 0x20, 0x6D, 0x65, 0x6D, 
  0x6F, 0x72, 0x79, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 
  0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 
  0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 
  0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x20, 0x30, 0x2E, 0xDA, 0x83, 0x07, 0xD3, 0x02, 0xDA, 0x03, 
  0xDA, 0x83, 0x08, 0xDA, 0x09, 0xCE, 0x29, 0x28, 0x6F, 0x73, 0x2F, 0x72, 0x6D, 0x20, 0x70, 0x61, 
  0x74, 0x68, 0x29, 0x0A, 0x0A, 0x44, 0x65, 0x6C, 0x65, 0x74, 0x65, 0x20, 0x61, 0x20, 0x66, 0x69, 
  0x6C, 0x65, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 
  0xDA, 0x83, 0x09, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x83, 0x0B, 0xDA, 0x09, 0xCE, 0x55, 0x28, 0x74, 
  0x61, 0x6B, 0x65, 0x20, 0x6E, 0x20, 0x69, 0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x54, 0x61, 0x6B, 0x65, 
  0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x6E, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 
  0x73, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x65, 0x64, 0x20, 
  0x74, 0x79, 0x70, 0x65, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 0x65, 
  0x77, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x73, 0x74, 0x61, 0x6E, 
  0x63, 0x65, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x83, 0xAA, 0x01, 0xDA, 0x83, 0x0C, 
  0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x81, 0x40, 0xDA, 0x09, 0xCE, 0x65, 0x28, 0x70, 0x6F, 0x73, 0x74, 
  0x77, 0x61, 0x6C, 0x6B, 0x20, 0x66, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x29, 0x0A, 0x0A, 0x44, 0x6F, 
  0x20, 0x61, 0x20, 0x70, 0x6F, 0x73, 0x74, 0x2D, 0x6F, 0x72, 0x64, 0x65, 0x72, 0x20, 0x74, 0x72, 
  0x61, 0x76, 0x65, 0x72, 0x73, 0x61, 0x6C, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x20, 0x64, 0x61, 0x74, 
  0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x20, 0x61, 0x6E, 0x64, 0x20, 
  0x63, 0x61, 0x6C, 0x6C, 0x20, 0x28, 0x66, 0x20, 0x78, 0x29, 0x20, 0x20, 0x6F, 0x6E, 0x20, 0x65, 
  0x76, 0x65, 0x72, 0x79, 0x20, 0x76, 0x69, 0x73, 0x69, 0x74, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 
  0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x84, 0x58, 0x01, 0xDA, 0x83, 0x0D, 0xD3, 0x03, 0xDA, 
  0x03, 0xDA, 0x80, 0xCD, 0xDA, 0x09, 0xCE, 0x58, 0x54, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x6D, 0x61, 
  0x70, 0x70, 0x69, 0x6E, 0x67, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x6C, 0x79, 0x20, 
  0x6C, 0x6F, 0x61, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x73, 0x20, 
  0x74, 0x6F, 0x20, 0x74, 0x72, 0x75, 0x65, 0x2E, 0x20, 0x55, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6F, 
  0x20, 0x70, 0x72, 0x65, 0x76, 0x65, 0x6E, 0x74, 0x20, 0x20, 0x63, 0x69, 0x72, 0x63, 0x75, 0x6C, 
  0x61, 0x72, 0x20, 0x64, 0x65, 0x70, 0x65, 0x6E, 0x64, 0x65, 0x6E, 0x63, 0x69, 0x65, 0x73, 0x2E, 
  0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x88, 0xF1, 0x01, 0xDA, 0x83, 0x0E, 0xD3, 0x02, 0xDA, 
  0x03, 0xDA, 0x83, 0x0F, 0xDA, 0x09, 0xCE, 0x80, 0x9D, 0x28, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 
  0x2F, 0x74, 0x72, 0x69, 0x6D, 0x6C, 0x20, 0x73, 0x74, 0x72, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 
  0x73, 0x65, 0x74, 0x29, 0x0A, 0x0A, 0x54, 0x72, 0x69, 0x6D, 0x20, 0x6C, 0x65, 0x61, 0x64, 0x69, 
  0x6E, 0x67, 0x20, 0x77, 0x68, 0x69, 0x74, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20, 0x66, 0x72, 
  0x6F, 0x6D, 0x20, 0x61, 0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6E, 
  0x63, 0x65, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 
  0x65, 0x6E, 0x74, 0x20, 0x73, 0x65, 0x74, 0x20, 0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x76, 0x69, 
  0x64, 0x65, 0x64, 0x2C, 0x20, 0x63, 0x6F, 0x6E, 0x73, 0x69, 0x64, 0x65, 0x72, 0x20, 0x6F, 0x6E, 
  0x6C, 0x79, 0x20, 0x63, 0x68, 0x61, 0x72, 0x61, 0x63, 0x74, 0x65, 0x72, 0x73, 0x20, 0x69, 0x6E, 
  0x20, 0x73, 0x65, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x62, 0x65, 0x20, 0x77, 0x68, 0x69, 0x74, 0x65, 
  0x73, 0x70, 0x61, 0x63, 0x65, 0x2E, 0xDA, 0x76, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 0x75, 0xDA, 0x09, 
  0xCE, 0x4A, 0x28, 0x64, 0x65, 0x66, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x2D, 0x20, 0x6E, 0x61, 0x6D, 
  0x65, 0x20, 0x26, 0x20, 0x6D, 0x6F, 0x72, 0x65, 0x29, 0x0A, 0x0A, 0x44, 0x65, 0x66, 0x69, 0x6E, 
  0x65, 0x20, 0x61, 0x20, 0x70, 0x72, 0x69, 0x76, 0x61, 0x74, 0x65, 0x20, 0x6D, 0x61, 0x63, 0x72, 
  0x6F, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x6E, 0x6F, 0x74, 0x20, 
  0x62, 0x65, 0x20, 0x65, 0x78, 0x70, 0x6F, 0x72, 0x74, 0x65, 0x64, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 
  0x00, 0xDA, 0x05, 0x2E, 0x01, 0xDA, 0x35, 0xCB, 0xDA, 0x83, 0x10, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 
  0x83, 0x11, 0xDA, 0x09, 0xCE, 0x80, 0xD1, 0x28, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x63, 
  0x6C, 0x6F, 0x6E, 0x65, 0x20, 0x70, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x73, 
  0x20, 0x61, 0x20, 0x64, 0x65, 0x65, 0x70, 0x20, 0x63, 0x6C, 0x6F, 0x6E, 0x65, 0x20, 0x6F, 0x66, 
  0x20, 0x61, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 
  0x73, 0x20, 0x69, 0x64, 0x65, 0x6E, 0x74, 0x69, 0x63, 0x61, 0x6C, 0x20, 0x74, 0x6F, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x69, 0x6E, 0x70, 0x75, 0x74, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2E, 
  0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x63, 0x6C, 0x6F, 0x6E, 0x65, 0x64, 0x20, 0x70, 0x61, 0x72, 
  0x73, 0x65, 0x72, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 
  0x74, 0x6F, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x69, 0x6E, 0x75, 0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 
  0x69, 0x6E, 0x67, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x61, 0x20, 0x67, 0x6F, 0x6F, 0x64, 0x20, 
  0x63, 0x68, 0x65, 0x63, 0x6B, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x20, 0x69, 0x66, 0x20, 0x70, 0x61, 
  0x72, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x6C, 0x61, 0x74, 0x65, 0x72, 0x20, 0x66, 0x61, 0x69, 0x6C, 
  0x73, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 
  0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2E, 0xDA, 0x83, 0x12, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 
  0x83, 0x13, 0xDA, 0x09, 0xCE, 0x81, 0x30, 0x28, 0x6F, 0x73, 0x2F, 0x6D, 0x6B, 0x74, 0x69, 0x6D, 
  0x65, 0x20, 0x64, 0x61, 0x74, 0x65, 0x2D, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x20, 0x26, 0x6F, 
  0x70, 0x74, 0x20, 0x6C, 0x6F, 0x63, 0x61, 0x6C, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x62, 0x72, 0x6F, 0x6B, 0x65, 0x6E, 0x20, 0x64, 0x6F, 0x77, 0x6E, 0x20, 0x64, 
  0x61, 0x74, 0x65, 0x2D, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x20, 
  0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x20, 0x6F, 0x66, 0x20, 0x73, 0x65, 0x63, 0x6F, 
  0x6E, 0x64, 0x73, 0x20, 0x73, 0x69, 0x6E, 0x63, 0x65, 0x20, 0x4A, 0x61, 0x6E, 0x75, 0x61, 0x72, 
  0x79, 0x20, 0x31, 0x2C, 0x20, 0x31, 0x39, 0x37, 0x30, 0x2C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x55, 
  0x6E, 0x69, 0x78, 0x20, 0x65, 0x70, 0x6F, 0x63, 0x68, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x73, 0x20, 0x61, 0x20, 0x72, 0x65, 0x61, 0x6C, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 
  0x2E, 0x20, 0x44, 0x61, 0x74, 0x65, 0x20, 0x69, 0x73, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 
  0x69, 0x6E, 0x20, 0x55, 0x54, 0x43, 0x20, 0x75, 0x6E, 0x6C, 0x65, 0x73, 0x73, 0x20, 0x6C, 0x6F, 
  0x63, 0x61, 0x6C, 0x20, 0x69, 0x73, 0x20, 0x74, 0x72, 0x75, 0x74, 0x68, 0x79, 0x2C, 0x20, 0x69, 
  0x6E, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x63, 0x61, 0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x64, 0x61, 0x74, 0x65, 0x20, 0x69, 0x73, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x75, 0x74, 0x65, 
  0x64, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x6F, 0x63, 0x61, 0x6C, 0x20, 
  0x74, 0x69, 0x6D, 0x65, 0x7A, 0x6F, 0x6E, 0x65, 0x2E, 0x0A, 0x0A, 0x49, 0x6E, 0x76, 0x65, 0x72, 
  0x73, 0x65, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x74, 0x6F, 0x20, 0x6F, 
  0x73, 0x2F, 0x64, 0x61, 0x74, 0x65, 0x2E, 0xDA, 0x83, 0x14, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x80, 
  0xD0, 0xDA, 0x09, 0xCE, 0x80, 0x88, 0x41, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x6F, 0x66, 
  0x20, 0x6C, 0x6F, 0x61, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x6D, 0x65, 0x74, 0x68, 0x6F, 0x64, 0x20, 
  0x6E, 0x61, 0x6D, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x6C, 0x6F, 0x61, 0x64, 0x69, 0x6E, 0x67, 
  0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x2E, 0x20, 0x20, 0x54, 0x68, 0x69, 
  0x73, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x6C, 0x65, 0x74, 0x73, 0x20, 0x72, 0x65, 0x71, 
  0x75, 0x69, 0x72, 0x65, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x69, 0x6D, 0x70, 0x6F, 0x72, 0x74, 0x20, 
  0x6C, 0x6F, 0x61, 0x64, 0x20, 0x6D, 0x61, 0x6E, 0x79, 0x20, 0x64, 0x69, 0x66, 0x66, 0x65, 0x72, 
  0x65, 0x6E, 0x74, 0x20, 0x6B, 0x69, 0x6E, 0x64, 0x73, 0x20, 0x20, 0x6F, 0x66, 0x20, 0x66, 0x69, 
  0x6C, 0x65, 0x73, 0x20, 0x61, 0x73, 0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2E, 0xDA, 0x0B, 
  0xD2, 0x03, 0x00, 0xDA, 0x05, 0x89, 0x23, 0x01, 0xDA, 0x80, 0x8A, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 
  0x80, 0x89, 0xDA, 0x09, 0xCE, 0x2E, 0x28, 0x64, 0x69, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x72, 
  0x79, 0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 
  0x78, 0x20, 0x61, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x6F, 0x72, 0x20, 0x73, 0x74, 0x72, 
  0x75, 0x63, 0x74, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x69, 0x01, 0xDA, 0x83, 0x15, 
  0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x83, 0x1A, 0xDA, 0x09, 0xCE, 0x80, 0xDE, 0x28, 0x72, 0x61, 0x6E, 
  0x67, 0x65, 0x20, 0x26, 0x20, 0x61, 0x72, 0x67, 0x73, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 
  0x74, 0x65, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x6F, 0x66, 0x20, 0x76, 
  0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x5B, 0x73, 0x74, 0x61, 0x72, 0x74, 0x2C, 0x20, 0x65, 0x6E, 
  0x64, 0x29, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 
  0x73, 0x74, 0x65, 0x70, 0x2E, 0x20, 0x20, 0x57, 0x69, 0x74, 0x68, 0x20, 0x6F, 0x6E, 0x65, 0x20, 
  0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x61, 0x20, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x5B, 0x30, 0x2C, 0x20, 0x65, 0x6E, 0x64, 
  0x29, 0x2E, 0x20, 0x57, 0x69, 0x74, 0x68, 0x20, 0x74, 0x77, 0x6F, 0x20, 0x61, 0x72, 0x67, 0x75, 
  0x6D, 0x65, 0x6E, 0x74, 0x73, 0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x20, 
  0x61, 0x20, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x5B, 0x73, 0x74, 0x61, 0x72, 0x74, 0x2C, 0x20, 
  0x65, 0x6E, 0x64, 0x29, 0x2E, 0x20, 0x57, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x72, 0x65, 0x65, 
  0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x72, 0x61, 0x6E, 0x67, 
  0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x20, 
  0x73, 0x74, 0x65, 0x70, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 
  0x05, 0x83, 0x7F, 0x01, 0xDA, 0x82, 0x9C, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x59, 0xDA, 0x09, 0xCE, 
  0x3F, 0x28, 0x3C, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 
  0x20, 0x69, 0x66, 0x20, 0x78, 0x73, 0x20, 0x69, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x73, 0x63, 
  0x65, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x6F, 0x72, 0x64, 0x65, 0x72, 0x2E, 0x20, 0x52, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x62, 0x6F, 0x6F, 0x6C, 0x65, 0x61, 0x6E, 0x2E, 
  0xDA, 0x83, 0x1B, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x83, 0x1C, 0xDA, 0x09, 0xCE, 0x80, 0xE8, 0x28, 
  0x6F, 0x73, 0x2F, 0x6C, 0x69, 0x6E, 0x6B, 0x20, 0x6F, 0x6C, 0x64, 0x70, 0x61, 0x74, 0x68, 0x20, 
  0x6E, 0x65, 0x77, 0x70, 0x61, 0x74, 0x68, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x73, 0x79, 0x6D, 
  0x6C, 0x69, 0x6E, 0x6B, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 
  0x6C, 0x69, 0x6E, 0x6B, 0x20, 0x61, 0x74, 0x20, 0x6E, 0x65, 0x77, 0x70, 0x61, 0x74, 0x68, 0x20, 
  0x74, 0x68, 0x61, 0x74, 0x20, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x6F, 
  0x6C, 0x64, 0x70, 0x61, 0x74, 0x68, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0x20, 0x49, 0x66, 0x66, 0x20, 0x73, 0x79, 0x6D, 0x6C, 
  0x69, 0x6E, 0x6B, 0x20, 0x69, 0x73, 0x20, 0x74, 0x72, 0x75, 0x74, 0x68, 0x79, 0x2C, 0x20, 0x63, 
  0x72, 0x65, 0x61, 0x74, 0x65, 0x73, 0x20, 0x61, 0x20, 0x73, 0x79, 0x6D, 0x6C, 0x69, 0x6E, 0x6B, 
  0x2E, 0x20, 0x49, 0x66, 0x66, 0x20, 0x73, 0x79, 0x6D, 0x6C, 0x69, 0x6E, 0x6B, 0x20, 0x69, 0x73, 
  0x20, 0x66, 0x61, 0x6C, 0x73, 0x65, 0x79, 0x20, 0x6F, 0x72, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x70, 
  0x72, 0x6F, 0x76, 0x69, 0x64, 0x65, 0x64, 0x2C, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x73, 
  0x20, 0x61, 0x20, 0x68, 0x61, 0x72, 0x64, 0x20, 0x6C, 0x69, 0x6E, 0x6B, 0x2E, 0x20, 0x44, 0x6F, 
  0x65, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x77, 0x6F, 0x72, 0x6B, 0x20, 0x6F, 0x6E, 0x20, 0x57, 
  0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x2E, 0xDA, 0x83, 0x1D, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x83, 
  0x1E, 0xDA, 0x09, 0xCE, 0x80, 0xBE, 0x28, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x61, 0x73, 
  0x63, 0x69, 0x69, 0x2D, 0x6C, 0x6F, 0x77, 0x65, 0x72, 0x20, 0x73, 0x74, 0x72, 0x29, 0x0A, 0x0A, 
  0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x73, 0x74, 
  0x72, 0x69, 0x6E, 0x67, 0x20, 0x77, 0x68, 0x65, 0x72, 0x65, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x62, 
  0x79, 0x74, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x72, 0x65, 0x70, 0x6C, 0x61, 0x63, 0x65, 
  0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x6F, 0x77, 0x65, 0x72, 
  0x63, 0x61, 0x73, 0x65, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x6F, 0x66, 0x20, 
  0x74, 0x68, 0x65, 0x6D, 0x73, 0x65, 0x6C, 0x76, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x41, 0x53, 
  0x43, 0x49, 0x49, 0x2E, 0x20, 0x44, 0x6F, 0x65, 0x73, 0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x20, 0x61, 
  0x20, 0x76, 0x65, 0x72, 0x79, 0x20, 0x73, 0x69, 0x6D, 0x70, 0x6C, 0x65, 0x20, 0x63, 0x61, 0x73, 
  0x65, 0x20, 0x63, 0x68, 0x65, 0x63, 0x6B, 0x2C, 0x20, 0x6D, 0x65, 0x61, 0x6E, 0x69, 0x6E, 0x67, 
  0x20, 0x6E, 0x6F, 0x20, 0x75, 0x6E, 0x69, 0x63, 0x6F, 0x64, 0x65, 0x20, 0x73, 0x75, 0x70, 0x70, 
  0x6F, 0x72, 0x74, 0x2E, 0xDA, 0x83, 0x1F, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x83, 0x21, 0xDA, 0x09, 
  0xCE, 0x80, 0xC7, 0x28, 0x2F, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x71, 0x75, 0x6F, 0x74, 0x69, 0x65, 0x6E, 
  0x74, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x73, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x78, 0x73, 0x20, 0x69, 
  0x73, 0x20, 0x65, 0x6D, 0x70, 0x74, 0x79, 0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x31, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x78, 0x73, 0x20, 0x68, 0x61, 0x73, 0x20, 0x6F, 0x6E, 
  0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x78, 0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x63, 0x69, 0x70, 0x72, 0x6F, 0x63, 0x61, 
  0x6C, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x2E, 0x20, 0x4F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 
  0x65, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 
  0x73, 0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x73, 0x20, 0x72, 
  0x65, 0x70, 0x65, 0x61, 0x74, 0x65, 0x64, 0x6C, 0x79, 0x20, 0x64, 0x69, 0x76, 0x69, 0x64, 0x65, 
  0x64, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x6D, 0x61, 0x69, 0x6E, 0x69, 
  0x6E, 0x67, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x2E, 0xDA, 0x83, 0x22, 0xD3, 0x02, 0xDA, 
  0x03, 0xDA, 0x83, 0x23, 0xDA, 0x09, 0xCE, 0x50, 0x28, 0x67, 0x63, 0x63, 0x6F, 0x6C, 0x6C, 0x65, 
  0x63, 0x74, 0x29, 0x0A, 0x0A, 0x52, 0x75, 0x6E, 0x20, 0x67, 0x61, 0x72, 0x62, 0x61, 0x67, 0x65, 
  0x20, 0x63, 0x6F, 0x6C, 0x6C, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0x20, 0x59, 0x6F, 0x75, 
  0x20, 0x73, 0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x70, 0x72, 0x6F, 0x62, 0x61, 0x62, 0x6C, 0x79, 
  0x20, 0x6E, 0x6F, 0x74, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x6D, 
  0x61, 0x6E, 0x75, 0x61, 0x6C, 0x6C, 0x79, 0x2E, 0xDA, 0x83, 0x24, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 
  0x83, 0x2E, 0xDA, 0x09, 0xCE, 0x6C, 0x28, 0x74, 0x72, 0x61, 0x63, 0x65, 0x76, 0x20, 0x78, 0x29, 
  0x0A, 0x0A, 0x50, 0x72, 0x69, 0x6E, 0x74, 0x20, 0x61, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 
  0x61, 0x6E, 0x64, 0x20, 0x61, 0x20, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6F, 
  0x6E, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x20, 0x74, 0x68, 
  0x61, 0x74, 0x20, 0x70, 0x72, 0x6F, 0x64, 0x75, 0x63, 0x65, 0x64, 0x20, 0x74, 0x68, 0x61, 0x74, 
  0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x20, 0x73, 0x74, 0x64, 0x65, 0x72, 
  0x72, 0x2E, 0x20, 0x45, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 
  0x78, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x83, 0xF3, 0x01, 0xDA, 0x35, 0xCB, 0xDA, 
  0x83, 0x2F, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x83, 0x30, 0xDA, 0x09, 0xCE, 0x70, 0x28, 0x67, 0x63, 
  0x69, 0x6E, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6C, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x6E, 
  0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x74, 
  0x6F, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x20, 0x62, 0x65, 0x66, 0x6F, 0x72, 
  0x65, 0x20, 0x72, 0x75, 0x6E, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x74, 0x65, 
  0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x6F, 0x66, 0x20, 0x67, 0x61, 0x72, 0x62, 0x61, 0x67, 
  0x65, 0x20, 0x63, 0x6F, 0x6C, 0x6C, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0xDA, 0x83, 0x31, 
  0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x82, 0x31, 0xDA, 0x09, 0xCE, 0x80, 0xA4, 0x28, 0x73, 0x79, 0x6D, 
  0x62, 0x6F, 0x6C, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 
  0x65, 0x73, 0x20, 0x61, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x20, 0x62, 0x79, 0x20, 0x63, 
  0x6F, 0x6E, 0x63, 0x61, 0x74, 0x65, 0x6E, 0x61, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x76, 0x61, 0x6C, 
  0x75, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x67, 0x65, 0x74, 0x68, 0x65, 0x72, 0x2E, 0x20, 0x56, 0x61, 
  0x6C, 0x75, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x63, 0x6F, 0x6E, 0x76, 0x65, 0x72, 0x74, 
  0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x76, 0x69, 0x61, 0x20, 
  0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x79, 
  0x20, 0x61, 0x72, 0x65, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 0x73, 0x65, 
  0x71, 0x75, 0x65, 0x6E, 0x63, 0x65, 0x73, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x2E, 
  0xDA, 0x83, 0x34, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x83, 0x35, 0xDA, 0x09, 0xCE, 0x47, 0x28, 0x6F, 
  0x73, 0x2F, 0x73, 0x68, 0x65, 0x6C, 0x6C, 0x20, 0x73, 0x74, 0x72, 0x29, 0x0A, 0x0A, 0x50, 0x61, 
  0x73, 0x73, 0x20, 0x61, 0x20, 0x63, 0x6F, 0x6D, 0x6D, 0x61, 0x6E, 0x64, 0x20, 0x73, 0x74, 0x72, 
  0x69, 0x6E, 0x67, 0x20, 0x73, 0x74, 0x72, 0x20, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6C, 0x79, 
  0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x20, 0x73, 
  0x68, 0x65, 0x6C, 0x6C, 0x2E, 0xDA, 0x83, 0x36, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x81, 0xA6, 0xDA, 
  0x09, 0xCE, 0x45, 0x28, 0x3C, 0x3D, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x43, 0x68, 
  0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x73, 0x20, 0x69, 0x73, 0x20, 0x69, 0x6E, 0x20, 
  0x6E, 0x6F, 0x6E, 0x2D, 0x64, 0x65, 0x73, 0x63, 0x65, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x6F, 
  0x72, 0x64, 0x65, 0x72, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 
  0x62, 0x6F, 0x6F, 0x6C, 0x65, 0x61, 0x6E, 0x2E, 0xDA, 0x83, 0x37, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 
  0x81, 0x62, 0xDA, 0x09, 0xCE, 0x2A, 0x28, 0x6E, 0x6F, 0x74, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x6F, 0x6F, 0x6C, 0x65, 
  0x61, 0x6E, 0x20, 0x69, 0x6E, 0x76, 0x65, 0x72, 0x73, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x2E, 
  0xDA, 0x83, 0x38, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x83, 0x3A, 0xDA, 0x09, 0xCE, 0x59, 0x28, 0x65, 
  0x76, 0x65, 0x72, 0x79, 0x3F, 0x20, 0x69, 0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x73, 0x20, 0x74, 0x72, 0x75, 0x65, 0x20, 0x69, 0x66, 0x20, 0x65, 0x61, 0x63, 0x68, 
  0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x69, 0x73, 0x20, 0x74, 0x72, 0x75, 
  0x74, 0x68, 0x79, 0x2C, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x20, 0x66, 0x61, 0x6C, 0x73, 0x65, 0x79, 
  0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x84, 0x9F, 
  0x01, 0xDA, 0x83, 0x3B, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x83, 0x3C, 0xDA, 0x09, 0xCE, 0x41, 0x28, 
  0x74, 0x72, 0x61, 0x63, 0x65, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x29, 0x0A, 0x0A, 0x45, 0x6E, 0x61, 
  0x62, 0x6C, 0x65, 0x20, 0x74, 0x72, 0x61, 0x63, 0x69, 0x6E, 0x67, 0x20, 0x6F, 0x6E, 0x20, 0x61, 
  0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 
  0xDA, 0x83, 0x3D, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x83, 0x3E, 0xDA, 0x09, 0xCE, 0x80, 0xBE, 0x28, 
  0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x61, 0x73, 0x63, 0x69, 0x69, 0x2D, 0x75, 0x70, 0x70, 
  0x65, 0x72, 0x20, 0x73, 0x74, 0x72, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x77, 0x68, 
  0x65, 0x72, 0x65, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x61, 0x72, 
  0x65, 0x20, 0x72, 0x65, 0x70, 0x6C, 0x61, 0x63, 0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x75, 0x70, 0x70, 0x65, 0x72, 0x63, 0x61, 0x73, 0x65, 0x20, 0x76, 0x65, 
  0x72, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x6D, 0x73, 0x65, 0x6C, 
  0x76, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x41, 0x53, 0x43, 0x49, 0x49, 0x2E, 0x20, 0x44, 0x6F, 
  0x65, 0x73, 0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x20, 0x61, 0x20, 0x76, 0x65, 0x72, 0x79, 0x20, 0x73, 
  0x69, 0x6D, 0x70, 0x6C, 0x65, 0x20, 0x63, 0x61, 0x73, 0x65, 0x20, 0x63, 0x68, 0x65, 0x63, 0x6B, 
  0x2C, 0x20, 0x6D, 0x65, 0x61, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x6E, 0x6F, 0x20, 0x75, 0x6E, 0x69, 
  0x63, 0x6F, 0x64, 0x65, 0x20, 0x73, 0x75, 0x70, 0x70, 0x6F, 0x72, 0x74, 0x2E, 0xDA, 0x83, 0x3F, 
  0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x83, 0x40, 0xDA, 0x09, 0xCE, 0x80, 0x8E, 0x28, 0x66, 0x69, 0x62, 
  0x65, 0x72, 0x2F, 0x73, 0x65, 0x74, 0x6D, 0x61, 0x78, 0x73, 0x74, 0x61, 0x63, 0x6B, 0x20, 0x66, 
  0x69, 0x62, 0x20, 0x6D, 0x61, 0x78, 0x73, 0x74, 0x61, 0x63, 0x6B, 0x29, 0x0A, 0x0A, 0x53, 0x65, 
  0x74, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x61, 0x78, 0x69, 0x6D, 0x75, 0x6D, 0x20, 0x73, 
  0x74, 0x61, 0x63, 0x6B, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x6A, 0x61, 0x6E, 
  0x65, 0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x61, 0x20, 
  0x66, 0x69, 0x62, 0x65, 0x72, 0x2E, 0x20, 0x42, 0x79, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 
  0x74, 0x2C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x61, 0x78, 0x69, 0x6D, 0x75, 0x6D, 0x20, 0x73, 
  0x74, 0x61, 0x63, 0x6B, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x20, 0x69, 0x73, 0x20, 0x75, 0x73, 0x75, 
  0x61, 0x6C, 0x6C, 0x79, 0x20, 0x38, 0x31, 0x39, 0x32, 0x2E, 0xDA, 0x83, 0x41, 0xD3, 0x02, 0xDA, 
  0x03, 0xDA, 0x83, 0x42, 0xDA, 0x09, 0xCE, 0x80, 0xE2, 0x28, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2F, 
  0x72, 0x61, 0x77, 0x67, 0x65, 0x74, 0x20, 0x74, 0x61, 0x62, 0x20, 0x6B, 0x65, 0x79, 0x29, 0x0A, 
  0x0A, 0x47, 0x65, 0x74, 0x73, 0x20, 0x61, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x66, 0x72, 
  0x6F, 0x6D, 0x20, 0x61, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x6F, 
  0x75, 0x74, 0x20, 0x6C, 0x6F, 0x6F, 0x6B, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x74, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0x74, 0x79, 0x70, 0x65, 0x20, 0x74, 0x61, 0x62, 0x6C, 
  0x65, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x61, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x74, 0x61, 
  0x62, 0x20, 0x64, 0x6F, 0x65, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x61, 
  0x69, 0x6E, 0x20, 0x74, 0x20, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6C, 0x79, 0x2C, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x77, 0x69, 0x6C, 0x6C, 
  0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x6E, 0x69, 0x6C, 0x20, 0x77, 0x69, 0x74, 0x68, 
  0x6F, 0x75, 0x74, 0x20, 0x63, 0x68, 0x65, 0x63, 0x6B, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0x74, 0x79, 0x70, 0x65, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x69, 0x6E, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0xDA, 0x83, 0x43, 0xD3, 0x02, 
  0xDA, 0x03, 0xDA, 0x83, 0x44, 0xDA, 0x09, 0xCE, 0x7B, 0x28, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x66, 
  0x20, 0x66, 0x6D, 0x74, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x50, 0x72, 0x69, 0x6E, 
  0x74, 0x73, 0x20, 0x6F, 0x75, 0x74, 0x70, 0x75, 0x74, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 
  0x74, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 0x69, 0x66, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x28, 
  0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x20, 0x66, 0x6D, 
  0x74, 0x20, 0x3B, 0x78, 0x73, 0x29, 0x20, 0x74, 0x6F, 0x20, 0x28, 0x64, 0x79, 0x6E, 0x20, 0x3A, 
  0x6F, 0x75, 0x74, 0x20, 0x73, 0x74, 0x64, 0x6F, 0x75, 0x74, 0x29, 0x20, 0x77, 0x69, 0x74, 0x68, 
  0x20, 0x61, 0x20, 0x74, 0x72, 0x61, 0x69, 0x6C, 0x69, 0x6E, 0x67, 0x20, 0x6E, 0x65, 0x77, 0x6C, 
  0x69, 0x6E, 0x65, 0x2E, 0xDA, 0x83, 0x45, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x83, 0x46, 0xDA, 0x09, 
  0xCE, 0x24, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x73, 0x69, 0x6E, 0x20, 0x78, 0x29, 0x0A, 0x0A, 
  0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x69, 0x6E, 0x65, 
  0x20, 0x6F, 0x66, 0x20, 0x78, 0x2E, 0xDA, 0x83, 0x47, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x83, 0x48, 
  0xDA, 0x09, 0xCE, 0x4C, 0x28, 0x69, 0x6E, 0x74, 0x2F, 0x75, 0x36, 0x34, 0x20, 0x76, 0x61, 0x6C, 
  0x75, 0x65, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 0x62, 0x6F, 
  0x78, 0x65, 0x64, 0x20, 0x75, 0x6E, 0x73, 0x69, 0x67, 0x6E, 0x65, 0x64, 0x20, 0x36, 0x34, 0x20, 
  0x62, 0x69, 0x74, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x66, 0x72, 0x6F, 0x6D, 
  0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2E, 
  0xDA, 0x83, 0x49, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x83, 0x4B, 0xDA, 0x09, 0xCE, 0x71, 0x28, 0x6D, 
  0x61, 0x70, 0x63, 0x61, 0x74, 0x20, 0x66, 0x20, 0x69, 0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x4D, 0x61, 
  0x70, 0x20, 0x61, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x6F, 0x76, 0x65, 
  0x72, 0x20, 0x65, 0x76, 0x65, 0x72, 0x79, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 
  0x69, 0x6E, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x6F, 0x72, 0x20, 0x74, 
  0x75, 0x70, 0x6C, 0x65, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x20, 0x75, 0x73, 0x65, 0x20, 0x61, 0x72, 
  0x72, 0x61, 0x79, 0x20, 0x74, 0x6F, 0x20, 0x63, 0x6F, 0x6E, 0x63, 0x61, 0x74, 0x65, 0x6E, 0x61, 
  0x74, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6C, 0x74, 0x73, 0x2E, 0xDA, 
  0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x83, 0x58, 0x01, 0xDA, 0x83, 0x4C, 0xD3, 0x02, 0xDA, 0x03, 
  0xDA, 0x83, 0x4D, 0xDA, 0x09, 0xCE, 0x80, 0xA9, 0x28, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 
  0x74, 0x72, 0x69, 0x6D, 0x20, 0x73, 0x74, 0x72, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x73, 0x65, 
  0x74, 0x29, 0x0A, 0x0A, 0x54, 0x72, 0x69, 0x6D, 0x20, 0x6C, 0x65, 0x61, 0x64, 0x69, 0x6E, 0x67, 
  0x20, 0x61, 0x6E, 0x64, 0x20, 0x74, 0x72, 0x61, 0x69, 0x6C, 0x69, 0x6E, 0x67, 0x20, 0x77, 0x68, 
  0x69, 0x74, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x61, 0x20, 
  0x62, 0x79, 0x74, 0x65, 0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6E, 0x63, 0x65, 0x2E, 0x20, 0x49, 
  0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x73, 
  0x65, 0x74, 0x20, 0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x76, 0x69, 0x64, 0x65, 0x64, 0x2C, 0x20, 
  0x63, 0x6F, 0x6E, 0x73, 0x69, 0x64, 0x65, 0x72, 0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x20, 0x63, 0x68, 
  0x61, 0x72, 0x61, 0x63, 0x74, 0x65, 0x72, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x73, 0x65, 0x74, 0x20, 
  0x74, 0x6F, 0x20, 0x62, 0x65, 0x20, 0x77, 0x68, 0x69, 0x74, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 
  0x2E, 0xDA, 0x83, 0x4E, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x83, 0x50, 0xDA, 0x09, 0xCE, 0x80, 0xAD, 
  0x28, 0x64, 0x65, 0x62, 0x75, 0x67, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x78, 0x29, 0x0A, 0x0A, 
  0x54, 0x68, 0x72, 0x6F, 0x77, 0x73, 0x20, 0x61, 0x20, 0x64, 0x65, 0x62, 0x75, 0x67, 0x20, 0x73, 
  0x69, 0x67, 0x6E, 0x61, 0x6C, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 
  0x65, 0x20, 0x63, 0x61, 0x75, 0x67, 0x68, 0x74, 0x20, 0x62, 0x79, 0x20, 0x61, 0x20, 0x70, 0x61, 
  0x72, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x75, 
  0x73, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x69, 0x6E, 0x73, 0x70, 0x65, 0x63, 0x74, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x72, 0x75, 0x6E, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 
  0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 
  0x66, 0x69, 0x62, 0x65, 0x72, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x70, 0x61, 0x73, 0x73, 0x65, 0x64, 0x20, 
  0x69, 0x6E, 0x20, 0x62, 0x79, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6D, 0x65, 0x2E, 0xDA, 0x83, 0x51, 
  0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x83, 0x52, 0xDA, 0x09, 0xCE, 0x33, 0x28, 0x6D, 0x61, 0x74, 0x68, 
  0x2F, 0x61, 0x73, 0x69, 0x6E, 0x68, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x68, 0x79, 0x70, 0x65, 0x72, 0x62, 0x6F, 0x6C, 0x69, 0x63, 
  0x20, 0x61, 0x72, 0x63, 0x73, 0x69, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x2E, 0xDA, 0x83, 
  0x53, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x83, 0x54, 0xDA, 0x09, 0xCE, 0x5C, 0x28, 0x69, 0x6E, 0x74, 
  0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 
  0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x65, 0x78, 0x61, 0x63, 0x74, 0x6C, 0x79, 0x20, 
  0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6E, 0x74, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 0x61, 
  0x20, 0x33, 0x32, 0x20, 0x62, 0x69, 0x74, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x65, 0x64, 0x20, 0x74, 
  0x77, 0x6F, 0x27, 0x73, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 
  0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x2E, 0xDA, 0x83, 0x55, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 
  0x83, 0x56, 0xDA, 0x09, 0xCE, 0x29, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x6C, 0x6F, 0x67, 0x31, 
  0x30, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6C, 0x6F, 
  0x67, 0x20, 0x62, 0x61, 0x73, 0x65, 0x20, 0x31, 0x30, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x2E, 0xDA, 
  0x83, 0x57, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x83, 0x58, 0xDA, 0x09, 0xCE, 0x80, 0xA2, 0x28, 0x61, 
  0x72, 0x72, 0x61, 0x79, 0x2F, 0x66, 0x69, 0x6C, 0x6C, 0x20, 0x61, 0x72, 0x72, 0x20, 0x26, 0x6F, 
  0x70, 0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x70, 0x6C, 0x61, 
  0x63, 0x65, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 
  0x6F, 0x66, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x77, 0x69, 0x74, 0x68, 
  0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x28, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x69, 
  0x6E, 0x67, 0x20, 0x74, 0x6F, 0x20, 0x6E, 0x69, 0x6C, 0x29, 0x20, 0x77, 0x69, 0x74, 0x68, 0x6F, 
  0x75, 0x74, 0x20, 0x63, 0x68, 0x61, 0x6E, 0x67, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 
  0x72, 0x61, 0x79, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 
  0xDA, 0x83, 0x59, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x82, 0x3C, 0xDA, 0x09, 0xCE, 0x80, 0xD8, 0x28, 
  0x73, 0x63, 0x61, 0x6E, 0x2D, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x73, 0x74, 0x72, 0x29, 
  0x0A, 0x0A, 0x50, 0x61, 0x72, 0x73, 0x65, 0x20, 0x61, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 
  0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x61, 0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 0x73, 0x65, 0x71, 
  0x75, 0x65, 0x6E, 0x63, 0x65, 0x20, 0x61, 0x6E, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 
  0x74, 0x68, 0x61, 0x74, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x2C, 0x20, 0x65, 0x69, 0x74, 
  0x68, 0x65, 0x72, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 
  0x6F, 0x72, 0x20, 0x61, 0x20, 0x72, 0x65, 0x61, 0x6C, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x6E, 
  0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6D, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x69, 0x6E, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6D, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 
  0x20, 0x61, 0x73, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x6A, 
  0x61, 0x6E, 0x65, 0x74, 0x20, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x20, 0x63, 0x6F, 0x64, 0x65, 
  0x2E, 0x20, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x6E, 0x69, 
  0x6C, 0x20, 0x6F, 0x6E, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x76, 0x61, 0x6C, 0x69, 0x64, 0x20, 
  0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x2E, 0xDA, 0x83, 0x5A, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x81, 
  0x29, 0xDA, 0x09, 0xCE, 0x4F, 0x28, 0x73, 0x6F, 0x72, 0x74, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x64, 
  0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x62, 0x79, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x73, 0x6F, 0x72, 0x74, 0x65, 0x64, 0x20, 
  0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x77, 0x69, 0x74, 0x68, 0x6F, 0x75, 0x74, 0x20, 0x6D, 0x6F, 
  0x64, 0x69, 0x66, 0x79, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6F, 0x6C, 0x64, 0x20, 
  0x6F, 0x6E, 0x65, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x83, 0x07, 0x01, 0xDA, 0x83, 
  0x5B, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x81, 0x1E, 0xDA, 0x09, 0xCE, 0x36, 0x28, 0x62, 0x79, 0x74, 
  0x65, 0x73, 0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 
  0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2C, 0x20, 
  0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x2C, 0x20, 0x6F, 0x72, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 
  0x72, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x66, 0x01, 0xDA, 0x83, 0x5C, 0xD3, 0x03, 
  0xDA, 0x03, 0xDA, 0x81, 0x0E, 0xDA, 0x09, 0xCE, 0x81, 0x51, 0x28, 0x64, 0x6F, 0x66, 0x69, 0x6C, 
  0x65, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x26, 0x6B, 0x65, 0x79, 0x73, 0x20, 0x7B, 0x3A, 0x65, 
  0x78, 0x70, 0x61, 0x6E, 0x64, 0x65, 0x72, 0x20, 0x65, 0x78, 0x70, 0x61, 0x6E, 0x64, 0x65, 0x72, 
  0x20, 0x3A, 0x65, 0x6E, 0x76, 0x20, 0x65, 0x6E, 0x76, 0x20, 0x3A, 0x65, 0x78, 0x69, 0x74, 0x20, 
  0x65, 0x78, 0x69, 0x74, 0x20, 0x3A, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x20, 0x73, 0x72, 0x63, 
  0x20, 0x3A, 0x65, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x6F, 0x72, 0x20, 0x65, 0x76, 0x61, 0x6C, 
  0x75, 0x61, 0x74, 0x6F, 0x72, 0x7D, 0x29, 0x0A, 0x0A, 0x45, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 
  0x65, 0x20, 0x61, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x72, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6C, 0x74, 0x69, 0x6E, 
  0x67, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0x20, 0x3A, 
  0x65, 0x6E, 0x76, 0x2C, 0x20, 0x3A, 0x65, 0x78, 0x70, 0x61, 0x6E, 0x64, 0x65, 0x72, 0x2C, 0x20, 
  0x61, 0x6E, 0x64, 0x20, 0x20, 0x3A, 0x65, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x6F, 0x72, 0x20, 
  0x61, 0x72, 0x65, 0x20, 0x70, 0x61, 0x73, 0x73, 0x65, 0x64, 0x20, 0x74, 0x68, 0x72, 0x6F, 0x75, 
  0x67, 0x68, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x75, 0x6E, 0x64, 0x65, 0x72, 0x6C, 
  0x79, 0x69, 0x6E, 0x67, 0x20, 0x72, 0x75, 0x6E, 0x2D, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 
  0x20, 0x63, 0x61, 0x6C, 0x6C, 0x2E, 0x20, 0x20, 0x49, 0x66, 0x20, 0x65, 0x78, 0x69, 0x74, 0x20, 
  0x69, 0x73, 0x20, 0x74, 0x72, 0x75, 0x65, 0x2C, 0x20, 0x61, 0x6E, 0x79, 0x20, 0x74, 0x6F, 0x70, 
  0x20, 0x6C, 0x65, 0x76, 0x65, 0x6C, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x73, 0x20, 0x77, 0x69, 
  0x6C, 0x6C, 0x20, 0x74, 0x72, 0x69, 0x67, 0x67, 0x65, 0x72, 0x20, 0x61, 0x20, 0x63, 0x61, 0x6C, 
  0x6C, 0x20, 0x74, 0x6F, 0x20, 0x28, 0x6F, 0x73, 0x2F, 0x65, 0x78, 0x69, 0x74, 0x20, 0x31, 0x29, 
  0x20, 0x20, 0x61, 0x66, 0x74, 0x65, 0x72, 0x20, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x69, 0x6E, 0x67, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 
  0xDA, 0x05, 0x88, 0xF6, 0x01, 0xDA, 0x83, 0x5D, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x81, 0x15, 0xDA, 
  0x09, 0xCE, 0x50, 0x28, 0x73, 0x6C, 0x75, 0x72, 0x70, 0x20, 0x70, 0x61, 0x74, 0x68, 0x29, 0x0A, 
  0x0A, 0x52, 0x65, 0x61, 0x64, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x66, 
  0x72, 0x6F, 0x6D, 0x20, 0x61, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 
  0x6E, 0x61, 0x6D, 0x65, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x74, 
  0x68, 0x65, 0x6E, 0x20, 0x63, 0x6C, 0x6F, 0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 
  0x6C, 0x65, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x85, 0x90, 0x01, 0xDA, 0x83, 0x5E, 
  0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x83, 0x60, 0xDA, 0x09, 0xCE, 0x72, 0x28, 0x61, 0x6C, 0x6C, 0x20, 
  0x70, 0x72, 0x65, 0x64, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 
  0x73, 0x20, 0x74, 0x72, 0x75, 0x65, 0x20, 0x69, 0x66, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x78, 0x73, 
  0x20, 0x61, 0x72, 0x65, 0x20, 0x74, 0x72, 0x75, 0x74, 0x68, 0x79, 0x2C, 0x20, 0x6F, 0x74, 0x68, 
  0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6C, 
  0x74, 0x20, 0x6F, 0x66, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x20, 0x66, 0x61, 0x6C, 0x73, 
  0x65, 0x79, 0x20, 0x70, 0x72, 0x65, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x76, 0x61, 0x6C, 
  0x75, 0x65, 0x2C, 0x20, 0x28, 0x70, 0x72, 0x65, 0x64, 0x20, 0x78, 0x29, 0x2E, 0xDA, 0x0B, 0xD2, 
  0x03, 0x00, 0xDA, 0x05, 0x86, 0xFF, 0x01, 0xDA, 0x83, 0x61, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x83, 
  0x63, 0xDA, 0x09, 0xCE, 0x23, 0x28, 0x61, 0x72, 0x72, 0x61, 0x79, 0x3F, 0x20, 0x78, 0x29, 0x0A, 
  0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 0x61, 
  0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x63, 
  0x01, 0xDA, 0x83, 0x64, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x83, 0x65, 0xDA, 0x09, 0xCE, 0x2E, 0x28, 
  0x61, 0x62, 0x73, 0x74, 0x72, 0x61, 0x63, 0x74, 0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 
  0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x61, 
  0x62, 0x73, 0x74, 0x72, 0x61, 0x63, 0x74, 0x20, 0x74, 0x79, 0x70, 0x65, 0x2E, 0xDA, 0x83, 0x66, 
  0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x83, 0x67, 0xDA, 0x09, 0xCE, 0x80, 0x96, 0x28, 0x73, 0x74, 0x72, 
  0x69, 0x6E, 0x67, 0x2F, 0x66, 0x72, 0x6F, 0x6D, 0x2D, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x26, 
  0x20, 0x62, 0x79, 0x74, 0x65, 0x2D, 0x76, 0x61, 0x6C, 0x73, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 
  0x61, 0x74, 0x65, 0x73, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x66, 0x72, 
  0x6F, 0x6D, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6D, 
  0x65, 0x74, 0x65, 0x72, 0x73, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 
  0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x2E, 0x20, 0x41, 0x6C, 0x6C, 0x20, 0x69, 0x6E, 0x74, 0x65, 
  0x67, 0x65, 0x72, 0x73, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x63, 0x6F, 0x65, 
  0x72, 0x63, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x61, 0x6E, 0x67, 
  0x65, 0x20, 0x6F, 0x66, 0x20, 0x31, 0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 0x30, 0x2D, 0x32, 0x35, 
  0x35, 0x2E, 0xDA, 0x83, 0x68, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x83, 0x69, 0xDA, 0x09, 0xCE, 0x4A, 
  0x28, 0x69, 0x6E, 0x74, 0x2F, 0x73, 0x36, 0x34, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x29, 0x0A, 
  0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 0x62, 0x6F, 0x78, 0x65, 0x64, 0x20, 
  0x73, 0x69, 0x67, 0x6E, 0x65, 0x64, 0x20, 0x36, 0x34, 0x20, 0x62, 0x69, 0x74, 0x20, 0x69, 0x6E, 
  0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 
  0x69, 0x6E, 0x67, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2E, 0xDA, 0x83, 0x6A, 0xD3, 0x02, 0xDA, 
  0x03, 0xDA, 0x83, 0x6B, 0xDA, 0x09, 0xCE, 0x7E, 0x28, 0x6F, 0x73, 0x2F, 0x73, 0x79, 0x6D, 0x6C, 
  0x69, 0x6E, 0x6B, 0x20, 0x6F, 0x6C, 0x64, 0x70, 0x61, 0x74, 0x68, 0x20, 0x6E, 0x65, 0x77, 0x70, 
  0x61, 0x74, 0x68, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 0x73, 
  0x79, 0x6D, 0x6C, 0x69, 0x6E, 0x6B, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x6F, 0x6C, 0x64, 0x70, 
  0x61, 0x74, 0x68, 0x20, 0x74, 0x6F, 0x20, 0x6E, 0x65, 0x77, 0x70, 0x61, 0x74, 0x68, 0x2C, 0x20, 
  0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0x20, 0x53, 
  0x61, 0x6D, 0x65, 0x20, 0x61, 0x73, 0x20, 0x28, 0x6F, 0x73, 0x2F, 0x6C, 0x69, 0x6E, 0x6B, 0x20, 
  0x6F, 0x6C, 0x64, 0x70, 0x61, 0x74, 0x68, 0x20, 0x6E, 0x65, 0x77, 0x70, 0x61, 0x74, 0x68, 0x20, 
  0x74, 0x72, 0x75, 0x65, 0x29, 0x2E, 0xDA, 0x81, 0x8D, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 0x83, 0x70, 
  0xDA, 0x09, 0xCE, 0x80, 0xAA, 0x28, 0x6C, 0x65, 0x74, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 
  0x67, 0x73, 0x20, 0x26, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 
  0x74, 0x65, 0x20, 0x61, 0x20, 0x73, 0x63, 0x6F, 0x70, 0x65, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x62, 
  0x69, 0x6E, 0x64, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x73, 0x79, 
  0x6D, 0x62, 0x6F, 0x6C, 0x73, 0x2E, 0x20, 0x45, 0x61, 0x63, 0x68, 0x20, 0x70, 0x61, 0x69, 0x72, 
  0x20, 0x69, 0x6E, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x20, 0x69, 0x73, 0x20, 
  0x20, 0x61, 0x73, 0x73, 0x69, 0x67, 0x6E, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 0x69, 0x66, 0x20, 
  0x77, 0x69, 0x74, 0x68, 0x20, 0x64, 0x65, 0x66, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x65, 
  0x74, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x6C, 0x61, 0x73, 0x74, 0x20, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2E, 0xDA, 
  0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x80, 0xD1, 0x01, 0xDA, 0x35, 0xCB, 0xDA, 0x83, 0x71, 0xD3, 
  0x02, 0xDA, 0x03, 0xDA, 0x83, 0x72, 0xDA, 0x09, 0xCE, 0x81, 0x0E, 0x28, 0x6E, 0x65, 0x74, 0x2F, 
  0x72, 0x65, 0x61, 0x64, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x20, 0x6E, 0x62, 0x79, 0x74, 
  0x65, 0x73, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x62, 0x75, 0x66, 0x29, 0x0A, 0x0A, 0x52, 0x65, 
  0x61, 0x64, 0x20, 0x75, 0x70, 0x20, 0x74, 0x6F, 0x20, 0x6E, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 
  0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x2C, 0x20, 
  0x73, 0x75, 0x73, 0x70, 0x65, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 
  0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x75, 0x6E, 0x74, 
  0x69, 0x6C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65, 
  0x20, 0x61, 0x76, 0x61, 0x69, 0x6C, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x6C, 
  0x65, 0x73, 0x73, 0x20, 0x74, 0x68, 0x61, 0x6E, 0x20, 0x6E, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 
  0x20, 0x61, 0x72, 0x65, 0x20, 0x61, 0x76, 0x61, 0x69, 0x6C, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x28, 
  0x61, 0x6E, 0x64, 0x20, 0x6D, 0x6F, 0x72, 0x65, 0x20, 0x74, 0x68, 0x61, 0x6E, 0x20, 0x30, 0x29, 
  0x2C, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x70, 0x75, 0x73, 0x68, 0x20, 0x74, 0x68, 0x6F, 0x73, 
  0x65, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x72, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x20, 0x65, 0x61, 0x72, 0x6C, 0x79, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 
  0x73, 0x20, 0x61, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 
  0x75, 0x70, 0x20, 0x74, 0x6F, 0x20, 0x6E, 0x20, 0x6D, 0x6F, 0x72, 0x65, 0x20, 0x62, 0x79, 0x74, 
  0x65, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x69, 0x74, 0x2E, 0xDA, 0x83, 0x73, 0xD3, 0x02, 0xDA, 0x03, 
  0xDA, 0x83, 0x74, 0xDA, 0x09, 0xCE, 0x18, 0x54, 0x68, 0x65, 0x20, 0x73, 0x74, 0x61, 0x6E, 0x64, 
  0x61, 0x72, 0x64, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x2E, 0xDA, 
  0x83, 0x75, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x83, 0x76, 0xDA, 0x09, 0xCE, 0x35, 0x28, 0x6D, 0x61, 
  0x74, 0x68, 0x2F, 0x61, 0x63, 0x6F, 0x73, 0x68, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x68, 0x79, 0x70, 0x65, 0x72, 0x62, 0x6F, 0x6C, 
  0x69, 0x63, 0x20, 0x61, 0x72, 0x63, 0x63, 0x6F, 0x73, 0x69, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x20, 
  0x78, 0x2E, 0xDA, 0x83, 0x77, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 0x83, 0x79, 0xDA, 0x09, 0xCE, 0x47, 
  0x28, 0x75, 0x6E, 0x6C, 0x65, 0x73, 0x73, 0x20, 0x63, 0x6F, 0x6E, 0x64, 0x69, 0x74, 0x69, 0x6F, 
  0x6E, 0x20, 0x26, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x29, 0x0A, 0x0A, 0x53, 0x68, 0x6F, 0x72, 0x74, 
  0x68, 0x61, 0x6E, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x28, 0x77, 0x68, 0x65, 0x6E, 0x20, 0x28, 
  0x6E, 0x6F, 0x74, 0x20, 0x63, 0x6F, 0x6E, 0x64, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x29, 0x20, 0x3B, 
  0x62, 0x6F, 0x64, 0x79, 0x29, 0x2E, 0x20, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x80, 0xA9, 
  0x01, 0xDA, 0x35, 0xCB, 0xDA, 0x83, 0x7A, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x84, 0x64, 0xDA, 0x09, 
  0xCE, 0x80, 0xA3, 0x28, 0x63, 0x6C, 0x69, 0x2D, 0x6D, 0x61, 0x69, 0x6E, 0x20, 0x61, 0x72, 0x67, 
  0x73, 0x29, 0x0A, 0x0A, 0x45, 0x6E, 0x74, 0x72, 0x61, 0x6E, 0x63, 0x65, 0x20, 0x66, 0x6F, 0x72, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x4A, 0x61, 0x6E, 0x65, 0x74, 0x20, 0x43, 0x4C, 0x49, 0x20, 0x74, 
  0x6F, 0x6F, 0x6C, 0x2E, 0x20, 0x43, 0x61, 0x6C, 0x6C, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x66, 
  0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x63, 0x6F, 0x6D, 0x6D, 0x61, 0x6E, 0x64, 0x20, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0x20, 
  0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x61, 0x73, 0x20, 0x61, 0x6E, 0x20, 
  0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x6F, 0x72, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x20, 0x6F, 
  0x66, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x69, 0x6E, 0x76, 
  0x6F, 0x6B, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x43, 0x4C, 0x49, 0x20, 0x69, 0x6E, 0x74, 0x65, 
  0x72, 0x66, 0x61, 0x63, 0x65, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x8A, 0x77, 0x01, 
  0xDA, 0x84, 0x65, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x81, 0xB2, 0xDA, 0x09, 0xCE, 0x48, 0x28, 0x6E, 
  0x6F, 0x74, 0x3D, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 
  0x20, 0x69, 0x66, 0x20, 0x61, 0x6E, 0x79, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x69, 
  0x6E, 0x20, 0x78, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x65, 0x71, 0x75, 
  0x61, 0x6C, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x62, 0x6F, 
  0x6F, 0x6C, 0x65, 0x61, 0x6E, 0x2E, 0xDA, 0x84, 0x66, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x84, 0x67, 
  0xDA, 0x09, 0xCE, 0x81, 0x00, 0x28, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x69, 0x6E, 0x73, 0x65, 
  0x72, 0x74, 0x20, 0x61, 0x72, 0x72, 0x20, 0x61, 0x74, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 
  0x0A, 0x49, 0x6E, 0x73, 0x65, 0x72, 0x74, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x6F, 0x66, 0x20, 0x78, 
  0x73, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x61, 0x72, 0x72, 
  0x20, 0x61, 0x74, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x61, 0x74, 0x2E, 0x20, 0x61, 0x74, 
  0x20, 0x73, 0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x62, 0x65, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 
  0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x30, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 
  0x72, 0x61, 0x79, 0x2E, 0x20, 0x41, 0x20, 0x6E, 0x65, 0x67, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 
  0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x61, 0x74, 0x20, 0x77, 0x69, 0x6C, 
  0x6C, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x65, 0x6E, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x72, 0x61, 
  0x79, 0x2C, 0x20, 0x73, 0x75, 0x63, 0x68, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x6E, 0x73, 
  0x65, 0x72, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x74, 0x20, 0x2D, 0x31, 0x20, 0x61, 0x70, 0x70, 
  0x65, 0x6E, 0x64, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x72, 0x61, 
  0x79, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 
  0x72, 0x72, 0x61, 0x79, 0x2E, 0xDA, 0x84, 0x68, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x00, 0xDA, 0x09, 
  0xCE, 0x40, 0x54, 0x68, 0x65, 0x20, 0x72, 0x6F, 0x6F, 0x74, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 
  0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x63, 
  0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 
  0x74, 0x73, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x28, 0x6D, 0x61, 0x6B, 0x65, 0x2D, 0x65, 0x6E, 
  0x76, 0x29, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x8B, 0x08, 0x01, 0xDA, 0x84, 0x69, 0xD3, 
  0x02, 0xDA, 0x03, 0xDA, 0x84, 0x6A, 0xDA, 0x09, 0xCE, 0x80, 0xBF, 0x28, 0x68, 0x61, 0x73, 0x68, 
  0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x73, 0x20, 0x61, 0x20, 
  0x68, 0x61, 0x73, 0x68, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x61, 0x6E, 0x79, 0x20, 0x76, 0x61, 0x6C, 
  0x75, 0x65, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x68, 0x61, 0x73, 0x68, 0x20, 0x69, 0x73, 0x20, 
  0x61, 0x6E, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 
  0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 0x61, 0x20, 0x63, 0x68, 0x65, 0x61, 
  0x70, 0x20, 0x68, 0x61, 0x73, 0x68, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 
  0x66, 0x6F, 0x72, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x2E, 0x20, 
  0x49, 0x66, 0x20, 0x74, 0x77, 0x6F, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x61, 0x72, 
  0x65, 0x20, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x6C, 0x79, 0x20, 0x65, 0x71, 0x75, 0x61, 0x6C, 
  0x2C, 0x20, 0x74, 0x68, 0x65, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x79, 0x20, 0x77, 0x69, 0x6C, 0x6C, 
  0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6D, 0x65, 0x20, 0x68, 
  0x61, 0x73, 0x68, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2E, 0xDA, 0x84, 0x6B, 0xD3, 0x02, 0xDA, 
  0x03, 0xDA, 0x84, 0x6C, 0xDA, 0x09, 0xCE, 0x4B, 0x28, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 
  0x72, 0x65, 0x76, 0x65, 0x72, 0x73, 0x65, 0x20, 0x73, 0x74, 0x72, 0x29, 0x0A, 0x0A, 0x52, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x74, 
  0x68, 0x61, 0x74, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x76, 0x65, 0x72, 
  0x73, 0x65, 0x64, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x6F, 0x66, 0x20, 0x73, 
  0x74, 0x72, 0x2E, 0xDA, 0x84, 0x73, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x82, 0x26, 0xDA, 0x09, 0xCE, 
  0x39, 0x28, 0x73, 0x65, 0x74, 0x64, 0x79, 0x6E, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x76, 0x61, 0x6C, 
  0x75, 0x65, 0x29, 0x0A, 0x0A, 0x53, 0x65, 0x74, 0x20, 0x61, 0x20, 0x64, 0x79, 0x6E, 0x61, 0x6D, 
  0x69, 0x63, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x73, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2E, 0xDA, 0x84, 0x99, 0xD3, 0x02, 0xDA, 
  0x03, 0xDA, 0x82, 0x1A, 0xDA, 0x09, 0xCE, 0x50, 0x28, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x2F, 0x62, 
  0x72, 0x61, 0x63, 0x6B, 0x65, 0x74, 0x73, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x43, 
  0x72, 0x65, 0x61, 0x74, 0x65, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x62, 0x72, 0x61, 
  0x63, 0x6B, 0x65, 0x74, 0x65, 0x64, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x20, 0x63, 0x6F, 0x6E, 
  0x74, 0x61, 0x69, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6C, 0x65, 0x6D, 
  0x65, 0x6E, 0x74, 0x73, 0x20, 0x78, 0x73, 0x2E, 0xDA, 0x84, 0x70, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 
  0x84, 0x72, 0xDA, 0x09, 0xCE, 0x5D, 0x28, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0x3E, 0x20, 
  0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x45, 0x71, 0x75, 0x69, 0x76, 0x61, 0x6C, 0x65, 0x6E, 
  0x74, 0x20, 0x6F, 0x66, 0x20, 0x27, 0x3E, 0x27, 0x20, 0x62, 0x75, 0x74, 0x20, 0x75, 0x73, 0x69, 
  0x6E, 0x67, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 
  0x69, 0x6F, 0x6E, 0x20, 0x69, 0x6E, 0x73, 0x74, 0x65, 0x61, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x70, 
  0x72, 0x69, 0x6D, 0x69, 0x74, 0x69, 0x76, 0x65, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x61, 
  0x74, 0x6F, 0x72, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x82, 0xD0, 0x01, 0xDA, 0x84, 0x74, 
  0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x7D, 0xDA, 0x09, 0xCE, 0x66, 0x28, 0x64, 0x79, 0x6E, 0x20, 0x6B, 
  0x65, 0x79, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x29, 
  0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 0x61, 0x20, 0x64, 0x79, 0x6E, 0x61, 0x6D, 0x69, 0x63, 0x20, 
  0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x20, 0x76, 0x61, 0x6C, 
  0x75, 0x65, 0x20, 0x28, 0x6F, 0x72, 0x20, 0x6E, 0x69, 0x6C, 0x29, 0x20, 0x69, 0x66, 0x20, 0x6E, 
  0x6F, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x2E, 
  0xDA, 0x84, 0x75, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x80, 0xF3, 0xDA, 0x09, 0xCE, 0x80, 0xD1, 0x28, 
  0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x63, 0x6F, 0x6E, 0x73, 0x75, 0x6D, 0x65, 0x20, 0x70, 
  0x61, 0x72, 0x73, 0x65, 0x72, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x26, 0x6F, 0x70, 0x74, 
  0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x29, 0x0A, 0x0A, 0x49, 0x6E, 0x70, 0x75, 0x74, 0x20, 0x62, 
  0x79, 0x74, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 
  0x72, 0x73, 0x65, 0x72, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x20, 0x74, 
  0x68, 0x65, 0x6D, 0x2E, 0x20, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x74, 0x68, 
  0x72, 0x6F, 0x77, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x73, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 
  0x65, 0x72, 0x65, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x20, 0x65, 
  0x72, 0x72, 0x6F, 0x72, 0x2E, 0x20, 0x53, 0x74, 0x61, 0x72, 0x74, 0x73, 0x20, 0x61, 0x74, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x67, 
  0x69, 0x76, 0x65, 0x6E, 0x20, 0x62, 0x79, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x2E, 0x20, 0x52, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 
  0x72, 0x20, 0x6F, 0x66, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x72, 0x65, 0x61, 0x64, 0x2E, 
  0xDA, 0x84, 0x76, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x83, 0xC6, 0xDA, 0x09, 0xCE, 0x51, 0x28, 0x73, 
  0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x72, 0x65, 0x70, 0x65, 0x61, 0x74, 0x20, 0x62, 0x79, 0x74, 
  0x65, 0x73, 0x20, 0x6E, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 
  0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x73, 0x20, 
  0x6E, 0x20, 0x63, 0x6F, 0x70, 0x69, 0x65, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x62, 0x79, 0x74, 0x65, 
  0x73, 0x20, 0x63, 0x6F, 0x6E, 0x63, 0x61, 0x74, 0x65, 0x6E, 0x61, 0x74, 0x65, 0x64, 0x2E, 0xDA, 
  0x84, 0x94, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 0x84, 0x98, 0xDA, 0x09, 0xCE, 0x80, 0xA4, 0x28, 0x67, 
  0x65, 0x6E, 0x65, 0x72, 0x61, 0x74, 0x65, 0x20, 0x68, 0x65, 0x61, 0x64, 0x20, 0x26, 0x20, 0x62, 
  0x6F, 0x64, 0x79, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 0x67, 
  0x65, 0x6E, 0x65, 0x72, 0x61, 0x74, 0x6F, 0x72, 0x20, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 
  0x69, 0x6F, 0x6E, 0x20, 0x75, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x6F, 
  0x6F, 0x70, 0x20, 0x73, 0x79, 0x6E, 0x74, 0x61, 0x78, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x73, 0x20, 0x61, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x20, 0x74, 0x68, 0x61, 0x74, 
  0x20, 0x79, 0x69, 0x65, 0x6C, 0x64, 0x73, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x76, 0x61, 0x6C, 0x75, 
  0x65, 0x73, 0x20, 0x69, 0x6E, 0x73, 0x69, 0x64, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x6F, 
  0x6F, 0x70, 0x20, 0x69, 0x6E, 0x20, 0x6F, 0x72, 0x64, 0x65, 0x72, 0x2E, 0x20, 0x53, 0x65, 0x65, 
  0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x64, 0x65, 0x74, 0x61, 0x69, 0x6C, 
  0x73, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x82, 0x29, 0x01, 0xDA, 0x35, 0xCB, 0xDA, 
  0x84, 0x7A, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x84, 0x7B, 0xDA, 0x09, 0xCE, 0x4F, 0x28, 0x61, 0x72, 
  0x72, 0x61, 0x79, 0x20, 0x26, 0x20, 0x69, 0x74, 0x65, 0x6D, 0x73, 0x29, 0x0A, 0x0A, 0x43, 0x72, 
  0x65, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 
  0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 0x73, 0x20, 0x69, 
  0x74, 0x65, 0x6D, 0x73, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0xDA, 0x84, 0x77, 0xD3, 
  0x03, 0xDA, 0x03, 0xDA, 0x84, 0x79, 0xDA, 0x09, 0xCE, 0x43, 0x28, 0x70, 0x72, 0x6F, 0x64, 0x75, 
  0x63, 0x74, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x64, 0x75, 0x63, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x78, 
  0x73, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x78, 0x73, 0x20, 0x69, 0x73, 0x20, 0x65, 0x6D, 0x70, 0x74, 
  0x79, 0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x31, 0x2E, 0xDA, 0x0B, 0xD2, 
  0x03, 0x00, 0xDA, 0x05, 0x82, 0x40, 0x01, 0xDA, 0x84, 0x8F, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x80, 
  0xBF, 0xDA, 0x09, 0xCE, 0x73, 0x28, 0x6D, 0x61, 0x70, 0x20, 0x66, 0x20, 0x26, 0x20, 0x69, 0x6E, 
  0x64, 0x73, 0x29, 0x0A, 0x0A, 0x4D, 0x61, 0x70, 0x20, 0x61, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 
  0x69, 0x6F, 0x6E, 0x20, 0x6F, 0x76, 0x65, 0x72, 0x20, 0x65, 0x76, 0x65, 0x72, 0x79, 0x20, 0x65, 
  0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x64, 
  0x65, 0x78, 0x65, 0x64, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 
  0x75, 0x72, 0x65, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 
  0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x72, 0x65, 0x73, 0x75, 0x6C, 0x74, 0x73, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x83, 
  0x41, 0x01, 0xDA, 0x84, 0x90, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x84, 0x51, 0xDA, 0x09, 0xCE, 0x3C, 
  0x28, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x6E, 
  0x20, 0x61, 0x73, 0x73, 0x6F, 0x63, 0x69, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x64, 0x61, 0x74, 
  0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 
  0x00, 0xDA, 0x05, 0x85, 0x24, 0x01, 0xDA, 0x84, 0x91, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 0x84, 0x93, 
  0xDA, 0x09, 0xCE, 0x45, 0x28, 0x6A, 0x75, 0x78, 0x74, 0x20, 0x26, 0x20, 0x66, 0x75, 0x6E, 0x73, 
  0x29, 0x0A, 0x0A, 0x4D, 0x61, 0x63, 0x72, 0x6F, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x20, 0x6F, 0x66, 
  0x20, 0x6A, 0x75, 0x78, 0x74, 0x2A, 0x2E, 0x20, 0x53, 0x61, 0x6D, 0x65, 0x20, 0x62, 0x65, 0x68, 
  0x61, 0x76, 0x69, 0x6F, 0x72, 0x20, 0x62, 0x75, 0x74, 0x20, 0x6D, 0x6F, 0x72, 0x65, 0x20, 0x65, 
  0x66, 0x66, 0x69, 0x63, 0x69, 0x65, 0x6E, 0x74, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 
  0x83, 0xEA, 0x01, 0xDA, 0x35, 0xCB, 0xDA, 0x84, 0x6D, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x84, 0x6F, 
  0xDA, 0x09, 0xCE, 0x62, 0x28, 0x70, 0x70, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x50, 0x72, 0x65, 0x74, 
  0x74, 0x79, 0x20, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x73, 0x74, 0x64, 0x6F, 
  0x75, 0x74, 0x20, 0x6F, 0x72, 0x20, 0x28, 0x64, 0x79, 0x6E, 0x20, 0x3A, 0x6F, 0x75, 0x74, 0x29, 
  0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x20, 0x73, 0x74, 0x72, 
  0x69, 0x6E, 0x67, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x69, 0x73, 0x20, 0x28, 0x64, 0x79, 0x6E, 
  0x20, 0x3A, 0x70, 0x72, 0x65, 0x74, 0x74, 0x79, 0x2D, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x20, 
  0x22, 0x25, 0x71, 0x22, 0x29, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x85, 0xA5, 0x01, 
  0xDA, 0x84, 0x7C, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x84, 0x8E, 0xDA, 0x09, 0xCE, 0x61, 0x28, 0x64, 
  0x6F, 0x63, 0x2A, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x73, 0x79, 0x6D, 0x29, 0x0A, 0x0A, 0x47, 
  0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x6F, 0x63, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x61, 
  0x74, 0x69, 0x6F, 0x6E, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x61, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 
  0x6C, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x65, 0x6E, 0x76, 
  0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0x20, 0x46, 0x75, 0x6E, 0x63, 0x74, 0x69, 
  0x6F, 0x6E, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x20, 0x6F, 0x66, 0x20, 0x64, 0x6F, 0x63, 0x2E, 0xDA, 
  0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x86, 0x6A, 0x01, 0xDA, 0x84, 0x9A, 0xD3, 0x02, 0xDA, 0x03, 
  0xDA, 0x81, 0x99, 0xDA, 0x09, 0xCE, 0x68, 0x28, 0x2B, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 
  0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x75, 0x6D, 
  0x20, 0x6F, 0x66, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x78, 0x73, 0x2E, 0x20, 0x78, 0x73, 0x20, 0x6D, 
  0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x73, 0x20, 
  0x6F, 0x72, 0x20, 0x72, 0x65, 0x61, 0x6C, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x73, 0x20, 
  0x6F, 0x6E, 0x6C, 0x79, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x78, 0x73, 0x20, 0x69, 0x73, 0x20, 0x65, 
  0x6D, 0x70, 0x74, 0x79, 0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x30, 0x2E, 0xDA, 
  0x84, 0x9B, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x84, 0x9C, 0xDA, 0x09, 0xCE, 0x54, 0x28, 0x6D, 0x61, 
  0x74, 0x68, 0x2F, 0x66, 0x6C, 0x6F, 0x6F, 0x72, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x61, 0x72, 0x67, 0x65, 0x73, 0x74, 
  0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x6E, 
  0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x6F, 
  0x74, 0x20, 0x67, 0x72, 0x65, 0x61, 0x74, 0x65, 0x72, 0x20, 0x74, 0x68, 0x61, 0x6E, 0x20, 0x78, 
  0x2E, 0xDA, 0x84, 0x9D, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x83, 0xC7, 0xDA, 0x09, 0xCE, 0x3E, 0x28, 
  0x70, 0x72, 0x69, 0x6E, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x53, 0x61, 0x6D, 0x65, 
  0x20, 0x61, 0x73, 0x20, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x64, 
  0x6F, 0x65, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x61, 0x64, 0x64, 0x20, 0x74, 0x72, 0x61, 0x69, 
  0x6C, 0x69, 0x6E, 0x67, 0x20, 0x6E, 0x65, 0x77, 0x6C, 0x69, 0x6E, 0x65, 0x2E, 0xDA, 0x84, 0x9E, 
  0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x70, 0xDA, 0x09, 0xCE, 0x81, 0xC0, 0x28, 0x74, 0x75, 0x70, 0x6C, 
  0x65, 0x2F, 0x73, 0x6C, 0x69, 0x63, 0x65, 0x20, 0x61, 0x72, 0x72, 0x74, 0x75, 0x70, 0x20, 0x5B, 
  0x2C, 0x73, 0x74, 0x61, 0x72, 0x74, 0x3D, 0x30, 0x20, 0x5B, 0x2C, 0x65, 0x6E, 0x64, 0x3D, 0x28, 
  0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x20, 0x61, 0x72, 0x72, 0x74, 0x75, 0x70, 0x29, 0x5D, 0x5D, 
  0x29, 0x0A, 0x0A, 0x54, 0x61, 0x6B, 0x65, 0x20, 0x61, 0x20, 0x73, 0x75, 0x62, 0x20, 0x73, 0x65, 
  0x71, 0x75, 0x65, 0x6E, 0x63, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 
  0x61, 0x79, 0x20, 0x6F, 0x72, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x20, 0x66, 0x72, 0x6F, 0x6D, 
  0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x69, 0x6E, 0x63, 
  0x6C, 0x75, 0x73, 0x69, 0x76, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 
  0x65, 0x6E, 0x64, 0x20, 0x65, 0x78, 0x63, 0x6C, 0x75, 0x73, 0x69, 0x76, 0x65, 0x2E, 0x20, 0x49, 
  0x66, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x6F, 0x72, 0x20, 0x65, 0x6E, 0x64, 0x20, 0x61, 
  0x72, 0x65, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x70, 0x72, 0x6F, 0x76, 0x69, 0x64, 0x65, 0x64, 0x2C, 
  0x20, 0x74, 0x68, 0x65, 0x79, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x20, 0x74, 0x6F, 
  0x20, 0x30, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 
  0x68, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x72, 0x72, 0x74, 0x75, 0x70, 0x20, 0x72, 0x65, 0x73, 0x70, 
  0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x6C, 0x79, 0x2E, 0x20, 0x27, 0x73, 0x74, 0x61, 0x72, 0x74, 
  0x27, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x27, 0x65, 0x6E, 0x64, 0x27, 0x20, 0x63, 0x61, 0x6E, 0x20, 
  0x61, 0x6C, 0x73, 0x6F, 0x20, 0x62, 0x65, 0x20, 0x6E, 0x65, 0x67, 0x61, 0x74, 0x69, 0x76, 0x65, 
  0x20, 0x74, 0x6F, 0x20, 0x69, 0x6E, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x69, 0x6E, 0x64, 
  0x65, 0x78, 0x69, 0x6E, 0x67, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 
  0x6E, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6E, 0x70, 0x75, 0x74, 0x2E, 
  0x20, 0x4E, 0x6F, 0x74, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 
  0x20, 0x2D, 0x31, 0x20, 0x69, 0x73, 0x20, 0x73, 0x79, 0x6E, 0x6F, 0x6E, 0x79, 0x6D, 0x6F, 0x75, 
  0x73, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x27, 0x28, 0x6C, 
  0x65, 0x6E, 0x67, 0x74, 0x68, 0x20, 0x61, 0x72, 0x72, 0x74, 0x75, 0x70, 0x29, 0x27, 0x20, 0x74, 
  0x6F, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x77, 0x20, 0x61, 0x20, 0x66, 0x75, 0x6C, 0x6C, 0x20, 0x6E, 
  0x65, 0x67, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x73, 0x6C, 0x69, 0x63, 0x65, 0x20, 0x72, 0x61, 
  0x6E, 0x67, 0x65, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x6E, 0x65, 0x77, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x2E, 0xDA, 0x84, 0x55, 0xD3, 0x03, 
  0xDA, 0x03, 0xDA, 0x84, 0xA0, 0xDA, 0x09, 0xCE, 0x38, 0x28, 0x64, 0x65, 0x66, 0x67, 0x6C, 0x6F, 
  0x62, 0x61, 0x6C, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x29, 0x0A, 
  0x0A, 0x44, 0x79, 0x6E, 0x61, 0x6D, 0x69, 0x63, 0x61, 0x6C, 0x6C, 0x79, 0x20, 0x63, 0x72, 0x65, 
  0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 0x67, 0x6C, 0x6F, 0x62, 0x61, 0x6C, 0x20, 0x64, 0x65, 0x66, 
  0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x42, 0x01, 0xDA, 0x84, 0xA1, 0xD3, 0x02, 0xDA, 
  0x03, 0xDA, 0x84, 0xA2, 0xDA, 0x09, 0xCE, 0x38, 0x28, 0x6F, 0x73, 0x2F, 0x73, 0x65, 0x74, 0x65, 
  0x6E, 0x76, 0x20, 0x76, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 
  0x65, 0x29, 0x0A, 0x0A, 0x53, 0x65, 0x74, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 
  0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6C, 0x65, 0x2E, 
  0xDA, 0x84, 0xA3, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x83, 0x18, 0xDA, 0x09, 0xCE, 0x24, 0x28, 0x6E, 
  0x65, 0x67, 0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 
  0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 0x6C, 0x65, 0x73, 0x73, 0x20, 0x74, 0x68, 0x61, 0x6E, 0x20, 
  0x30, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x56, 0x01, 0xDA, 0x84, 0xA4, 0xD3, 0x03, 
  0xDA, 0x03, 0xDA, 0x84, 0x2C, 0xDA, 0x09, 0xCE, 0x80, 0xBF, 0x28, 0x6D, 0x65, 0x72, 0x67, 0x65, 
  0x2D, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x74, 0x61, 0x62, 0x20, 0x26, 0x20, 0x63, 0x6F, 0x6C, 0x6C, 
  0x73, 0x29, 0x0A, 0x0A, 0x4D, 0x65, 0x72, 0x67, 0x65, 0x73, 0x20, 0x6D, 0x75, 0x6C, 0x74, 0x69, 
  0x70, 0x6C, 0x65, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x73, 0x2F, 0x73, 0x74, 0x72, 0x75, 0x63, 
  0x74, 0x73, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2E, 
  0x20, 0x49, 0x66, 0x20, 0x61, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x61, 0x70, 0x70, 0x65, 0x61, 0x72, 
  0x73, 0x20, 0x69, 0x6E, 0x20, 0x6D, 0x6F, 0x72, 0x65, 0x20, 0x74, 0x68, 0x61, 0x6E, 0x20, 0x6F, 
  0x6E, 0x65, 0x20, 0x20, 0x63, 0x6F, 0x6C, 0x6C, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2C, 0x20, 
  0x74, 0x68, 0x65, 0x6E, 0x20, 0x6C, 0x61, 0x74, 0x65, 0x72, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 
  0x73, 0x20, 0x72, 0x65, 0x70, 0x6C, 0x61, 0x63, 0x65, 0x20, 0x61, 0x6E, 0x79, 0x20, 0x70, 0x72, 
  0x65, 0x76, 0x69, 0x6F, 0x75, 0x73, 0x20, 0x6F, 0x6E, 0x65, 0x73, 0x2E, 0x20, 0x20, 0x52, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6F, 0x72, 0x69, 0x67, 0x69, 0x6E, 
  0x61, 0x6C, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 
  0x85, 0x05, 0x01, 0xDA, 0x84, 0xA5, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x84, 0xA7, 0xDA, 0x09, 0xCE, 
  0x80, 0x91, 0x28, 0x62, 0x6C, 0x73, 0x68, 0x69, 0x66, 0x74, 0x20, 0x78, 0x20, 0x26, 0x20, 0x73, 
  0x68, 0x69, 0x66, 0x74, 0x73, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x20, 0x62, 
  0x69, 0x74, 0x20, 0x73, 0x68, 0x69, 0x66, 0x74, 0x65, 0x64, 0x20, 0x6C, 0x65, 0x66, 0x74, 0x20, 
  0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x75, 0x6D, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x6C, 
  0x6C, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x73, 0x68, 0x69, 0x66, 
  0x74, 0x73, 0x2E, 0x20, 0x78, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x65, 0x61, 0x63, 0x68, 0x20, 0x65, 
  0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x69, 0x6E, 0x20, 0x73, 0x68, 0x69, 0x66, 0x74, 0x20, 
  0x6D, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 
  0x65, 0x72, 0x2E, 0xDA, 0x84, 0xA8, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x84, 0xA9, 0xDA, 0x09, 0xCE, 
  0x81, 0x08, 0x28, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x62, 0x6C, 0x69, 0x74, 0x20, 0x64, 
  0x65, 0x73, 0x74, 0x20, 0x73, 0x72, 0x63, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x64, 0x65, 0x73, 
  0x74, 0x2D, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x73, 0x72, 0x63, 0x2D, 0x73, 0x74, 0x61, 0x72, 
  0x74, 0x20, 0x73, 0x72, 0x63, 0x2D, 0x65, 0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x49, 0x6E, 0x73, 0x65, 
  0x72, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x73, 0x20, 
  0x6F, 0x66, 0x20, 0x73, 0x72, 0x63, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x64, 0x65, 0x73, 0x74, 
  0x2E, 0x20, 0x43, 0x61, 0x6E, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x6C, 0x79, 
  0x20, 0x74, 0x61, 0x6B, 0x65, 0x20, 0x69, 0x6E, 0x64, 0x69, 0x63, 0x65, 0x73, 0x20, 0x74, 0x68, 
  0x61, 0x74, 0x20, 0x69, 0x6E, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x77, 0x68, 0x69, 0x63, 
  0x68, 0x20, 0x70, 0x61, 0x72, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x73, 0x72, 0x63, 0x20, 0x74, 0x6F, 
  0x20, 0x63, 0x6F, 0x70, 0x79, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 
  0x20, 0x70, 0x61, 0x72, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x64, 0x65, 0x73, 0x74, 0x2E, 0x20, 0x49, 
  0x6E, 0x64, 0x69, 0x63, 0x65, 0x73, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x6E, 0x65, 
  0x67, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 
  0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6E, 0x64, 0x20, 0x6F, 0x66, 0x20, 
  0x73, 0x72, 0x63, 0x20, 0x6F, 0x72, 0x20, 0x64, 0x65, 0x73, 0x74, 0x2E, 0x20, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x64, 0x65, 0x73, 0x74, 0x2E, 0xDA, 0x84, 0xAA, 0xD3, 0x03, 0xDA, 
  0x03, 0xDA, 0x82, 0x0B, 0xDA, 0x09, 0xCE, 0x1E, 0x28, 0x7A, 0x65, 0x72, 0x6F, 0x3F, 0x20, 0x78, 
  0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 0x73, 
  0x20, 0x7A, 0x65, 0x72, 0x6F, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x54, 0x01, 0xDA, 
  0x84, 0xAB, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x82, 0x91, 0xDA, 0x09, 0xCE, 0x17, 0x28, 0x64, 0x65, 
  0x63, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x78, 0x20, 
  0x2D, 0x20, 0x31, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x80, 0x82, 0x01, 0xDA, 0x84, 
  0xAC, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x84, 0xAD, 0xDA, 0x09, 0xCE, 0x57, 0x28, 0x62, 0x75, 0x66, 
  0x66, 0x65, 0x72, 0x2F, 0x62, 0x69, 0x74, 0x2D, 0x73, 0x65, 0x74, 0x20, 0x62, 0x75, 0x66, 0x66, 
  0x65, 0x72, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x29, 0x0A, 0x0A, 0x53, 0x65, 0x74, 0x73, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x62, 0x69, 0x74, 0x20, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x67, 
  0x69, 0x76, 0x65, 0x6E, 0x20, 0x62, 0x69, 0x74, 0x2D, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x2E, 0x20, 
  0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x75, 0x66, 0x66, 
  0x65, 0x72, 0x2E, 0xDA, 0x84, 0xAE, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x84, 0xAF, 0xDA, 0x09, 0xCE, 
  0x60, 0x28, 0x6F, 0x73, 0x2F, 0x73, 0x6C, 0x65, 0x65, 0x70, 0x20, 0x6E, 0x73, 0x65, 0x63, 0x29, 
  0x0A, 0x0A, 0x53, 0x75, 0x73, 0x70, 0x65, 0x6E, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 
  0x6F, 0x67, 0x72, 0x61, 0x6D, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x6E, 0x73, 0x65, 0x63, 0x20, 0x73, 
  0x65, 0x63, 0x6F, 0x6E, 0x64, 0x73, 0x2E, 0x20, 0x27, 0x6E, 0x73, 0x65, 0x63, 0x27, 0x20, 0x63, 
  0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x61, 0x20, 0x72, 0x65, 0x61, 0x6C, 0x20, 0x6E, 0x75, 0x6D, 
  0x62, 0x65, 0x72, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 
  0x2E, 0xDA, 0x84, 0xB0, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x84, 0xB1, 0xDA, 0x09, 0xCE, 0x4E, 0x28, 
  0x6F, 0x73, 0x2F, 0x72, 0x65, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x6F, 0x6C, 0x64, 0x6E, 0x61, 0x6D, 
  0x65, 0x20, 0x6E, 0x65, 0x77, 0x6E, 0x61, 0x6D, 0x65, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x6E, 0x61, 
  0x6D, 0x65, 0x20, 0x61, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x6F, 0x6E, 0x20, 0x64, 0x69, 0x73, 
  0x6B, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x70, 0x61, 0x74, 0x68, 0x2E, 
  0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0xDA, 0x84, 0xB2, 
  0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x84, 0xB3, 0xDA, 0x09, 0xCE, 0x6B, 0x28, 0x6F, 0x73, 0x2F, 0x70, 
  0x65, 0x72, 0x6D, 0x2D, 0x69, 0x6E, 0x74, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x29, 0x0A, 0x0A, 
  0x50, 0x61, 0x72, 0x73, 0x65, 0x20, 0x61, 0x20, 0x39, 0x20, 0x63, 0x68, 0x61, 0x72, 0x61, 0x63, 
  0x74, 0x65, 0x72, 0x20, 0x70, 0x65, 0x72, 0x6D, 0x69, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x73, 
  0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 
  0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x74, 0x68, 0x61, 0x74, 
  0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 
  0x63, 0x68, 0x6D, 0x6F, 0x64, 0x2E, 0xDA, 0x84, 0xB4, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 0x84, 0xB7, 
  0xDA, 0x09, 0xCE, 0x50, 0x28, 0x63, 0x68, 0x72, 0x20, 0x63, 0x29, 0x0A, 0x0A, 0x43, 0x6F, 0x6E, 
  0x76, 0x65, 0x72, 0x74, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x6F, 0x66, 
  0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x20, 0x31, 0x20, 0x74, 0x6F, 0x20, 0x69, 0x74, 0x73, 
  0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 0x28, 0x61, 0x73, 0x63, 0x69, 0x69, 0x29, 0x20, 0x76, 0x61, 
  0x6C, 0x75, 0x65, 0x20, 0x61, 0x74, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x20, 0x74, 
  0x69, 0x6D, 0x65, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x81, 0x50, 0x01, 0xDA, 0x35, 
  0xCB, 0xDA, 0x84, 0xB8, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x84, 0xBA, 0xDA, 0x09, 0xCE, 0x7B, 0x28, 
  0x67, 0x65, 0x74, 0x2D, 0x69, 0x6E, 0x20, 0x64, 0x73, 0x20, 0x6B, 0x73, 0x20, 0x26, 0x6F, 0x70, 
  0x74, 0x20, 0x64, 0x66, 0x6C, 0x74, 0x29, 0x0A, 0x0A, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x20, 
  0x61, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x73, 
  0x74, 0x65, 0x64, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 
  0x72, 0x65, 0x2E, 0x20, 0x4C, 0x6F, 0x6F, 0x6B, 0x73, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 
  0x65, 0x20, 0x76, 0x69, 0x61, 0x20, 0x20, 0x61, 0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6E, 0x63, 
  0x65, 0x20, 0x6F, 0x66, 0x20, 0x6B, 0x65, 0x79, 0x73, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 
  0x05, 0x84, 0xC9, 0x01, 0xDA, 0x84, 0xBB, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x82, 0xAE, 0xDA, 0x09, 
  0xCE, 0x80, 0x95, 0x28, 0x72, 0x65, 0x64, 0x75, 0x63, 0x65, 0x20, 0x66, 0x20, 0x69, 0x6E, 0x69, 
  0x74, 0x20, 0x69, 0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x64, 0x75, 0x63, 0x65, 0x2C, 0x20, 
  0x61, 0x6C, 0x73, 0x6F, 0x20, 0x6B, 0x6E, 0x6F, 0x77, 0x20, 0x61, 0x73, 0x20, 0x66, 0x6F, 0x6C, 
  0x64, 0x2D, 0x6C, 0x65, 0x66, 0x74, 0x20, 0x69, 0x6E, 0x20, 0x6D, 0x61, 0x6E, 0x79, 0x20, 0x6C, 
  0x61, 0x6E, 0x67, 0x75, 0x61, 0x67, 0x65, 0x73, 0x2C, 0x20, 0x74, 0x72, 0x61, 0x6E, 0x73, 0x66, 
  0x6F, 0x72, 0x6D, 0x73, 0x20, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x65, 0x64, 
  0x20, 0x74, 0x79, 0x70, 0x65, 0x20, 0x28, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2C, 0x20, 0x74, 0x75, 
  0x70, 0x6C, 0x65, 0x29, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61, 0x20, 0x66, 0x75, 0x6E, 0x63, 
  0x74, 0x69, 0x6F, 0x6E, 0x20, 0x74, 0x6F, 0x20, 0x70, 0x72, 0x6F, 0x64, 0x75, 0x63, 0x65, 0x20, 
  0x61, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x83, 
  0x12, 0x01, 0xDA, 0x84, 0xBC, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x80, 0xC6, 0xDA, 0x09, 0xCE, 0x66, 
  0x28, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x70, 0x6F, 0x73, 0x65, 0x20, 0x73, 0x65, 0x70, 0x20, 0x69, 
  0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x73, 
  0x65, 0x71, 0x75, 0x65, 0x6E, 0x63, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 
  0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x69, 0x6E, 0x64, 0x20, 0x73, 
  0x65, 0x70, 0x61, 0x72, 0x61, 0x74, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x20, 0x73, 0x65, 0x70, 
  0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 
  0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x85, 0x6E, 0x01, 
  0xDA, 0x84, 0x5D, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 0x84, 0xBE, 0xDA, 0x09, 0xCE, 0x82, 0x2B, 0x28, 
  0x69, 0x6D, 0x70, 0x6F, 0x72, 0x74, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x26, 0x20, 0x61, 0x72, 
  0x67, 0x73, 0x29, 0x0A, 0x0A, 0x49, 0x6D, 0x70, 0x6F, 0x72, 0x74, 0x20, 0x61, 0x20, 0x6D, 0x6F, 
  0x64, 0x75, 0x6C, 0x65, 0x2E, 0x20, 0x46, 0x69, 0x72, 0x73, 0x74, 0x20, 0x72, 0x65, 0x71, 0x75, 
  0x69, 0x72, 0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2C, 
  0x20, 0x61, 0x6E, 0x64, 0x20, 0x74, 0x68, 0x65, 0x6E, 0x20, 0x6D, 0x65, 0x72, 0x67, 0x65, 0x73, 
  0x20, 0x69, 0x74, 0x73, 0x20, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x73, 0x20, 0x69, 0x6E, 
  0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x65, 
  0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x2C, 0x20, 0x70, 0x72, 0x65, 0x70, 
  0x65, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x70, 
  0x72, 0x65, 0x66, 0x69, 0x78, 0x20, 0x61, 0x73, 0x20, 0x6E, 0x65, 0x65, 0x64, 0x65, 0x64, 0x2E, 
  0x20, 0x20, 0x28, 0x75, 0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x3A, 0x61, 0x73, 0x20, 0x6F, 
  0x72, 0x20, 0x3A, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 
  0x20, 0x74, 0x6F, 0x20, 0x73, 0x65, 0x74, 0x20, 0x61, 0x20, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 
  0x29, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x6E, 0x6F, 0x20, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x20, 
  0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x76, 0x69, 0x64, 0x65, 0x64, 0x2C, 0x20, 0x20, 0x75, 0x73, 
  0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x20, 0x61, 0x73, 0x20, 0x61, 0x20, 0x70, 0x72, 
  0x65, 0x66, 0x69, 0x78, 0x2E, 0x20, 0x4F, 0x6E, 0x65, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x61, 0x6C, 
  0x73, 0x6F, 0x20, 0x75, 0x73, 0x65, 0x20, 0x3A, 0x65, 0x78, 0x70, 0x6F, 0x72, 0x74, 0x20, 0x74, 
  0x72, 0x75, 0x65, 0x20, 0x20, 0x74, 0x6F, 0x20, 0x72, 0x65, 0x2D, 0x65, 0x78, 0x70, 0x6F, 0x72, 
  0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6D, 0x70, 0x6F, 0x72, 0x74, 0x65, 0x64, 0x20, 0x73, 
  0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x73, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x3A, 0x65, 0x78, 0x69, 0x74, 
  0x20, 0x74, 0x72, 0x75, 0x65, 0x20, 0x69, 0x73, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x61, 
  0x73, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x2C, 0x20, 0x20, 
  0x61, 0x6E, 0x79, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x73, 0x20, 0x65, 0x6E, 0x63, 0x6F, 0x75, 
  0x6E, 0x74, 0x65, 0x72, 0x65, 0x64, 0x20, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x6F, 
  0x70, 0x20, 0x6C, 0x65, 0x76, 0x65, 0x6C, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 
  0x6F, 0x64, 0x75, 0x6C, 0x65, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x63, 0x61, 0x75, 0x73, 0x65, 
  0x20, 0x28, 0x6F, 0x73, 0x2F, 0x65, 0x78, 0x69, 0x74, 0x20, 0x31, 0x29, 0x20, 0x20, 0x74, 0x6F, 
  0x20, 0x62, 0x65, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x65, 0x64, 0x2E, 0x20, 0x44, 0x79, 0x6E, 0x61, 
  0x6D, 0x69, 0x63, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x20, 0x77, 0x69, 0x6C, 
  0x6C, 0x20, 0x4E, 0x4F, 0x54, 0x20, 0x62, 0x65, 0x20, 0x69, 0x6D, 0x70, 0x6F, 0x72, 0x74, 0x65, 
  0x64, 0x2E, 0x20, 0x55, 0x73, 0x65, 0x20, 0x3A, 0x66, 0x72, 0x65, 0x73, 0x68, 0x20, 0x74, 0x6F, 
  0x20, 0x62, 0x79, 0x70, 0x61, 0x73, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x20, 0x6D, 0x6F, 0x64, 
  0x75, 0x6C, 0x65, 0x20, 0x63, 0x61, 0x63, 0x68, 0x65, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 
  0x05, 0x89, 0x59, 0x01, 0xDA, 0x35, 0xCB, 0xDA, 0x84, 0xBF, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x84, 
  0xC6, 0xDA, 0x09, 0xCE, 0x81, 0x70, 0x28, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2F, 0x61, 0x64, 
  0x64, 0x2D, 0x70, 0x61, 0x74, 0x68, 0x73, 0x20, 0x65, 0x78, 0x74, 0x20, 0x6C, 0x6F, 0x61, 0x64, 
  0x65, 0x72, 0x29, 0x0A, 0x0A, 0x41, 0x64, 0x64, 0x20, 0x70, 0x61, 0x74, 0x68, 0x73, 0x20, 0x74, 
  0x6F, 0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2F, 0x70, 0x61, 0x74, 0x68, 0x73, 0x20, 0x66, 
  0x6F, 0x72, 0x20, 0x61, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x6C, 0x6F, 0x61, 0x64, 0x65, 
  0x72, 0x20, 0x73, 0x75, 0x63, 0x68, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x67, 0x65, 0x6E, 0x65, 0x72, 0x61, 0x74, 0x65, 0x64, 0x20, 0x70, 0x61, 0x74, 0x68, 0x73, 
  0x20, 0x62, 0x65, 0x68, 0x61, 0x76, 0x65, 0x20, 0x6C, 0x69, 0x6B, 0x65, 0x20, 0x6F, 0x74, 0x68, 
  0x65, 0x72, 0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x20, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2C, 
  0x20, 0x69, 0x6E, 0x63, 0x6C, 0x75, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x20, 0x72, 0x65, 0x6C, 0x61, 
  0x74, 0x69, 0x76, 0x65, 0x20, 0x69, 0x6D, 0x70, 0x6F, 0x72, 0x74, 0x73, 0x20, 0x61, 0x6E, 0x64, 
  0x20, 0x73, 0x79, 0x73, 0x70, 0x61, 0x74, 0x68, 0x20, 0x69, 0x6D, 0x70, 0x6F, 0x72, 0x74, 0x73, 
  0x2E, 0x20, 0x65, 0x78, 0x74, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 
  0x65, 0x20, 0x65, 0x78, 0x74, 0x65, 0x6E, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x20, 0x74, 0x6F, 0x20, 
  0x61, 0x73, 0x73, 0x6F, 0x63, 0x69, 0x61, 0x74, 0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 
  0x68, 0x69, 0x73, 0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x20, 0x74, 0x79, 0x70, 0x65, 0x2C, 
  0x20, 0x69, 0x6E, 0x63, 0x6C, 0x75, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 
  0x6F, 0x74, 0x2E, 0x20, 0x6C, 0x6F, 0x61, 0x64, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x20, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x20, 
  0x6F, 0x66, 0x20, 0x61, 0x20, 0x6C, 0x6F, 0x61, 0x64, 0x65, 0x72, 0x20, 0x74, 0x68, 0x61, 0x74, 
  0x20, 0x69, 0x73, 0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2F, 0x6C, 0x6F, 0x61, 0x64, 0x65, 
  0x72, 0x73, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2F, 
  0x70, 0x61, 0x74, 0x68, 0x73, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x88, 0xA1, 0x01, 
  0xDA, 0x84, 0xC7, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x83, 0x95, 0xDA, 0x09, 0xCE, 0x81, 0x45, 0x28, 
  0x70, 0x72, 0x69, 0x6E, 0x74, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x50, 0x72, 0x69, 
  0x6E, 0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x63, 0x6F, 0x6E, 0x73, 0x6F, 0x6C, 0x65, 0x20, 0x28, 0x73, 0x74, 0x61, 0x6E, 0x64, 0x61, 
  0x72, 0x64, 0x20, 0x6F, 0x75, 0x74, 0x29, 0x2E, 0x20, 0x56, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x61, 
  0x72, 0x65, 0x20, 0x63, 0x6F, 0x6E, 0x76, 0x65, 0x72, 0x74, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 
  0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x73, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x79, 0x20, 
  0x61, 0x72, 0x65, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x61, 0x6C, 0x72, 0x65, 0x61, 0x64, 0x79, 0x2E, 
  0x20, 0x41, 0x66, 0x74, 0x65, 0x72, 0x20, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x69, 0x6E, 0x67, 0x20, 
  0x61, 0x6C, 0x6C, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x2C, 0x20, 0x61, 0x20, 0x6E, 0x65, 
  0x77, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0x63, 0x68, 0x61, 0x72, 0x61, 0x63, 0x74, 0x65, 0x72, 0x20, 
  0x69, 0x73, 0x20, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x65, 0x64, 0x2E, 0x20, 0x55, 0x73, 0x65, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x28, 0x64, 0x79, 
  0x6E, 0x20, 0x3A, 0x6F, 0x75, 0x74, 0x20, 0x73, 0x74, 0x64, 0x6F, 0x75, 0x74, 0x29, 0x20, 0x74, 
  0x6F, 0x20, 0x64, 0x65, 0x74, 0x65, 0x72, 0x6D, 0x69, 0x6E, 0x65, 0x20, 0x77, 0x68, 0x61, 0x74, 
  0x20, 0x74, 0x6F, 0x20, 0x70, 0x75, 0x73, 0x68, 0x20, 0x63, 0x68, 0x61, 0x72, 0x61, 0x63, 0x74, 
  0x65, 0x72, 0x73, 0x20, 0x74, 0x6F, 0x2E, 0x20, 0x45, 0x78, 0x70, 0x65, 0x63, 0x74, 0x73, 0x20, 
  0x28, 0x64, 0x79, 0x6E, 0x20, 0x3A, 0x6F, 0x75, 0x74, 0x20, 0x73, 0x74, 0x64, 0x6F, 0x75, 0x74, 
  0x29, 0x20, 0x74, 0x6F, 0x20, 0x62, 0x65, 0x20, 0x65, 0x69, 0x74, 0x68, 0x65, 0x72, 0x20, 0x61, 
  0x20, 0x63, 0x6F, 0x72, 0x65, 0x2F, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x6F, 0x72, 0x20, 0x61, 0x20, 
  0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 
  0x6E, 0x69, 0x6C, 0x2E, 0xDA, 0x84, 0xC8, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x84, 0xC9, 0xDA, 0x09, 
  0xCE, 0x80, 0x8B, 0x28, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x6E, 0x65, 0x77, 0x2D, 0x66, 0x69, 
  0x6C, 0x6C, 0x65, 0x64, 0x20, 0x63, 0x6F, 0x75, 0x6E, 0x74, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 
  0x76, 0x61, 0x6C, 0x75, 0x65, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x73, 0x20, 
  0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x6F, 0x66, 0x20, 0x63, 
  0x6F, 0x75, 0x6E, 0x74, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x2C, 0x20, 0x61, 
  0x6C, 0x6C, 0x20, 0x73, 0x65, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2C, 
  0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x73, 0x20, 
  0x74, 0x6F, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0xDA, 0x84, 
  0xCA, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x82, 0x9B, 0xDA, 0x09, 0xCE, 0x80, 0xB1, 0x28, 0x6C, 0x65, 
  0x6E, 0x67, 0x74, 0x68, 0x20, 0x64, 0x73, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 
  0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x20, 0x6F, 0x72, 0x20, 
  0x63, 0x6F, 0x75, 0x6E, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 
  0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x63, 0x6F, 0x6E, 
  0x73, 0x74, 0x61, 0x6E, 0x74, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x20, 0x61, 0x73, 0x20, 0x61, 0x6E, 
  0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x2E, 0x20, 0x46, 0x6F, 0x72, 0x20, 0x73, 0x74, 
  0x72, 0x75, 0x63, 0x74, 0x73, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x73, 
  0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x75, 
  0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x6B, 0x65, 0x79, 0x2D, 0x76, 0x61, 0x6C, 0x75, 
  0x65, 0x20, 0x70, 0x61, 0x69, 0x72, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 
  0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x2E, 0xDA, 0x81, 
  0x56, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x52, 0xDA, 0x09, 0xCE, 0x66, 0x28, 0x61, 0x72, 0x72, 0x61, 
  0x79, 0x2F, 0x70, 0x75, 0x73, 0x68, 0x20, 0x61, 0x72, 0x72, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x49, 
  0x6E, 0x73, 0x65, 0x72, 0x74, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 
  0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6E, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x61, 
  0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0x20, 0x4D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 
  0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6E, 0x70, 0x75, 0x74, 0x20, 0x61, 0x72, 0x72, 0x61, 
  0x79, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x69, 0x74, 
  0x2E, 0xDA, 0x84, 0xCB, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x84, 0xCD, 0xDA, 0x09, 0xCE, 0x3B, 0x28, 
  0x6D, 0x69, 0x6E, 0x20, 0x26, 0x20, 0x61, 0x72, 0x67, 0x73, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x75, 0x6D, 0x65, 0x72, 0x69, 0x63, 
  0x20, 0x6D, 0x69, 0x6E, 0x69, 0x6D, 0x75, 0x6D, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 
  0x05, 0x82, 0x90, 0x01, 0xDA, 0x84, 0xCE, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x84, 0xCF, 0xDA, 0x09, 
  0xCE, 0x27, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x6C, 0x6F, 0x67, 0x32, 0x20, 0x78, 0x29, 0x0A, 
  0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6C, 0x6F, 0x67, 0x20, 0x62, 0x61, 0x73, 
  0x65, 0x20, 0x32, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x2E, 0xDA, 0x84, 0xD0, 0xD3, 0x02, 0xDA, 0x03, 
  0xDA, 0x84, 0xD1, 0xDA, 0x09, 0xCE, 0x80, 0xCA, 0x28, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 
  0x63, 0x68, 0x65, 0x63, 0x6B, 0x2D, 0x73, 0x65, 0x74, 0x20, 0x73, 0x65, 0x74, 0x20, 0x73, 0x74, 
  0x72, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x73, 0x74, 0x72, 0x20, 0x6F, 
  0x6E, 0x6C, 0x79, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 0x73, 0x20, 0x62, 0x79, 0x74, 
  0x65, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x61, 0x70, 0x70, 0x65, 0x61, 0x72, 0x20, 0x69, 
  0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x73, 0x65, 0x74, 
  0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x72, 0x75, 0x65, 0x20, 0x69, 
  0x66, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x73, 
  0x74, 0x72, 0x20, 0x61, 0x70, 0x70, 0x65, 0x61, 0x72, 0x20, 0x69, 0x6E, 0x20, 0x73, 0x65, 0x74, 
  0x2C, 0x20, 0x66, 0x61, 0x6C, 0x73, 0x65, 0x20, 0x69, 0x66, 0x20, 0x73, 0x6F, 0x6D, 0x65, 0x20, 
  0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x73, 0x74, 0x72, 0x20, 0x64, 0x6F, 0x20, 
  0x6E, 0x6F, 0x74, 0x20, 0x61, 0x70, 0x70, 0x65, 0x61, 0x72, 0x20, 0x69, 0x6E, 0x20, 0x73, 0x65, 
  0x74, 0x2E, 0xDA, 0x7A, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x79, 0xDA, 0x09, 0xCE, 0x3A, 0x28, 0x66, 
  0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 
  0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x66, 0x75, 0x6E, 
  0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x28, 0x6E, 0x6F, 0x74, 0x20, 0x61, 0x20, 0x63, 0x66, 0x75, 
  0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x29, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x5E, 
  0x01, 0xDA, 0x84, 0xD2, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x82, 0x39, 0xDA, 0x09, 0xCE, 0x3B, 0x28, 
  0x6D, 0x61, 0x78, 0x20, 0x26, 0x20, 0x61, 0x72, 0x67, 0x73, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x75, 0x6D, 0x65, 0x72, 0x69, 0x63, 
  0x20, 0x6D, 0x61, 0x78, 0x69, 0x6D, 0x75, 0x6D, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 
  0x05, 0x82, 0x8C, 0x01, 0xDA, 0x84, 0xD3, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x83, 0xA8, 0xDA, 0x09, 
  0xCE, 0x80, 0xF9, 0x28, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 0x73, 0x74, 0x65, 0x70, 0x20, 0x66, 
  0x69, 0x62, 0x65, 0x72, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x75, 
  0x6E, 0x20, 0x61, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x6F, 0x6E, 
  0x65, 0x20, 0x76, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6C, 0x20, 0x69, 0x6E, 0x73, 0x74, 0x72, 0x75, 
  0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x4A, 0x61, 0x6E, 
  0x65, 0x74, 0x20, 0x6D, 0x61, 0x63, 0x68, 0x69, 0x6E, 0x65, 0x2E, 0x20, 0x43, 0x61, 0x6E, 0x20, 
  0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x6C, 0x79, 0x20, 0x70, 0x61, 0x73, 0x73, 0x20, 
  0x69, 0x6E, 0x20, 0x61, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 
  0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x70, 0x61, 0x73, 0x73, 0x65, 0x64, 0x20, 0x61, 
  0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6D, 0x69, 0x6E, 0x67, 0x20, 0x76, 
  0x61, 0x6C, 0x75, 0x65, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2C, 0x20, 
  0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x75, 0x73, 0x75, 0x61, 0x6C, 
  0x6C, 0x79, 0x20, 0x62, 0x65, 0x20, 0x6E, 0x69, 0x6C, 0x2C, 0x20, 0x61, 0x73, 0x20, 0x62, 0x72, 
  0x65, 0x61, 0x6B, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x73, 0x20, 0x72, 0x61, 0x69, 0x73, 0x65, 0x20, 
  0x6E, 0x69, 0x6C, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0x73, 0x2E, 0xDA, 0x84, 0xD4, 0xD3, 
  0x02, 0xDA, 0x03, 0xDA, 0x53, 0xDA, 0x09, 0xCE, 0x80, 0x83, 0x28, 0x74, 0x61, 0x62, 0x6C, 0x65, 
  0x2F, 0x67, 0x65, 0x74, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0x20, 0x74, 0x61, 0x62, 0x29, 0x0A, 0x0A, 
  0x47, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0x74, 0x79, 0x70, 
  0x65, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x20, 0x74, 0x61, 0x62, 
  0x6C, 0x65, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x20, 
  0x69, 0x66, 0x20, 0x61, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x68, 0x61, 0x73, 0x20, 0x6E, 
  0x6F, 0x20, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0x74, 0x79, 0x70, 0x65, 0x2C, 0x20, 0x6F, 0x74, 0x68, 
  0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0x74, 0x79, 0x70, 0x65, 0x2E, 0xDA, 0x84, 0xD5, 
  0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x84, 0xD6, 0xDA, 0x09, 0xCE, 0x45, 0x28, 0x74, 0x61, 0x72, 0x72, 
  0x61, 0x79, 0x2F, 0x70, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x20, 0x61, 0x72, 
  0x72, 0x61, 0x79, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x74, 0x79, 0x70, 
  0x65, 0x64, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x70, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 
  0x69, 0x65, 0x73, 0x20, 0x61, 0x73, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x2E, 
  0xDA, 0x84, 0xD7, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 0x84, 0xD9, 0xDA, 0x09, 0xCE, 0x72, 0x28, 0x64, 
  0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x20, 0x73, 0x79, 0x6D, 0x20, 0x76, 0x61, 0x6C, 0x29, 0x0A, 
  0x0A, 0x44, 0x65, 0x66, 0x69, 0x6E, 0x65, 0x20, 0x61, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 
  0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x61, 0x6E, 0x20, 0x6F, 
  0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 
  0x2E, 0x20, 0x20, 0x45, 0x78, 0x70, 0x61, 0x6E, 0x64, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x28, 0x64, 
  0x65, 0x66, 0x20, 0x73, 0x79, 0x6D, 0x20, 0x28, 0x69, 0x66, 0x20, 0x28, 0x3D, 0x20, 0x6E, 0x69, 
  0x6C, 0x20, 0x73, 0x79, 0x6D, 0x29, 0x20, 0x76, 0x61, 0x6C, 0x20, 0x73, 0x79, 0x6D, 0x29, 0x29, 
  0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x80, 0x95, 0x01, 0xDA, 0x35, 0xCB, 0xDA, 0x84, 0xDA, 
  0xD3, 0x04, 0xDA, 0x03, 0xDA, 0x84, 0xDC, 0xDA, 0x09, 0xCE, 0x5F, 0x28, 0x63, 0x6F, 0x6D, 0x70, 
  0x74, 0x69, 0x6D, 0x65, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x20, 0x20, 0x45, 0x76, 0x61, 0x6C, 0x73, 
  0x20, 0x78, 0x20, 0x61, 0x74, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x20, 0x74, 0x69, 
  0x6D, 0x65, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6C, 0x74, 0x2E, 0x20, 0x53, 0x69, 0x6D, 0x69, 0x6C, 
  0x61, 0x72, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x74, 0x6F, 0x70, 0x20, 0x6C, 0x65, 0x76, 0x65, 
  0x6C, 0x20, 0x75, 0x6E, 0x71, 0x75, 0x6F, 0x74, 0x65, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 
  0x05, 0x88, 0x80, 0x01, 0xDA, 0x35, 0xCB, 0xDA, 0x84, 0xDD, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x84, 
  0xDF, 0xDA, 0x09, 0xCE, 0x80, 0xA9, 0x28, 0x6D, 0x65, 0x72, 0x67, 0x65, 0x20, 0x26, 0x20, 0x63, 
  0x6F, 0x6C, 0x6C, 0x73, 0x29, 0x0A, 0x0A, 0x4D, 0x65, 0x72, 0x67, 0x65, 0x73, 0x20, 0x6D, 0x75, 
  0x6C, 0x74, 0x69, 0x70, 0x6C, 0x65, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x73, 0x2F, 0x73, 0x74, 
  0x72, 0x75, 0x63, 0x74, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x6F, 0x6E, 0x65, 0x2E, 0x20, 0x49, 0x66, 
  0x20, 0x61, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x61, 0x70, 0x70, 0x65, 0x61, 0x72, 0x73, 0x20, 0x69, 
  0x6E, 0x20, 0x6D, 0x6F, 0x72, 0x65, 0x20, 0x74, 0x68, 0x61, 0x6E, 0x20, 0x6F, 0x6E, 0x65, 0x20, 
  0x20, 0x63, 0x6F, 0x6C, 0x6C, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2C, 0x20, 0x74, 0x68, 0x65, 
  0x6E, 0x20, 0x6C, 0x61, 0x74, 0x65, 0x72, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x72, 
  0x65, 0x70, 0x6C, 0x61, 0x63, 0x65, 0x20, 0x61, 0x6E, 0x79, 0x20, 0x70, 0x72, 0x65, 0x76, 0x69, 
  0x6F, 0x75, 0x73, 0x20, 0x6F, 0x6E, 0x65, 0x73, 0x2E, 0x20, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0xDA, 
  0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x85, 0x0F, 0x01, 0xDA, 0x84, 0xE0, 0xD3, 0x04, 0xDA, 0x03, 
  0xDA, 0x84, 0xE2, 0xDA, 0x09, 0xCE, 0x80, 0xDD, 0x28, 0x2D, 0x3E, 0x20, 0x78, 0x20, 0x26, 0x20, 
  0x66, 0x6F, 0x72, 0x6D, 0x73, 0x29, 0x0A, 0x0A, 0x54, 0x68, 0x72, 0x65, 0x61, 0x64, 0x69, 0x6E, 
  0x67, 0x20, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x2E, 0x20, 0x49, 0x6E, 0x73, 0x65, 0x72, 0x74, 0x73, 
  0x20, 0x78, 0x20, 0x61, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x63, 0x6F, 0x6E, 0x64, 
  0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 
  0x72, 0x73, 0x74, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x20, 0x20, 0x69, 0x6E, 0x20, 0x66, 0x6F, 0x72, 
  0x6D, 0x73, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x69, 0x6E, 0x73, 0x65, 0x72, 0x74, 0x73, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x66, 0x69, 0x72, 
  0x73, 0x74, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x73, 0x65, 0x63, 0x6F, 0x6E, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x20, 0x20, 0x69, 0x6E, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6D, 0x65, 0x20, 0x6D, 0x61, 0x6E, 0x6E, 0x65, 0x72, 
  0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x73, 0x6F, 0x20, 0x6F, 0x6E, 0x2E, 0x20, 0x55, 0x73, 0x65, 
  0x66, 0x75, 0x6C, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 
  0x6E, 0x67, 0x20, 0x70, 0x69, 0x70, 0x65, 0x6C, 0x69, 0x6E, 0x65, 0x73, 0x20, 0x6F, 0x66, 0x20, 
  0x64, 0x61, 0x74, 0x61, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x84, 0x02, 0x01, 0xDA, 
  0x35, 0xCB, 0xDA, 0x84, 0xE3, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x80, 0xC1, 0xDA, 0x09, 0xCE, 0x39, 
  0x28, 0x69, 0x64, 0x65, 0x6E, 0x74, 0x69, 0x74, 0x79, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x41, 0x20, 
  0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x72, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x69, 0x74, 0x73, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 
  0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 
  0x82, 0x79, 0x01, 0xDA, 0x84, 0xE4, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x84, 0xE6, 0xDA, 0x09, 0xCE, 
  0x5F, 0x28, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0x3C, 0x3D, 0x20, 0x26, 0x20, 0x78, 0x73, 
  0x29, 0x0A, 0x0A, 0x45, 0x71, 0x75, 0x69, 0x76, 0x61, 0x6C, 0x65, 0x6E, 0x74, 0x20, 0x6F, 0x66, 
  0x20, 0x27, 0x3C, 0x3D, 0x27, 0x20, 0x62, 0x75, 0x74, 0x20, 0x75, 0x73, 0x69, 0x6E, 0x67, 0x20, 
  0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 
  0x20, 0x69, 0x6E, 0x73, 0x74, 0x65, 0x61, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x70, 0x72, 0x69, 0x6D, 
  0x69, 0x74, 0x69, 0x76, 0x65, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x61, 0x74, 0x6F, 0x72, 
  0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x82, 0xCB, 0x01, 0xDA, 0x84, 0xE7, 0xD3, 0x02, 0xDA, 
  0x03, 0xDA, 0x84, 0xE9, 0xDA, 0x09, 0xCE, 0x82, 0x57, 0x28, 0x70, 0x75, 0x74, 0x20, 0x64, 0x73, 
  0x20, 0x6B, 0x65, 0x79, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x29, 0x0A, 0x0A, 0x41, 0x73, 0x73, 
  0x6F, 0x63, 0x69, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x77, 0x69, 0x74, 
  0x68, 0x20, 0x61, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x6E, 0x79, 
  0x20, 0x6D, 0x75, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x61, 0x73, 0x73, 0x6F, 0x63, 0x69, 0x61, 
  0x74, 0x69, 0x76, 0x65, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 
  0x75, 0x72, 0x65, 0x2E, 0x20, 0x49, 0x6E, 0x64, 0x65, 0x78, 0x65, 0x64, 0x20, 0x64, 0x61, 0x74, 
  0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x73, 0x20, 0x28, 0x61, 0x72, 
  0x72, 0x61, 0x79, 0x73, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x73, 
  0x29, 0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x20, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x20, 0x6E, 0x6F, 
  0x6E, 0x2D, 0x6E, 0x65, 0x67, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 
  0x65, 0x72, 0x20, 0x6B, 0x65, 0x79, 0x73, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x77, 0x69, 0x6C, 
  0x6C, 0x20, 0x65, 0x78, 0x70, 0x61, 0x6E, 0x64, 0x20, 0x69, 0x66, 0x20, 0x61, 0x6E, 0x20, 0x6F, 
  0x75, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x62, 0x6F, 0x75, 0x6E, 0x64, 0x73, 0x20, 0x76, 0x61, 0x6C, 
  0x75, 0x65, 0x20, 0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x76, 0x69, 0x64, 0x65, 0x64, 0x2E, 0x20, 
  0x49, 0x6E, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2C, 0x20, 0x65, 0x78, 0x74, 
  0x72, 0x61, 0x20, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 
  0x20, 0x66, 0x69, 0x6C, 0x6C, 0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x6E, 0x69, 0x6C, 
  0x73, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x62, 0x75, 0x66, 0x66, 
  0x65, 0x72, 0x2C, 0x20, 0x65, 0x78, 0x74, 0x72, 0x61, 0x20, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20, 
  0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x6C, 0x65, 0x64, 0x20, 0x77, 
  0x69, 0x74, 0x68, 0x20, 0x30, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x2E, 0x20, 0x49, 0x6E, 0x20, 
  0x61, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2C, 0x20, 0x70, 0x75, 0x74, 0x74, 0x69, 0x6E, 0x67, 
  0x20, 0x61, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x73, 0x20, 0x63, 
  0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0x74, 0x79, 0x70, 0x65, 0x20, 
  0x77, 0x69, 0x6C, 0x6C, 0x20, 0x68, 0x69, 0x64, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x73, 
  0x73, 0x6F, 0x63, 0x69, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64, 0x65, 0x66, 0x69, 0x6E, 0x65, 
  0x64, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0x74, 0x79, 
  0x70, 0x65, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x6E, 0x6F, 0x74, 
  0x20, 0x6D, 0x75, 0x74, 0x61, 0x74, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x74, 
  0x6F, 0x74, 0x79, 0x70, 0x65, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0x20, 0x50, 0x75, 0x74, 
  0x74, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x6E, 0x69, 0x6C, 
  0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x77, 0x69, 
  0x6C, 0x6C, 0x20, 0x72, 0x65, 0x6D, 0x6F, 0x76, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6B, 0x65, 
  0x79, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 
  0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x61, 
  0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x20, 0x64, 0x73, 0x2E, 
  0xDA, 0x84, 0xEA, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x84, 0xEB, 0xDA, 0x09, 0xCE, 0x31, 0x28, 0x6D, 
  0x61, 0x74, 0x68, 0x2F, 0x63, 0x6F, 0x73, 0x68, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x68, 0x79, 0x70, 0x65, 0x72, 0x62, 0x6F, 0x6C, 
  0x69, 0x63, 0x20, 0x63, 0x6F, 0x73, 0x69, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x2E, 0xDA, 
  0x84, 0xEC, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 0x84, 0xEE, 0xDA, 0x09, 0xCE, 0x4F, 0x28, 0x66, 0x6F, 
  0x72, 0x20, 0x69, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x73, 0x74, 0x6F, 0x70, 0x20, 0x26, 
  0x20, 0x62, 0x6F, 0x64, 0x79, 0x29, 0x0A, 0x0A, 0x44, 0x6F, 0x20, 0x61, 0x20, 0x63, 0x20, 0x73, 
  0x74, 0x79, 0x6C, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x6C, 0x6F, 0x6F, 0x70, 0x20, 0x66, 0x6F, 
  0x72, 0x20, 0x73, 0x69, 0x64, 0x65, 0x20, 0x65, 0x66, 0x66, 0x65, 0x63, 0x74, 0x73, 0x2E, 0x20, 
  0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 
  0x00, 0xDA, 0x05, 0x81, 0xE1, 0x01, 0xDA, 0x35, 0xCB, 0xDA, 0x84, 0xEF, 0xD3, 0x03, 0xDA, 0x03, 
  0xDA, 0x84, 0xF1, 0xDA, 0x09, 0xCE, 0x80, 0xC8, 0x28, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x20, 
  0x64, 0x73, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x20, 0x26, 0x20, 0x61, 0x72, 
  0x67, 0x73, 0x29, 0x0A, 0x0A, 0x41, 0x63, 0x63, 0x65, 0x70, 0x74, 0x73, 0x20, 0x61, 0x20, 0x6B, 
  0x65, 0x79, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x61, 0x6E, 0x64, 0x20, 
  0x70, 0x61, 0x73, 0x73, 0x65, 0x73, 0x20, 0x69, 0x74, 0x73, 0x20, 0x61, 0x73, 0x73, 0x6F, 0x63, 
  0x69, 0x61, 0x74, 0x65, 0x64, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x61, 
  0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0x20, 0x20, 0x54, 0x68, 0x65, 0x20, 
  0x6B, 0x65, 0x79, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x2D, 0x61, 0x73, 
  0x73, 0x6F, 0x63, 0x69, 0x61, 0x74, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x27, 0x73, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x20, 0x20, 0x64, 0x61, 
  0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x20, 0x64, 0x73, 0x2E, 
  0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x84, 0xFD, 0x01, 0xDA, 0x84, 0xF2, 0xD3, 0x03, 0xDA, 
  0x03, 0xDA, 0x82, 0x5D, 0xDA, 0x09, 0xCE, 0x80, 0xBD, 0x28, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 
  0x65, 0x2D, 0x70, 0x72, 0x69, 0x6D, 0x69, 0x74, 0x69, 0x76, 0x65, 0x20, 0x78, 0x20, 0x79, 0x29, 
  0x0A, 0x0A, 0x43, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0x20, 0x78, 0x20, 0x61, 0x6E, 0x64, 0x20, 
  0x79, 0x20, 0x75, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x70, 0x72, 0x69, 0x6D, 0x69, 0x74, 0x69, 0x76, 
  0x65, 0x20, 0x6F, 0x70, 0x65, 0x72, 0x61, 0x74, 0x6F, 0x72, 0x73, 0x2E, 0x20, 0x20, 0x20, 0x52, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x2D, 0x31, 0x2C, 0x30, 0x2C, 0x31, 0x20, 0x66, 0x6F, 
  0x72, 0x20, 0x78, 0x20, 0x3C, 0x20, 0x79, 0x2C, 0x20, 0x78, 0x20, 0x3D, 0x20, 0x79, 0x2C, 0x20, 
  0x78, 0x20, 0x3E, 0x20, 0x79, 0x20, 0x72, 0x65, 0x73, 0x70, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 
  0x6C, 0x79, 0x2E, 0x20, 0x20, 0x20, 0x50, 0x72, 0x65, 0x73, 0x65, 0x6E, 0x74, 0x20, 0x6D, 0x6F, 
  0x73, 0x74, 0x6C, 0x79, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x72, 0x75, 
  0x63, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x27, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 0x27, 0x20, 
  0x6D, 0x65, 0x74, 0x68, 0x6F, 0x64, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x70, 0x72, 0x6F, 0x74, 0x6F, 
  0x74, 0x79, 0x70, 0x65, 0x73, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x82, 0xA0, 0x01, 
  0xDA, 0x84, 0xF3, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x80, 0xF2, 0xDA, 0x09, 0xCE, 0x76, 0x28, 0x70, 
  0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x65, 0x6F, 0x66, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 
  0x29, 0x0A, 0x0A, 0x49, 0x6E, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6E, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x66, 0x69, 0x6C, 0x65, 
  0x20, 0x77, 0x61, 0x73, 0x20, 0x72, 0x65, 0x61, 0x63, 0x68, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2E, 0x20, 0x54, 0x68, 0x69, 0x73, 
  0x20, 0x70, 0x75, 0x74, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 
  0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x3A, 0x64, 0x65, 0x61, 0x64, 0x20, 0x73, 0x74, 
  0x61, 0x74, 0x65, 0x2E, 0xDA, 0x84, 0xF4, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x84, 0xF5, 0xDA, 0x09, 
  0xCE, 0x78, 0x28, 0x6E, 0x65, 0x74, 0x2F, 0x77, 0x72, 0x69, 0x74, 0x65, 0x20, 0x73, 0x74, 0x72, 
  0x65, 0x61, 0x6D, 0x20, 0x64, 0x61, 0x74, 0x61, 0x29, 0x0A, 0x0A, 0x57, 0x72, 0x69, 0x74, 0x65, 
  0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 
  0x6D, 0x2C, 0x20, 0x73, 0x75, 0x73, 0x70, 0x65, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 
  0x75, 0x6E, 0x74, 0x69, 0x6C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x20, 
  0x63, 0x6F, 0x6D, 0x70, 0x6C, 0x65, 0x74, 0x65, 0x73, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x73, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x2E, 0xDA, 0x84, 0xF6, 0xD3, 0x03, 0xDA, 
  0x03, 0xDA, 0x82, 0x38, 0xDA, 0x09, 0xCE, 0x80, 0xBF, 0x28, 0x65, 0x78, 0x74, 0x72, 0x65, 0x6D, 
  0x65, 0x20, 0x6F, 0x72, 0x64, 0x65, 0x72, 0x20, 0x61, 0x72, 0x67, 0x73, 0x29, 0x0A, 0x0A, 0x52, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x6F, 0x73, 0x74, 0x20, 
  0x65, 0x78, 0x74, 0x72, 0x65, 0x6D, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x69, 0x6E, 
  0x20, 0x61, 0x72, 0x67, 0x73, 0x20, 0x62, 0x61, 0x73, 0x65, 0x64, 0x20, 0x6F, 0x6E, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x6F, 0x72, 0x64, 0x65, 
  0x72, 0x2E, 0x20, 0x20, 0x6F, 0x72, 0x64, 0x65, 0x72, 0x20, 0x73, 0x68, 0x6F, 0x75, 0x6C, 0x64, 
  0x20, 0x74, 0x61, 0x6B, 0x65, 0x20, 0x74, 0x77, 0x6F, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 
  0x20, 0x61, 0x6E, 0x64, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x74, 0x72, 0x75, 0x65, 
  0x20, 0x6F, 0x72, 0x20, 0x66, 0x61, 0x6C, 0x73, 0x65, 0x20, 0x28, 0x61, 0x20, 0x63, 0x6F, 0x6D, 
  0x70, 0x61, 0x72, 0x69, 0x73, 0x6F, 0x6E, 0x29, 0x2E, 0x20, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x20, 0x69, 0x66, 0x20, 0x61, 0x72, 0x67, 0x73, 0x20, 0x69, 
  0x73, 0x20, 0x65, 0x6D, 0x70, 0x74, 0x79, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x82, 
  0x83, 0x01, 0xDA, 0x84, 0xF7, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x83, 0x2D, 0xDA, 0x09, 0xCE, 0x7C, 
  0x28, 0x65, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x66, 0x20, 0x66, 0x6D, 0x74, 0x20, 0x26, 0x20, 0x78, 
  0x73, 0x29, 0x0A, 0x0A, 0x50, 0x72, 0x69, 0x6E, 0x74, 0x73, 0x20, 0x6F, 0x75, 0x74, 0x70, 0x75, 
  0x74, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x74, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 0x69, 
  0x66, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x28, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x66, 
  0x6F, 0x72, 0x6D, 0x61, 0x74, 0x20, 0x66, 0x6D, 0x74, 0x20, 0x3B, 0x78, 0x73, 0x29, 0x20, 0x74, 
  0x6F, 0x20, 0x28, 0x64, 0x79, 0x6E, 0x20, 0x3A, 0x65, 0x72, 0x72, 0x20, 0x73, 0x74, 0x64, 0x65, 
  0x72, 0x72, 0x29, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61, 0x20, 0x74, 0x72, 0x61, 0x69, 0x6C, 
  0x69, 0x6E, 0x67, 0x20, 0x6E, 0x65, 0x77, 0x6C, 0x69, 0x6E, 0x65, 0x2E, 0xDA, 0x84, 0xF8, 0xD3, 
  0x02, 0xDA, 0x03, 0xDA, 0x84, 0xF9, 0xDA, 0x09, 0xCE, 0x50, 0x28, 0x74, 0x61, 0x72, 0x72, 0x61, 
  0x79, 0x2F, 0x6E, 0x65, 0x77, 0x20, 0x74, 0x79, 0x70, 0x65, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x20, 
  0x26, 0x6F, 0x70, 0x74, 0x20, 0x73, 0x74, 0x72, 0x69, 0x64, 0x65, 0x20, 0x6F, 0x66, 0x66, 0x73, 
  0x65, 0x74, 0x20, 0x74, 0x61, 0x72, 0x72, 0x61, 0x79, 0x7C, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 
  0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x74, 0x79, 
  0x70, 0x65, 0x64, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0xDA, 0x84, 0xFA, 0xD3, 0x03, 0xDA, 
  0x03, 0xDA, 0x84, 0xFC, 0xDA, 0x09, 0xCE, 0x5F, 0x28, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x6C, 0x65, 
  0x61, 0x76, 0x65, 0x20, 0x26, 0x20, 0x63, 0x6F, 0x6C, 0x73, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x6F, 0x66, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 
  0x6E, 0x74, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x65, 0x61, 0x63, 0x68, 0x20, 0x63, 0x6F, 0x6C, 0x2C, 
  0x20, 0x20, 0x74, 0x68, 0x65, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x63, 0x6F, 0x6E, 
  0x64, 0x2C, 0x20, 0x65, 0x74, 0x63, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x85, 0x41, 
  0x01, 0xDA, 0x84, 0xFD, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x84, 0xFF, 0xDA, 0x09, 0xCE, 0x80, 0xF4, 
  0x28, 0x62, 0x72, 0x75, 0x73, 0x68, 0x69, 0x66, 0x74, 0x20, 0x78, 0x20, 0x26, 0x20, 0x73, 0x68, 
  0x69, 0x66, 0x74, 0x73, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x20, 0x62, 0x69, 
  0x74, 0x20, 0x73, 0x68, 0x69, 0x66, 0x74, 0x65, 0x64, 0x20, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 
  0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x75, 0x6D, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x6C, 
  0x6C, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x73, 0x68, 0x69, 0x66, 
  0x74, 0x73, 0x2E, 0x20, 0x78, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x65, 0x61, 0x63, 0x68, 0x20, 0x65, 
  0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x69, 0x6E, 0x20, 0x73, 0x68, 0x69, 0x66, 0x74, 0x20, 
  0x6D, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 
  0x65, 0x72, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x20, 0x6F, 0x66, 0x20, 
  0x78, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x70, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 
  0x65, 0x64, 0x2C, 0x20, 0x73, 0x6F, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x70, 0x6F, 0x73, 0x69, 0x74, 
  0x69, 0x76, 0x65, 0x20, 0x73, 0x68, 0x69, 0x66, 0x74, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x77, 0x69, 0x6C, 0x6C, 
  0x20, 0x61, 0x6C, 0x77, 0x61, 0x79, 0x73, 0x20, 0x62, 0x65, 0x20, 0x70, 0x6F, 0x73, 0x69, 0x74, 
  0x69, 0x76, 0x65, 0x2E, 0xDA, 0x85, 0x00, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x85, 0x02, 0xDA, 0x09, 
  0xCE, 0x22, 0x28, 0x74, 0x72, 0x75, 0x74, 0x68, 0x79, 0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 
  0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 0x74, 0x72, 0x75, 
  0x74, 0x68, 0x79, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x6F, 0x01, 0xDA, 0x85, 0x03, 
  0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x83, 0xB0, 0xDA, 0x09, 0xCE, 0x83, 0x2D, 0x28, 0x64, 0x65, 0x62, 
  0x75, 0x67, 0x2F, 0x73, 0x74, 0x61, 0x63, 0x6B, 0x20, 0x66, 0x69, 0x62, 0x29, 0x0A, 0x0A, 0x47, 
  0x65, 0x74, 0x73, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 
  0x61, 0x62, 0x6F, 0x75, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x61, 0x63, 0x6B, 0x20, 
  0x61, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x6F, 0x66, 0x20, 0x74, 
  0x61, 0x62, 0x6C, 0x65, 0x73, 0x2E, 0x20, 0x45, 0x61, 0x63, 0x68, 0x20, 0x74, 0x61, 0x62, 0x6C, 
  0x65, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x63, 
  0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 0x73, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 
  0x69, 0x6F, 0x6E, 0x20, 0x61, 0x62, 0x6F, 0x75, 0x74, 0x20, 0x61, 0x20, 0x73, 0x74, 0x61, 0x63, 
  0x6B, 0x20, 0x66, 0x72, 0x61, 0x6D, 0x65, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x74, 0x6F, 0x70, 
  0x20, 0x6D, 0x6F, 0x73, 0x74, 0x2C, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x73, 
  0x74, 0x61, 0x63, 0x6B, 0x20, 0x66, 0x72, 0x61, 0x6D, 0x65, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x69, 0x6E, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x62, 0x6F, 0x74, 0x74, 0x6F, 0x6D, 0x20, 0x6D, 0x6F, 0x73, 0x74, 0x20, 
  0x73, 0x74, 0x61, 0x63, 0x6B, 0x20, 0x66, 0x72, 0x61, 0x6D, 0x65, 0x20, 0x69, 0x73, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x6C, 0x61, 0x73, 0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2E, 0x20, 0x45, 
  0x61, 0x63, 0x68, 0x20, 0x73, 0x74, 0x61, 0x63, 0x6B, 0x20, 0x66, 0x72, 0x61, 0x6D, 0x65, 0x20, 
  0x63, 0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 0x73, 0x20, 0x73, 0x6F, 0x6D, 0x65, 0x20, 0x6F, 0x66, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x6F, 0x6C, 0x6C, 0x6F, 0x77, 0x69, 0x6E, 0x67, 0x20, 0x61, 
  0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x73, 0x3A, 0x0A, 0x0A, 0x09, 0x3A, 0x63, 0x20, 
  0x2D, 0x20, 0x74, 0x72, 0x75, 0x65, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 
  0x61, 0x63, 0x6B, 0x20, 0x66, 0x72, 0x61, 0x6D, 0x65, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x63, 
  0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x69, 0x6E, 0x76, 0x6F, 0x63, 0x61, 
  0x74, 0x69, 0x6F, 0x6E, 0x0A, 0x09, 0x3A, 0x63, 0x6F, 0x6C, 0x75, 0x6D, 0x6E, 0x20, 0x2D, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x73, 0x6F, 0x75, 0x72, 
  0x63, 0x65, 0x20, 0x63, 0x6F, 0x6C, 0x75, 0x6D, 0x6E, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x73, 0x74, 0x61, 0x63, 0x6B, 0x20, 0x66, 0x72, 0x61, 0x6D, 0x65, 0x0A, 0x09, 0x3A, 0x66, 
  0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x2D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x75, 
  0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x73, 0x74, 0x61, 0x63, 0x6B, 0x20, 0x66, 0x72, 0x61, 0x6D, 0x65, 0x20, 0x72, 0x65, 0x70, 0x72, 
  0x65, 0x73, 0x65, 0x6E, 0x74, 0x73, 0x0A, 0x09, 0x3A, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0x2D, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x73, 0x6F, 0x75, 0x72, 
  0x63, 0x65, 0x20, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 
  0x74, 0x61, 0x63, 0x6B, 0x20, 0x66, 0x72, 0x61, 0x6D, 0x65, 0x0A, 0x09, 0x3A, 0x6E, 0x61, 0x6D, 
  0x65, 0x20, 0x2D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x68, 0x75, 0x6D, 0x61, 0x6E, 0x20, 0x66, 0x72, 
  0x69, 0x65, 0x6E, 0x64, 0x6C, 0x79, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x0A, 0x09, 0x3A, 0x70, 0x63, 
  0x20, 0x2D, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x69, 0x6E, 0x64, 0x69, 0x63, 
  0x61, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x69, 
  0x6F, 0x6E, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x67, 0x72, 0x61, 
  0x6D, 0x20, 0x63, 0x6F, 0x75, 0x6E, 0x74, 0x65, 0x72, 0x0A, 0x09, 0x3A, 0x73, 0x6F, 0x75, 0x72, 
  0x63, 0x65, 0x20, 0x2D, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x77, 0x69, 0x74, 0x68, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x6F, 
  0x72, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x20, 0x69, 0x64, 0x65, 0x6E, 0x74, 0x69, 0x66, 0x69, 
  0x65, 0x72, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x6F, 0x75, 0x72, 0x63, 
  0x65, 0x20, 0x63, 0x6F, 0x64, 0x65, 0x0A, 0x09, 0x3A, 0x73, 0x6C, 0x6F, 0x74, 0x73, 0x20, 0x2D, 
  0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x76, 0x61, 
  0x6C, 0x75, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x65, 0x61, 0x63, 0x68, 0x20, 0x73, 0x6C, 0x6F, 
  0x74, 0x0A, 0x09, 0x3A, 0x74, 0x61, 0x69, 0x6C, 0x20, 0x2D, 0x20, 0x62, 0x6F, 0x6F, 0x6C, 0x65, 
  0x61, 0x6E, 0x20, 0x69, 0x6E, 0x64, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x20, 
  0x74, 0x61, 0x69, 0x6C, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0xDA, 0x85, 0x04, 0xD3, 0x02, 0xDA, 0x03, 
  0xDA, 0x85, 0x05, 0xDA, 0x09, 0xCE, 0x38, 0x28, 0x6F, 0x73, 0x2F, 0x75, 0x6D, 0x61, 0x73, 0x6B, 
  0x20, 0x6D, 0x61, 0x73, 0x6B, 0x29, 0x0A, 0x0A, 0x53, 0x65, 0x74, 0x20, 0x61, 0x20, 0x6E, 0x65, 
  0x77, 0x20, 0x75, 0x6D, 0x61, 0x73, 0x6B, 0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x6F, 0x6C, 0x64, 0x20, 0x75, 0x6D, 0x61, 0x73, 0x6B, 0x2E, 0xDA, 
  0x85, 0x06, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x85, 0x07, 0xDA, 0x09, 0xCE, 0x32, 0x28, 0x6D, 0x61, 
  0x74, 0x68, 0x2F, 0x74, 0x61, 0x6E, 0x68, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x68, 0x79, 0x70, 0x65, 0x72, 0x62, 0x6F, 0x6C, 0x69, 
  0x63, 0x20, 0x74, 0x61, 0x6E, 0x67, 0x65, 0x6E, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x2E, 0xDA, 
  0x85, 0x08, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x80, 0x91, 0xDA, 0x09, 0xCE, 0x82, 0x0A, 0x54, 0x68, 
  0x65, 0x20, 0x6C, 0x69, 0x73, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x70, 0x61, 0x74, 0x68, 0x73, 0x20, 
  0x74, 0x6F, 0x20, 0x6C, 0x6F, 0x6F, 0x6B, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x6D, 0x6F, 0x64, 0x75, 
  0x6C, 0x65, 0x73, 0x2C, 0x20, 0x74, 0x65, 0x6D, 0x70, 0x6C, 0x61, 0x74, 0x65, 0x64, 0x20, 0x66, 
  0x6F, 0x72, 0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2F, 0x65, 0x78, 0x70, 0x61, 0x6E, 0x64, 
  0x2D, 0x70, 0x61, 0x74, 0x68, 0x2E, 0x20, 0x20, 0x45, 0x61, 0x63, 0x68, 0x20, 0x65, 0x6C, 0x65, 
  0x6D, 0x65, 0x6E, 0x74, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x74, 0x77, 0x6F, 0x20, 0x65, 0x6C, 
  0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x2C, 0x20, 0x63, 0x6F, 0x6E, 
  0x74, 0x61, 0x69, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x74, 0x68, 
  0x20, 0x20, 0x74, 0x65, 0x6D, 0x70, 0x6C, 0x61, 0x74, 0x65, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x61, 
  0x20, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 0x20, 0x3A, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 
  0x2C, 0x20, 0x3A, 0x6E, 0x61, 0x74, 0x69, 0x76, 0x65, 0x2C, 0x20, 0x6F, 0x72, 0x20, 0x3A, 0x69, 
  0x6D, 0x61, 0x67, 0x65, 0x20, 0x69, 0x6E, 0x64, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6E, 0x67, 0x20, 
  0x68, 0x6F, 0x77, 0x20, 0x20, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x20, 0x73, 0x68, 0x6F, 
  0x75, 0x6C, 0x64, 0x20, 0x6C, 0x6F, 0x61, 0x64, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x73, 0x20, 0x66, 
  0x6F, 0x75, 0x6E, 0x64, 0x20, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x73, 0x65, 0x20, 0x70, 0x61, 
  0x74, 0x68, 0x73, 0x2E, 0x0A, 0x0A, 0x41, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x20, 0x63, 0x61, 
  0x6E, 0x20, 0x61, 0x6C, 0x73, 0x6F, 0x20, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 0x20, 
  0x61, 0x20, 0x74, 0x68, 0x69, 0x72, 0x64, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x2C, 
  0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x79, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x20, 0x66, 0x69, 
  0x6C, 0x74, 0x65, 0x72, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x70, 0x72, 0x65, 0x76, 0x65, 0x6E, 
  0x74, 0x73, 0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2F, 0x66, 0x69, 0x6E, 0x64, 0x20, 0x20, 
  0x66, 0x72, 0x6F, 0x6D, 0x20, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x69, 0x6E, 0x67, 0x20, 0x74, 
  0x68, 0x61, 0x74, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x74, 0x65, 0x6D, 0x70, 0x6C, 0x61, 0x74, 
  0x65, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x74, 0x65, 0x72, 0x20, 
  0x64, 0x6F, 0x65, 0x73, 0x6E, 0x27, 0x74, 0x20, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x69, 0x6E, 0x70, 0x75, 0x74, 0x20, 0x20, 0x70, 0x61, 0x74, 0x68, 0x2E, 0x20, 0x54, 
  0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x74, 0x65, 0x72, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 
  0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x6F, 0x72, 0x20, 0x61, 0x20, 0x70, 
  0x72, 0x65, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 
  0x6E, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x20, 0x69, 0x73, 0x20, 0x6F, 0x66, 0x74, 0x65, 0x6E, 
  0x20, 0x61, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x65, 0x78, 0x74, 0x65, 0x6E, 0x73, 0x69, 0x6F, 
  0x6E, 0x2C, 0x20, 0x69, 0x6E, 0x63, 0x6C, 0x75, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x70, 0x65, 0x72, 0x69, 0x6F, 0x64, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x88, 
  0x93, 0x01, 0xDA, 0x85, 0x09, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x85, 0x0A, 0xDA, 0x09, 0xCE, 0x80, 
  0xE3, 0x28, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x72, 0x65, 0x6D, 0x6F, 0x76, 0x65, 0x20, 0x61, 
  0x72, 0x72, 0x20, 0x61, 0x74, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x6E, 0x29, 0x0A, 0x0A, 0x52, 
  0x65, 0x6D, 0x6F, 0x76, 0x65, 0x20, 0x75, 0x70, 0x20, 0x74, 0x6F, 0x20, 0x6E, 0x20, 0x65, 0x6C, 
  0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x69, 0x6E, 0x67, 0x20, 
  0x61, 0x74, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x61, 0x74, 0x20, 0x69, 0x6E, 0x20, 0x61, 
  0x72, 0x72, 0x61, 0x79, 0x20, 0x61, 0x72, 0x72, 0x2E, 0x20, 0x61, 0x74, 0x20, 0x63, 0x61, 0x6E, 
  0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x65, 0x6E, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 
  0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x67, 0x61, 0x74, 0x69, 0x76, 0x65, 
  0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x6E, 0x20, 0x6D, 0x75, 
  0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x61, 0x20, 0x6E, 0x6F, 0x6E, 0x2D, 0x6E, 0x65, 0x67, 0x61, 
  0x74, 0x69, 0x76, 0x65, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x2E, 0x20, 0x42, 0x79, 
  0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x2C, 0x20, 0x6E, 0x20, 0x69, 0x73, 0x20, 0x31, 
  0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 
  0x72, 0x61, 0x79, 0x2E, 0xDA, 0x85, 0x0B, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x85, 0x0F, 0xDA, 0x09, 
  0xCE, 0x80, 0x9F, 0x28, 0x74, 0x61, 0x6B, 0x65, 0x2D, 0x77, 0x68, 0x69, 0x6C, 0x65, 0x20, 0x70, 
  0x72, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x47, 0x69, 0x76, 0x65, 0x6E, 0x20, 
  0x61, 0x20, 0x70, 0x72, 0x65, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x2C, 0x20, 0x74, 0x61, 0x6B, 
  0x65, 0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 
  0x66, 0x72, 0x6F, 0x6D, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x65, 0x64, 0x20, 
  0x74, 0x79, 0x70, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x73, 0x61, 0x74, 0x69, 0x73, 0x66, 
  0x79, 0x20, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x65, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 
  0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x61, 0x62, 0x6F, 0x72, 0x74, 0x20, 0x6F, 0x6E, 0x20, 0x66, 
  0x69, 0x72, 0x73, 0x74, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x75, 0x72, 0x65, 0x2E, 0x20, 0x52, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x61, 0x72, 0x72, 0x61, 
  0x79, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x83, 0xBF, 0x01, 0xDA, 0x85, 0x10, 0xD3, 
  0x02, 0xDA, 0x03, 0xDA, 0x85, 0x11, 0xDA, 0x09, 0xCE, 0x81, 0x52, 0x28, 0x73, 0x74, 0x72, 0x69, 
  0x6E, 0x67, 0x2F, 0x66, 0x69, 0x6E, 0x64, 0x2D, 0x61, 0x6C, 0x6C, 0x20, 0x70, 0x61, 0x74, 0x74, 
  0x20, 0x73, 0x74, 0x72, 0x29, 0x0A, 0x0A, 0x53, 0x65, 0x61, 0x72, 0x63, 0x68, 0x65, 0x73, 0x20, 
  0x66, 0x6F, 0x72, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x69, 0x6E, 0x73, 0x74, 0x61, 0x6E, 0x63, 0x65, 
  0x73, 0x20, 0x6F, 0x66, 0x20, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6E, 0x20, 0x70, 0x61, 0x74, 
  0x74, 0x20, 0x69, 0x6E, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x73, 0x74, 0x72, 0x2E, 
  0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 
  0x79, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x69, 0x6E, 0x64, 0x69, 0x63, 0x65, 0x73, 
  0x20, 0x6F, 0x66, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x20, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 
  0x6E, 0x73, 0x2E, 0x20, 0x4F, 0x76, 0x65, 0x72, 0x6C, 0x61, 0x70, 0x70, 0x69, 0x6E, 0x67, 0x20, 
  0x69, 0x6E, 0x73, 0x74, 0x61, 0x6E, 0x63, 0x65, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6E, 0x20, 0x61, 0x72, 0x65, 0x20, 0x6E, 0x6F, 0x74, 
  0x20, 0x63, 0x6F, 0x75, 0x6E, 0x74, 0x65, 0x64, 0x2C, 0x20, 0x6D, 0x65, 0x61, 0x6E, 0x69, 0x6E, 
  0x67, 0x20, 0x61, 0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x73, 0x74, 0x72, 0x69, 
  0x6E, 0x67, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x20, 0x63, 0x6F, 0x6E, 
  0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x66, 0x69, 0x6E, 0x64, 0x69, 
  0x6E, 0x67, 0x20, 0x61, 0x74, 0x20, 0x6D, 0x6F, 0x73, 0x74, 0x20, 0x6F, 0x6E, 0x20, 0x6F, 0x63, 
  0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x63, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x70, 0x61, 0x74, 0x74, 
  0x65, 0x72, 0x6E, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x6E, 0x6F, 0x20, 0x6F, 0x63, 0x63, 0x75, 0x72, 
  0x72, 0x65, 0x6E, 0x63, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 
  0x2C, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x61, 0x6E, 
  0x20, 0x65, 0x6D, 0x70, 0x74, 0x79, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0xDA, 0x85, 0x12, 
  0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x82, 0x2A, 0xDA, 0x09, 0xCE, 0x7E, 0x28, 0x73, 0x6F, 0x6D, 0x65, 
  0x20, 0x70, 0x72, 0x65, 0x64, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x20, 0x69, 0x66, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x78, 0x73, 
  0x20, 0x61, 0x72, 0x65, 0x20, 0x66, 0x61, 0x6C, 0x73, 0x65, 0x20, 0x6F, 0x72, 0x20, 0x6E, 0x69, 
  0x6C, 0x2C, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x20, 0x72, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6C, 0x74, 0x20, 
  0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x74, 0x72, 
  0x75, 0x74, 0x68, 0x79, 0x20, 0x70, 0x72, 0x65, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x2C, 0x20, 
  0x28, 0x70, 0x72, 0x65, 0x64, 0x20, 0x78, 0x29, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 
  0x87, 0x07, 0x01, 0xDA, 0x85, 0x13, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x84, 0x34, 0xDA, 0x09, 0xCE, 
  0x81, 0x37, 0x28, 0x72, 0x65, 0x70, 0x6C, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x63, 0x68, 0x75, 
  0x6E, 0x6B, 0x73, 0x20, 0x6F, 0x6E, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0x20, 0x65, 0x6E, 0x76, 
  0x29, 0x0A, 0x0A, 0x52, 0x75, 0x6E, 0x20, 0x61, 0x20, 0x72, 0x65, 0x70, 0x6C, 0x2E, 0x20, 0x54, 
  0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6D, 0x65, 0x74, 
  0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 
  0x6C, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x74, 0x6F, 0x20, 0x63, 0x61, 
  0x6C, 0x6C, 0x20, 0x74, 0x6F, 0x20, 0x20, 0x67, 0x65, 0x74, 0x20, 0x61, 0x20, 0x63, 0x68, 0x75, 
  0x6E, 0x6B, 0x20, 0x6F, 0x66, 0x20, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x20, 0x63, 0x6F, 0x64, 
  0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x73, 0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x72, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x20, 0x6E, 0x69, 0x6C, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x65, 0x6E, 0x64, 
  0x20, 0x6F, 0x66, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x2E, 0x20, 0x20, 0x54, 0x68, 0x65, 0x20, 0x73, 
  0x65, 0x63, 0x6F, 0x6E, 0x64, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6D, 0x65, 0x74, 0x65, 0x72, 0x20, 
  0x69, 0x73, 0x20, 0x61, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x74, 0x68, 
  0x61, 0x74, 0x20, 0x69, 0x73, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x65, 0x64, 0x20, 0x77, 0x68, 0x65, 
  0x6E, 0x20, 0x61, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0x20, 0x69, 0x73, 0x20, 0x20, 0x63, 
  0x61, 0x75, 0x67, 0x68, 0x74, 0x2E, 0x20, 0x4F, 0x6E, 0x65, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x70, 
  0x72, 0x6F, 0x76, 0x69, 0x64, 0x65, 0x20, 0x61, 0x6E, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 
  0x61, 0x6C, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 
  0x61, 0x62, 0x6C, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x72, 0x75, 0x6E, 0x20, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x72, 0x65, 0x70, 0x6C, 0x20, 0x69, 0x6E, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 
  0x8A, 0x1D, 0x01, 0xDA, 0x85, 0x14, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x85, 0x16, 0xDA, 0x09, 0xCE, 
  0x4E, 0x28, 0x7A, 0x69, 0x70, 0x63, 0x6F, 0x6C, 0x6C, 0x20, 0x6B, 0x73, 0x20, 0x76, 0x73, 0x29, 
  0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x73, 0x20, 0x61, 0x20, 0x74, 0x61, 0x62, 0x6C, 
  0x65, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x77, 0x6F, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 
  0x73, 0x2F, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x73, 0x2E, 0x20, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0xDA, 
  0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x84, 0xBD, 0x01, 0xDA, 0x85, 0x17, 0xD3, 0x04, 0xDA, 0x03, 
  0xDA, 0x85, 0x19, 0xDA, 0x09, 0xCE, 0x52, 0x28, 0x63, 0x6F, 0x72, 0x6F, 0x20, 0x26, 0x20, 0x62, 
  0x6F, 0x64, 0x79, 0x29, 0x0A, 0x0A, 0x41, 0x20, 0x77, 0x72, 0x61, 0x70, 0x70, 0x65, 0x72, 0x20, 
  0x66, 0x6F, 0x72, 0x20, 0x6D, 0x61, 0x6B, 0x69, 0x6E, 0x67, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 
  0x73, 0x2E, 0x20, 0x53, 0x61, 0x6D, 0x65, 0x20, 0x61, 0x73, 0x20, 0x28, 0x66, 0x69, 0x62, 0x65, 
  0x72, 0x2F, 0x6E, 0x65, 0x77, 0x20, 0x28, 0x66, 0x6E, 0x20, 0x5B, 0x5D, 0x20, 0x3B, 0x62, 0x6F, 
  0x64, 0x79, 0x29, 0x20, 0x3A, 0x79, 0x69, 0x29, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 
  0x82, 0x2F, 0x01, 0xDA, 0x35, 0xCB, 0xDA, 0x85, 0x1A, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x85, 0x1C, 
  0xDA, 0x09, 0xCE, 0x80, 0x9C, 0x28, 0x64, 0x72, 0x6F, 0x70, 0x2D, 0x77, 0x68, 0x69, 0x6C, 0x65, 
  0x20, 0x70, 0x72, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x47, 0x69, 0x76, 0x65, 
  0x6E, 0x20, 0x61, 0x20, 0x70, 0x72, 0x65, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x2C, 0x20, 0x72, 
  0x65, 0x6D, 0x6F, 0x76, 0x65, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x66, 
  0x72, 0x6F, 0x6D, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x65, 0x64, 0x20, 0x74, 
  0x79, 0x70, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x73, 0x61, 0x74, 0x69, 0x73, 0x66, 0x79, 
  0x20, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x65, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x2C, 
  0x20, 0x61, 0x6E, 0x64, 0x20, 0x61, 0x62, 0x6F, 0x72, 0x74, 0x20, 0x6F, 0x6E, 0x20, 0x66, 0x69, 
  0x72, 0x73, 0x74, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x75, 0x72, 0x65, 0x2E, 0x20, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 
  0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x83, 0xDA, 0x01, 0xDA, 0x85, 0x1D, 0xD3, 0x02, 
  0xDA, 0x03, 0xDA, 0x85, 0x1E, 0xDA, 0x09, 0xCE, 0x2B, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x65, 
  0x78, 0x70, 0x32, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 
  0x32, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x6F, 0x77, 0x65, 0x72, 0x20, 0x6F, 
  0x66, 0x20, 0x78, 0x2E, 0xDA, 0x85, 0x1F, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x81, 0x3B, 0xDA, 0x09, 
  0xCE, 0x80, 0x84, 0x28, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2F, 0x74, 0x6F, 0x2D, 0x73, 0x74, 0x72, 
  0x75, 0x63, 0x74, 0x20, 0x74, 0x61, 0x62, 0x29, 0x0A, 0x0A, 0x43, 0x6F, 0x6E, 0x76, 0x65, 0x72, 
  0x74, 0x20, 0x61, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x73, 
  0x74, 0x72, 0x75, 0x63, 0x74, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 
  0x20, 0x6E, 0x65, 0x77, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x2E, 0x20, 0x54, 0x68, 0x69, 
  0x73, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64, 0x6F, 0x65, 0x73, 0x20, 
  0x6E, 0x6F, 0x74, 0x20, 0x74, 0x61, 0x6B, 0x65, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x61, 0x63, 
  0x63, 0x6F, 0x75, 0x6E, 0x74, 0x20, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0x74, 0x79, 0x70, 0x65, 0x20, 
  0x74, 0x61, 0x62, 0x6C, 0x65, 0x73, 0x2E, 0xDA, 0x85, 0x20, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x83, 
  0x7E, 0xDA, 0x09, 0xCE, 0x50, 0x28, 0x6F, 0x73, 0x2F, 0x67, 0x65, 0x74, 0x65, 0x6E, 0x76, 0x20, 
  0x76, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x64, 0x66, 
  0x6C, 0x74, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x72, 
  0x69, 0x6E, 0x67, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x6E, 0x20, 
  0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x61, 0x72, 0x69, 
  0x61, 0x62, 0x6C, 0x65, 0x2E, 0xDA, 0x85, 0x21, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x85, 0x22, 0xDA, 
  0x09, 0xCE, 0x30, 0x28, 0x6F, 0x73, 0x2F, 0x63, 0x77, 0x64, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 
  0x20, 0x77, 0x6F, 0x72, 0x6B, 0x69, 0x6E, 0x67, 0x20, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6F, 
  0x72, 0x79, 0x2E, 0xDA, 0x85, 0x23, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x80, 0x84, 0xDA, 0x09, 0xCE, 
  0x48, 0x28, 0x65, 0x66, 0x6C, 0x75, 0x73, 0x68, 0x29, 0x0A, 0x0A, 0x46, 0x6C, 0x75, 0x73, 0x68, 
  0x20, 0x28, 0x64, 0x79, 0x6E, 0x20, 0x3A, 0x65, 0x72, 0x72, 0x20, 0x73, 0x74, 0x64, 0x65, 0x72, 
  0x72, 0x29, 0x20, 0x69, 0x66, 0x20, 0x69, 0x74, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x66, 0x69, 
  0x6C, 0x65, 0x2C, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x20, 0x64, 0x6F, 
  0x20, 0x6E, 0x6F, 0x74, 0x68, 0x69, 0x6E, 0x67, 0x2E, 0xDA, 0x85, 0x24, 0xD3, 0x02, 0xDA, 0x03, 
  0xDA, 0x85, 0x25, 0xDA, 0x09, 0xCE, 0x2D, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x61, 0x62, 0x73, 
  0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x61, 0x62, 0x73, 0x6F, 0x6C, 0x75, 0x74, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x6F, 
  0x66, 0x20, 0x78, 0x2E, 0xDA, 0x85, 0x26, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x81, 0x5D, 0xDA, 0x09, 
  0xCE, 0x30, 0x28, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0x20, 0x77, 0x68, 0x61, 0x74, 0x20, 0x78, 
  0x29, 0x0A, 0x0A, 0x52, 0x61, 0x69, 0x73, 0x65, 0x20, 0x61, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 
  0x6C, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x70, 0x61, 0x79, 0x6C, 0x6F, 0x61, 0x64, 0x20, 0x78, 
  0x2E, 0x20, 0xDA, 0x85, 0x27, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x81, 0x1F, 0xDA, 0x09, 0xCE, 0x81, 
  0x64, 0x28, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x73, 0x6C, 0x69, 0x63, 0x65, 0x20, 0x62, 
  0x79, 0x74, 0x65, 0x73, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 
  0x65, 0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 
  0x73, 0x75, 0x62, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x61, 
  0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6E, 0x63, 0x65, 0x2E, 0x20, 
  0x54, 0x68, 0x65, 0x20, 0x73, 0x75, 0x62, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x69, 0x73, 
  0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x73, 0x74, 0x61, 0x72, 
  0x74, 0x20, 0x69, 0x6E, 0x63, 0x6C, 0x75, 0x73, 0x69, 0x76, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x69, 
  0x6E, 0x64, 0x65, 0x78, 0x20, 0x65, 0x6E, 0x64, 0x20, 0x65, 0x78, 0x63, 0x6C, 0x75, 0x73, 0x69, 
  0x76, 0x65, 0x2E, 0x20, 0x41, 0x6C, 0x6C, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x69, 0x6E, 0x67, 
  0x20, 0x69, 0x73, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x30, 0x2E, 0x20, 0x27, 0x73, 0x74, 0x61, 
  0x72, 0x74, 0x27, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x27, 0x65, 0x6E, 0x64, 0x27, 0x20, 0x63, 0x61, 
  0x6E, 0x20, 0x61, 0x6C, 0x73, 0x6F, 0x20, 0x62, 0x65, 0x20, 0x6E, 0x65, 0x67, 0x61, 0x74, 0x69, 
  0x76, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x69, 0x6E, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x69, 
  0x6E, 0x64, 0x65, 0x78, 0x69, 0x6E, 0x67, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x65, 0x6E, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x72, 0x69, 
  0x6E, 0x67, 0x2E, 0x20, 0x4E, 0x6F, 0x74, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x6E, 
  0x64, 0x65, 0x78, 0x20, 0x2D, 0x31, 0x20, 0x69, 0x73, 0x20, 0x73, 0x79, 0x6E, 0x6F, 0x6E, 0x79, 
  0x6D, 0x6F, 0x75, 0x73, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 
  0x28, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x29, 0x20, 0x74, 
  0x6F, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x77, 0x20, 0x61, 0x20, 0x66, 0x75, 0x6C, 0x6C, 0x20, 0x6E, 
  0x65, 0x67, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x73, 0x6C, 0x69, 0x63, 0x65, 0x20, 0x72, 0x61, 
  0x6E, 0x67, 0x65, 0x2E, 0x20, 0xDA, 0x85, 0x28, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x84, 0x3C, 0xDA, 
  0x09, 0xCE, 0x64, 0x28, 0x66, 0x69, 0x6C, 0x65, 0x2F, 0x77, 0x72, 0x69, 0x74, 0x65, 0x20, 0x66, 
  0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x29, 0x0A, 0x0A, 0x57, 0x72, 0x69, 0x74, 0x65, 0x73, 0x20, 
  0x74, 0x6F, 0x20, 0x61, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x2E, 0x20, 0x27, 0x62, 0x79, 0x74, 0x65, 
  0x73, 0x27, 0x20, 0x6D, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 
  0x67, 0x2C, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2C, 0x20, 0x6F, 0x72, 0x20, 0x73, 0x79, 
  0x6D, 0x62, 0x6F, 0x6C, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x2E, 0xDA, 0x85, 0x29, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x84, 
  0x8D, 0xDA, 0x09, 0xCE, 0x80, 0xA8, 0x28, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x66, 0x69, 
  0x6E, 0x64, 0x20, 0x70, 0x61, 0x74, 0x74, 0x20, 0x73, 0x74, 0x72, 0x29, 0x0A, 0x0A, 0x53, 0x65, 
  0x61, 0x72, 0x63, 0x68, 0x65, 0x73, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 
  0x69, 0x72, 0x73, 0x74, 0x20, 0x69, 0x6E, 0x73, 0x74, 0x61, 0x6E, 0x63, 0x65, 0x20, 0x6F, 0x66, 
  0x20, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6E, 0x20, 0x70, 0x61, 0x74, 0x74, 0x20, 0x69, 0x6E, 
  0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x73, 0x74, 0x72, 0x2E, 0x20, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x6F, 
  0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x63, 0x68, 0x61, 0x72, 
  0x61, 0x63, 0x74, 0x65, 0x72, 0x20, 0x69, 0x6E, 0x20, 0x70, 0x61, 0x74, 0x74, 0x20, 0x69, 0x66, 
  0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x2C, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 
  0x65, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0xDA, 0x84, 
  0x54, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x85, 0x2B, 0xDA, 0x09, 0xCE, 0x37, 0x28, 0x76, 0x61, 0x72, 
  0x67, 0x6C, 0x6F, 0x62, 0x61, 0x6C, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x69, 0x6E, 0x69, 0x74, 
  0x29, 0x0A, 0x0A, 0x44, 0x79, 0x6E, 0x61, 0x6D, 0x69, 0x63, 0x61, 0x6C, 0x6C, 0x79, 0x20, 0x63, 
  0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 0x67, 0x6C, 0x6F, 0x62, 0x61, 0x6C, 0x20, 0x76, 
  0x61, 0x72, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x49, 0x01, 0xDA, 0x85, 0x2C, 0xD3, 
  0x04, 0xDA, 0x03, 0xDA, 0x85, 0x2E, 0xDA, 0x09, 0xCE, 0x24, 0x28, 0x2D, 0x3D, 0x20, 0x78, 0x20, 
  0x6E, 0x29, 0x0A, 0x0A, 0x44, 0x65, 0x63, 0x72, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x76, 0x61, 0x72, 0x20, 0x78, 0x20, 0x62, 0x79, 0x20, 0x6E, 0x2E, 0xDA, 0x0B, 
  0xD2, 0x03, 0x00, 0xDA, 0x05, 0x80, 0x86, 0x01, 0xDA, 0x35, 0xCB, 0xDA, 0x85, 0x2F, 0xD3, 0x02, 
  0xDA, 0x03, 0xDA, 0x51, 0xDA, 0x09, 0xCE, 0x60, 0x28, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2F, 0x67, 
  0x65, 0x74, 0x65, 0x6E, 0x76, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x29, 0x0A, 0x0A, 0x47, 0x65, 
  0x74, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 
  0x6E, 0x74, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x61, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2E, 0x20, 
  0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x20, 0x69, 0x66, 0x20, 0x6E, 
  0x6F, 0x20, 0x73, 0x75, 0x63, 0x68, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x69, 0x73, 0x20, 
  0x73, 0x65, 0x74, 0x20, 0x79, 0x65, 0x74, 0x2E, 0xDA, 0x2A, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x85, 
  0x31, 0xDA, 0x09, 0xCE, 0x41, 0x28, 0x3D, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x43, 
  0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x76, 0x61, 0x6C, 0x75, 
  0x65, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x78, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x65, 0x71, 0x75, 
  0x61, 0x6C, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x62, 0x6F, 
  0x6F, 0x6C, 0x65, 0x61, 0x6E, 0x2E, 0xDA, 0x85, 0x32, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 0x85, 0x34, 
  0xDA, 0x09, 0xCE, 0x81, 0x2B, 0x28, 0x2D, 0x3F, 0x3E, 0x3E, 0x20, 0x78, 0x20, 0x26, 0x20, 0x66, 
  0x6F, 0x72, 0x6D, 0x73, 0x29, 0x0A, 0x0A, 0x53, 0x68, 0x6F, 0x72, 0x74, 0x20, 0x63, 0x69, 0x72, 
  0x63, 0x75, 0x69, 0x74, 0x20, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x6D, 
  0x61, 0x63, 0x72, 0x6F, 0x2E, 0x20, 0x49, 0x6E, 0x73, 0x65, 0x72, 0x74, 0x73, 0x20, 0x78, 0x20, 
  0x61, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x61, 0x73, 0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 
  0x65, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x66, 
  0x6F, 0x72, 0x6D, 0x20, 0x20, 0x69, 0x6E, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x73, 0x2C, 0x20, 0x61, 
  0x6E, 0x64, 0x20, 0x69, 0x6E, 0x73, 0x65, 0x72, 0x74, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 
  0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x66, 0x6F, 
  0x72, 0x6D, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x63, 0x6F, 
  0x6E, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x20, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x73, 0x61, 0x6D, 0x65, 0x20, 0x6D, 0x61, 0x6E, 0x6E, 0x65, 0x72, 0x2C, 0x20, 0x61, 0x6E, 0x64, 
  0x20, 0x73, 0x6F, 0x20, 0x6F, 0x6E, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x70, 0x69, 0x70, 0x65, 
  0x6C, 0x69, 0x6E, 0x65, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 
  0x20, 0x6E, 0x69, 0x6C, 0x20, 0x20, 0x69, 0x66, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x74, 0x65, 
  0x72, 0x6D, 0x65, 0x64, 0x69, 0x61, 0x74, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x69, 
  0x73, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0x20, 0x20, 0x55, 0x73, 0x65, 0x66, 0x75, 0x6C, 0x20, 0x66, 
  0x6F, 0x72, 0x20, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x70, 0x69, 
  0x70, 0x65, 0x6C, 0x69, 0x6E, 0x65, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x64, 0x61, 0x74, 0x61, 0x2E, 
  0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x84, 0x2C, 0x01, 0xDA, 0x35, 0xCB, 0xDA, 0x85, 0x35, 
  0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x85, 0x36, 0xDA, 0x09, 0xCE, 0x2F, 0x28, 0x6D, 0x61, 0x74, 0x68, 
  0x2F, 0x73, 0x69, 0x6E, 0x68, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x68, 0x79, 0x70, 0x65, 0x72, 0x62, 0x6F, 0x6C, 0x69, 0x63, 0x20, 
  0x73, 0x69, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x2E, 0xDA, 0x85, 0x37, 0xD3, 0x02, 0xDA, 
  0x03, 0xDA, 0x85, 0x38, 0xDA, 0x09, 0xCE, 0x5C, 0x28, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 
  0x62, 0x79, 0x74, 0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x20, 0x62, 0x29, 0x0A, 0x0A, 
  0x49, 0x6E, 0x70, 0x75, 0x74, 0x20, 0x61, 0x20, 0x73, 0x69, 0x6E, 0x67, 0x6C, 0x65, 0x20, 0x62, 
  0x79, 0x74, 0x65, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 
  0x73, 0x65, 0x72, 0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x2E, 
  0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 
  0x73, 0x65, 0x72, 0x2E, 0xDA, 0x85, 0x39, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x85, 0x3A, 0xDA, 0x09, 
  0xCE, 0x80, 0xA7, 0x28, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x72, 0x65, 0x70, 0x6C, 0x61, 
  0x63, 0x65, 0x20, 0x70, 0x61, 0x74, 0x74, 0x20, 0x73, 0x75, 0x62, 0x73, 0x74, 0x20, 0x73, 0x74, 
  0x72, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x70, 0x6C, 0x61, 0x63, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x6F, 0x63, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x63, 0x65, 
  0x20, 0x6F, 0x66, 0x20, 0x70, 0x61, 0x74, 0x74, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x73, 0x75, 
  0x62, 0x73, 0x74, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 
  0x67, 0x20, 0x73, 0x74, 0x72, 0x2E, 0x20, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x72, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 
  0x67, 0x20, 0x69, 0x66, 0x20, 0x70, 0x61, 0x74, 0x74, 0x20, 0x69, 0x73, 0x20, 0x66, 0x6F, 0x75, 
  0x6E, 0x64, 0x2C, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x20, 0x72, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x73, 0x74, 0x72, 0x2E, 0xDA, 0x85, 0x3B, 0xD3, 0x02, 0xDA, 
  0x03, 0xDA, 0x83, 0x92, 0xDA, 0x09, 0xCE, 0x30, 0x54, 0x68, 0x65, 0x20, 0x76, 0x65, 0x72, 0x73, 
  0x69, 0x6F, 0x6E, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x72, 0x75, 0x6E, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x6A, 0x61, 0x6E, 0x65, 0x74, 0x20, 
  0x70, 0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x2E, 0xDA, 0x85, 0x3C, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 
  0x85, 0x3E, 0xDA, 0x09, 0xCE, 0x80, 0x9E, 0x28, 0x61, 0x73, 0x2D, 0x3E, 0x20, 0x78, 0x20, 0x61, 
  0x73, 0x20, 0x26, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x73, 0x29, 0x0A, 0x0A, 0x54, 0x68, 0x72, 0x65, 
  0x61, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x73, 0x20, 0x74, 0x6F, 0x67, 0x65, 0x74, 0x68, 0x65, 
  0x72, 0x2C, 0x20, 0x72, 0x65, 0x70, 0x6C, 0x61, 0x63, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x73, 0x20, 
  0x69, 0x6E, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x73, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x70, 0x72, 0x65, 0x76, 0x69, 0x6F, 0x75, 0x73, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x2E, 0x20, 0x54, 
  0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x69, 0x73, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x78, 0x2E, 0x20, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x20, 0x6C, 0x61, 0x73, 0x74, 0x20, 0x76, 
  0x61, 0x6C, 0x75, 0x65, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x84, 0x63, 0x01, 0xDA, 
  0x35, 0xCB, 0xDA, 0x85, 0x3F, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x85, 0x40, 0xDA, 0x09, 0xCE, 0x81, 
  0xC0, 0x28, 0x66, 0x69, 0x6C, 0x65, 0x2F, 0x73, 0x65, 0x65, 0x6B, 0x20, 0x66, 0x20, 0x26, 0x6F, 
  0x70, 0x74, 0x20, 0x77, 0x68, 0x65, 0x6E, 0x63, 0x65, 0x20, 0x6E, 0x29, 0x0A, 0x0A, 0x4A, 0x75, 
  0x6D, 0x70, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x72, 0x65, 0x6C, 0x61, 0x74, 0x69, 0x76, 0x65, 
  0x20, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x66, 0x69, 0x6C, 0x65, 0x2E, 0x20, 0x27, 0x77, 0x68, 0x65, 0x6E, 0x63, 0x65, 0x27, 0x20, 
  0x6D, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x6F, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x0A, 0x0A, 
  0x09, 0x3A, 0x63, 0x75, 0x72, 0x20, 0x2D, 0x20, 0x6A, 0x75, 0x6D, 0x70, 0x20, 0x72, 0x65, 0x6C, 
  0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 
  0x72, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x69, 
  0x6F, 0x6E, 0x0A, 0x09, 0x3A, 0x73, 0x65, 0x74, 0x20, 0x2D, 0x20, 0x6A, 0x75, 0x6D, 0x70, 0x20, 
  0x72, 0x65, 0x6C, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x62, 0x65, 0x67, 0x69, 0x6E, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x66, 0x69, 0x6C, 0x65, 0x0A, 0x09, 0x3A, 0x65, 0x6E, 0x64, 0x20, 0x2D, 0x20, 0x6A, 0x75, 
  0x6D, 0x70, 0x20, 0x72, 0x65, 0x6C, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x65, 0x6E, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 
  0x6C, 0x65, 0x0A, 0x0A, 0x42, 0x79, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x2C, 0x20, 
  0x27, 0x77, 0x68, 0x65, 0x6E, 0x63, 0x65, 0x27, 0x20, 0x69, 0x73, 0x20, 0x3A, 0x63, 0x75, 0x72, 
  0x2E, 0x20, 0x4F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x6C, 0x79, 0x20, 0x61, 0x20, 0x76, 
  0x61, 0x6C, 0x75, 0x65, 0x20, 0x6E, 0x20, 0x6D, 0x61, 0x79, 0x20, 0x62, 0x65, 0x20, 0x70, 0x61, 
  0x73, 0x73, 0x65, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x6C, 
  0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 
  0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x73, 0x65, 0x65, 0x6B, 0x20, 0x69, 0x6E, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x2E, 0x20, 0x6E, 0x20, 0x6D, 0x61, 0x79, 
  0x20, 0x62, 0x65, 0x20, 0x61, 0x20, 0x72, 0x65, 0x61, 0x6C, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 
  0x72, 0x20, 0x74, 0x6F, 0x20, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x20, 0x6C, 0x61, 0x72, 0x67, 
  0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x6D, 0x6F, 0x72, 0x65, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x34, 0x47, 0x42, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65, 
  0x2E, 0xDA, 0x85, 0x41, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 0x85, 0x44, 0xDA, 0x09, 0xCE, 0x80, 0x8C, 
  0x28, 0x70, 0x72, 0x6F, 0x6D, 0x70, 0x74, 0x20, 0x74, 0x61, 0x67, 0x20, 0x26, 0x20, 0x62, 0x6F, 
  0x64, 0x79, 0x29, 0x0A, 0x0A, 0x53, 0x65, 0x74, 0x20, 0x75, 0x70, 0x20, 0x61, 0x20, 0x63, 0x68, 
  0x65, 0x63, 0x6B, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 0x61, 
  0x6E, 0x20, 0x62, 0x65, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x65, 0x64, 0x20, 0x74, 0x6F, 
  0x2E, 0x20, 0x54, 0x61, 0x67, 0x20, 0x73, 0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x62, 0x65, 0x20, 
  0x61, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x73, 
  0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x2C, 0x20, 0x6C, 0x69, 0x6B, 
  0x65, 0x20, 0x61, 0x20, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 
  0x00, 0xDA, 0x05, 0x81, 0x43, 0x01, 0xDA, 0x35, 0xCB, 0xDA, 0x85, 0x45, 0xD3, 0x02, 0xDA, 0x03, 
  0xDA, 0x85, 0x46, 0xDA, 0x09, 0xCE, 0x80, 0xAC, 0x28, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x2F, 
  0x73, 0x65, 0x6E, 0x64, 0x20, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x20, 0x6D, 0x73, 0x67, 0x29, 
  0x0A, 0x0A, 0x53, 0x65, 0x6E, 0x64, 0x20, 0x61, 0x20, 0x6D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 
  0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x2E, 0x20, 
  0x54, 0x68, 0x69, 0x73, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x6E, 0x65, 0x76, 0x65, 0x72, 0x20, 
  0x62, 0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 
  0x73, 0x20, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x20, 0x69, 0x6D, 0x6D, 0x65, 0x64, 0x69, 0x61, 
  0x74, 0x65, 0x6C, 0x79, 0x2E, 0x20, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x74, 0x68, 0x72, 0x6F, 0x77, 
  0x20, 0x61, 0x6E, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 
  0x72, 0x65, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x70, 0x72, 0x6F, 0x62, 0x6C, 0x65, 0x6D, 0x20, 
  0x73, 0x65, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x65, 0x73, 0x73, 
  0x61, 0x67, 0x65, 0x2E, 0xDA, 0x85, 0x47, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x85, 0x48, 0xDA, 0x09, 
  0xCE, 0x27, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x74, 0x61, 0x6E, 0x20, 0x78, 0x29, 0x0A, 0x0A, 
  0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x61, 0x6E, 0x67, 
  0x65, 0x6E, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x2E, 0xDA, 0x85, 0x49, 0xD3, 0x03, 0xDA, 0x03, 
  0xDA, 0x80, 0xDB, 0xDA, 0x09, 0xCE, 0x80, 0xBA, 0x28, 0x6D, 0x61, 0x6B, 0x65, 0x2D, 0x65, 0x6E, 
  0x76, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x70, 0x61, 0x72, 0x65, 0x6E, 0x74, 0x29, 0x0A, 0x0A, 
  0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x65, 0x6E, 0x76, 
  0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0x20, 
  0x54, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 
  0x65, 0x6E, 0x74, 0x20, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x69, 0x6E, 0x68, 0x65, 0x72, 0x69, 
  0x74, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 
  0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x6E, 0x65, 0x77, 0x20, 
  0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x6E, 
  0x6F, 0x74, 0x20, 0x70, 0x6F, 0x6C, 0x6C, 0x75, 0x74, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 
  0x61, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 
  0x74, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x87, 0xAB, 0x01, 0xDA, 0x85, 0x4A, 0xD3, 
  0x03, 0xDA, 0x03, 0xDA, 0x85, 0x4C, 0xDA, 0x09, 0xCE, 0x80, 0xED, 0x28, 0x61, 0x63, 0x63, 0x75, 
  0x6D, 0x75, 0x6C, 0x61, 0x74, 0x65, 0x20, 0x66, 0x20, 0x69, 0x6E, 0x69, 0x74, 0x20, 0x69, 0x6E, 
  0x64, 0x29, 0x0A, 0x0A, 0x53, 0x69, 0x6D, 0x69, 0x6C, 0x61, 0x72, 0x20, 0x74, 0x6F, 0x20, 0x72, 
  0x65, 0x64, 0x75, 0x63, 0x65, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x61, 0x63, 0x63, 0x75, 0x6D, 
  0x75, 0x6C, 0x61, 0x74, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x6D, 0x65, 0x64, 0x69, 
  0x61, 0x74, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 
  0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0x20, 0x20, 0x54, 0x68, 0x65, 0x20, 0x6C, 
  0x61, 0x73, 0x74, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x69, 0x6E, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x69, 0x73, 0x20, 0x77, 0x68, 0x61, 0x74, 
  0x20, 0x77, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x62, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 
  0x72, 0x65, 0x64, 0x75, 0x63, 0x65, 0x2E, 0x20, 0x20, 0x54, 0x68, 0x65, 0x20, 0x69, 0x6E, 0x69, 
  0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x61, 
  0x64, 0x64, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x72, 0x61, 
  0x79, 0x2E, 0x20, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 
  0x77, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x83, 
  0x27, 0x01, 0xDA, 0x85, 0x4D, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x85, 0x50, 0xDA, 0x09, 0xCE, 0x80, 
  0x89, 0x28, 0x70, 0x61, 0x72, 0x73, 0x65, 0x20, 0x73, 0x74, 0x72, 0x29, 0x0A, 0x0A, 0x50, 0x61, 
  0x72, 0x73, 0x65, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x6E, 0x64, 
  0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 
  0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2E, 0x20, 0x46, 0x6F, 0x72, 0x20, 0x63, 0x6F, 0x6D, 
  0x70, 0x6C, 0x65, 0x78, 0x20, 0x70, 0x61, 0x72, 0x73, 0x69, 0x6E, 0x67, 0x2C, 0x20, 0x73, 0x75, 
  0x63, 0x68, 0x20, 0x61, 0x73, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x61, 0x20, 0x72, 0x65, 0x70, 0x6C, 
  0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x68, 0x61, 0x6E, 0x64, 
  0x6C, 0x69, 0x6E, 0x67, 0x2C, 0x20, 0x20, 0x75, 0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 
  0x61, 0x72, 0x73, 0x65, 0x72, 0x20, 0x61, 0x70, 0x69, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 
  0x05, 0x88, 0x69, 0x01, 0xDA, 0x85, 0x51, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 0x85, 0x53, 0xDA, 0x09, 
  0xCE, 0x81, 0x2C, 0x28, 0x2D, 0x3F, 0x3E, 0x20, 0x78, 0x20, 0x26, 0x20, 0x66, 0x6F, 0x72, 0x6D, 
  0x73, 0x29, 0x0A, 0x0A, 0x53, 0x68, 0x6F, 0x72, 0x74, 0x20, 0x63, 0x69, 0x72, 0x63, 0x75, 0x69, 
  0x74, 0x20, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x6D, 0x61, 0x63, 0x72, 
  0x6F, 0x2E, 0x20, 0x49, 0x6E, 0x73, 0x65, 0x72, 0x74, 0x73, 0x20, 0x78, 0x20, 0x61, 0x73, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x63, 0x6F, 0x6E, 0x64, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 
  0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x66, 0x6F, 
  0x72, 0x6D, 0x20, 0x20, 0x69, 0x6E, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x73, 0x2C, 0x20, 0x61, 0x6E, 
  0x64, 0x20, 0x69, 0x6E, 0x73, 0x65, 0x72, 0x74, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x6F, 
  0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x66, 0x6F, 0x72, 
  0x6D, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x63, 0x6F, 0x6E, 
  0x64, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x20, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 
  0x61, 0x6D, 0x65, 0x20, 0x6D, 0x61, 0x6E, 0x6E, 0x65, 0x72, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 
  0x73, 0x6F, 0x20, 0x6F, 0x6E, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x70, 0x69, 0x70, 0x65, 0x6C, 
  0x69, 0x6E, 0x65, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 
  0x6E, 0x69, 0x6C, 0x20, 0x20, 0x69, 0x66, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x72, 
  0x6D, 0x65, 0x64, 0x69, 0x61, 0x74, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x69, 0x73, 
  0x20, 0x6E, 0x69, 0x6C, 0x2E, 0x20, 0x20, 0x55, 0x73, 0x65, 0x66, 0x75, 0x6C, 0x20, 0x66, 0x6F, 
  0x72, 0x20, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x70, 0x69, 0x70, 
  0x65, 0x6C, 0x69, 0x6E, 0x65, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x64, 0x61, 0x74, 0x61, 0x2E, 0xDA, 
  0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x84, 0x1C, 0x01, 0xDA, 0x35, 0xCB, 0xDA, 0x85, 0x54, 0xD3, 
  0x03, 0xDA, 0x03, 0xDA, 0x84, 0x48, 0xDA, 0x09, 0xCE, 0x3F, 0x28, 0x6C, 0x61, 0x73, 0x74, 0x20, 
  0x78, 0x73, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x61, 0x73, 
  0x74, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x61, 
  0x6E, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x65, 0x64, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 
  0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 
  0x82, 0x99, 0x01, 0xDA, 0x85, 0x55, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x85, 0x56, 0xDA, 0x09, 0xCE, 
  0x80, 0x83, 0x28, 0x6F, 0x73, 0x2F, 0x63, 0x6C, 0x6F, 0x63, 0x6B, 0x29, 0x0A, 0x0A, 0x52, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 
  0x6F, 0x66, 0x20, 0x73, 0x65, 0x63, 0x6F, 0x6E, 0x64, 0x73, 0x20, 0x73, 0x69, 0x6E, 0x63, 0x65, 
  0x20, 0x73, 0x6F, 0x6D, 0x65, 0x20, 0x66, 0x69, 0x78, 0x65, 0x64, 0x20, 0x70, 0x6F, 0x69, 0x6E, 
  0x74, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x63, 
  0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x69, 0x73, 0x20, 0x67, 0x75, 0x61, 0x72, 0x61, 0x6E, 0x74, 0x65, 
  0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x62, 0x65, 0x20, 0x6E, 0x6F, 0x6E, 0x20, 0x64, 0x65, 0x63, 
  0x72, 0x65, 0x61, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x69, 0x6E, 0x20, 0x72, 0x65, 0x61, 0x6C, 0x20, 
  0x74, 0x69, 0x6D, 0x65, 0x2E, 0xDA, 0x85, 0x57, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x85, 0x58, 0xDA, 
  0x09, 0xCE, 0x80, 0xA8, 0x28, 0x6F, 0x73, 0x2F, 0x64, 0x69, 0x72, 0x20, 0x64, 0x69, 0x72, 0x20, 
  0x26, 0x6F, 0x70, 0x74, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x29, 0x0A, 0x0A, 0x49, 0x74, 0x65, 
  0x72, 0x61, 0x74, 0x65, 0x20, 0x6F, 0x76, 0x65, 0x72, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x73, 0x20, 
  0x61, 0x6E, 0x64, 0x20, 0x73, 0x75, 0x62, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x69, 
  0x65, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6F, 0x72, 
  0x79, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 
  0x72, 0x61, 0x79, 0x20, 0x6F, 0x66, 0x20, 0x70, 0x61, 0x74, 0x68, 0x73, 0x20, 0x70, 0x61, 0x72, 
  0x74, 0x73, 0x2C, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x6F, 0x72, 0x20, 0x64, 
  0x69, 0x72, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x79, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x61, 0x6E, 
  0x64, 0x20, 0x6E, 0x6F, 0x20, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x2E, 0xDA, 0x85, 0x59, 0xD3, 
  0x03, 0xDA, 0x03, 0xDA, 0x82, 0x15, 0xDA, 0x09, 0xCE, 0x24, 0x28, 0x73, 0x79, 0x6D, 0x62, 0x6F, 
  0x6C, 0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 
  0x78, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x2E, 0xDA, 0x0B, 
  0xD2, 0x03, 0x00, 0xDA, 0x05, 0x5B, 0x01, 0xDA, 0x85, 0x5A, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x81, 
  0x00, 0xDA, 0x09, 0xCE, 0x81, 0x21, 0x28, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x20, 0x61, 
  0x73, 0x74, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x65, 0x6E, 0x76, 0x20, 0x73, 0x6F, 0x75, 0x72, 
  0x63, 0x65, 0x29, 0x0A, 0x0A, 0x43, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x73, 0x20, 0x61, 0x6E, 
  0x20, 0x41, 0x62, 0x73, 0x74, 0x72, 0x61, 0x63, 0x74, 0x20, 0x53, 0x79, 0x6E, 0x74, 0x61, 0x78, 
  0x20, 0x54, 0x72, 0x65, 0x65, 0x20, 0x28, 0x61, 0x73, 0x74, 0x29, 0x20, 0x69, 0x6E, 0x74, 0x6F, 
  0x20, 0x61, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0x20, 0x50, 0x61, 0x69, 
  0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x20, 0x66, 0x75, 
  0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x70, 0x61, 0x72, 0x73, 
  0x69, 0x6E, 0x67, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x69, 0x74, 
  0x79, 0x20, 0x74, 0x6F, 0x20, 0x69, 0x6D, 0x70, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x65, 
  0x76, 0x61, 0x6C, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 
  0x65, 0x77, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x61, 0x6E, 0x64, 0x20, 
  0x64, 0x6F, 0x65, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x79, 0x20, 
  0x61, 0x73, 0x74, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x6E, 0x20, 
  0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x20, 0x77, 0x69, 0x74, 
  0x68, 0x20, 0x6B, 0x65, 0x79, 0x73, 0x20, 0x3A, 0x6C, 0x69, 0x6E, 0x65, 0x2C, 0x20, 0x3A, 0x63, 
  0x6F, 0x6C, 0x75, 0x6D, 0x6E, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x3A, 0x65, 0x72, 0x72, 0x6F, 
  0x72, 0x20, 0x69, 0x66, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x61, 0x74, 0x69, 0x6F, 0x6E, 
  0x20, 0x66, 0x61, 0x69, 0x6C, 0x73, 0x2E, 0xDA, 0x85, 0x5B, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x82, 
  0x03, 0xDA, 0x09, 0xCE, 0x7C, 0x28, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x66, 0x6F, 0x72, 
  0x6D, 0x61, 0x74, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x20, 0x26, 0x20, 0x76, 0x61, 0x6C, 
  0x75, 0x65, 0x73, 0x29, 0x0A, 0x0A, 0x53, 0x69, 0x6D, 0x69, 0x6C, 0x61, 0x72, 0x20, 0x74, 0x6F, 
  0x20, 0x73, 0x6E, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x66, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x73, 
  0x70, 0x65, 0x63, 0x69, 0x61, 0x6C, 0x69, 0x7A, 0x65, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x6F, 
  0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x4A, 0x61, 
  0x6E, 0x65, 0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 
  0x2E, 0xDA, 0x85, 0x5C, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x85, 0x5D, 0xDA, 0x09, 0xCE, 0x63, 0x28, 
  0x6D, 0x61, 0x74, 0x68, 0x2F, 0x6E, 0x65, 0x78, 0x74, 0x20, 0x78, 0x20, 0x79, 0x29, 0x0A, 0x0A, 
  0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x78, 0x74, 
  0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6E, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x66, 
  0x6C, 0x6F, 0x61, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x20, 0x76, 0x61, 
  0x6C, 0x75, 0x65, 0x20, 0x61, 0x66, 0x74, 0x65, 0x72, 0x20, 0x78, 0x20, 0x69, 0x6E, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x6F, 0x66, 0x20, 
  0x79, 0x2E, 0xDA, 0x85, 0x5E, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x85, 0x5F, 0xDA, 0x09, 0xCE, 0x80, 
  0xE4, 0x28, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x70, 0x75, 0x73, 0x68, 0x2D, 0x77, 0x6F, 
  0x72, 0x64, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x41, 0x70, 
  0x70, 0x65, 0x6E, 0x64, 0x20, 0x61, 0x20, 0x6D, 0x61, 0x63, 0x68, 0x69, 0x6E, 0x65, 0x20, 0x77, 
  0x6F, 0x72, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 
  0x20, 0x54, 0x68, 0x65, 0x20, 0x34, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x6F, 0x66, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x61, 0x72, 0x65, 0x20, 
  0x61, 0x70, 0x70, 0x65, 0x6E, 0x64, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x77, 0x6F, 0x73, 
  0x20, 0x63, 0x6F, 0x6D, 0x70, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x2C, 0x20, 0x6C, 0x69, 0x74, 
  0x74, 0x6C, 0x65, 0x20, 0x65, 0x6E, 0x64, 0x69, 0x61, 0x6E, 0x20, 0x6F, 0x72, 0x64, 0x65, 0x72, 
  0x2C, 0x20, 0x75, 0x6E, 0x73, 0x69, 0x67, 0x6E, 0x65, 0x64, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 
  0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0x20, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x74, 0x68, 
  0x72, 0x6F, 0x77, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x69, 0x66, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x6F, 0x76, 0x65, 0x72, 0x66, 
  0x6C, 0x6F, 0x77, 0x73, 0x2E, 0xDA, 0x85, 0x60, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x85, 0x61, 0xDA, 
  0x09, 0xCE, 0x35, 0x28, 0x6F, 0x73, 0x2F, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x29, 0x0A, 
  0x0A, 0x47, 0x65, 0x74, 0x20, 0x61, 0x20, 0x63, 0x6F, 0x70, 0x79, 0x20, 0x6F, 0x66, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x6F, 0x73, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 
  0x74, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x2E, 0xDA, 0x85, 0x62, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 
  0x85, 0x63, 0xDA, 0x09, 0xCE, 0x80, 0xAD, 0x28, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x2F, 0x72, 
  0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x74, 0x69, 0x6D, 0x65, 
  0x6F, 0x75, 0x74, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 0x61, 0x20, 0x6D, 0x65, 0x73, 0x73, 
  0x61, 0x67, 0x65, 0x20, 0x73, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x69, 0x73, 
  0x20, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x74, 0x69, 0x6D, 0x65, 
  0x6F, 0x75, 0x74, 0x20, 0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x76, 0x69, 0x64, 0x65, 0x64, 0x2C, 
  0x20, 0x61, 0x6E, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 
  0x65, 0x20, 0x74, 0x68, 0x72, 0x6F, 0x77, 0x6E, 0x20, 0x61, 0x66, 0x74, 0x65, 0x72, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x6F, 0x75, 0x74, 0x20, 0x68, 0x61, 0x73, 0x20, 0x65, 
  0x6C, 0x61, 0x70, 0x73, 0x65, 0x64, 0x20, 0x62, 0x75, 0x74, 0x20, 0x6E, 0x6F, 0x20, 0x6D, 0x65, 
  0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 
  0x76, 0x65, 0x64, 0x2E, 0xDA, 0x85, 0x64, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x81, 0xA9, 0xDA, 0x09, 
  0xCE, 0x80, 0xDB, 0x28, 0x2D, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x69, 0x66, 0x66, 0x65, 0x72, 0x65, 
  0x6E, 0x63, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x73, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x78, 0x73, 
  0x20, 0x69, 0x73, 0x20, 0x65, 0x6D, 0x70, 0x74, 0x79, 0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x73, 0x20, 0x30, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x78, 0x73, 0x20, 0x68, 0x61, 0x73, 0x20, 
  0x6F, 0x6E, 0x65, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x2C, 0x20, 0x72, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x67, 0x61, 0x74, 0x69, 0x76, 
  0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 
  0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0x20, 0x4F, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 
  0x73, 0x65, 0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x69, 0x6E, 
  0x20, 0x78, 0x73, 0x20, 0x6D, 0x69, 0x6E, 0x75, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x75, 
  0x6D, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x74, 0x20, 0x6F, 0x66, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x2E, 0xDA, 0x85, 
  0x65, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 0x85, 0x67, 0xDA, 0x09, 0xCE, 0x41, 0x28, 0x77, 0x68, 0x65, 
  0x6E, 0x2D, 0x6C, 0x65, 0x74, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x20, 0x26, 
  0x20, 0x62, 0x6F, 0x64, 0x79, 0x29, 0x0A, 0x0A, 0x53, 0x61, 0x6D, 0x65, 0x20, 0x61, 0x73, 0x20, 
  0x28, 0x69, 0x66, 0x2D, 0x6C, 0x65, 0x74, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 
  0x20, 0x28, 0x64, 0x6F, 0x20, 0x3B, 0x62, 0x6F, 0x64, 0x79, 0x29, 0x29, 0x2E, 0xDA, 0x0B, 0xD2, 
  0x03, 0x00, 0xDA, 0x05, 0x82, 0x66, 0x01, 0xDA, 0x35, 0xCB, 0xDA, 0x85, 0x68, 0xD3, 0x04, 0xDA, 
  0x03, 0xDA, 0x85, 0x6B, 0xDA, 0x09, 0xCE, 0x81, 0x00, 0x28, 0x76, 0x61, 0x72, 0x66, 0x6E, 0x20, 
  0x6E, 0x61, 0x6D, 0x65, 0x20, 0x26, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x29, 0x0A, 0x0A, 0x43, 0x72, 
  0x65, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 
  0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x72, 0x65, 0x62, 0x6F, 
  0x75, 0x6E, 0x64, 0x2E, 0x20, 0x76, 0x61, 0x72, 0x66, 0x6E, 0x20, 0x68, 0x61, 0x73, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x73, 0x61, 0x6D, 0x65, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x74, 0x75, 0x72, 
  0x65, 0x20, 0x20, 0x61, 0x73, 0x20, 0x64, 0x65, 0x66, 0x6E, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 
  0x64, 0x65, 0x66, 0x69, 0x6E, 0x65, 0x73, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 
  0x73, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 
  0x6D, 0x65, 0x6E, 0x74, 0x20, 0x61, 0x73, 0x20, 0x76, 0x61, 0x72, 0x73, 0x2E, 0x20, 0x49, 0x66, 
  0x20, 0x61, 0x20, 0x76, 0x61, 0x72, 0x20, 0x27, 0x6E, 0x61, 0x6D, 0x65, 0x27, 0x20, 0x20, 0x61, 
  0x6C, 0x72, 0x65, 0x61, 0x64, 0x79, 0x20, 0x65, 0x78, 0x69, 0x73, 0x74, 0x73, 0x20, 0x69, 0x6E, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 
  0x2C, 0x20, 0x69, 0x74, 0x20, 0x69, 0x73, 0x20, 0x72, 0x65, 0x62, 0x6F, 0x75, 0x6E, 0x64, 0x20, 
  0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 
  0x69, 0x6F, 0x6E, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x20, 0x61, 0x20, 
  0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 
  0x87, 0x44, 0x01, 0xDA, 0x35, 0xCB, 0xDA, 0x85, 0x6C, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x83, 0x6E, 
  0xDA, 0x09, 0xCE, 0x1C, 0x28, 0x6F, 0x64, 0x64, 0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 
  0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 0x6F, 0x64, 0x64, 0x2E, 
  0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x53, 0x01, 0xDA, 0x85, 0x6D, 0xD3, 0x03, 0xDA, 0x03, 
  0xDA, 0x85, 0x6F, 0xDA, 0x09, 0xCE, 0x80, 0xC9, 0x28, 0x66, 0x72, 0x65, 0x65, 0x7A, 0x65, 0x20, 
  0x78, 0x29, 0x0A, 0x0A, 0x46, 0x72, 0x65, 0x65, 0x7A, 0x65, 0x20, 0x61, 0x6E, 0x20, 0x6F, 0x62, 
  0x6A, 0x65, 0x63, 0x74, 0x20, 0x28, 0x6D, 0x61, 0x6B, 0x65, 0x20, 0x69, 0x74, 0x20, 0x69, 0x6D, 
  0x6D, 0x75, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x29, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x64, 0x6F, 0x20, 
  0x61, 0x20, 0x64, 0x65, 0x65, 0x70, 0x20, 0x63, 0x6F, 0x70, 0x79, 0x2C, 0x20, 0x6D, 0x61, 0x6B, 
  0x69, 0x6E, 0x67, 0x20, 0x20, 0x63, 0x68, 0x69, 0x6C, 0x64, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 
  0x73, 0x20, 0x61, 0x6C, 0x73, 0x6F, 0x20, 0x69, 0x6D, 0x6D, 0x75, 0x74, 0x61, 0x62, 0x6C, 0x65, 
  0x2E, 0x20, 0x43, 0x6C, 0x6F, 0x73, 0x75, 0x72, 0x65, 0x73, 0x2C, 0x20, 0x66, 0x69, 0x62, 0x65, 
  0x72, 0x73, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x61, 0x62, 0x73, 0x74, 0x72, 0x61, 0x63, 0x74, 
  0x20, 0x74, 0x79, 0x70, 0x65, 0x73, 0x20, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x6E, 0x6F, 0x74, 
  0x20, 0x62, 0x65, 0x20, 0x72, 0x65, 0x63, 0x75, 0x72, 0x73, 0x69, 0x76, 0x65, 0x6C, 0x79, 0x20, 
  0x66, 0x72, 0x6F, 0x7A, 0x65, 0x6E, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x61, 0x6C, 0x6C, 0x20, 
  0x6F, 0x74, 0x68, 0x65, 0x72, 0x20, 0x74, 0x79, 0x70, 0x65, 0x73, 0x20, 0x77, 0x69, 0x6C, 0x6C, 
  0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x87, 0x24, 0x01, 0xDA, 0x85, 0x70, 0xD3, 0x02, 
  0xDA, 0x03, 0xDA, 0x83, 0x93, 0xDA, 0x09, 0xCE, 0x32, 0x54, 0x68, 0x65, 0x20, 0x62, 0x75, 0x69, 
  0x6C, 0x64, 0x20, 0x69, 0x64, 0x65, 0x6E, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x20, 0x6F, 0x66, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x75, 0x6E, 0x6E, 0x69, 0x6E, 0x67, 0x20, 0x6A, 0x61, 0x6E, 
  0x65, 0x74, 0x20, 0x70, 0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x2E, 0xDA, 0x85, 0x71, 0xD3, 0x03, 
  0xDA, 0x03, 0xDA, 0x81, 0x9D, 0xDA, 0x09, 0xCE, 0x2E, 0x28, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x65, 
  0x64, 0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 
  0x78, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x6F, 0x72, 
  0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x6C, 0x01, 
  0xDA, 0x85, 0x72, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 0x85, 0x74, 0xDA, 0x09, 0xCE, 0x28, 0x28, 0x2F, 
  0x3D, 0x20, 0x78, 0x20, 0x6E, 0x29, 0x0A, 0x0A, 0x53, 0x68, 0x6F, 0x72, 0x74, 0x68, 0x61, 0x6E, 
  0x64, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x28, 0x73, 0x65, 0x74, 0x20, 0x78, 0x20, 0x28, 0x2F, 0x20, 
  0x78, 0x20, 0x6E, 0x29, 0x29, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x80, 0x88, 0x01, 
  0xDA, 0x35, 0xCB, 0xDA, 0x85, 0x75, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x80, 0xCB, 0xDA, 0x09, 0xCE, 
  0x81, 0x01, 0x28, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2F, 0x66, 0x69, 0x6E, 0x64, 0x20, 0x70, 
  0x61, 0x74, 0x68, 0x29, 0x0A, 0x0A, 0x54, 0x72, 0x79, 0x20, 0x74, 0x6F, 0x20, 0x6D, 0x61, 0x74, 
  0x63, 0x68, 0x20, 0x61, 0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x20, 0x6F, 0x72, 0x20, 0x70, 
  0x61, 0x74, 0x68, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6E, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x6D, 0x6F, 
  0x64, 0x75, 0x6C, 0x65, 0x2F, 0x70, 0x61, 0x74, 0x68, 0x73, 0x2E, 0x20, 0x20, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x20, 0x28, 0x66, 0x75, 
  0x6C, 0x6C, 0x70, 0x61, 0x74, 0x68, 0x20, 0x6B, 0x69, 0x6E, 0x64, 0x29, 0x20, 0x77, 0x68, 0x65, 
  0x72, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6B, 0x69, 0x6E, 0x64, 0x20, 0x69, 0x73, 0x20, 0x6F, 
  0x6E, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x3A, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x2C, 0x20, 0x3A, 
  0x6E, 0x61, 0x74, 0x69, 0x76, 0x65, 0x2C, 0x20, 0x20, 0x6F, 0x72, 0x20, 0x69, 0x6D, 0x61, 0x67, 
  0x65, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x20, 
  0x69, 0x73, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x2C, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x77, 
  0x69, 0x73, 0x65, 0x20, 0x61, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 
  0x20, 0x6E, 0x69, 0x6C, 0x20, 0x66, 0x6F, 0x6C, 0x6C, 0x6F, 0x77, 0x65, 0x64, 0x20, 0x62, 0x79, 
  0x20, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x6D, 0x65, 0x73, 0x73, 0x61, 
  0x67, 0x65, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x88, 0xCD, 0x01, 0xDA, 0x85, 0x76, 
  0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x85, 0x78, 0xDA, 0x09, 0xCE, 0x4E, 0x28, 0x65, 0x72, 0x72, 0x6F, 
  0x72, 0x20, 0x65, 0x29, 0x0A, 0x0A, 0x54, 0x68, 0x72, 0x6F, 0x77, 0x73, 0x20, 0x61, 0x6E, 0x20, 
  0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 0x61, 0x6E, 
  0x20, 0x62, 0x65, 0x20, 0x63, 0x61, 0x75, 0x67, 0x68, 0x74, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x68, 
  0x61, 0x6E, 0x64, 0x6C, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x61, 0x20, 0x70, 0x61, 0x72, 0x65, 
  0x6E, 0x74, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2E, 0xDA, 0x85, 0x79, 0xD3, 0x02, 0xDA, 0x03, 
  0xDA, 0x85, 0x7B, 0xDA, 0x09, 0xCE, 0x34, 0x28, 0x62, 0x6E, 0x6F, 0x74, 0x20, 0x78, 0x29, 0x0A, 
  0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x69, 0x74, 
  0x2D, 0x77, 0x69, 0x73, 0x65, 0x20, 0x69, 0x6E, 0x76, 0x65, 0x72, 0x73, 0x65, 0x20, 0x6F, 0x66, 
  0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x78, 0x2E, 0xDA, 0x85, 0x7C, 0xD3, 0x04, 
  0xDA, 0x03, 0xDA, 0x85, 0x7E, 0xDA, 0x09, 0xCE, 0x81, 0x3C, 0x28, 0x74, 0x72, 0x79, 0x20, 0x62, 
  0x6F, 0x64, 0x79, 0x20, 0x63, 0x61, 0x74, 0x63, 0x68, 0x29, 0x0A, 0x0A, 0x54, 0x72, 0x79, 0x20, 
  0x73, 0x6F, 0x6D, 0x65, 0x74, 0x68, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x63, 0x61, 
  0x74, 0x63, 0x68, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x73, 0x2E, 0x20, 0x42, 0x6F, 0x64, 0x79, 
  0x20, 0x69, 0x73, 0x20, 0x61, 0x6E, 0x79, 0x20, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 
  0x6F, 0x6E, 0x2C, 0x20, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x63, 0x61, 0x74, 0x63, 0x68, 0x20, 0x73, 
  0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x62, 0x65, 0x20, 0x61, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x20, 
  0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x65, 
  0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x61, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x2E, 0x20, 
  0x54, 0x68, 0x69, 0x73, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x20, 0x20, 0x73, 0x68, 0x6F, 0x75, 
  0x6C, 0x64, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x62, 0x69, 0x6E, 
  0x64, 0x69, 0x6E, 0x67, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x73, 0x20, 
  0x61, 0x6E, 0x64, 0x20, 0x61, 0x6E, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x20, 
  0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x77, 0x72, 0x61, 0x70, 0x70, 0x69, 0x6E, 0x67, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 
  0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6C, 0x74, 0x20, 0x6F, 0x66, 0x20, 
  0x62, 0x6F, 0x64, 0x79, 0x20, 0x69, 0x66, 0x20, 0x6E, 0x6F, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 
  0x2C, 0x20, 0x20, 0x6F, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6C, 0x74, 
  0x20, 0x6F, 0x66, 0x20, 0x63, 0x61, 0x74, 0x63, 0x68, 0x20, 0x69, 0x66, 0x20, 0x61, 0x6E, 0x20, 
  0x65, 0x72, 0x72, 0x6F, 0x72, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x80, 0xE1, 0x01, 
  0xDA, 0x35, 0xCB, 0xDA, 0x85, 0x7F, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x85, 0x81, 0xDA, 0x09, 0xCE, 
  0x24, 0x28, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 
  0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x62, 0x75, 
  0x66, 0x66, 0x65, 0x72, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x5D, 0x01, 0xDA, 0x85, 
  0x82, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x85, 0x84, 0xDA, 0x09, 0xCE, 0x5D, 0x28, 0x63, 0x6F, 0x6D, 
  0x70, 0x61, 0x72, 0x65, 0x3D, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x45, 0x71, 0x75, 
  0x69, 0x76, 0x61, 0x6C, 0x65, 0x6E, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x27, 0x3D, 0x27, 0x20, 0x62, 
  0x75, 0x74, 0x20, 0x75, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x61, 0x72, 0x65, 
  0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x69, 0x6E, 0x73, 0x74, 0x65, 0x61, 
  0x64, 0x20, 0x6F, 0x66, 0x20, 0x70, 0x72, 0x69, 0x6D, 0x69, 0x74, 0x69, 0x76, 0x65, 0x20, 0x63, 
  0x6F, 0x6D, 0x70, 0x61, 0x72, 0x61, 0x74, 0x6F, 0x72, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 
  0x82, 0xC1, 0x01, 0xDA, 0x85, 0x85, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x80, 0xFF, 0xDA, 0x09, 0xCE, 
  0x4E, 0x28, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2F, 0x63, 0x61, 0x6E, 0x2D, 0x72, 0x65, 0x73, 0x75, 
  0x6D, 0x65, 0x3F, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 
  0x6B, 0x20, 0x69, 0x66, 0x20, 0x61, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 
  0x66, 0x69, 0x6E, 0x69, 0x73, 0x68, 0x65, 0x64, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x63, 0x61, 0x6E, 
  0x6E, 0x6F, 0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6D, 0x65, 0x64, 0x2E, 0xDA, 
  0x84, 0x57, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 0x85, 0x87, 0xDA, 0x09, 0xCE, 0x43, 0x28, 0x76, 0x61, 
  0x72, 0x2D, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x26, 0x20, 0x6D, 0x6F, 0x72, 0x65, 0x29, 0x0A, 
  0x0A, 0x44, 0x65, 0x66, 0x69, 0x6E, 0x65, 0x20, 0x61, 0x20, 0x70, 0x72, 0x69, 0x76, 0x61, 0x74, 
  0x65, 0x20, 0x76, 0x61, 0x72, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 
  0x6E, 0x6F, 0x74, 0x20, 0x62, 0x65, 0x20, 0x65, 0x78, 0x70, 0x6F, 0x72, 0x74, 0x65, 0x64, 0x2E, 
  0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x3D, 0x01, 0xDA, 0x35, 0xCB, 0xDA, 0x85, 0x88, 0xD3, 
  0x02, 0xDA, 0x03, 0xDA, 0x7F, 0xDA, 0x09, 0xCE, 0x80, 0xD4, 0x28, 0x64, 0x65, 0x62, 0x75, 0x67, 
  0x2F, 0x73, 0x74, 0x61, 0x63, 0x6B, 0x74, 0x72, 0x61, 0x63, 0x65, 0x20, 0x66, 0x69, 0x62, 0x65, 
  0x72, 0x20, 0x65, 0x72, 0x72, 0x29, 0x0A, 0x0A, 0x50, 0x72, 0x69, 0x6E, 0x74, 0x73, 0x20, 0x61, 
  0x20, 0x6E, 0x69, 0x63, 0x65, 0x20, 0x6C, 0x6F, 0x6F, 0x6B, 0x69, 0x6E, 0x67, 0x20, 0x73, 0x74, 
  0x61, 0x63, 0x6B, 0x74, 0x72, 0x61, 0x63, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x61, 0x20, 0x66, 
  0x69, 0x62, 0x65, 0x72, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 
  0x6D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x65, 0x72, 0x72, 0x20, 0x6D, 0x75, 0x73, 0x74, 
  0x20, 0x62, 0x65, 0x20, 0x70, 0x61, 0x73, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x61, 0x73, 0x20, 0x66, 0x69, 
  0x62, 0x65, 0x72, 0x27, 0x73, 0x20, 0x64, 0x6F, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x6B, 0x65, 0x65, 
  0x70, 0x20, 0x74, 0x72, 0x61, 0x63, 0x6B, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 
  0x61, 0x73, 0x74, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x74, 0x68, 0x65, 0x79, 0x20, 0x68, 
  0x61, 0x76, 0x65, 0x20, 0x74, 0x68, 0x72, 0x6F, 0x77, 0x6E, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2E, 0xDA, 0x85, 
  0x89, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x85, 0x8A, 0xDA, 0x09, 0xCE, 0x6C, 0x28, 0x6D, 0x61, 0x74, 
  0x68, 0x2F, 0x73, 0x65, 0x65, 0x64, 0x72, 0x61, 0x6E, 0x64, 0x6F, 0x6D, 0x20, 0x73, 0x65, 0x65, 
  0x64, 0x29, 0x0A, 0x0A, 0x53, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x65, 0x64, 
  0x20, 0x66, 0x6F, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x61, 0x6E, 0x64, 0x6F, 0x6D, 0x20, 
  0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x67, 0x65, 0x6E, 0x65, 0x72, 0x61, 0x74, 0x6F, 0x72, 
  0x2E, 0x20, 0x73, 0x65, 0x65, 0x64, 0x20, 0x73, 0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x62, 0x65, 
  0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x6F, 0x72, 0x20, 0x61, 
  0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0xDA, 0x85, 0x8B, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 
  0x85, 0x8E, 0xDA, 0x09, 0xCE, 0x7A, 0x28, 0x6C, 0x61, 0x62, 0x65, 0x6C, 0x20, 0x6E, 0x61, 0x6D, 
  0x65, 0x20, 0x26, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x29, 0x0A, 0x0A, 0x53, 0x65, 0x74, 0x20, 0x61, 
  0x20, 0x6C, 0x61, 0x62, 0x65, 0x6C, 0x20, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x20, 0x74, 0x68, 0x61, 
  0x74, 0x20, 0x69, 0x73, 0x20, 0x6C, 0x65, 0x78, 0x69, 0x63, 0x61, 0x6C, 0x6C, 0x79, 0x20, 0x73, 
  0x63, 0x6F, 0x70, 0x65, 0x64, 0x2E, 0x20, 0x4E, 0x61, 0x6D, 0x65, 0x20, 0x73, 0x68, 0x6F, 0x75, 
  0x6C, 0x64, 0x20, 0x62, 0x65, 0x20, 0x61, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x20, 0x20, 
  0x74, 0x68, 0x61, 0x74, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x62, 0x6F, 0x75, 
  0x6E, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x61, 0x62, 0x65, 0x6C, 0x2E, 
  0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x81, 0x57, 0x01, 0xDA, 0x35, 0xCB, 0xDA, 0x84, 0x97, 
  0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x24, 0xDA, 0x09, 0xCE, 0x83, 0x67, 0x28, 0x66, 0x69, 0x62, 0x65, 
  0x72, 0x2F, 0x6E, 0x65, 0x77, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 
  0x73, 0x69, 0x67, 0x6D, 0x61, 0x73, 0x6B, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 
  0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x77, 0x69, 0x74, 
  0x68, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x20, 
  0x66, 0x75, 0x6E, 0x63, 0x2E, 0x20, 0x43, 0x61, 0x6E, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 
  0x61, 0x6C, 0x6C, 0x79, 0x20, 0x74, 0x61, 0x6B, 0x65, 0x20, 0x61, 0x20, 0x73, 0x65, 0x74, 0x20, 
  0x6F, 0x66, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x62, 0x6C, 
  0x6F, 0x63, 0x6B, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 
  0x72, 0x65, 0x6E, 0x74, 0x20, 0x70, 0x61, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x69, 0x62, 0x65, 
  0x72, 0x20, 0x77, 0x68, 0x65, 0x6E, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x65, 0x64, 0x2E, 0x20, 0x54, 
  0x68, 0x65, 0x20, 0x6D, 0x61, 0x73, 0x6B, 0x20, 0x69, 0x73, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 
  0x66, 0x69, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 0x61, 0x20, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 
  0x64, 0x20, 0x77, 0x68, 0x65, 0x72, 0x65, 0x20, 0x65, 0x61, 0x63, 0x68, 0x20, 0x63, 0x68, 0x61, 
  0x72, 0x61, 0x63, 0x74, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x74, 
  0x6F, 0x20, 0x69, 0x6E, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 0x73, 0x69, 0x67, 
  0x6E, 0x61, 0x6C, 0x20, 0x74, 0x6F, 0x20, 0x62, 0x6C, 0x6F, 0x63, 0x6B, 0x2E, 0x20, 0x54, 0x68, 
  0x65, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x20, 0x73, 0x69, 0x67, 0x6D, 0x61, 0x73, 
  0x6B, 0x20, 0x69, 0x73, 0x20, 0x3A, 0x79, 0x2E, 0x20, 0x46, 0x6F, 0x72, 0x20, 0x65, 0x78, 0x61, 
  0x6D, 0x70, 0x6C, 0x65, 0x2C, 0x20, 0x0A, 0x0A, 0x09, 0x28, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2F, 
  0x6E, 0x65, 0x77, 0x20, 0x6D, 0x79, 0x66, 0x75, 0x6E, 0x20, 0x3A, 0x65, 0x31, 0x32, 0x33, 0x29, 
  0x0A, 0x0A, 0x62, 0x6C, 0x6F, 0x63, 0x6B, 0x73, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x73, 
  0x69, 0x67, 0x6E, 0x61, 0x6C, 0x73, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 
  0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0x73, 0x20, 0x31, 0x2C, 0x20, 0x32, 0x20, 0x61, 0x6E, 0x64, 
  0x20, 0x33, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0x73, 0x20, 
  0x61, 0x72, 0x65, 0x20, 0x61, 0x73, 0x20, 0x66, 0x6F, 0x6C, 0x6C, 0x6F, 0x77, 0x73, 0x3A, 0x20, 
  0x0A, 0x0A, 0x09, 0x61, 0x20, 0x2D, 0x20, 0x62, 0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x61, 0x6C, 0x6C, 
  0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0x73, 0x0A, 0x09, 0x64, 0x20, 0x2D, 0x20, 0x62, 0x6C, 
  0x6F, 0x63, 0x6B, 0x20, 0x64, 0x65, 0x62, 0x75, 0x67, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 
  0x73, 0x0A, 0x09, 0x65, 0x20, 0x2D, 0x20, 0x62, 0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x65, 0x72, 0x72, 
  0x6F, 0x72, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0x73, 0x0A, 0x09, 0x74, 0x20, 0x2D, 0x20, 
  0x62, 0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x74, 0x65, 0x72, 0x6D, 0x69, 0x6E, 0x61, 0x74, 0x69, 0x6F, 
  0x6E, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0x73, 0x3A, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 
  0x20, 0x2B, 0x20, 0x75, 0x73, 0x65, 0x72, 0x5B, 0x30, 0x2D, 0x34, 0x5D, 0x0A, 0x09, 0x75, 0x20, 
  0x2D, 0x20, 0x62, 0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x73, 0x69, 0x67, 
  0x6E, 0x61, 0x6C, 0x73, 0x0A, 0x09, 0x79, 0x20, 0x2D, 0x20, 0x62, 0x6C, 0x6F, 0x63, 0x6B, 0x20, 
  0x79, 0x69, 0x65, 0x6C, 0x64, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0x73, 0x0A, 0x09, 0x30, 
  0x2D, 0x39, 0x20, 0x2D, 0x20, 0x62, 0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x61, 0x20, 0x73, 0x70, 0x65, 
  0x63, 0x69, 0x66, 0x69, 0x63, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 
  0x6C, 0x0A, 0x0A, 0x54, 0x68, 0x65, 0x20, 0x73, 0x69, 0x67, 0x6D, 0x61, 0x73, 0x6B, 0x20, 0x61, 
  0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x61, 0x6C, 0x73, 0x6F, 0x20, 0x63, 0x61, 0x6E, 
  0x20, 0x74, 0x61, 0x6B, 0x65, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 
  0x74, 0x20, 0x66, 0x6C, 0x61, 0x67, 0x73, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x61, 0x6E, 0x79, 0x20, 
  0x6D, 0x75, 0x74, 0x75, 0x61, 0x6C, 0x6C, 0x79, 0x20, 0x65, 0x78, 0x63, 0x6C, 0x75, 0x73, 0x69, 
  0x76, 0x65, 0x20, 0x66, 0x6C, 0x61, 0x67, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x70, 0x72, 0x65, 
  0x73, 0x65, 0x6E, 0x74, 0x2C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x61, 0x73, 0x74, 0x20, 0x66, 
  0x6C, 0x61, 0x67, 0x20, 0x74, 0x61, 0x6B, 0x65, 0x73, 0x20, 0x70, 0x72, 0x65, 0x63, 0x65, 0x64, 
  0x65, 0x6E, 0x63, 0x65, 0x2E, 0x0A, 0x0A, 0x09, 0x69, 0x20, 0x2D, 0x20, 0x69, 0x6E, 0x68, 0x65, 
  0x72, 0x69, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 
  0x65, 0x6E, 0x74, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 
  0x72, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x0A, 0x09, 0x70, 0x20, 0x2D, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x20, 
  0x74, 0x61, 0x62, 0x6C, 0x65, 0x27, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0x74, 0x79, 0x70, 
  0x65, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 
  0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x61, 0x62, 
  0x6C, 0x65, 0xDA, 0x85, 0x8F, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x85, 0x91, 0xDA, 0x09, 0xCE, 0x42, 
  0x28, 0x70, 0x72, 0x65, 0x77, 0x61, 0x6C, 0x6B, 0x20, 0x66, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x29, 
  0x0A, 0x0A, 0x53, 0x69, 0x6D, 0x69, 0x6C, 0x61, 0x72, 0x20, 0x74, 0x6F, 0x20, 0x70, 0x6F, 0x73, 
  0x74, 0x77, 0x61, 0x6C, 0x6B, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x64, 0x6F, 0x20, 0x70, 0x72, 
  0x65, 0x2D, 0x6F, 0x72, 0x64, 0x65, 0x72, 0x20, 0x74, 0x72, 0x61, 0x76, 0x65, 0x72, 0x73, 0x61, 
  0x6C, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x84, 0x5E, 0x01, 0xDA, 0x85, 0x92, 0xD3, 
  0x02, 0xDA, 0x03, 0xDA, 0x84, 0x81, 0xDA, 0x09, 0xCE, 0x51, 0x28, 0x64, 0x65, 0x73, 0x63, 0x72, 
  0x69, 0x62, 0x65, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 
  0x61, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x73, 
  0x20, 0x61, 0x20, 0x68, 0x75, 0x6D, 0x61, 0x6E, 0x20, 0x72, 0x65, 0x61, 0x64, 0x61, 0x62, 0x6C, 
  0x65, 0x20, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x6F, 0x66, 
  0x20, 0x61, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x78, 0x2E, 0xDA, 0x85, 0x93, 0xD3, 0x02, 
  0xDA, 0x03, 0xDA, 0x85, 0x94, 0xDA, 0x09, 0xCE, 0x76, 0x28, 0x6E, 0x65, 0x74, 0x2F, 0x63, 0x68, 
  0x75, 0x6E, 0x6B, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x20, 0x6E, 0x62, 0x79, 0x74, 0x65, 
  0x73, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x62, 0x75, 0x66, 0x29, 0x0A, 0x0A, 0x53, 0x61, 0x6D, 
  0x65, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x74, 0x2F, 0x72, 0x65, 0x61, 0x64, 0x2C, 0x20, 0x62, 0x75, 
  0x74, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x77, 0x61, 0x69, 0x74, 0x20, 0x66, 0x6F, 0x72, 0x20, 
  0x61, 0x6C, 0x6C, 0x20, 0x6E, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x61, 
  0x72, 0x72, 0x69, 0x76, 0x65, 0x20, 0x72, 0x61, 0x74, 0x68, 0x65, 0x72, 0x20, 0x74, 0x68, 0x61, 
  0x6E, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x65, 0x61, 0x72, 0x6C, 0x79, 0x2E, 0xDA, 
  0x85, 0x95, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x85, 0x96, 0xDA, 0x09, 0xCE, 0x54, 0x28, 0x6F, 0x73, 
  0x2F, 0x72, 0x65, 0x61, 0x64, 0x6C, 0x69, 0x6E, 0x6B, 0x20, 0x70, 0x61, 0x74, 0x68, 0x29, 0x0A, 
  0x0A, 0x52, 0x65, 0x61, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 
  0x74, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x69, 0x63, 
  0x20, 0x6C, 0x69, 0x6E, 0x6B, 0x2E, 0x20, 0x44, 0x6F, 0x65, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 
  0x77, 0x6F, 0x72, 0x6B, 0x20, 0x6F, 0x6E, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x2E, 
  0x0A, 0xDA, 0x85, 0x97, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x84, 0x80, 0xDA, 0x09, 0xCE, 0x80, 0xC8, 
  0x28, 0x61, 0x6C, 0x6C, 0x2D, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x20, 0x26, 0x6F, 
  0x70, 0x74, 0x20, 0x65, 0x6E, 0x76, 0x20, 0x6C, 0x6F, 0x63, 0x61, 0x6C, 0x29, 0x0A, 0x0A, 0x47, 
  0x65, 0x74, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x73, 0x20, 0x61, 
  0x76, 0x61, 0x69, 0x6C, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x6E, 0x20, 0x65, 
  0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0x20, 0x44, 0x65, 0x66, 0x61, 
  0x75, 0x6C, 0x74, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 
  0x65, 0x6E, 0x74, 0x20, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x27, 0x73, 0x20, 0x65, 0x6E, 0x76, 
  0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x6C, 0x6F, 0x63, 
  0x61, 0x6C, 0x20, 0x69, 0x73, 0x20, 0x74, 0x72, 0x75, 0x74, 0x68, 0x79, 0x2C, 0x20, 0x77, 0x69, 
  0x6C, 0x6C, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x73, 0x68, 0x6F, 0x77, 0x20, 0x69, 0x6E, 0x68, 0x65, 
  0x72, 0x69, 0x74, 0x65, 0x64, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x20, 0x20, 
  0x28, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x70, 0x72, 0x6F, 0x74, 0x6F, 0x74, 0x79, 0x70, 0x65, 0x20, 
  0x74, 0x61, 0x62, 0x6C, 0x65, 0x73, 0x29, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x86, 
  0x2B, 0x01, 0xDA, 0x85, 0x98, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x85, 0x99, 0xDA, 0x09, 0xCE, 0x2A, 
  0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x61, 0x63, 0x6F, 0x73, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x63, 0x63, 0x6F, 
  0x73, 0x69, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x2E, 0xDA, 0x85, 0x9A, 0xD3, 0x02, 0xDA, 
  0x03, 0xDA, 0x85, 0x9B, 0xDA, 0x09, 0xCE, 0x45, 0x28, 0x75, 0x6E, 0x74, 0x72, 0x61, 0x63, 0x65, 
  0x20, 0x66, 0x75, 0x6E, 0x63, 0x29, 0x0A, 0x0A, 0x44, 0x69, 0x73, 0x61, 0x62, 0x6C, 0x65, 0x73, 
  0x20, 0x74, 0x72, 0x61, 0x63, 0x69, 0x6E, 0x67, 0x20, 0x6F, 0x6E, 0x20, 0x61, 0x20, 0x66, 0x75, 
  0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0xDA, 0x61, 0xD3, 
  0x03, 0xDA, 0x03, 0xDA, 0x60, 0xDA, 0x09, 0xCE, 0x80, 0xC7, 0x28, 0x61, 0x6C, 0x6C, 0x2D, 0x64, 
  0x79, 0x6E, 0x61, 0x6D, 0x69, 0x63, 0x73, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x65, 0x6E, 0x76, 
  0x20, 0x6C, 0x6F, 0x63, 0x61, 0x6C, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 0x61, 0x6C, 0x6C, 
  0x20, 0x64, 0x79, 0x6E, 0x61, 0x6D, 0x69, 0x63, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 
  0x73, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 
  0x65, 0x6E, 0x74, 0x2E, 0x20, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x73, 0x20, 0x74, 0x6F, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x20, 0x66, 0x69, 
  0x62, 0x65, 0x72, 0x27, 0x73, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 
  0x74, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x6C, 0x6F, 0x63, 0x61, 0x6C, 0x20, 0x69, 0x73, 0x20, 0x74, 
  0x72, 0x75, 0x74, 0x68, 0x79, 0x2C, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x6E, 0x6F, 0x74, 0x20, 
  0x73, 0x68, 0x6F, 0x77, 0x20, 0x69, 0x6E, 0x68, 0x65, 0x72, 0x69, 0x74, 0x65, 0x64, 0x20, 0x62, 
  0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x20, 0x20, 0x28, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x70, 
  0x72, 0x6F, 0x74, 0x6F, 0x74, 0x79, 0x70, 0x65, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x73, 0x29, 
  0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x86, 0x32, 0x01, 0xDA, 0x43, 0xD3, 0x02, 0xDA, 
  0x03, 0xDA, 0x42, 0xDA, 0x09, 0xCE, 0x29, 0x54, 0x68, 0x65, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 
  0x72, 0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6E, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x70, 
  0x6F, 0x73, 0x69, 0x74, 0x69, 0x76, 0x65, 0x20, 0x69, 0x6E, 0x66, 0x69, 0x6E, 0x69, 0x74, 0x79, 
  0xDA, 0x85, 0x9C, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x85, 0x9D, 0xDA, 0x09, 0xCE, 0x80, 0xA2, 0x28, 
  0x6F, 0x73, 0x2F, 0x72, 0x65, 0x61, 0x6C, 0x70, 0x61, 0x74, 0x68, 0x20, 0x70, 0x61, 0x74, 0x68, 
  0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x62, 0x73, 0x6F, 0x6C, 
  0x75, 0x74, 0x65, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x61, 0x20, 0x67, 
  0x69, 0x76, 0x65, 0x6E, 0x20, 0x70, 0x61, 0x74, 0x68, 0x2C, 0x20, 0x66, 0x6F, 0x6C, 0x6C, 0x6F, 
  0x77, 0x69, 0x6E, 0x67, 0x20, 0x2E, 0x2E, 0x2F, 0x2C, 0x20, 0x2E, 0x2F, 0x2C, 0x20, 0x61, 0x6E, 
  0x64, 0x20, 0x73, 0x79, 0x6D, 0x6C, 0x69, 0x6E, 0x6B, 0x73, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x62, 0x73, 0x6F, 0x6C, 0x75, 0x74, 0x65, 0x20, 
  0x70, 0x61, 0x74, 0x68, 0x20, 0x61, 0x73, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 
  0x2E, 0x20, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x72, 0x61, 0x69, 0x73, 0x65, 0x20, 0x61, 0x6E, 0x20, 
  0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x6F, 0x6E, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 
  0x2E, 0xDA, 0x85, 0x9E, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x6B, 0xDA, 0x09, 0xCE, 0x80, 0xD6, 0x28, 
  0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x70, 0x75, 0x73, 0x68, 0x2D, 0x73, 0x74, 0x72, 0x69, 
  0x6E, 0x67, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x73, 0x74, 0x72, 0x29, 0x0A, 0x0A, 
  0x50, 0x75, 0x73, 0x68, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x6F, 0x6E, 
  0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6E, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x20, 
  0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0x20, 0x4E, 0x6F, 0x6E, 0x20, 0x73, 0x74, 0x72, 0x69, 
  0x6E, 0x67, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 
  0x65, 0x20, 0x63, 0x6F, 0x6E, 0x76, 0x65, 0x72, 0x74, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x73, 
  0x74, 0x72, 0x69, 0x6E, 0x67, 0x73, 0x20, 0x62, 0x65, 0x66, 0x6F, 0x72, 0x65, 0x20, 0x62, 0x65, 
  0x69, 0x6E, 0x67, 0x20, 0x70, 0x75, 0x73, 0x68, 0x65, 0x64, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 
  0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0x20, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x74, 0x68, 
  0x72, 0x6F, 0x77, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x69, 0x66, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x6F, 0x76, 0x65, 0x72, 0x66, 
  0x6C, 0x6F, 0x77, 0x73, 0x2E, 0xDA, 0x85, 0x9F, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x84, 0x38, 0xDA, 
  0x09, 0xCE, 0x80, 0x83, 0x28, 0x65, 0x76, 0x61, 0x6C, 0x2D, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 
  0x20, 0x73, 0x74, 0x72, 0x29, 0x0A, 0x0A, 0x45, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0x73, 
  0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 
  0x6D, 0x65, 0x6E, 0x74, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x6D, 0x6F, 0x72, 0x65, 0x20, 0x63, 0x6F, 
  0x6E, 0x74, 0x72, 0x6F, 0x6C, 0x20, 0x6F, 0x76, 0x65, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x20, 
  0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x69, 0x73, 0x20, 0x6E, 
  0x65, 0x65, 0x64, 0x65, 0x64, 0x2C, 0x20, 0x75, 0x73, 0x65, 0x20, 0x72, 0x75, 0x6E, 0x2D, 0x63, 
  0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x88, 0x47, 
  0x01, 0xDA, 0x85, 0xA0, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x85, 0xA1, 0xDA, 0x09, 0xCE, 0x80, 0xBE, 
  0x28, 0x75, 0x6E, 0x6D, 0x61, 0x72, 0x73, 0x68, 0x61, 0x6C, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 
  0x72, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x6C, 0x6F, 0x6F, 0x6B, 0x75, 0x70, 0x29, 0x0A, 0x0A, 
  0x55, 0x6E, 0x6D, 0x61, 0x72, 0x73, 0x68, 0x61, 0x6C, 0x20, 0x61, 0x20, 0x76, 0x61, 0x6C, 0x75, 
  0x65, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x61, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 
  0x20, 0x41, 0x6E, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x20, 0x6C, 0x6F, 0x6F, 
  0x6B, 0x75, 0x70, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 
  0x20, 0x70, 0x72, 0x6F, 0x76, 0x69, 0x64, 0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x6C, 0x6C, 
  0x6F, 0x77, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x61, 0x6C, 0x69, 0x61, 0x73, 0x65, 0x73, 0x20, 0x74, 
  0x6F, 0x20, 0x62, 0x65, 0x20, 0x72, 0x65, 0x73, 0x6F, 0x6C, 0x76, 0x65, 0x64, 0x2E, 0x20, 0x52, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 
  0x20, 0x75, 0x6E, 0x6D, 0x61, 0x72, 0x73, 0x68, 0x61, 0x6C, 0x6C, 0x65, 0x64, 0x20, 0x66, 0x72, 
  0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0xDA, 0x85, 
  0xA2, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 0x85, 0xA6, 0xDA, 0x09, 0xCE, 0x28, 0x28, 0x25, 0x3D, 0x20, 
  0x78, 0x20, 0x6E, 0x29, 0x0A, 0x0A, 0x53, 0x68, 0x6F, 0x72, 0x74, 0x68, 0x61, 0x6E, 0x64, 0x20, 
  0x66, 0x6F, 0x72, 0x20, 0x28, 0x73, 0x65, 0x74, 0x20, 0x78, 0x20, 0x28, 0x25, 0x20, 0x78, 0x20, 
  0x6E, 0x29, 0x29, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x80, 0x89, 0x01, 0xDA, 0x35, 
  0xCB, 0xDA, 0x84, 0x4D, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 0x85, 0xA8, 0xDA, 0x09, 0xCE, 0x27, 0x28, 
  0x64, 0x65, 0x66, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x26, 0x20, 
  0x6D, 0x6F, 0x72, 0x65, 0x29, 0x0A, 0x0A, 0x44, 0x65, 0x66, 0x69, 0x6E, 0x65, 0x20, 0x61, 0x20, 
  0x6D, 0x61, 0x63, 0x72, 0x6F, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x29, 0x01, 0xDA, 
  0x35, 0xCB, 0xDA, 0x31, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 0x85, 0xAC, 0xDA, 0x09, 0xCE, 0x80, 0xC7, 
  0x28, 0x69, 0x66, 0x2D, 0x6C, 0x65, 0x74, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 
  0x20, 0x74, 0x72, 0x75, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x66, 0x61, 0x6C, 0x29, 0x0A, 0x0A, 
  0x4D, 0x61, 0x6B, 0x65, 0x20, 0x6D, 0x75, 0x6C, 0x74, 0x69, 0x70, 0x6C, 0x65, 0x20, 0x62, 0x69, 
  0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x69, 0x66, 0x20, 0x61, 
  0x6C, 0x6C, 0x20, 0x61, 0x72, 0x65, 0x20, 0x74, 0x72, 0x75, 0x74, 0x68, 0x79, 0x2C, 0x20, 0x20, 
  0x65, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x72, 0x75, 
  0x20, 0x66, 0x6F, 0x72, 0x6D, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x61, 0x6E, 0x79, 0x20, 0x61, 0x72, 
  0x65, 0x20, 0x66, 0x61, 0x6C, 0x73, 0x65, 0x20, 0x6F, 0x72, 0x20, 0x6E, 0x69, 0x6C, 0x2C, 0x20, 
  0x65, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0x20, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x61, 
  0x6C, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x2E, 0x20, 0x42, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 
  0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6D, 0x65, 0x20, 0x73, 
  0x79, 0x6E, 0x74, 0x61, 0x78, 0x20, 0x61, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x65, 0x74, 
  0x20, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x82, 0x47, 
  0x01, 0xDA, 0x35, 0xCB, 0xDA, 0x85, 0xAD, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x82, 0x3D, 0xDA, 0x09, 
  0xCE, 0x69, 0x28, 0x6E, 0x61, 0x74, 0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 
  0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x65, 0x78, 
  0x61, 0x63, 0x74, 0x6C, 0x79, 0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6E, 0x74, 0x65, 
  0x64, 0x20, 0x61, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x6F, 0x6E, 0x2D, 0x6E, 0x65, 0x67, 0x61, 0x74, 
  0x69, 0x76, 0x65, 0x20, 0x33, 0x32, 0x20, 0x62, 0x69, 0x74, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x65, 
  0x64, 0x20, 0x74, 0x77, 0x6F, 0x27, 0x73, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x6C, 0x65, 0x6D, 0x65, 
  0x6E, 0x74, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x2E, 0xDA, 0x85, 0xAE, 0xD3, 0x02, 
  0xDA, 0x03, 0xDA, 0x80, 0xEE, 0xDA, 0x09, 0xCE, 0x80, 0x8A, 0x28, 0x70, 0x61, 0x72, 0x73, 0x65, 
  0x72, 0x2F, 0x6E, 0x65, 0x77, 0x29, 0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x73, 0x20, 
  0x61, 0x6E, 0x64, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 
  0x77, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x20, 0x6F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x2E, 
  0x20, 0x50, 0x61, 0x72, 0x73, 0x65, 0x72, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x73, 0x74, 0x61, 
  0x74, 0x65, 0x20, 0x6D, 0x61, 0x63, 0x68, 0x69, 0x6E, 0x65, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 
  0x20, 0x63, 0x61, 0x6E, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x20, 0x62, 0x79, 0x74, 
  0x65, 0x73, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x67, 0x65, 0x6E, 0x65, 0x72, 0x61, 0x74, 0x65, 
  0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x20, 0x6F, 0x66, 0x20, 0x76, 0x61, 0x6C, 
  0x75, 0x65, 0x73, 0x2E, 0xDA, 0x85, 0xAF, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x80, 0xFE, 0xDA, 0x09, 
  0xCE, 0x71, 0x28, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2F, 0x73, 0x65, 0x74, 0x65, 0x6E, 0x76, 0x20, 
  0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x29, 0x0A, 0x0A, 0x53, 0x65, 
  0x74, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 
  0x6E, 0x74, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x61, 0x20, 0x66, 
  0x69, 0x62, 0x65, 0x72, 0x2E, 0x20, 0x53, 0x65, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x6E, 0x69, 0x6C, 
  0x20, 0x74, 0x6F, 0x20, 0x72, 0x65, 0x6D, 0x6F, 0x76, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 
  0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 
  0x6E, 0x74, 0x2E, 0xDA, 0x85, 0xB0, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x85, 0xB2, 0xDA, 0x09, 0xCE, 
  0x80, 0x8C, 0x28, 0x64, 0x65, 0x65, 0x70, 0x3D, 0x20, 0x78, 0x20, 0x79, 0x29, 0x0A, 0x0A, 0x4C, 
  0x69, 0x6B, 0x65, 0x20, 0x3D, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x6D, 0x75, 0x74, 0x61, 0x62, 
  0x6C, 0x65, 0x20, 0x74, 0x79, 0x70, 0x65, 0x73, 0x20, 0x28, 0x61, 0x72, 0x72, 0x61, 0x79, 0x73, 
  0x2C, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x73, 0x2C, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 
  0x73, 0x29, 0x20, 0x61, 0x72, 0x65, 0x20, 0x63, 0x6F, 0x6E, 0x73, 0x69, 0x64, 0x65, 0x72, 0x65, 
  0x64, 0x20, 0x20, 0x65, 0x71, 0x75, 0x61, 0x6C, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x79, 
  0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x69, 0x64, 0x65, 0x6E, 0x74, 0x69, 0x63, 0x61, 0x6C, 0x20, 
  0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x2E, 0x20, 0x4D, 0x75, 0x63, 0x68, 0x20, 
  0x73, 0x6C, 0x6F, 0x77, 0x65, 0x72, 0x20, 0x74, 0x68, 0x61, 0x6E, 0x20, 0x3D, 0x2E, 0xDA, 0x0B, 
  0xD2, 0x03, 0x00, 0xDA, 0x05, 0x87, 0x1E, 0x01, 0xDA, 0x85, 0xB3, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 
  0x85, 0xB4, 0xDA, 0x09, 0xCE, 0x53, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x72, 0x6E, 0x67, 0x2D, 
  0x73, 0x65, 0x65, 0x64, 0x20, 0x72, 0x6E, 0x67, 0x20, 0x73, 0x65, 0x65, 0x64, 0x29, 0x0A, 0x0A, 
  0x45, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x20, 0x61, 0x20, 0x72, 0x61, 0x6E, 0x64, 0x6F, 0x6D, 
  0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 
  0x61, 0x6E, 0x67, 0x65, 0x20, 0x5B, 0x30, 0x2C, 0x20, 0x31, 0x29, 0x20, 0x66, 0x72, 0x6F, 0x6D, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x52, 0x4E, 0x47, 0x2E, 0xDA, 0x85, 0xB5, 0xD3, 0x03, 0xDA, 0x03, 
  0xDA, 0x80, 0xEC, 0xDA, 0x09, 0xCE, 0x37, 0x28, 0x62, 0x61, 0x64, 0x2D, 0x70, 0x61, 0x72, 0x73, 
  0x65, 0x20, 0x70, 0x20, 0x77, 0x68, 0x65, 0x72, 0x65, 0x29, 0x0A, 0x0A, 0x44, 0x65, 0x66, 0x61, 
  0x75, 0x6C, 0x74, 0x20, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x72, 0x20, 0x66, 0x6F, 0x72, 0x20, 
  0x61, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x2E, 0xDA, 0x0B, 
  0xD2, 0x03, 0x00, 0xDA, 0x05, 0x87, 0xB4, 0x01, 0xDA, 0x85, 0xB6, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 
  0x50, 0xDA, 0x09, 0xCE, 0x35, 0x28, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2F, 0x63, 0x75, 0x72, 0x72, 
  0x65, 0x6E, 0x74, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x6C, 0x79, 0x20, 0x72, 0x75, 0x6E, 0x6E, 
  0x69, 0x6E, 0x67, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2E, 0xDA, 0x85, 0xB7, 0xD3, 0x02, 0xDA, 
  0x03, 0xDA, 0x80, 0x83, 0xDA, 0x09, 0xCE, 0x56, 0x28, 0x65, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x20, 
  0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x53, 0x61, 0x6D, 0x65, 0x20, 0x61, 0x73, 0x20, 0x70, 
  0x72, 0x69, 0x6E, 0x74, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x75, 0x73, 0x65, 0x73, 0x20, 0x28, 
  0x64, 0x79, 0x6E, 0x20, 0x3A, 0x65, 0x72, 0x72, 0x20, 0x73, 0x74, 0x64, 0x65, 0x72, 0x72, 0x29, 
  0x20, 0x69, 0x6E, 0x73, 0x74, 0x65, 0x61, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x28, 0x64, 0x79, 0x6E, 
  0x20, 0x3A, 0x6F, 0x75, 0x74, 0x20, 0x73, 0x74, 0x64, 0x6F, 0x75, 0x74, 0x29, 0x2E, 0xDA, 0x85, 
  0xB8, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x81, 0x63, 0xDA, 0x09, 0xCE, 0x4E, 0x28, 0x69, 0x64, 0x65, 
  0x6D, 0x70, 0x6F, 0x74, 0x65, 0x6E, 0x74, 0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 
  0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x76, 0x61, 0x6C, 
  0x75, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x65, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 
  0x73, 0x20, 0x74, 0x6F, 0x20, 0x69, 0x74, 0x73, 0x65, 0x6C, 0x66, 0x20, 0x77, 0x68, 0x65, 0x6E, 
  0x20, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x64, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 
  0x05, 0x75, 0x01, 0xDA, 0x85, 0xB9, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x80, 0xD8, 0xDA, 0x09, 0xCE, 
  0x81, 0xEF, 0x28, 0x66, 0x69, 0x6C, 0x65, 0x2F, 0x6F, 0x70, 0x65, 0x6E, 0x20, 0x70, 0x61, 0x74, 
  0x68, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x6D, 0x6F, 0x64, 0x65, 0x29, 0x0A, 0x0A, 0x4F, 0x70, 
  0x65, 0x6E, 0x20, 0x61, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x2E, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 
  0x69, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x62, 0x73, 0x6F, 0x6C, 0x75, 0x74, 0x65, 0x20, 0x6F, 
  0x72, 0x20, 0x72, 0x65, 0x6C, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x70, 0x61, 0x74, 0x68, 0x2C, 
  0x20, 0x61, 0x6E, 0x64, 0x20, 0x6D, 0x6F, 0x64, 0x65, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x73, 
  0x65, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x66, 0x6C, 0x61, 0x67, 0x73, 0x20, 0x69, 0x6E, 0x64, 0x69, 
  0x63, 0x61, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x6F, 0x64, 0x65, 0x20, 
  0x74, 0x6F, 0x20, 0x6F, 0x70, 0x65, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 
  0x20, 0x69, 0x6E, 0x2E, 0x20, 0x6D, 0x6F, 0x64, 0x65, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x6B, 
  0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 0x20, 0x77, 0x68, 0x65, 0x72, 0x65, 0x20, 0x65, 0x61, 0x63, 
  0x68, 0x20, 0x63, 0x68, 0x61, 0x72, 0x61, 0x63, 0x74, 0x65, 0x72, 0x20, 0x72, 0x65, 0x70, 0x72, 
  0x65, 0x73, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x61, 0x20, 0x66, 0x6C, 0x61, 0x67, 0x2E, 0x20, 0x49, 
  0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x63, 0x61, 0x6E, 0x6E, 0x6F, 
  0x74, 0x20, 0x62, 0x65, 0x20, 0x6F, 0x70, 0x65, 0x6E, 0x65, 0x64, 0x2C, 0x20, 0x72, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x2C, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x77, 
  0x69, 0x73, 0x65, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x6E, 0x65, 0x77, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x2E, 
  0x20, 0x4D, 0x6F, 0x64, 0x65, 0x20, 0x66, 0x6C, 0x61, 0x67, 0x73, 0x3A, 0x0A, 0x0A, 0x09, 0x72, 
  0x20, 0x2D, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x77, 0x20, 0x72, 0x65, 0x61, 0x64, 0x69, 0x6E, 0x67, 
  0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x0A, 0x09, 
  0x77, 0x20, 0x2D, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x77, 0x20, 0x77, 0x72, 0x69, 0x74, 0x69, 0x6E, 
  0x67, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x0A, 0x09, 0x61, 
  0x20, 0x2D, 0x20, 0x61, 0x70, 0x70, 0x65, 0x6E, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x66, 0x69, 0x6C, 0x65, 0x0A, 0x09, 0x62, 0x20, 0x2D, 0x20, 0x6F, 0x70, 0x65, 0x6E, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x62, 0x69, 0x6E, 0x61, 
  0x72, 0x79, 0x20, 0x6D, 0x6F, 0x64, 0x65, 0x20, 0x28, 0x72, 0x61, 0x74, 0x68, 0x65, 0x72, 0x20, 
  0x74, 0x68, 0x61, 0x6E, 0x20, 0x74, 0x65, 0x78, 0x74, 0x20, 0x6D, 0x6F, 0x64, 0x65, 0x29, 0x0A, 
  0x09, 0x2B, 0x20, 0x2D, 0x20, 0x61, 0x70, 0x70, 0x65, 0x6E, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x69, 0x6E, 0x73, 0x74, 0x65, 0x61, 0x64, 0x20, 
  0x6F, 0x66, 0x20, 0x6F, 0x76, 0x65, 0x72, 0x77, 0x72, 0x69, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x69, 
  0x74, 0xDA, 0x85, 0xBA, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x82, 0x18, 0xDA, 0x09, 0xCE, 0x81, 0x1D, 
  0x28, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x2F, 0x74, 0x79, 0x70, 0x65, 0x20, 0x74, 0x75, 0x70, 0x29, 
  0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x73, 0x20, 0x68, 0x6F, 0x77, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x20, 0x77, 0x61, 0x73, 0x20, 0x63, 0x6F, 0x6E, 0x73, 0x74, 
  0x72, 0x75, 0x63, 0x74, 0x65, 0x64, 0x2E, 0x20, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x72, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 0x20, 
  0x3A, 0x62, 0x72, 0x61, 0x63, 0x6B, 0x65, 0x74, 0x73, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x20, 0x77, 0x61, 0x73, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 
  0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x62, 0x72, 0x61, 0x63, 0x6B, 0x65, 0x74, 0x73, 0x2C, 
  0x20, 0x61, 0x6E, 0x64, 0x20, 0x3A, 0x70, 0x61, 0x72, 0x65, 0x6E, 0x73, 0x20, 0x6F, 0x74, 0x68, 
  0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x74, 0x77, 0x6F, 0x20, 
  0x74, 0x79, 0x70, 0x65, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x73, 0x20, 
  0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x68, 0x61, 0x76, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x73, 0x61, 0x6D, 0x65, 0x20, 0x6D, 0x6F, 0x73, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x74, 0x69, 0x6D, 0x65, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 
  0x70, 0x72, 0x69, 0x6E, 0x74, 0x20, 0x64, 0x69, 0x66, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x74, 0x6C, 
  0x79, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x62, 0x65, 0x20, 0x74, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 
  0x20, 0x64, 0x69, 0x66, 0x66, 0x65, 0x72, 0x65, 0x6E, 0x74, 0x6C, 0x79, 0x20, 0x62, 0x79, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x72, 0x2E, 0xDA, 0x85, 0xBB, 
  0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x85, 0xBC, 0xDA, 0x09, 0xCE, 0x80, 0xA8, 0x28, 0x74, 0x61, 0x72, 
  0x72, 0x61, 0x79, 0x2F, 0x63, 0x6F, 0x70, 0x79, 0x2D, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x73, 
  0x72, 0x63, 0x20, 0x73, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x64, 0x73, 0x74, 0x20, 0x64, 0x69, 
  0x6E, 0x64, 0x65, 0x78, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x63, 0x6F, 0x75, 0x6E, 0x74, 0x29, 
  0x0A, 0x0A, 0x43, 0x6F, 0x70, 0x79, 0x20, 0x63, 0x6F, 0x75, 0x6E, 0x74, 0x20, 0x65, 0x6C, 0x65, 
  0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x28, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x20, 0x31, 
  0x29, 0x20, 0x6F, 0x66, 0x20, 0x73, 0x72, 0x63, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x66, 
  0x72, 0x6F, 0x6D, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x73, 0x69, 0x6E, 0x64, 0x65, 0x78, 
  0x20, 0x74, 0x6F, 0x20, 0x64, 0x73, 0x74, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x61, 0x74, 
  0x20, 0x70, 0x6F, 0x73, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x64, 0x69, 0x6E, 0x64, 0x65, 0x78, 
  0x20, 0x6D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x6F, 0x76, 0x65, 0x72, 
  0x6C, 0x61, 0x70, 0x2E, 0xDA, 0x81, 0x92, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 0x85, 0xBE, 0xDA, 0x09, 
  0xCE, 0x22, 0x28, 0x2D, 0x2D, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x44, 0x65, 0x63, 0x72, 0x65, 0x6D, 
  0x65, 0x6E, 0x74, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x61, 0x72, 0x20, 0x78, 0x20, 0x62, 
  0x79, 0x20, 0x31, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x80, 0x84, 0x01, 0xDA, 0x35, 
  0xCB, 0xDA, 0x85, 0xBF, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x80, 0xF6, 0xDA, 0x09, 0xCE, 0x80, 0xFD, 
  0x28, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x70, 
  0x61, 0x72, 0x73, 0x65, 0x72, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x73, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 
  0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x20, 0x73, 0x74, 
  0x61, 0x74, 0x65, 0x20, 0x6D, 0x61, 0x63, 0x68, 0x69, 0x6E, 0x65, 0x2E, 0x20, 0x54, 0x68, 0x65, 
  0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 
  0x6F, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x3A, 0x0A, 0x0A, 0x09, 0x3A, 0x70, 0x65, 0x6E, 0x64, 0x69, 
  0x6E, 0x67, 0x20, 0x2D, 0x20, 0x61, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x69, 0x73, 0x20, 
  0x62, 0x65, 0x69, 0x6E, 0x67, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x64, 0x2E, 0x0A, 0x09, 0x3A, 
  0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x2D, 0x20, 0x61, 0x20, 0x70, 0x61, 0x72, 0x73, 0x69, 0x6E, 
  0x67, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x77, 0x61, 0x73, 0x20, 0x65, 0x6E, 0x63, 0x6F, 
  0x75, 0x6E, 0x74, 0x65, 0x72, 0x65, 0x64, 0x2E, 0x0A, 0x09, 0x3A, 0x72, 0x6F, 0x6F, 0x74, 0x20, 
  0x2D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x20, 0x63, 0x61, 0x6E, 
  0x20, 0x65, 0x69, 0x74, 0x68, 0x65, 0x72, 0x20, 0x72, 0x65, 0x61, 0x64, 0x20, 0x6D, 0x6F, 0x72, 
  0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x6F, 0x72, 0x20, 0x73, 0x61, 0x66, 0x65, 
  0x6C, 0x79, 0x20, 0x74, 0x65, 0x72, 0x6D, 0x69, 0x6E, 0x61, 0x74, 0x65, 0x2E, 0xDA, 0x85, 0xC0, 
  0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x85, 0xC1, 0xDA, 0x09, 0xCE, 0x55, 0x28, 0x6D, 0x61, 0x74, 0x68, 
  0x2F, 0x6C, 0x6F, 0x67, 0x31, 0x70, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x73, 0x20, 0x28, 0x6C, 0x6F, 0x67, 0x20, 0x62, 0x61, 0x73, 0x65, 0x20, 0x65, 0x20, 0x6F, 
  0x66, 0x20, 0x78, 0x29, 0x20, 0x2B, 0x20, 0x31, 0x20, 0x6D, 0x6F, 0x72, 0x65, 0x20, 0x61, 0x63, 
  0x63, 0x75, 0x72, 0x61, 0x74, 0x65, 0x6C, 0x79, 0x20, 0x74, 0x68, 0x61, 0x6E, 0x20, 0x28, 0x2B, 
  0x20, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x6C, 0x6F, 0x67, 0x20, 0x78, 0x29, 0x20, 0x31, 0x29, 
  0xDA, 0x85, 0xC2, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x85, 0xC3, 0xDA, 0x09, 0xCE, 0x1C, 0x54, 0x68, 
  0x65, 0x20, 0x62, 0x61, 0x73, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x61, 
  0x74, 0x75, 0x72, 0x61, 0x6C, 0x20, 0x6C, 0x6F, 0x67, 0x2E, 0xDA, 0x85, 0xC4, 0xD3, 0x03, 0xDA, 
  0x03, 0xDA, 0x85, 0xC5, 0xDA, 0x09, 0xCE, 0x80, 0x8B, 0x54, 0x68, 0x65, 0x20, 0x64, 0x65, 0x66, 
  0x61, 0x75, 0x6C, 0x74, 0x20, 0x67, 0x72, 0x61, 0x6D, 0x6D, 0x61, 0x72, 0x20, 0x75, 0x73, 0x65, 
  0x64, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x70, 0x65, 0x67, 0x73, 0x2E, 0x20, 0x54, 0x68, 0x69, 0x73, 
  0x20, 0x67, 0x72, 0x61, 0x6D, 0x6D, 0x61, 0x72, 0x20, 0x64, 0x65, 0x66, 0x69, 0x6E, 0x65, 0x73, 
  0x20, 0x73, 0x65, 0x76, 0x65, 0x72, 0x61, 0x6C, 0x20, 0x63, 0x6F, 0x6D, 0x6D, 0x6F, 0x6E, 0x20, 
  0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6E, 0x73, 0x20, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x73, 
  0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x6D, 0x61, 0x6B, 0x65, 0x20, 0x69, 0x74, 0x20, 0x65, 0x61, 
  0x73, 0x69, 0x65, 0x72, 0x20, 0x74, 0x6F, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x20, 0x6D, 0x6F, 
  0x72, 0x65, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x6C, 0x65, 0x78, 0x20, 0x70, 0x61, 0x74, 0x74, 0x65, 
  0x72, 0x6E, 0x73, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x87, 0x8C, 0x01, 0xDA, 0x85, 
  0xEB, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x81, 0xD9, 0xDA, 0x09, 0xCE, 0x80, 0x91, 0x28, 0x66, 0x6C, 
  0x61, 0x74, 0x74, 0x65, 0x6E, 0x2D, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 
  0x78, 0x73, 0x29, 0x0A, 0x0A, 0x54, 0x61, 0x6B, 0x65, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x73, 
  0x74, 0x65, 0x64, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x28, 0x74, 0x72, 0x65, 0x65, 0x29, 
  0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x61, 0x70, 0x70, 0x65, 0x6E, 0x64, 0x73, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x64, 0x65, 0x70, 0x74, 0x68, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x74, 0x72, 
  0x61, 0x76, 0x65, 0x72, 0x73, 0x61, 0x6C, 0x20, 0x6F, 0x66, 0x20, 0x20, 0x74, 0x68, 0x61, 0x74, 
  0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 
  0x61, 0x79, 0x20, 0x27, 0x69, 0x6E, 0x74, 0x6F, 0x27, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x73, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x2E, 0xDA, 0x0B, 
  0xD2, 0x03, 0x00, 0xDA, 0x05, 0x85, 0x56, 0x01, 0xDA, 0x85, 0xEC, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 
  0x85, 0xEE, 0xDA, 0x09, 0xCE, 0x41, 0x28, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x78, 0x73, 0x29, 
  0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 
  0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x61, 0x6E, 0x20, 
  0x69, 0x6E, 0x64, 0x65, 0x78, 0x65, 0x64, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 
  0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x82, 0x94, 
  0x01, 0xDA, 0x85, 0xEF, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x82, 0x2D, 0xDA, 0x09, 0xCE, 0x80, 0x96, 
  0x28, 0x64, 0x65, 0x65, 0x70, 0x2D, 0x6E, 0x6F, 0x74, 0x3D, 0x20, 0x78, 0x20, 0x79, 0x29, 0x0A, 
  0x0A, 0x4C, 0x69, 0x6B, 0x65, 0x20, 0x6E, 0x6F, 0x74, 0x3D, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 
  0x6D, 0x75, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x74, 0x79, 0x70, 0x65, 0x73, 0x20, 0x28, 0x61, 
  0x72, 0x72, 0x61, 0x79, 0x73, 0x2C, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x73, 0x2C, 0x20, 0x62, 
  0x75, 0x66, 0x66, 0x65, 0x72, 0x73, 0x29, 0x20, 0x61, 0x72, 0x65, 0x20, 0x63, 0x6F, 0x6E, 0x73, 
  0x69, 0x64, 0x65, 0x72, 0x65, 0x64, 0x20, 0x20, 0x65, 0x71, 0x75, 0x61, 0x6C, 0x20, 0x69, 0x66, 
  0x20, 0x74, 0x68, 0x65, 0x79, 0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x69, 0x64, 0x65, 0x6E, 0x74, 
  0x69, 0x63, 0x61, 0x6C, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x2E, 0x20, 
  0x4D, 0x75, 0x63, 0x68, 0x20, 0x73, 0x6C, 0x6F, 0x77, 0x65, 0x72, 0x20, 0x74, 0x68, 0x61, 0x6E, 
  0x20, 0x6E, 0x6F, 0x74, 0x3D, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x87, 0x0F, 0x01, 
  0xDA, 0x85, 0xF0, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x85, 0xF1, 0xDA, 0x09, 0xCE, 0x2A, 0x28, 0x6D, 
  0x61, 0x74, 0x68, 0x2F, 0x63, 0x62, 0x72, 0x74, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x62, 0x65, 0x20, 0x72, 0x6F, 
  0x6F, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x2E, 0xDA, 0x85, 0xF2, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 
  0x83, 0xFA, 0xDA, 0x09, 0xCE, 0x80, 0xD3, 0x28, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 0x66, 0x62, 
  0x72, 0x65, 0x61, 0x6B, 0x20, 0x66, 0x75, 0x6E, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x70, 0x63, 
  0x29, 0x0A, 0x0A, 0x53, 0x65, 0x74, 0x20, 0x61, 0x20, 0x62, 0x72, 0x65, 0x61, 0x6B, 0x70, 0x6F, 
  0x69, 0x6E, 0x74, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x66, 
  0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0x20, 0x70, 0x63, 0x20, 0x69, 0x73, 0x20, 0x61, 
  0x6E, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x20, 0x6F, 0x66, 0x66, 0x73, 0x65, 
  0x74, 0x2C, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x69, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x62, 
  0x79, 0x74, 0x65, 0x63, 0x6F, 0x64, 0x65, 0x20, 0x69, 0x6E, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 
  0x69, 0x6F, 0x6E, 0x73, 0x2E, 0x20, 0x66, 0x75, 0x6E, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x66, 
  0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2E, 0x20, 0x57, 
  0x69, 0x6C, 0x6C, 0x20, 0x74, 0x68, 0x72, 0x6F, 0x77, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x72, 0x72, 
  0x6F, 0x72, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6F, 0x66, 0x66, 0x73, 0x65, 0x74, 
  0x20, 0x69, 0x73, 0x20, 0x74, 0x6F, 0x6F, 0x20, 0x6C, 0x61, 0x72, 0x67, 0x65, 0x20, 0x6F, 0x72, 
  0x20, 0x6E, 0x65, 0x67, 0x61, 0x74, 0x69, 0x76, 0x65, 0x2E, 0xDA, 0x85, 0xF3, 0xD3, 0x02, 0xDA, 
  0x03, 0xDA, 0x85, 0xF4, 0xDA, 0x09, 0xCE, 0x7E, 0x28, 0x6F, 0x73, 0x2F, 0x63, 0x72, 0x79, 0x70, 
  0x74, 0x6F, 0x72, 0x61, 0x6E, 0x64, 0x20, 0x6E, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x62, 0x75, 
  0x66, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 0x6F, 0x72, 0x20, 0x61, 0x70, 0x70, 0x65, 0x6E, 
  0x64, 0x20, 0x6E, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x67, 0x6F, 0x6F, 
  0x64, 0x20, 0x71, 0x75, 0x61, 0x6C, 0x69, 0x74, 0x79, 0x20, 0x72, 0x61, 0x6E, 0x64, 0x6F, 0x6D, 
  0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x70, 0x72, 0x6F, 0x76, 0x69, 0x64, 0x65, 0x64, 0x20, 0x62, 
  0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x4F, 0x53, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 
  0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x6F, 
  0x72, 0x20, 0x62, 0x75, 0x66, 0x2E, 0xDA, 0x44, 0xD3, 0x02, 0xDA, 0x03, 0x01, 0xDA, 0x09, 0xCE, 
  0x7E, 0x54, 0x68, 0x65, 0x20, 0x66, 0x6C, 0x61, 0x67, 0x20, 0x73, 0x65, 0x74, 0x20, 0x6F, 0x66, 
  0x20, 0x63, 0x6F, 0x6E, 0x66, 0x69, 0x67, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x20, 
  0x66, 0x72, 0x6F, 0x6D, 0x20, 0x6A, 0x61, 0x6E, 0x65, 0x74, 0x63, 0x6F, 0x6E, 0x66, 0x2E, 0x68, 
  0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x69, 0x73, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x74, 
  0x6F, 0x20, 0x63, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x6E, 0x61, 0x74, 0x69, 0x76, 
  0x65, 0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x63, 0x6F, 
  0x6D, 0x70, 0x61, 0x74, 0x69, 0x62, 0x6C, 0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x68, 0x6F, 0x73, 0x74, 0x20, 0x70, 0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x2E, 0xDA, 
  0x85, 0xF5, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x85, 0xF6, 0xDA, 0x09, 0xCE, 0x80, 0xF2, 0x28, 0x70, 
  0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x69, 0x6E, 0x73, 0x65, 0x72, 0x74, 0x20, 0x70, 0x61, 0x72, 
  0x73, 0x65, 0x72, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x29, 0x0A, 0x0A, 0x49, 0x6E, 0x73, 0x65, 
  0x72, 0x74, 0x20, 0x61, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2E, 0x20, 0x54, 0x68, 0x69, 0x73, 
  0x20, 0x6D, 0x65, 0x61, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x20, 0x63, 0x61, 0x6E, 
  0x20, 0x62, 0x65, 0x20, 0x6D, 0x61, 0x6E, 0x69, 0x70, 0x75, 0x6C, 0x61, 0x74, 0x65, 0x64, 0x20, 
  0x69, 0x6E, 0x20, 0x62, 0x65, 0x74, 0x77, 0x65, 0x65, 0x6E, 0x20, 0x63, 0x68, 0x75, 0x6E, 0x6B, 
  0x73, 0x20, 0x6F, 0x66, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x2E, 0x20, 0x54, 0x68, 0x69, 0x73, 
  0x20, 0x77, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x77, 0x20, 0x61, 0x20, 0x75, 
  0x73, 0x65, 0x72, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x64, 0x64, 0x20, 0x65, 0x78, 0x74, 0x72, 0x61, 
  0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x72, 0x72, 
  0x61, 0x79, 0x73, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x73, 0x2C, 0x20, 
  0x66, 0x6F, 0x72, 0x20, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x2E, 0x20, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2E, 
  0xDA, 0x85, 0xF7, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x85, 0xF8, 0xDA, 0x09, 0xCE, 0x81, 0x10, 0x28, 
  0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 0x62, 0x72, 0x65, 0x61, 0x6B, 0x20, 0x73, 0x6F, 0x75, 0x72, 
  0x63, 0x65, 0x20, 0x62, 0x79, 0x74, 0x65, 0x2D, 0x6F, 0x66, 0x66, 0x73, 0x65, 0x74, 0x29, 0x0A, 
  0x0A, 0x53, 0x65, 0x74, 0x73, 0x20, 0x61, 0x20, 0x62, 0x72, 0x65, 0x61, 0x6B, 0x70, 0x6F, 0x69, 
  0x6E, 0x74, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x20, 0x61, 
  0x20, 0x6B, 0x65, 0x79, 0x20, 0x61, 0x74, 0x20, 0x61, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 
  0x6C, 0x69, 0x6E, 0x65, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x63, 0x6F, 0x6C, 0x75, 0x6D, 0x6E, 0x2E, 
  0x20, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x74, 0x68, 0x72, 0x6F, 0x77, 0x20, 0x61, 0x6E, 0x20, 0x65, 
  0x72, 0x72, 0x6F, 0x72, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x72, 0x65, 0x61, 
  0x6B, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x20, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 
  0x63, 0x61, 0x6E, 0x6E, 0x6F, 0x74, 0x20, 0x62, 0x65, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x2E, 
  0x20, 0x46, 0x6F, 0x72, 0x20, 0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65, 0x0A, 0x0A, 0x09, 0x28, 
  0x64, 0x65, 0x62, 0x75, 0x67, 0x2F, 0x62, 0x72, 0x65, 0x61, 0x6B, 0x20, 0x22, 0x63, 0x6F, 0x72, 
  0x65, 0x2E, 0x6A, 0x61, 0x6E, 0x65, 0x74, 0x22, 0x20, 0x31, 0x30, 0x30, 0x30, 0x29, 0x0A, 0x0A, 
  0x77, 0x69, 0x6C, 0x20, 0x73, 0x65, 0x74, 0x20, 0x61, 0x20, 0x62, 0x72, 0x65, 0x61, 0x6B, 0x70, 
  0x6F, 0x69, 0x6E, 0x74, 0x20, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x31, 0x30, 0x30, 0x30, 
  0x74, 0x68, 0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 
  0x69, 0x6C, 0x65, 0x20, 0x63, 0x6F, 0x72, 0x65, 0x2E, 0x6A, 0x61, 0x6E, 0x65, 0x74, 0x2E, 0xDA, 
  0x85, 0xF9, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x85, 0xFC, 0xDA, 0x09, 0xCE, 0x27, 0x28, 0x63, 0x66, 
  0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 
  0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x61, 0x20, 0x63, 0x66, 0x75, 0x6E, 0x63, 0x74, 
  0x69, 0x6F, 0x6E, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x60, 0x01, 0xDA, 0x85, 0xFD, 
  0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x85, 0xFE, 0xDA, 0x09, 0xCE, 0x82, 0x6E, 0x28, 0x6F, 0x73, 0x2F, 
  0x64, 0x61, 0x74, 0x65, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x20, 0x6C, 
  0x6F, 0x63, 0x61, 0x6C, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x20, 0x61, 0x73, 
  0x20, 0x61, 0x20, 0x64, 0x61, 0x74, 0x65, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x2C, 0x20, 
  0x6F, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x74, 
  0x69, 0x6D, 0x65, 0x20, 0x69, 0x66, 0x20, 0x6E, 0x6F, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x20, 0x69, 
  0x73, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x66, 
  0x6F, 0x6C, 0x6C, 0x6F, 0x77, 0x69, 0x6E, 0x67, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x76, 0x61, 0x6C, 
  0x75, 0x65, 0x73, 0x2E, 0x20, 0x4E, 0x6F, 0x74, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x61, 
  0x6C, 0x6C, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x30, 
  0x2D, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x65, 0x64, 0x2E, 0x20, 0x44, 0x61, 0x74, 0x65, 0x20, 0x69, 
  0x73, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x69, 0x6E, 0x20, 0x55, 0x54, 0x43, 0x20, 0x75, 
  0x6E, 0x6C, 0x65, 0x73, 0x73, 0x20, 0x6C, 0x6F, 0x63, 0x61, 0x6C, 0x20, 0x69, 0x73, 0x20, 0x74, 
  0x72, 0x75, 0x74, 0x68, 0x79, 0x2C, 0x20, 0x69, 0x6E, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 
  0x63, 0x61, 0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x61, 0x74, 0x65, 0x20, 0x69, 0x73, 
  0x20, 0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x74, 0x65, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x6C, 0x6F, 0x63, 0x61, 0x6C, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x7A, 0x6F, 0x6E, 
  0x65, 0x2E, 0x0A, 0x0A, 0x09, 0x3A, 0x73, 0x65, 0x63, 0x6F, 0x6E, 0x64, 0x73, 0x20, 0x2D, 0x20, 
  0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x73, 0x65, 0x63, 0x6F, 0x6E, 0x64, 
  0x73, 0x20, 0x5B, 0x30, 0x2D, 0x36, 0x31, 0x5D, 0x0A, 0x09, 0x3A, 0x6D, 0x69, 0x6E, 0x75, 0x74, 
  0x65, 0x73, 0x20, 0x2D, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x6D, 
  0x69, 0x6E, 0x75, 0x74, 0x65, 0x73, 0x20, 0x5B, 0x30, 0x2D, 0x35, 0x39, 0x5D, 0x0A, 0x09, 0x3A, 
  0x68, 0x6F, 0x75, 0x72, 0x73, 0x20, 0x2D, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 
  0x66, 0x20, 0x68, 0x6F, 0x75, 0x72, 0x73, 0x20, 0x5B, 0x30, 0x2D, 0x32, 0x33, 0x5D, 0x0A, 0x09, 
  0x3A, 0x6D, 0x6F, 0x6E, 0x74, 0x68, 0x2D, 0x64, 0x61, 0x79, 0x20, 0x2D, 0x20, 0x64, 0x61, 0x79, 
  0x20, 0x6F, 0x66, 0x20, 0x6D, 0x6F, 0x6E, 0x74, 0x68, 0x20, 0x5B, 0x30, 0x2D, 0x33, 0x30, 0x5D, 
  0x0A, 0x09, 0x3A, 0x6D, 0x6F, 0x6E, 0x74, 0x68, 0x20, 0x2D, 0x20, 0x6D, 0x6F, 0x6E, 0x74, 0x68, 
  0x20, 0x6F, 0x66, 0x20, 0x79, 0x65, 0x61, 0x72, 0x20, 0x5B, 0x30, 0x2C, 0x20, 0x31, 0x31, 0x5D, 
  0x0A, 0x09, 0x3A, 0x79, 0x65, 0x61, 0x72, 0x20, 0x2D, 0x20, 0x79, 0x65, 0x61, 0x72, 0x73, 0x20, 
  0x73, 0x69, 0x6E, 0x63, 0x65, 0x20, 0x79, 0x65, 0x61, 0x72, 0x20, 0x30, 0x20, 0x28, 0x65, 0x2E, 
  0x67, 0x2E, 0x20, 0x32, 0x30, 0x31, 0x39, 0x29, 0x0A, 0x09, 0x3A, 0x77, 0x65, 0x65, 0x6B, 0x2D, 
  0x64, 0x61, 0x79, 0x20, 0x2D, 0x20, 0x64, 0x61, 0x79, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x77, 0x65, 0x65, 0x6B, 0x20, 0x5B, 0x30, 0x2D, 0x36, 0x5D, 0x0A, 0x09, 0x3A, 0x79, 0x65, 
  0x61, 0x72, 0x2D, 0x64, 0x61, 0x79, 0x20, 0x2D, 0x20, 0x64, 0x61, 0x79, 0x20, 0x6F, 0x66, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x79, 0x65, 0x61, 0x72, 0x20, 0x5B, 0x30, 0x2D, 0x33, 0x36, 0x35, 0x5D, 
  0x0A, 0x09, 0x3A, 0x64, 0x73, 0x74, 0x20, 0x2D, 0x20, 0x49, 0x66, 0x20, 0x44, 0x61, 0x79, 0x20, 
  0x4C, 0x69, 0x67, 0x68, 0x74, 0x20, 0x53, 0x61, 0x76, 0x69, 0x6E, 0x67, 0x73, 0x20, 0x69, 0x73, 
  0x20, 0x69, 0x6E, 0x20, 0x65, 0x66, 0x66, 0x65, 0x63, 0x74, 0xDA, 0x85, 0xFF, 0xD3, 0x04, 0xDA, 
  0x03, 0xDA, 0x86, 0x04, 0xDA, 0x09, 0xCE, 0x80, 0x8B, 0x28, 0x77, 0x69, 0x74, 0x68, 0x2D, 0x76, 
  0x61, 0x72, 0x73, 0x20, 0x76, 0x61, 0x72, 0x73, 0x20, 0x26, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x29, 
  0x0A, 0x0A, 0x45, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0x73, 0x20, 0x62, 0x6F, 0x64, 0x79, 
  0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x65, 0x61, 0x63, 0x68, 0x20, 0x76, 0x61, 0x72, 0x20, 0x69, 
  0x6E, 0x20, 0x76, 0x61, 0x72, 0x73, 0x20, 0x74, 0x65, 0x6D, 0x70, 0x6F, 0x72, 0x61, 0x72, 0x69, 
  0x6C, 0x79, 0x20, 0x62, 0x6F, 0x75, 0x6E, 0x64, 0x2E, 0x20, 0x53, 0x69, 0x6D, 0x69, 0x6C, 0x61, 
  0x72, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x74, 0x75, 0x72, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x20, 
  0x6C, 0x65, 0x74, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x65, 0x61, 0x63, 0x68, 0x20, 0x62, 0x69, 
  0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x6D, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x61, 0x20, 
  0x76, 0x61, 0x72, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x84, 0x87, 0x01, 0xDA, 0x35, 
  0xCB, 0xDA, 0x86, 0x05, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x84, 0x3D, 0xDA, 0x09, 0xCE, 0x65, 0x28, 
  0x73, 0x70, 0x69, 0x74, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 
  0x74, 0x73, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x6D, 0x6F, 0x64, 0x65, 0x29, 0x0A, 0x0A, 0x57, 
  0x72, 0x69, 0x74, 0x65, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x74, 0x6F, 
  0x20, 0x61, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x61, 0x74, 0x20, 0x70, 0x61, 0x74, 0x68, 0x2E, 
  0x20, 0x20, 0x43, 0x61, 0x6E, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x6C, 0x79, 
  0x20, 0x61, 0x70, 0x70, 0x65, 0x6E, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 
  0x69, 0x6C, 0x65, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x85, 0x9A, 0x01, 0xDA, 0x86, 
  0x06, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x83, 0x96, 0xDA, 0x09, 0xCE, 0x47, 0x28, 0x66, 0x6C, 0x75, 
  0x73, 0x68, 0x29, 0x0A, 0x0A, 0x46, 0x6C, 0x75, 0x73, 0x68, 0x20, 0x28, 0x64, 0x79, 0x6E, 0x20, 
  0x3A, 0x6F, 0x75, 0x74, 0x20, 0x73, 0x74, 0x64, 0x6F, 0x75, 0x74, 0x29, 0x20, 0x69, 0x66, 0x20, 
  0x69, 0x74, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x2C, 0x20, 0x6F, 0x74, 
  0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x20, 0x64, 0x6F, 0x20, 0x6E, 0x6F, 0x74, 0x68, 0x69, 
  0x6E, 0x67, 0x2E, 0xDA, 0x86, 0x07, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 0x86, 0x09, 0xDA, 0x09, 0xCE, 
  0x24, 0x28, 0x2B, 0x3D, 0x20, 0x78, 0x20, 0x6E, 0x29, 0x0A, 0x0A, 0x49, 0x6E, 0x63, 0x72, 0x65, 
  0x6D, 0x65, 0x6E, 0x74, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x61, 0x72, 0x20, 0x78, 0x20, 
  0x62, 0x79, 0x20, 0x6E, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x80, 0x85, 0x01, 0xDA, 
  0x35, 0xCB, 0xDA, 0x86, 0x0A, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x86, 0x0B, 0xDA, 0x09, 0xCE, 0x80, 
  0xFA, 0x28, 0x70, 0x65, 0x67, 0x2F, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x20, 0x70, 0x65, 0x67, 0x20, 
  0x74, 0x65, 0x78, 0x74, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 
  0x26, 0x20, 0x61, 0x72, 0x67, 0x73, 0x29, 0x0A, 0x0A, 0x4D, 0x61, 0x74, 0x63, 0x68, 0x20, 0x61, 
  0x20, 0x50, 0x61, 0x72, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x45, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 
  0x69, 0x6F, 0x6E, 0x20, 0x47, 0x72, 0x61, 0x6D, 0x6D, 0x61, 0x72, 0x20, 0x74, 0x6F, 0x20, 0x61, 
  0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x6E, 0x64, 
  0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 
  0x20, 0x6F, 0x66, 0x20, 0x63, 0x61, 0x70, 0x74, 0x75, 0x72, 0x65, 0x64, 0x20, 0x76, 0x61, 0x6C, 
  0x75, 0x65, 0x73, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 
  0x20, 0x69, 0x66, 0x20, 0x74, 0x65, 0x78, 0x74, 0x20, 0x64, 0x6F, 0x65, 0x73, 0x20, 0x6E, 0x6F, 
  0x74, 0x20, 0x6D, 0x61, 0x74, 0x63, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x61, 0x6E, 0x67, 
  0x75, 0x61, 0x67, 0x65, 0x20, 0x64, 0x65, 0x66, 0x69, 0x6E, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 
  0x70, 0x65, 0x67, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x73, 0x79, 0x6E, 0x74, 0x61, 0x78, 0x20, 
  0x6F, 0x66, 0x20, 0x50, 0x45, 0x47, 0x73, 0x20, 0x69, 0x73, 0x20, 0x64, 0x6F, 0x63, 0x75, 0x6D, 
  0x65, 0x6E, 0x74, 0x65, 0x64, 0x20, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x4A, 0x61, 0x6E, 
  0x65, 0x74, 0x20, 0x77, 0x65, 0x62, 0x73, 0x69, 0x74, 0x65, 0x2E, 0xDA, 0x86, 0x0C, 0xD3, 0x02, 
  0xDA, 0x03, 0xDA, 0x86, 0x0E, 0xDA, 0x09, 0xCE, 0x5B, 0x28, 0x62, 0x61, 0x6E, 0x64, 0x20, 0x26, 
  0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x62, 0x69, 0x74, 0x2D, 0x77, 0x69, 0x73, 0x65, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x6F, 
  0x66, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x20, 
  0x78, 0x73, 0x2E, 0x20, 0x45, 0x61, 0x63, 0x68, 0x20, 0x78, 0x20, 0x69, 0x6E, 0x20, 0x78, 0x73, 
  0x20, 0x6D, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x74, 0x65, 
  0x67, 0x65, 0x72, 0x2E, 0xDA, 0x86, 0x0F, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x80, 0xF1, 0xDA, 0x09, 
  0xCE, 0x80, 0xE3, 0x28, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x2F, 0x66, 0x6C, 0x75, 0x73, 0x68, 
  0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x29, 0x0A, 0x0A, 0x43, 0x6C, 0x65, 0x61, 0x72, 0x73, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x20, 0x73, 0x74, 0x61, 0x74, 
  0x65, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x20, 0x71, 0x75, 0x65, 0x75, 
  0x65, 0x2E, 0x20, 0x43, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x74, 
  0x6F, 0x20, 0x72, 0x65, 0x73, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 
  0x65, 0x72, 0x20, 0x69, 0x66, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x77, 
  0x61, 0x73, 0x20, 0x65, 0x6E, 0x63, 0x6F, 0x75, 0x6E, 0x74, 0x65, 0x72, 0x65, 0x64, 0x2E, 0x20, 
  0x44, 0x6F, 0x65, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x72, 0x65, 0x73, 0x65, 0x74, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x6C, 0x69, 0x6E, 0x65, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x63, 0x6F, 0x6C, 0x75, 
  0x6D, 0x6E, 0x20, 0x63, 0x6F, 0x75, 0x6E, 0x74, 0x65, 0x72, 0x2C, 0x20, 0x73, 0x6F, 0x20, 0x74, 
  0x6F, 0x20, 0x62, 0x65, 0x67, 0x69, 0x6E, 0x20, 0x70, 0x61, 0x72, 0x73, 0x69, 0x6E, 0x67, 0x20, 
  0x69, 0x6E, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 
  0x2C, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x70, 
  0x61, 0x72, 0x73, 0x65, 0x72, 0x2E, 0xDA, 0x86, 0x10, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x86, 0x11, 
  0xDA, 0x09, 0xCE, 0x81, 0x08, 0x28, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2F, 0x6D, 0x61, 0x78, 0x73, 
  0x74, 0x61, 0x63, 0x6B, 0x20, 0x66, 0x69, 0x62, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x73, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x6D, 0x61, 0x78, 0x69, 0x6D, 0x75, 0x6D, 0x20, 0x73, 0x74, 0x61, 0x63, 
  0x6B, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x6A, 0x61, 0x6E, 0x65, 0x74, 0x20, 
  0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x77, 0x65, 0x64, 0x20, 0x66, 
  0x6F, 0x72, 0x20, 0x61, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2E, 0x20, 0x57, 0x68, 0x69, 0x6C, 
  0x65, 0x20, 0x6D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x27, 0x73, 0x20, 0x73, 0x74, 0x61, 0x63, 0x6B, 0x20, 0x69, 
  0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x64, 0x20, 
  0x75, 0x70, 0x20, 0x66, 0x72, 0x6F, 0x6E, 0x74, 0x2C, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 
  0x62, 0x65, 0x72, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x61, 0x6C, 0x6C, 
  0x6F, 0x63, 0x61, 0x74, 0x65, 0x64, 0x20, 0x6D, 0x6F, 0x72, 0x65, 0x20, 0x74, 0x68, 0x61, 0x6E, 
  0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x61, 0x6D, 0x6F, 0x75, 0x6E, 0x74, 0x20, 0x61, 0x6E, 0x64, 
  0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x74, 0x68, 0x72, 0x6F, 0x77, 0x20, 0x61, 0x20, 0x73, 0x74, 
  0x61, 0x63, 0x6B, 0x2D, 0x6F, 0x76, 0x65, 0x72, 0x66, 0x6C, 0x6F, 0x77, 0x20, 0x65, 0x72, 0x72, 
  0x6F, 0x72, 0x20, 0x69, 0x66, 0x20, 0x6D, 0x6F, 0x72, 0x65, 0x20, 0x6D, 0x65, 0x6D, 0x6F, 0x72, 
  0x79, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x65, 0x65, 0x64, 0x65, 0x64, 0x2E, 0x20, 0xDA, 0x86, 0x12, 
  0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x80, 0xBC, 0xDA, 0x09, 0xCE, 0x83, 0x96, 0x28, 0x6F, 0x73, 0x2F, 
  0x73, 0x74, 0x61, 0x74, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x74, 
  0x61, 0x62, 0x7C, 0x6B, 0x65, 0x79, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x73, 0x20, 0x69, 0x6E, 
  0x66, 0x6F, 0x72, 0x6D, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x61, 0x62, 0x6F, 0x75, 0x74, 0x20, 
  0x61, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x6F, 0x72, 0x20, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 
  0x6F, 0x72, 0x79, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x74, 
  0x61, 0x62, 0x6C, 0x65, 0x20, 0x49, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x68, 0x69, 0x72, 
  0x64, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 
  0x6B, 0x65, 0x79, 0x77, 0x6F, 0x72, 0x64, 0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x20, 0x6F, 0x6E, 0x6C, 0x79, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x6E, 0x66, 0x6F, 
  0x72, 0x6D, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x73, 0x74, 0x61, 
  0x74, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x6F, 
  0x72, 0x20, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6F, 0x72, 0x79, 0x20, 0x64, 0x6F, 0x65, 0x73, 
  0x20, 0x6E, 0x6F, 0x74, 0x20, 0x65, 0x78, 0x69, 0x73, 0x74, 0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x6B, 0x65, 0x79, 
  0x73, 0x20, 0x61, 0x72, 0x65, 0x0A, 0x0A, 0x09, 0x3A, 0x64, 0x65, 0x76, 0x20, 0x2D, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x69, 0x73, 0x20, 0x6F, 0x6E, 0x0A, 0x09, 0x3A, 
  0x6D, 0x6F, 0x64, 0x65, 0x20, 0x2D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x79, 0x70, 0x65, 0x20, 
  0x6F, 0x66, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x2C, 0x20, 0x6F, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x20, 
  0x3A, 0x66, 0x69, 0x6C, 0x65, 0x2C, 0x20, 0x3A, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6F, 0x72, 
  0x79, 0x2C, 0x20, 0x3A, 0x62, 0x6C, 0x6F, 0x63, 0x6B, 0x2C, 0x20, 0x3A, 0x63, 0x68, 0x61, 0x72, 
  0x61, 0x63, 0x74, 0x65, 0x72, 0x2C, 0x20, 0x3A, 0x66, 0x69, 0x66, 0x6F, 0x2C, 0x20, 0x3A, 0x73, 
  0x6F, 0x63, 0x6B, 0x65, 0x74, 0x2C, 0x20, 0x3A, 0x6C, 0x69, 0x6E, 0x6B, 0x2C, 0x20, 0x6F, 0x72, 
  0x20, 0x3A, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x0A, 0x09, 0x3A, 0x69, 0x6E, 0x74, 0x2D, 0x70, 0x65, 
  0x72, 0x6D, 0x69, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x73, 0x20, 0x2D, 0x20, 0x41, 0x20, 0x55, 0x6E, 
  0x69, 0x78, 0x20, 0x70, 0x65, 0x72, 0x6D, 0x69, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x69, 0x6E, 
  0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x6C, 0x69, 0x6B, 0x65, 0x20, 0x38, 0x72, 0x37, 0x34, 0x34, 
  0x0A, 0x09, 0x3A, 0x70, 0x65, 0x72, 0x6D, 0x69, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x73, 0x20, 0x2D, 
  0x20, 0x41, 0x20, 0x55, 0x6E, 0x69, 0x78, 0x20, 0x70, 0x65, 0x72, 0x6D, 0x69, 0x73, 0x73, 0x69, 
  0x6F, 0x6E, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x6C, 0x69, 0x6B, 0x65, 0x20, 0x22, 
  0x72, 0x77, 0x78, 0x72, 0x2D, 0x2D, 0x72, 0x2D, 0x2D, 0x22, 0x0A, 0x09, 0x3A, 0x75, 0x69, 0x64, 
  0x20, 0x2D, 0x20, 0x46, 0x69, 0x6C, 0x65, 0x20, 0x75, 0x69, 0x64, 0x0A, 0x09, 0x3A, 0x67, 0x69, 
  0x64, 0x20, 0x2D, 0x20, 0x46, 0x69, 0x6C, 0x65, 0x20, 0x67, 0x69, 0x64, 0x0A, 0x09, 0x3A, 0x6E, 
  0x6C, 0x69, 0x6E, 0x6B, 0x20, 0x2D, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 
  0x20, 0x6C, 0x69, 0x6E, 0x6B, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x0A, 0x09, 
  0x3A, 0x72, 0x64, 0x65, 0x76, 0x20, 0x2D, 0x20, 0x52, 0x65, 0x61, 0x6C, 0x20, 0x64, 0x65, 0x76, 
  0x69, 0x63, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x2E, 0x20, 0x30, 0x20, 0x6F, 
  0x6E, 0x20, 0x77, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x2E, 0x0A, 0x09, 0x3A, 0x73, 0x69, 0x7A, 
  0x65, 0x20, 0x2D, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x66, 0x69, 0x6C, 0x65, 
  0x20, 0x69, 0x6E, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x0A, 0x09, 0x3A, 0x62, 0x6C, 0x6F, 0x63, 
  0x6B, 0x73, 0x20, 0x2D, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x62, 
  0x6C, 0x6F, 0x63, 0x6B, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x2E, 0x20, 0x30, 
  0x20, 0x6F, 0x6E, 0x20, 0x77, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x0A, 0x09, 0x3A, 0x62, 0x6C, 
  0x6F, 0x63, 0x6B, 0x73, 0x69, 0x7A, 0x65, 0x20, 0x2D, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x20, 0x6F, 
  0x66, 0x20, 0x62, 0x6C, 0x6F, 0x63, 0x6B, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x66, 0x69, 0x6C, 0x65, 
  0x2E, 0x20, 0x30, 0x20, 0x6F, 0x6E, 0x20, 0x77, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x0A, 0x09, 
  0x3A, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x65, 0x64, 0x20, 0x2D, 0x20, 0x74, 0x69, 0x6D, 0x65, 
  0x73, 0x74, 0x61, 0x6D, 0x70, 0x20, 0x77, 0x68, 0x65, 0x6E, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 
  0x6C, 0x61, 0x73, 0x74, 0x20, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x65, 0x64, 0x0A, 0x09, 0x3A, 
  0x63, 0x68, 0x61, 0x6E, 0x67, 0x65, 0x64, 0x20, 0x2D, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x73, 0x74, 
  0x61, 0x6D, 0x70, 0x20, 0x77, 0x68, 0x65, 0x6E, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x6C, 0x61, 
  0x73, 0x74, 0x20, 0x63, 0x68, 0x61, 0x6E, 0x67, 0x65, 0x64, 0x20, 0x28, 0x70, 0x65, 0x72, 0x6D, 
  0x69, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x73, 0x20, 0x63, 0x68, 0x61, 0x6E, 0x67, 0x65, 0x64, 0x29, 
  0x0A, 0x09, 0x3A, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x2D, 0x20, 0x74, 0x69, 
  0x6D, 0x65, 0x73, 0x74, 0x61, 0x6D, 0x70, 0x20, 0x77, 0x68, 0x65, 0x6E, 0x20, 0x66, 0x69, 0x6C, 
  0x65, 0x20, 0x6C, 0x61, 0x73, 0x74, 0x20, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 
  0x28, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x20, 0x63, 0x68, 0x61, 0x6E, 0x67, 0x65, 0x64, 
  0x29, 0x0A, 0xDA, 0x86, 0x13, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x86, 0x02, 0xDA, 0x09, 0xCE, 0x1E, 
  0x28, 0x65, 0x76, 0x65, 0x6E, 0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 
  0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 0x65, 0x76, 0x65, 0x6E, 0x2E, 0xDA, 0x0B, 
  0xD2, 0x03, 0x00, 0xDA, 0x05, 0x52, 0x01, 0xDA, 0x86, 0x14, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x86, 
  0x16, 0xDA, 0x09, 0xCE, 0x62, 0x28, 0x72, 0x65, 0x76, 0x65, 0x72, 0x73, 0x65, 0x20, 0x74, 0x29, 
  0x0A, 0x0A, 0x52, 0x65, 0x76, 0x65, 0x72, 0x73, 0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6F, 
  0x72, 0x64, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6C, 0x65, 0x6D, 
  0x65, 0x6E, 0x74, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 
  0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x6F, 0x72, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x20, 0x61, 
  0x6E, 0x64, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 
  0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x84, 0xA8, 
  0x01, 0xDA, 0x86, 0x17, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x86, 0x18, 0xDA, 0x09, 0xCE, 0x41, 0x28, 
  0x6D, 0x61, 0x74, 0x68, 0x2F, 0x68, 0x79, 0x70, 0x6F, 0x74, 0x20, 0x61, 0x20, 0x62, 0x29, 0x0A, 
  0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x20, 0x66, 
  0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x71, 0x75, 0x61, 0x74, 0x69, 0x6F, 0x6E, 
  0x20, 0x63, 0x5E, 0x32, 0x20, 0x3D, 0x20, 0x61, 0x5E, 0x32, 0x20, 0x2B, 0x20, 0x62, 0x5E, 0x32, 
  0xDA, 0x86, 0x19, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x86, 0x1A, 0xDA, 0x09, 0xCE, 0x41, 0x28, 0x6D, 
  0x61, 0x74, 0x68, 0x2F, 0x74, 0x72, 0x75, 0x6E, 0x63, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 
  0x72, 0x20, 0x62, 0x65, 0x74, 0x77, 0x65, 0x65, 0x6E, 0x20, 0x78, 0x20, 0x61, 0x6E, 0x64, 0x20, 
  0x30, 0x20, 0x6E, 0x65, 0x61, 0x72, 0x65, 0x73, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x78, 0x2E, 0xDA, 
  0x81, 0xB3, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x80, 0xFA, 0xDA, 0x09, 0xCE, 0x81, 0x8A, 0x28, 0x69, 
  0x6E, 0x20, 0x64, 0x73, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x64, 0x66, 
  0x6C, 0x74, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x69, 
  0x6E, 0x20, 0x64, 0x73, 0x20, 0x61, 0x74, 0x20, 0x6B, 0x65, 0x79, 0x2C, 0x20, 0x77, 0x6F, 0x72, 
  0x6B, 0x73, 0x20, 0x6F, 0x6E, 0x20, 0x61, 0x73, 0x73, 0x6F, 0x63, 0x69, 0x61, 0x74, 0x69, 0x76, 
  0x65, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 
  0x73, 0x2E, 0x20, 0x41, 0x72, 0x72, 0x61, 0x79, 0x73, 0x2C, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 
  0x73, 0x2C, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x73, 0x2C, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 
  0x74, 0x73, 0x2C, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x73, 0x2C, 0x20, 0x73, 0x79, 0x6D, 
  0x62, 0x6F, 0x6C, 0x73, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 
  0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x61, 0x6C, 0x6C, 0x20, 0x61, 0x73, 0x73, 0x6F, 0x63, 0x69, 
  0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 
  0x20, 0x75, 0x73, 0x65, 0x64, 0x2E, 0x20, 0x41, 0x72, 0x72, 0x61, 0x79, 0x73, 0x2C, 0x20, 0x74, 
  0x75, 0x70, 0x6C, 0x65, 0x73, 0x2C, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x73, 0x2C, 0x20, 
  0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x73, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x73, 0x79, 0x6D, 
  0x62, 0x6F, 0x6C, 0x73, 0x20, 0x6D, 0x75, 0x73, 0x74, 0x20, 0x75, 0x73, 0x65, 0x20, 0x69, 0x6E, 
  0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x6B, 0x65, 0x79, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 
  0x61, 0x72, 0x65, 0x20, 0x69, 0x6E, 0x20, 0x62, 0x6F, 0x75, 0x6E, 0x64, 0x73, 0x20, 0x6F, 0x72, 
  0x20, 0x61, 0x6E, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x69, 0x73, 0x20, 0x72, 0x61, 0x69, 
  0x73, 0x65, 0x64, 0x2E, 0x20, 0x53, 0x74, 0x72, 0x75, 0x63, 0x74, 0x73, 0x20, 0x61, 0x6E, 0x64, 
  0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x73, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x74, 0x61, 0x6B, 0x65, 
  0x20, 0x61, 0x6E, 0x79, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x61, 0x73, 0x20, 0x61, 0x20, 
  0x6B, 0x65, 0x79, 0x20, 0x65, 0x78, 0x63, 0x65, 0x70, 0x74, 0x20, 0x6E, 0x69, 0x6C, 0x20, 0x61, 
  0x6E, 0x64, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x6E, 
  0x69, 0x6C, 0x20, 0x6F, 0x72, 0x20, 0x64, 0x66, 0x6C, 0x74, 0x20, 0x69, 0x66, 0x20, 0x6E, 0x6F, 
  0x74, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x2E, 0xDA, 0x86, 0x1B, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 
  0x86, 0x1D, 0xDA, 0x09, 0xCE, 0x81, 0x59, 0x28, 0x64, 0x6F, 0x63, 0x20, 0x26, 0x6F, 0x70, 0x74, 
  0x20, 0x73, 0x79, 0x6D, 0x29, 0x0A, 0x0A, 0x53, 0x68, 0x6F, 0x77, 0x73, 0x20, 0x64, 0x6F, 0x63, 
  0x75, 0x6D, 0x65, 0x6E, 0x74, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x2C, 
  0x20, 0x6F, 0x72, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x73, 0x68, 0x6F, 0x77, 0x20, 0x61, 0x20, 0x6C, 
  0x69, 0x73, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x76, 0x61, 0x69, 0x6C, 0x61, 0x62, 0x6C, 0x65, 
  0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x2E, 0x20, 0x20, 0x49, 0x66, 0x20, 0x73, 
  0x79, 0x6D, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x2C, 0x20, 
  0x77, 0x69, 0x6C, 0x6C, 0x20, 0x6C, 0x6F, 0x6F, 0x6B, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x64, 0x6F, 
  0x63, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x66, 0x6F, 0x72, 0x20, 
  0x74, 0x68, 0x61, 0x74, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x2E, 0x20, 0x49, 0x66, 0x20, 
  0x73, 0x79, 0x6D, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 
  0x20, 0x6F, 0x72, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x70, 0x72, 0x6F, 0x76, 0x69, 
  0x64, 0x65, 0x64, 0x2C, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x73, 0x68, 0x6F, 0x77, 0x20, 0x61, 
  0x6C, 0x6C, 0x20, 0x6C, 0x65, 0x78, 0x69, 0x63, 0x61, 0x6C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x64, 
  0x79, 0x6E, 0x61, 0x6D, 0x69, 0x63, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x20, 
  0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x65, 
  0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 
  0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x20, 0x28, 0x61, 0x6C, 
  0x6C, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 
  0x62, 0x65, 0x20, 0x73, 0x68, 0x6F, 0x77, 0x6E, 0x20, 0x69, 0x66, 0x20, 0x6E, 0x6F, 0x20, 0x70, 
  0x72, 0x65, 0x66, 0x69, 0x78, 0x20, 0x69, 0x73, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x29, 0x2E, 
  0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x86, 0x8C, 0x01, 0xDA, 0x35, 0xCB, 0xDA, 0x86, 0x1E, 
  0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x80, 0xF4, 0xDA, 0x09, 0xCE, 0x51, 0x28, 0x70, 0x61, 0x72, 0x73, 
  0x65, 0x72, 0x2F, 0x68, 0x61, 0x73, 0x2D, 0x6D, 0x6F, 0x72, 0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 
  0x65, 0x72, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x70, 0x61, 0x72, 0x73, 0x65, 0x72, 0x20, 0x68, 0x61, 0x73, 0x20, 0x6D, 0x6F, 0x72, 
  0x65, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x71, 0x75, 0x65, 0x75, 0x65, 0x2E, 0xDA, 0x86, 0x1F, 0xD3, 
  0x02, 0xDA, 0x03, 0xDA, 0x86, 0x20, 0xDA, 0x09, 0xCE, 0x31, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 
  0x72, 0x6F, 0x75, 0x6E, 0x64, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 
  0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x6E, 0x65, 
  0x61, 0x72, 0x65, 0x73, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x78, 0x2E, 0xDA, 0x86, 0x21, 0xD3, 0x02, 
  0xDA, 0x03, 0xDA, 0x86, 0x22, 0xDA, 0x09, 0xCE, 0x47, 0x28, 0x6F, 0x73, 0x2F, 0x6C, 0x73, 0x74, 
  0x61, 0x74, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x74, 0x61, 0x62, 
  0x7C, 0x6B, 0x65, 0x79, 0x29, 0x0A, 0x0A, 0x4C, 0x69, 0x6B, 0x65, 0x20, 0x6F, 0x73, 0x2F, 0x73, 
  0x74, 0x61, 0x74, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x64, 0x6F, 0x6E, 0x27, 0x74, 0x20, 0x66, 
  0x6F, 0x6C, 0x6C, 0x6F, 0x77, 0x20, 0x73, 0x79, 0x6D, 0x6C, 0x69, 0x6E, 0x6B, 0x73, 0x2E, 0x0A, 
  0xDA, 0x86, 0x23, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x86, 0x24, 0xDA, 0x09, 0xCE, 0x58, 0x28, 0x73, 
  0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x73, 0x74, 0x72, 0x29, 
  0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x72, 0x72, 
  0x61, 0x79, 0x20, 0x6F, 0x66, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x73, 0x20, 0x74, 
  0x68, 0x61, 0x74, 0x20, 0x61, 0x72, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x79, 0x74, 0x65, 
  0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x73, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 
  0x74, 0x72, 0x69, 0x6E, 0x67, 0x2E, 0xDA, 0x86, 0x25, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x80, 0xCA, 
  0xDA, 0x09, 0xCE, 0x24, 0x28, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x3F, 0x20, 0x78, 0x29, 0x0A, 
  0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 0x61, 
  0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x5A, 
  0x01, 0xDA, 0x86, 0x26, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x86, 0x28, 0xDA, 0x09, 0xCE, 0x1E, 0x28, 
  0x74, 0x72, 0x75, 0x65, 0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 
  0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 0x74, 0x72, 0x75, 0x65, 0x2E, 0xDA, 0x0B, 0xD2, 
  0x03, 0x00, 0xDA, 0x05, 0x70, 0x01, 0xDA, 0x86, 0x29, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x86, 0x2A, 
  0xDA, 0x09, 0xCE, 0x81, 0x33, 0x28, 0x74, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x73, 0x6C, 0x69, 
  0x63, 0x65, 0x20, 0x74, 0x61, 0x72, 0x72, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x73, 0x74, 0x61, 
  0x72, 0x74, 0x20, 0x65, 0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x54, 0x61, 0x6B, 0x65, 0x73, 0x20, 0x61, 
  0x20, 0x73, 0x6C, 0x69, 0x63, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x20, 0x74, 0x79, 0x70, 0x65, 
  0x64, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x73, 0x74, 0x61, 
  0x72, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x65, 0x6E, 0x64, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x72, 
  0x61, 0x6E, 0x67, 0x65, 0x20, 0x69, 0x73, 0x20, 0x68, 0x61, 0x6C, 0x66, 0x20, 0x6F, 0x70, 0x65, 
  0x6E, 0x2C, 0x20, 0x5B, 0x73, 0x74, 0x61, 0x72, 0x74, 0x2C, 0x20, 0x65, 0x6E, 0x64, 0x29, 0x2E, 
  0x20, 0x49, 0x6E, 0x64, 0x65, 0x78, 0x65, 0x73, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x61, 0x6C, 0x73, 
  0x6F, 0x20, 0x62, 0x65, 0x20, 0x6E, 0x65, 0x67, 0x61, 0x74, 0x69, 0x76, 0x65, 0x2C, 0x20, 0x69, 
  0x6E, 0x64, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x69, 
  0x6E, 0x67, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6E, 0x64, 0x20, 
  0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6E, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x74, 0x79, 0x70, 0x65, 0x64, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0x20, 0x42, 
  0x79, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x2C, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 
  0x20, 0x69, 0x73, 0x20, 0x30, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x65, 0x6E, 0x64, 0x20, 0x69, 0x73, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x74, 0x79, 0x70, 0x65, 0x64, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0x20, 0x52, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x6A, 0x61, 0x6E, 0x65, 
  0x74, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0xDA, 0x86, 0x2B, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 
  0x86, 0x2D, 0xDA, 0x09, 0xCE, 0x65, 0x28, 0x61, 0x63, 0x63, 0x75, 0x6D, 0x75, 0x6C, 0x61, 0x74, 
  0x65, 0x32, 0x20, 0x66, 0x20, 0x69, 0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x54, 0x68, 0x65, 0x20, 0x32, 
  0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6F, 
  0x6E, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x63, 0x63, 0x75, 0x6D, 0x75, 0x6C, 0x61, 0x74, 0x65, 0x20, 
  0x74, 0x68, 0x61, 0x74, 0x20, 0x64, 0x6F, 0x65, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x74, 0x61, 
  0x6B, 0x65, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x69, 0x74, 0x69, 0x61, 0x6C, 0x69, 0x7A, 0x61, 
  0x74, 0x69, 0x6F, 0x6E, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 
  0xDA, 0x05, 0x83, 0x32, 0x01, 0xDA, 0x86, 0x2E, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x86, 0x2F, 0xDA, 
  0x09, 0xCE, 0x36, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x61, 0x74, 0x61, 0x6E, 0x68, 0x20, 0x78, 
  0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x68, 0x79, 
  0x70, 0x65, 0x72, 0x62, 0x6F, 0x6C, 0x69, 0x63, 0x20, 0x61, 0x72, 0x63, 0x74, 0x61, 0x6E, 0x67, 
  0x65, 0x6E, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x2E, 0xDA, 0x86, 0x30, 0xD3, 0x03, 0xDA, 0x03, 
  0xDA, 0x5E, 0xDA, 0x09, 0xCE, 0x53, 0x28, 0x73, 0x6F, 0x72, 0x74, 0x20, 0x61, 0x20, 0x26, 0x6F, 
  0x70, 0x74, 0x20, 0x62, 0x79, 0x29, 0x0A, 0x0A, 0x53, 0x6F, 0x72, 0x74, 0x20, 0x61, 0x6E, 0x20, 
  0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 0x69, 0x6E, 0x2D, 0x70, 0x6C, 0x61, 0x63, 0x65, 0x2E, 0x20, 
  0x55, 0x73, 0x65, 0x73, 0x20, 0x71, 0x75, 0x69, 0x63, 0x6B, 0x2D, 0x73, 0x6F, 0x72, 0x74, 0x20, 
  0x61, 0x6E, 0x64, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x61, 0x20, 0x73, 0x74, 0x61, 
  0x62, 0x6C, 0x65, 0x20, 0x73, 0x6F, 0x72, 0x74, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 
  0x82, 0xF9, 0x01, 0xDA, 0x86, 0x31, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x86, 0x32, 0xDA, 0x09, 0xCE, 
  0x4D, 0x28, 0x74, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 
  0x61, 0x72, 0x72, 0x61, 0x79, 0x7C, 0x73, 0x69, 0x7A, 0x65, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x20, 0x74, 0x79, 0x70, 0x65, 0x64, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x20, 
  0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x6F, 0x72, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 
  0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0xDA, 0x86, 
  0x33, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x86, 0x34, 0xDA, 0x09, 0xCE, 0x81, 0x96, 0x28, 0x6F, 0x73, 
  0x2F, 0x63, 0x68, 0x6D, 0x6F, 0x64, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x6D, 0x6F, 0x64, 0x65, 
  0x29, 0x0A, 0x0A, 0x43, 0x68, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x70, 
  0x65, 0x72, 0x6D, 0x69, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x73, 0x2C, 0x20, 0x77, 0x68, 0x65, 0x72, 
  0x65, 0x20, 0x6D, 0x6F, 0x64, 0x65, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x70, 0x65, 0x72, 0x6D, 
  0x69, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x61, 0x73, 
  0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x6F, 0x73, 0x2F, 
  0x70, 0x65, 0x72, 0x6D, 0x2D, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2C, 0x20, 0x6F, 0x72, 0x20, 
  0x61, 0x6E, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x20, 0x61, 0x73, 0x20, 0x72, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x6F, 0x73, 0x2F, 0x70, 0x65, 0x72, 
  0x6D, 0x2D, 0x69, 0x6E, 0x74, 0x2E, 0x20, 0x57, 0x68, 0x65, 0x6E, 0x20, 0x6D, 0x6F, 0x64, 0x65, 
  0x20, 0x69, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 0x2C, 0x20, 
  0x69, 0x74, 0x20, 0x69, 0x73, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x70, 0x72, 0x65, 0x74, 0x65, 
  0x64, 0x20, 0x61, 0x73, 0x20, 0x61, 0x20, 0x55, 0x6E, 0x69, 0x78, 0x20, 0x70, 0x65, 0x72, 0x6D, 
  0x69, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2C, 0x20, 0x62, 0x65, 
  0x73, 0x74, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x20, 
  0x6F, 0x63, 0x74, 0x61, 0x6C, 0x2C, 0x20, 0x6C, 0x69, 0x6B, 0x65, 0x20, 0x38, 0x72, 0x36, 0x36, 
  0x36, 0x20, 0x6F, 0x72, 0x20, 0x38, 0x72, 0x34, 0x30, 0x30, 0x2E, 0x20, 0x57, 0x69, 0x6E, 0x64, 
  0x6F, 0x77, 0x73, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x64, 0x69, 0x66, 
  0x66, 0x65, 0x72, 0x65, 0x6E, 0x74, 0x69, 0x61, 0x74, 0x65, 0x20, 0x62, 0x65, 0x74, 0x77, 0x65, 
  0x65, 0x6E, 0x20, 0x75, 0x73, 0x65, 0x72, 0x2C, 0x20, 0x67, 0x72, 0x6F, 0x75, 0x70, 0x2C, 0x20, 
  0x61, 0x6E, 0x64, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x20, 0x70, 0x65, 0x72, 0x6D, 0x69, 0x73, 
  0x73, 0x69, 0x6F, 0x6E, 0x73, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x74, 0x68, 0x75, 0x73, 0x20, 
  0x77, 0x69, 0x6C, 0x6C, 0x20, 0x63, 0x6F, 0x6D, 0x62, 0x69, 0x6E, 0x65, 0x20, 0x61, 0x6C, 0x6C, 
  0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x73, 0x65, 0x20, 0x70, 0x65, 0x72, 0x6D, 0x69, 0x73, 
  0x73, 0x69, 0x6F, 0x6E, 0x73, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 
  0x69, 0x6C, 0x2E, 0xDA, 0x86, 0x35, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x86, 0x37, 0xDA, 0x09, 0xCE, 
  0x39, 0x28, 0x6D, 0x65, 0x61, 0x6E, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 
  0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x65, 0x61, 0x6E, 0x20, 0x6F, 0x66, 0x20, 
  0x78, 0x73, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x65, 0x6D, 0x70, 0x74, 0x79, 0x2C, 0x20, 0x72, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x4E, 0x61, 0x4E, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 
  0x05, 0x82, 0x3B, 0x01, 0xDA, 0x86, 0x38, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x86, 0x39, 0xDA, 0x09, 
  0xCE, 0x6D, 0x28, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x62, 0x69, 0x74, 0x20, 0x62, 0x75, 
  0x66, 0x66, 0x65, 0x72, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x29, 0x0A, 0x0A, 0x47, 0x65, 0x74, 
  0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x69, 0x74, 0x20, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x62, 0x69, 0x74, 0x2D, 0x69, 0x6E, 0x64, 0x65, 0x78, 
  0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x72, 0x75, 0x65, 0x20, 0x69, 
  0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x69, 0x74, 0x20, 0x69, 0x73, 0x20, 0x73, 0x65, 0x74, 
  0x2C, 0x20, 0x66, 0x61, 0x6C, 0x73, 0x65, 0x20, 0x69, 0x66, 0x20, 0x6E, 0x6F, 0x74, 0x2E, 0xDA, 
  0x86, 0x3A, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 0x86, 0x3C, 0xDA, 0x09, 0xCE, 0x80, 0xE7, 0x28, 0x77, 
  0x69, 0x74, 0x68, 0x2D, 0x64, 0x79, 0x6E, 0x73, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 
  0x73, 0x20, 0x26, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x29, 0x0A, 0x0A, 0x52, 0x75, 0x6E, 0x20, 0x61, 
  0x20, 0x62, 0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x6F, 0x66, 0x20, 0x63, 0x6F, 0x64, 0x65, 0x20, 0x69, 
  0x6E, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x74, 0x68, 
  0x61, 0x74, 0x20, 0x68, 0x61, 0x73, 0x20, 0x73, 0x6F, 0x6D, 0x65, 0x20, 0x20, 0x64, 0x79, 0x6E, 
  0x61, 0x6D, 0x69, 0x63, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x20, 0x73, 0x65, 
  0x74, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x77, 0x69, 0x6C, 
  0x6C, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x6D, 0x61, 0x73, 0x6B, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 
  0x73, 0x20, 0x20, 0x6F, 0x72, 0x20, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0x73, 0x2C, 0x20, 0x62, 
  0x75, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x79, 0x6E, 0x61, 0x6D, 0x69, 0x63, 0x20, 0x62, 
  0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 
  0x70, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x6C, 0x79, 0x20, 0x20, 0x75, 0x6E, 0x73, 0x65, 0x74, 0x2C, 
  0x20, 0x61, 0x73, 0x20, 0x64, 0x79, 0x6E, 0x61, 0x6D, 0x69, 0x63, 0x20, 0x62, 0x69, 0x6E, 0x64, 
  0x69, 0x6E, 0x67, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x6C, 
  0x6F, 0x63, 0x61, 0x6C, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x84, 0x7C, 0x01, 0xDA, 
  0x35, 0xCB, 0xDA, 0x86, 0x3D, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x80, 0x8E, 0xDA, 0x09, 0xCE, 0x80, 
  0xCC, 0x28, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x20, 0x26, 0x20, 0x6B, 0x76, 0x73, 0x29, 0x0A, 
  0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x73, 0x74, 
  0x72, 0x75, 0x63, 0x74, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x61, 0x20, 0x73, 0x65, 0x71, 0x75, 
  0x65, 0x6E, 0x63, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x76, 0x61, 0x6C, 0x75, 
  0x65, 0x20, 0x70, 0x61, 0x69, 0x72, 0x73, 0x2E, 0x20, 0x6B, 0x76, 0x73, 0x20, 0x69, 0x73, 0x20, 
  0x61, 0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6E, 0x63, 0x65, 0x20, 0x6B, 0x31, 0x2C, 0x20, 0x76, 
  0x31, 0x2C, 0x20, 0x6B, 0x32, 0x2C, 0x20, 0x76, 0x32, 0x2C, 0x20, 0x6B, 0x33, 0x2C, 0x20, 0x76, 
  0x33, 0x2C, 0x20, 0x2E, 0x2E, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x6B, 0x76, 0x73, 0x20, 0x68, 0x61, 
  0x73, 0x20, 0x61, 0x6E, 0x20, 0x6F, 0x64, 0x64, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 
  0x6F, 0x66, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x2C, 0x20, 0x61, 0x6E, 0x20, 
  0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x74, 0x68, 
  0x72, 0x6F, 0x77, 0x6E, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x2E, 0xDA, 0x86, 0x3E, 
  0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x86, 0x3F, 0xDA, 0x09, 0xCE, 0x62, 0x28, 0x66, 0x69, 0x6C, 0x65, 
  0x2F, 0x74, 0x65, 0x6D, 0x70, 0x29, 0x0A, 0x0A, 0x4F, 0x70, 0x65, 0x6E, 0x20, 0x61, 0x6E, 0x20, 
  0x61, 0x6E, 0x6F, 0x6E, 0x79, 0x6D, 0x6F, 0x75, 0x73, 0x20, 0x74, 0x65, 0x6D, 0x70, 0x6F, 0x72, 
  0x61, 0x72, 0x79, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x73, 
  0x20, 0x72, 0x65, 0x6D, 0x6F, 0x76, 0x65, 0x64, 0x20, 0x6F, 0x6E, 0x20, 0x63, 0x6C, 0x6F, 0x73, 
  0x65, 0x2E, 0x52, 0x61, 0x69, 0x73, 0x65, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x72, 0x72, 0x6F, 
  0x72, 0x20, 0x6F, 0x6E, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x75, 0x72, 0x65, 0x2E, 0xDA, 0x86, 0x40, 
  0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x86, 0x41, 0xDA, 0x09, 0xCE, 0x80, 0xD5, 0x28, 0x6D, 0x61, 0x74, 
  0x68, 0x2F, 0x72, 0x6E, 0x67, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x73, 0x65, 0x65, 0x64, 0x29, 
  0x0A, 0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x73, 0x20, 0x61, 0x20, 0x50, 0x73, 0x75, 0x65, 
  0x64, 0x6F, 0x2D, 0x52, 0x61, 0x6E, 0x64, 0x6F, 0x6D, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 
  0x20, 0x67, 0x65, 0x6E, 0x65, 0x72, 0x61, 0x74, 0x6F, 0x72, 0x2C, 0x20, 0x77, 0x69, 0x74, 0x68, 
  0x20, 0x61, 0x6E, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x20, 0x73, 0x65, 0x65, 
  0x64, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x73, 0x65, 0x65, 0x64, 0x20, 0x73, 0x68, 0x6F, 0x75, 
  0x6C, 0x64, 0x20, 0x62, 0x65, 0x20, 0x61, 0x6E, 0x20, 0x75, 0x6E, 0x73, 0x69, 0x67, 0x6E, 0x65, 
  0x64, 0x20, 0x33, 0x32, 0x20, 0x62, 0x69, 0x74, 0x20, 0x69, 0x6E, 0x74, 0x65, 0x67, 0x65, 0x72, 
  0x20, 0x6F, 0x72, 0x20, 0x61, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0x20, 0x44, 0x6F, 
  0x20, 0x6E, 0x6F, 0x74, 0x20, 0x75, 0x73, 0x65, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x66, 0x6F, 
  0x72, 0x20, 0x63, 0x72, 0x79, 0x70, 0x74, 0x6F, 0x67, 0x72, 0x61, 0x70, 0x68, 0x79, 0x2E, 0x20, 
  0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x63, 0x6F, 0x72, 0x65, 0x2F, 0x72, 
  0x6E, 0x67, 0x20, 0x61, 0x62, 0x73, 0x74, 0x72, 0x61, 0x63, 0x74, 0x20, 0x74, 0x79, 0x70, 0x65, 
  0x2E, 0xDA, 0x86, 0x42, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x86, 0x43, 0xDA, 0x09, 0xCE, 0x67, 0x28, 
  0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x2F, 0x62, 0x69, 0x74, 0x2D, 0x74, 0x6F, 0x67, 0x67, 0x6C, 
  0x65, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x29, 0x0A, 
  0x0A, 0x54, 0x6F, 0x67, 0x67, 0x6C, 0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x69, 0x74, 
  0x20, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x62, 0x69, 
  0x74, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x69, 0x6E, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 
  0x72, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 
  0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0xDA, 0x86, 0x44, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x86, 0x46, 
  0xDA, 0x09, 0xCE, 0x81, 0x07, 0x28, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x2D, 0x69, 0x6E, 0x20, 
  0x64, 0x73, 0x20, 0x6B, 0x73, 0x20, 0x66, 0x20, 0x26, 0x20, 0x61, 0x72, 0x67, 0x73, 0x29, 0x0A, 
  0x0A, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 
  0x69, 0x6E, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x73, 0x74, 0x65, 0x64, 0x20, 0x64, 0x61, 0x74, 0x61, 
  0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x20, 0x62, 0x79, 0x20, 0x61, 0x70, 
  0x70, 0x6C, 0x79, 0x69, 0x6E, 0x67, 0x20, 0x66, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x63, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2E, 0x20, 0x20, 
  0x4C, 0x6F, 0x6F, 0x6B, 0x73, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 
  0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x20, 0x76, 0x69, 
  0x61, 0x20, 0x20, 0x61, 0x20, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6E, 0x63, 0x65, 0x20, 0x6F, 0x66, 
  0x20, 0x6B, 0x65, 0x79, 0x73, 0x2E, 0x20, 0x4D, 0x69, 0x73, 0x73, 0x69, 0x6E, 0x67, 0x20, 0x64, 
  0x61, 0x74, 0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x73, 0x20, 0x77, 
  0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x72, 0x65, 0x70, 0x6C, 0x61, 0x63, 0x65, 0x64, 0x20, 
  0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x73, 0x2E, 0x20, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x6F, 0x64, 0x69, 0x66, 0x69, 
  0x65, 0x64, 0x2C, 0x20, 0x6F, 0x72, 0x69, 0x67, 0x69, 0x6E, 0x61, 0x6C, 0x20, 0x64, 0x61, 0x74, 
  0x61, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 
  0x00, 0xDA, 0x05, 0x84, 0xD1, 0x01, 0xDA, 0x86, 0x47, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x86, 0x49, 
  0xDA, 0x09, 0xCE, 0x63, 0x28, 0x70, 0x61, 0x72, 0x74, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x6E, 
  0x20, 0x69, 0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x50, 0x61, 0x72, 0x74, 0x69, 0x74, 0x69, 0x6F, 0x6E, 
  0x20, 0x61, 0x6E, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x65, 0x64, 0x20, 0x64, 0x61, 0x74, 0x61, 
  0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x75, 0x72, 0x65, 0x20, 0x69, 0x6E, 0x74, 0x6F, 0x20, 
  0x74, 0x75, 0x70, 0x6C, 0x65, 0x73, 0x20, 0x20, 0x6F, 0x66, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x20, 
  0x6E, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 
  0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x85, 0x7B, 
  0x01, 0xDA, 0x86, 0x4A, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x82, 0x2F, 0xDA, 0x09, 0xCE, 0x81, 0x56, 
  0x28, 0x6D, 0x61, 0x63, 0x65, 0x78, 0x20, 0x78, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x6F, 0x6E, 
  0x2D, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x29, 0x0A, 0x0A, 0x45, 0x78, 0x70, 0x61, 0x6E, 
  0x64, 0x20, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x73, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x6C, 0x65, 0x74, 
  0x65, 0x6C, 0x79, 0x2E, 0x20, 0x20, 0x6F, 0x6E, 0x2D, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 
  0x20, 0x69, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x6F, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x61, 0x6C, 0x20, 
  0x63, 0x61, 0x6C, 0x6C, 0x62, 0x61, 0x63, 0x6B, 0x20, 0x77, 0x68, 0x65, 0x6E, 0x65, 0x76, 0x65, 
  0x72, 0x20, 0x61, 0x20, 0x6E, 0x6F, 0x72, 0x6D, 0x61, 0x6C, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 
  0x6C, 0x69, 0x63, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x20, 0x69, 0x73, 0x20, 
  0x65, 0x6E, 0x63, 0x6F, 0x75, 0x6E, 0x74, 0x65, 0x72, 0x2E, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 
  0x61, 0x6C, 0x6C, 0x6F, 0x77, 0x73, 0x20, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x73, 0x20, 0x74, 0x6F, 
  0x20, 0x65, 0x61, 0x73, 0x69, 0x6C, 0x79, 0x20, 0x73, 0x65, 0x65, 0x20, 0x61, 0x6C, 0x6C, 0x20, 
  0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x73, 0x20, 0x75, 0x73, 0x65, 0x20, 0x62, 0x79, 0x20, 
  0x74, 0x68, 0x65, 0x69, 0x72, 0x20, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x73, 
  0x20, 0x62, 0x79, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x69, 0x6E, 0x67, 0x20, 0x6D, 0x61, 0x63, 0x65, 
  0x78, 0x20, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x69, 0x72, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x65, 
  0x6E, 0x74, 0x73, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 
  0x20, 0x69, 0x74, 0x73, 0x65, 0x6C, 0x66, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6C, 0x73, 0x6F, 0x20, 
  0x20, 0x72, 0x65, 0x70, 0x6C, 0x61, 0x63, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x65, 0x64, 0x20, 
  0x62, 0x79, 0x20, 0x6F, 0x6E, 0x2D, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x77, 0x69, 
  0x74, 0x68, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x78, 0x70, 0x61, 0x6E, 0x64, 0x20, 
  0x6D, 0x61, 0x63, 0x72, 0x6F, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x87, 0x33, 0x01, 
  0xDA, 0x86, 0x4B, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x80, 0xB5, 0xDA, 0x09, 0xCE, 0x3E, 0x28, 0x73, 
  0x74, 0x72, 0x69, 0x6E, 0x67, 0x2F, 0x68, 0x61, 0x73, 0x2D, 0x73, 0x75, 0x66, 0x66, 0x69, 0x78, 
  0x3F, 0x20, 0x73, 0x66, 0x78, 0x20, 0x73, 0x74, 0x72, 0x29, 0x0A, 0x0A, 0x54, 0x65, 0x73, 0x74, 
  0x73, 0x20, 0x77, 0x68, 0x65, 0x74, 0x68, 0x65, 0x72, 0x20, 0x73, 0x74, 0x72, 0x20, 0x65, 0x6E, 
  0x64, 0x73, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x73, 0x66, 0x78, 0x2E, 0xDA, 0x86, 0x4C, 0xD3, 
  0x04, 0xDA, 0x03, 0xDA, 0x86, 0x4E, 0xDA, 0x09, 0xCE, 0x80, 0xBC, 0x28, 0x63, 0x61, 0x73, 0x65, 
  0x20, 0x64, 0x69, 0x73, 0x70, 0x61, 0x74, 0x63, 0x68, 0x20, 0x26, 0x20, 0x70, 0x61, 0x69, 0x72, 
  0x73, 0x29, 0x0A, 0x0A, 0x53, 0x65, 0x6C, 0x65, 0x63, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 
  0x6F, 0x64, 0x79, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x65, 0x71, 0x75, 0x61, 0x6C, 0x73, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x64, 0x69, 0x73, 0x70, 0x61, 0x74, 0x63, 0x68, 0x20, 0x76, 0x61, 0x6C, 
  0x75, 0x65, 0x2E, 0x20, 0x57, 0x68, 0x65, 0x6E, 0x20, 0x70, 0x61, 0x69, 0x72, 0x73, 0x20, 0x20, 
  0x68, 0x61, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x6F, 0x64, 0x64, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 
  0x72, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x73, 0x2C, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x6C, 0x61, 0x73, 0x74, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x20, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 
  0x6F, 0x6E, 0x2E, 0x20, 0x20, 0x49, 0x66, 0x20, 0x6E, 0x6F, 0x20, 0x6D, 0x61, 0x74, 0x63, 0x68, 
  0x20, 0x69, 0x73, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x2C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x80, 0xBD, 
  0x01, 0xDA, 0x35, 0xCB, 0xDA, 0x86, 0x4F, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 0x86, 0x51, 0xDA, 0x09, 
  0xCE, 0x28, 0x28, 0x2A, 0x3D, 0x20, 0x78, 0x20, 0x6E, 0x29, 0x0A, 0x0A, 0x53, 0x68, 0x6F, 0x72, 
  0x74, 0x68, 0x61, 0x6E, 0x64, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x28, 0x73, 0x65, 0x74, 0x20, 0x78, 
  0x20, 0x28, 0x2A, 0x20, 0x78, 0x20, 0x6E, 0x29, 0x29, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 
  0x05, 0x80, 0x87, 0x01, 0xDA, 0x35, 0xCB, 0xDA, 0x86, 0x52, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x86, 
  0x54, 0xDA, 0x09, 0xCE, 0x7C, 0x28, 0x6A, 0x75, 0x78, 0x74, 0x2A, 0x20, 0x26, 0x20, 0x66, 0x75, 
  0x6E, 0x73, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x6A, 0x75, 0x78, 0x74, 0x61, 0x70, 0x6F, 0x73, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x6F, 
  0x66, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x2E, 0x20, 0x49, 0x6E, 0x20, 
  0x6F, 0x74, 0x68, 0x65, 0x72, 0x20, 0x77, 0x6F, 0x72, 0x64, 0x73, 0x2C, 0x20, 0x20, 0x28, 0x28, 
  0x6A, 0x75, 0x78, 0x74, 0x2A, 0x20, 0x61, 0x20, 0x62, 0x20, 0x63, 0x29, 0x20, 0x78, 0x29, 0x20, 
  0x65, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0x73, 0x20, 0x74, 0x6F, 0x20, 0x5B, 0x28, 0x61, 
  0x20, 0x78, 0x29, 0x20, 0x28, 0x62, 0x20, 0x78, 0x29, 0x20, 0x28, 0x63, 0x20, 0x78, 0x29, 0x5D, 
  0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x83, 0xE0, 0x01, 0xDA, 0x84, 0x5C, 0xD3, 0x03, 
  0xDA, 0x03, 0xDA, 0x84, 0x49, 0xDA, 0x09, 0xCE, 0x80, 0x85, 0x28, 0x69, 0x6D, 0x70, 0x6F, 0x72, 
  0x74, 0x2A, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x26, 0x20, 0x61, 0x72, 0x67, 0x73, 0x29, 0x0A, 
  0x0A, 0x46, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x20, 0x6F, 
  0x66, 0x20, 0x69, 0x6D, 0x70, 0x6F, 0x72, 0x74, 0x2E, 0x20, 0x53, 0x61, 0x6D, 0x65, 0x20, 0x70, 
  0x61, 0x72, 0x61, 0x6D, 0x65, 0x74, 0x65, 0x72, 0x73, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x6F, 0x74, 0x68, 
  0x65, 0x72, 0x20, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6D, 0x65, 
  0x74, 0x65, 0x72, 0x73, 0x20, 0x73, 0x68, 0x6F, 0x75, 0x6C, 0x64, 0x20, 0x62, 0x65, 0x20, 0x73, 
  0x74, 0x72, 0x69, 0x6E, 0x67, 0x73, 0x20, 0x69, 0x6E, 0x73, 0x74, 0x65, 0x61, 0x64, 0x2E, 0xDA, 
  0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x89, 0x45, 0x01, 0xDA, 0x86, 0x55, 0xD3, 0x03, 0xDA, 0x03, 
  0xDA, 0x82, 0x97, 0xDA, 0x09, 0xCE, 0x22, 0x28, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x3F, 0x20, 0x78, 
  0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 0x73, 
  0x20, 0x61, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 
  0x64, 0x01, 0xDA, 0x86, 0x56, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x86, 0x57, 0xDA, 0x09, 0xCE, 0x33, 
  0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x6C, 0x6F, 0x67, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6C, 0x6F, 0x67, 0x20, 0x62, 0x61, 0x73, 0x65, 0x20, 0x6E, 
  0x61, 0x74, 0x75, 0x72, 0x61, 0x6C, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 0x66, 
  0x20, 0x78, 0x2E, 0xDA, 0x86, 0x58, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x81, 0x10, 0xDA, 0x09, 0xCE, 
  0x81, 0x28, 0x28, 0x6E, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x26, 
  0x6F, 0x70, 0x74, 0x20, 0x65, 0x6E, 0x76, 0x29, 0x0A, 0x0A, 0x4C, 0x6F, 0x61, 0x64, 0x20, 0x61, 
  0x20, 0x6E, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x20, 0x66, 
  0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 0x20, 0x70, 0x61, 
  0x74, 0x68, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x6D, 0x75, 0x73, 
  0x74, 0x20, 0x62, 0x65, 0x20, 0x61, 0x6E, 0x20, 0x61, 0x62, 0x73, 0x6F, 0x6C, 0x75, 0x74, 0x65, 
  0x20, 0x6F, 0x72, 0x20, 0x72, 0x65, 0x6C, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x70, 0x61, 0x74, 
  0x68, 0x20, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x73, 0x79, 
  0x73, 0x74, 0x65, 0x6D, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x69, 0x73, 0x20, 0x75, 0x73, 0x75, 
  0x61, 0x6C, 0x6C, 0x79, 0x20, 0x61, 0x20, 0x2E, 0x73, 0x6F, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 
  0x6F, 0x6E, 0x20, 0x55, 0x6E, 0x69, 0x78, 0x20, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x73, 0x2C, 
  0x20, 0x61, 0x6E, 0x64, 0x20, 0x61, 0x20, 0x2E, 0x64, 0x6C, 0x6C, 0x20, 0x66, 0x69, 0x6C, 0x65, 
  0x20, 0x6F, 0x6E, 0x20, 0x57, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x73, 0x2E, 0x20, 0x52, 0x65, 0x74, 
  0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 
  0x65, 0x6E, 0x74, 0x20, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 
  0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 0x73, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 
  0x73, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x6F, 0x74, 0x68, 0x65, 0x72, 0x20, 0x76, 0x61, 0x6C, 0x75, 
  0x65, 0x73, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x61, 0x74, 0x69, 
  0x76, 0x65, 0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x2E, 0xDA, 0x86, 0x59, 0xD3, 0x02, 0xDA, 
  0x03, 0xDA, 0x86, 0x5A, 0xDA, 0x09, 0xCE, 0x54, 0x28, 0x65, 0x70, 0x72, 0x69, 0x6E, 0x20, 0x26, 
  0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x53, 0x61, 0x6D, 0x65, 0x20, 0x61, 0x73, 0x20, 0x70, 0x72, 
  0x69, 0x6E, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x75, 0x73, 0x65, 0x73, 0x20, 0x28, 0x64, 0x79, 
  0x6E, 0x20, 0x3A, 0x65, 0x72, 0x72, 0x20, 0x73, 0x74, 0x64, 0x65, 0x72, 0x72, 0x29, 0x20, 0x69, 
  0x6E, 0x73, 0x74, 0x65, 0x61, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x28, 0x64, 0x79, 0x6E, 0x20, 0x3A, 
  0x6F, 0x75, 0x74, 0x20, 0x73, 0x74, 0x64, 0x6F, 0x75, 0x74, 0x29, 0x2E, 0xDA, 0x63, 0xD3, 0x02, 
  0xDA, 0x03, 0xDA, 0x62, 0xDA, 0x09, 0xCE, 0x29, 0x54, 0x68, 0x65, 0x20, 0x6E, 0x75, 0x6D, 0x62, 
  0x65, 0x72, 0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6E, 0x74, 0x69, 0x6E, 0x67, 0x20, 
  0x6E, 0x65, 0x67, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x69, 0x6E, 0x66, 0x69, 0x6E, 0x69, 0x74, 
  0x79, 0xDA, 0x86, 0x5B, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x83, 0xA2, 0xDA, 0x09, 0xCE, 0x42, 0x41, 
  0x6E, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x68, 
  0x61, 0x74, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 0x73, 0x20, 0x64, 0x6F, 0x74, 0x20, 
  0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x65, 0x64, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 
  0x6E, 0x73, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x64, 0x65, 0x62, 0x75, 0x67, 0x67, 0x69, 0x6E, 0x67, 
  0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x8A, 0x0F, 0x01, 0xDA, 0x86, 0x5C, 0xD3, 0x04, 
  0xDA, 0x03, 0xDA, 0x86, 0x5E, 0xDA, 0x09, 0xCE, 0x3C, 0x28, 0x65, 0x61, 0x63, 0x68, 0x20, 0x78, 
  0x20, 0x64, 0x73, 0x20, 0x26, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x29, 0x0A, 0x0A, 0x4C, 0x6F, 0x6F, 
  0x70, 0x20, 0x6F, 0x76, 0x65, 0x72, 0x20, 0x65, 0x61, 0x63, 0x68, 0x20, 0x76, 0x61, 0x6C, 0x75, 
  0x65, 0x20, 0x69, 0x6E, 0x20, 0x64, 0x73, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x6E, 0x69, 0x6C, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x81, 0xF0, 0x01, 0xDA, 
  0x35, 0xCB, 0xDA, 0x86, 0x5F, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x86, 0x60, 0xDA, 0x09, 0xCE, 0x2B, 
  0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x61, 0x74, 0x61, 0x6E, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x63, 0x74, 0x61, 
  0x6E, 0x67, 0x65, 0x6E, 0x74, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x2E, 0xDA, 0x84, 0x96, 0xD3, 0x02, 
  0xDA, 0x03, 0xDA, 0x86, 0x62, 0xDA, 0x09, 0xCE, 0x80, 0xE3, 0x28, 0x79, 0x69, 0x65, 0x6C, 0x64, 
  0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x59, 0x69, 0x65, 0x6C, 0x64, 0x20, 
  0x61, 0x20, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x20, 0x70, 0x61, 0x72, 
  0x65, 0x6E, 0x74, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x2E, 0x20, 0x57, 0x68, 0x65, 0x6E, 0x20, 
  0x61, 0x20, 0x66, 0x69, 0x62, 0x65, 0x72, 0x20, 0x79, 0x69, 0x65, 0x6C, 0x64, 0x73, 0x2C, 0x20, 
  0x69, 0x74, 0x73, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x69, 0x73, 
  0x20, 0x70, 0x61, 0x75, 0x73, 0x65, 0x64, 0x20, 0x75, 0x6E, 0x74, 0x69, 0x6C, 0x20, 0x61, 0x6E, 
  0x6F, 0x74, 0x68, 0x65, 0x72, 0x20, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64, 0x20, 0x72, 0x65, 0x73, 
  0x75, 0x6D, 0x65, 0x73, 0x20, 0x69, 0x74, 0x2E, 0x20, 0x54, 0x68, 0x65, 0x20, 0x66, 0x69, 0x62, 
  0x65, 0x72, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x74, 0x68, 0x65, 0x6E, 0x20, 0x72, 0x65, 0x73, 
  0x75, 0x6D, 0x65, 0x2C, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6C, 0x61, 0x73, 
  0x74, 0x20, 0x79, 0x69, 0x65, 0x6C, 0x64, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x20, 0x77, 0x69, 0x6C, 
  0x6C, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x61, 0x6C, 
  0x75, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x77, 0x61, 0x73, 0x20, 0x70, 0x61, 0x73, 0x73, 
  0x65, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6D, 0x65, 0x2E, 0xDA, 0x86, 0x63, 
  0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x86, 0x64, 0xDA, 0x09, 0xCE, 0x80, 0x8A, 0x28, 0x62, 0x75, 0x66, 
  0x66, 0x65, 0x72, 0x2F, 0x6E, 0x65, 0x77, 0x2D, 0x66, 0x69, 0x6C, 0x6C, 0x65, 0x64, 0x20, 0x63, 
  0x6F, 0x75, 0x6E, 0x74, 0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x62, 0x79, 0x74, 0x65, 0x29, 0x0A, 
  0x0A, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x62, 
  0x75, 0x66, 0x66, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x20, 
  0x63, 0x6F, 0x75, 0x6E, 0x74, 0x20, 0x66, 0x69, 0x6C, 0x6C, 0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 
  0x68, 0x20, 0x62, 0x79, 0x74, 0x65, 0x2E, 0x20, 0x42, 0x79, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 
  0x6C, 0x74, 0x2C, 0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 0x69, 0x73, 0x20, 0x30, 0x2E, 0x20, 0x52, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x62, 
  0x75, 0x66, 0x66, 0x65, 0x72, 0x2E, 0xDA, 0x86, 0x65, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x84, 0x62, 
  0xDA, 0x09, 0xCE, 0x19, 0x54, 0x68, 0x65, 0x20, 0x73, 0x74, 0x61, 0x6E, 0x64, 0x61, 0x72, 0x64, 
  0x20, 0x6F, 0x75, 0x74, 0x70, 0x75, 0x74, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x2E, 0xDA, 0x86, 0x66, 
  0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x86, 0x67, 0xDA, 0x09, 0xCE, 0x2E, 0x28, 0x6D, 0x61, 0x74, 0x68, 
  0x2F, 0x65, 0x72, 0x66, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 
  0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 
  0x69, 0x6F, 0x6E, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x2E, 0xDA, 0x86, 0x68, 0xD3, 0x02, 0xDA, 0x03, 
  0xDA, 0x81, 0x28, 0xDA, 0x09, 0xCE, 0x81, 0x87, 0x28, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2F, 0x73, 
  0x6C, 0x69, 0x63, 0x65, 0x20, 0x61, 0x72, 0x72, 0x74, 0x75, 0x70, 0x20, 0x26, 0x6F, 0x70, 0x74, 
  0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x65, 0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x54, 0x61, 0x6B, 
  0x65, 0x73, 0x20, 0x61, 0x20, 0x73, 0x6C, 0x69, 0x63, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x61, 0x72, 
  0x72, 0x61, 0x79, 0x20, 0x6F, 0x72, 0x20, 0x74, 0x75, 0x70, 0x6C, 0x65, 0x20, 0x66, 0x72, 0x6F, 
  0x6D, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x74, 0x6F, 0x20, 0x65, 0x6E, 0x64, 0x2E, 0x20, 
  0x54, 0x68, 0x65, 0x20, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x69, 0x73, 0x20, 0x68, 0x61, 0x6C, 
  0x66, 0x20, 0x6F, 0x70, 0x65, 0x6E, 0x2C, 0x20, 0x5B, 0x73, 0x74, 0x61, 0x72, 0x74, 0x2C, 0x20, 
  0x65, 0x6E, 0x64, 0x29, 0x2E, 0x20, 0x49, 0x6E, 0x64, 0x65, 0x78, 0x65, 0x73, 0x20, 0x63, 0x61, 
  0x6E, 0x20, 0x61, 0x6C, 0x73, 0x6F, 0x20, 0x62, 0x65, 0x20, 0x6E, 0x65, 0x67, 0x61, 0x74, 0x69, 
  0x76, 0x65, 0x2C, 0x20, 0x69, 0x6E, 0x64, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6E, 0x67, 0x20, 0x69, 
  0x6E, 0x64, 0x65, 0x78, 0x69, 0x6E, 0x67, 0x20, 0x66, 0x72, 0x6F, 0x6D, 0x20, 0x74, 0x68, 0x65, 
  0x20, 0x65, 0x6E, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6E, 0x64, 0x20, 
  0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0x20, 0x42, 0x79, 
  0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x2C, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 
  0x69, 0x73, 0x20, 0x30, 0x20, 0x61, 0x6E, 0x64, 0x20, 0x65, 0x6E, 0x64, 0x20, 0x69, 0x73, 0x20, 
  0x74, 0x68, 0x65, 0x20, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0x20, 0x4E, 0x6F, 0x74, 0x65, 0x20, 0x74, 0x68, 
  0x61, 0x74, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x2D, 0x31, 0x20, 0x69, 0x73, 0x20, 0x73, 
  0x79, 0x6E, 0x6F, 0x6E, 0x79, 0x6D, 0x6F, 0x75, 0x73, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x69, 
  0x6E, 0x64, 0x65, 0x78, 0x20, 0x28, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x20, 0x61, 0x72, 0x72, 
  0x74, 0x75, 0x70, 0x29, 0x20, 0x74, 0x6F, 0x20, 0x61, 0x6C, 0x6C, 0x6F, 0x77, 0x20, 0x61, 0x20, 
  0x66, 0x75, 0x6C, 0x6C, 0x20, 0x6E, 0x65, 0x67, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x73, 0x6C, 
  0x69, 0x63, 0x65, 0x20, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 
  0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x61, 0x72, 0x72, 0x61, 0x79, 0x2E, 0xDA, 
  0x86, 0x69, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x86, 0x6A, 0xDA, 0x09, 0xCE, 0x4E, 0x28, 0x6E, 0x65, 
  0x74, 0x2F, 0x63, 0x6C, 0x6F, 0x73, 0x65, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x29, 0x0A, 
  0x0A, 0x43, 0x6C, 0x6F, 0x73, 0x65, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x20, 
  0x73, 0x6F, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x6E, 0x6F, 0x20, 0x66, 0x75, 0x72, 0x74, 0x68, 
  0x65, 0x72, 0x20, 0x63, 0x6F, 0x6D, 0x6D, 0x75, 0x6E, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 
  0x20, 0x63, 0x61, 0x6E, 0x20, 0x6F, 0x63, 0x63, 0x75, 0x72, 0x2E, 0xDA, 0x84, 0x59, 0xD3, 0x04, 
  0xDA, 0x03, 0xDA, 0x86, 0x6C, 0xDA, 0x09, 0xCE, 0x80, 0x96, 0x28, 0x75, 0x73, 0x65, 0x20, 0x26, 
  0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 0x65, 0x73, 0x29, 0x0A, 0x0A, 0x53, 0x69, 0x6D, 0x69, 0x6C, 
  0x61, 0x72, 0x20, 0x74, 0x6F, 0x20, 0x69, 0x6D, 0x70, 0x6F, 0x72, 0x74, 0x2C, 0x20, 0x62, 0x75, 
  0x74, 0x20, 0x69, 0x6D, 0x70, 0x6F, 0x72, 0x74, 0x65, 0x64, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 
  0x6E, 0x67, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x70, 0x72, 0x65, 0x66, 
  0x69, 0x78, 0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61, 0x20, 0x6E, 0x61, 0x6D, 0x65, 
  0x73, 0x70, 0x61, 0x63, 0x65, 0x20, 0x20, 0x69, 0x64, 0x65, 0x6E, 0x74, 0x69, 0x66, 0x69, 0x65, 
  0x72, 0x2E, 0x20, 0x43, 0x61, 0x6E, 0x20, 0x61, 0x6C, 0x73, 0x6F, 0x20, 0x69, 0x6D, 0x70, 0x6F, 
  0x72, 0x74, 0x20, 0x6D, 0x75, 0x6C, 0x74, 0x69, 0x70, 0x6C, 0x65, 0x20, 0x6D, 0x6F, 0x64, 0x75, 
  0x6C, 0x65, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x6F, 0x6E, 0x65, 0x20, 0x73, 0x68, 0x6F, 0x74, 0x2E, 
  0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x89, 0x66, 0x01, 0xDA, 0x35, 0xCB, 0xDA, 0x86, 0x6D, 
  0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x86, 0x8F, 0xDA, 0x09, 0xCE, 0x50, 0x28, 0x6C, 0x6F, 0x61, 0x64, 
  0x2D, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x20, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x29, 0x0A, 0x0A, 0x54, 
  0x68, 0x65, 0x20, 0x69, 0x6E, 0x76, 0x65, 0x72, 0x73, 0x65, 0x20, 0x6F, 0x70, 0x65, 0x72, 0x61, 
  0x74, 0x69, 0x6F, 0x6E, 0x20, 0x74, 0x6F, 0x20, 0x6D, 0x61, 0x6B, 0x65, 0x2D, 0x69, 0x6D, 0x61, 
  0x67, 0x65, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x65, 
  0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 
  0xDA, 0x05, 0x88, 0x8B, 0x01, 0xDA, 0x86, 0x6F, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 0x86, 0x71, 0xDA, 
  0x09, 0xCE, 0x49, 0x28, 0x65, 0x61, 0x63, 0x68, 0x70, 0x20, 0x78, 0x20, 0x64, 0x73, 0x20, 0x26, 
  0x20, 0x62, 0x6F, 0x64, 0x79, 0x29, 0x0A, 0x0A, 0x4C, 0x6F, 0x6F, 0x70, 0x20, 0x6F, 0x76, 0x65, 
  0x72, 0x20, 0x65, 0x61, 0x63, 0x68, 0x20, 0x28, 0x6B, 0x65, 0x79, 0x2C, 0x20, 0x76, 0x61, 0x6C, 
  0x75, 0x65, 0x29, 0x20, 0x70, 0x61, 0x69, 0x72, 0x20, 0x69, 0x6E, 0x20, 0x64, 0x73, 0x2E, 0x20, 
  0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x6E, 0x69, 0x6C, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 
  0x00, 0xDA, 0x05, 0x81, 0xEB, 0x01, 0xDA, 0x35, 0xCB, 0xDA, 0x86, 0x72, 0xD3, 0x02, 0xDA, 0x03, 
  0xDA, 0x86, 0x74, 0xDA, 0x09, 0xCE, 0x41, 0x28, 0x6D, 0x6F, 0x64, 0x20, 0x64, 0x69, 0x76, 0x69, 
  0x64, 0x65, 0x6E, 0x64, 0x20, 0x64, 0x69, 0x76, 0x69, 0x73, 0x6F, 0x72, 0x29, 0x0A, 0x0A, 0x52, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6D, 0x6F, 0x64, 0x75, 0x6C, 
  0x6F, 0x20, 0x6F, 0x66, 0x20, 0x64, 0x69, 0x76, 0x69, 0x64, 0x65, 0x6E, 0x64, 0x20, 0x2F, 0x20, 
  0x64, 0x69, 0x76, 0x69, 0x73, 0x6F, 0x72, 0x2E, 0xDA, 0x86, 0x75, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 
  0x86, 0x76, 0xDA, 0x09, 0xCE, 0x26, 0x28, 0x6D, 0x61, 0x74, 0x68, 0x2F, 0x63, 0x6F, 0x73, 0x20, 
  0x78, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 
  0x63, 0x6F, 0x73, 0x69, 0x6E, 0x65, 0x20, 0x6F, 0x66, 0x20, 0x78, 0x2E, 0xDA, 0x86, 0x77, 0xD3, 
  0x03, 0xDA, 0x03, 0xDA, 0x81, 0x21, 0xDA, 0x09, 0xCE, 0x67, 0x28, 0x66, 0x69, 0x6E, 0x64, 0x2D, 
  0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 0x70, 0x72, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x64, 0x29, 0x0A, 
  0x0A, 0x46, 0x69, 0x6E, 0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x20, 
  0x6F, 0x66, 0x20, 0x69, 0x6E, 0x64, 0x65, 0x78, 0x65, 0x64, 0x20, 0x74, 0x79, 0x70, 0x65, 0x20, 
  0x66, 0x6F, 0x72, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x70, 0x72, 0x65, 0x64, 0x20, 0x69, 
  0x73, 0x20, 0x74, 0x72, 0x75, 0x65, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 
  0x6E, 0x69, 0x6C, 0x20, 0x69, 0x66, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 
  0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x83, 0x97, 0x01, 0xDA, 0x86, 0x78, 0xD3, 0x03, 
  0xDA, 0x03, 0xDA, 0x84, 0xDC, 0xDA, 0x09, 0xCE, 0x7B, 0x28, 0x65, 0x76, 0x61, 0x6C, 0x20, 0x66, 
  0x6F, 0x72, 0x6D, 0x29, 0x0A, 0x0A, 0x45, 0x76, 0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0x73, 0x20, 
  0x61, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x20, 0x69, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 
  0x72, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x65, 0x6E, 0x76, 0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 
  0x74, 0x2E, 0x20, 0x49, 0x66, 0x20, 0x6D, 0x6F, 0x72, 0x65, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x72, 
  0x6F, 0x6C, 0x20, 0x6F, 0x76, 0x65, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x20, 0x65, 0x6E, 0x76, 
  0x69, 0x72, 0x6F, 0x6E, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x69, 0x73, 0x20, 0x6E, 0x65, 0x65, 0x64, 
  0x65, 0x64, 0x2C, 0x20, 0x75, 0x73, 0x65, 0x20, 0x72, 0x75, 0x6E, 0x2D, 0x63, 0x6F, 0x6E, 0x74, 
  0x65, 0x78, 0x74, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x88, 0x60, 0x01, 0xDA, 0x86, 
  0x79, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x86, 0x7B, 0xDA, 0x09, 0xCE, 0x52, 0x28, 0x63, 0x6F, 0x75, 
  0x6E, 0x74, 0x20, 0x70, 0x72, 0x65, 0x64, 0x20, 0x69, 0x6E, 0x64, 0x29, 0x0A, 0x0A, 0x43, 0x6F, 
  0x75, 0x6E, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x20, 0x6F, 
  0x66, 0x20, 0x69, 0x74, 0x65, 0x6D, 0x73, 0x20, 0x69, 0x6E, 0x20, 0x69, 0x6E, 0x64, 0x20, 0x66, 
  0x6F, 0x72, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x28, 0x70, 0x72, 0x65, 0x64, 0x20, 0x69, 
  0x74, 0x65, 0x6D, 0x29, 0x20, 0x20, 0x69, 0x73, 0x20, 0x74, 0x72, 0x75, 0x65, 0x2E, 0xDA, 0x0B, 
  0xD2, 0x03, 0x00, 0xDA, 0x05, 0x83, 0x6B, 0x01, 0xDA, 0x86, 0x7C, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 
  0x82, 0x27, 0xDA, 0x09, 0xCE, 0x80, 0x82, 0x28, 0x6D, 0x61, 0x63, 0x65, 0x78, 0x31, 0x20, 0x78, 
  0x20, 0x26, 0x6F, 0x70, 0x74, 0x20, 0x6F, 0x6E, 0x2D, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 
  0x29, 0x0A, 0x0A, 0x45, 0x78, 0x70, 0x61, 0x6E, 0x64, 0x20, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x73, 
  0x20, 0x69, 0x6E, 0x20, 0x61, 0x20, 0x66, 0x6F, 0x72, 0x6D, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 
  0x64, 0x6F, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x72, 0x65, 0x63, 0x75, 0x72, 0x73, 0x69, 0x76, 0x65, 
  0x6C, 0x79, 0x20, 0x65, 0x78, 0x70, 0x61, 0x6E, 0x64, 0x20, 0x6D, 0x61, 0x63, 0x72, 0x6F, 0x73, 
  0x2E, 0x20, 0x20, 0x53, 0x65, 0x65, 0x20, 0x6D, 0x61, 0x63, 0x65, 0x78, 0x20, 0x64, 0x6F, 0x63, 
  0x73, 0x20, 0x66, 0x6F, 0x72, 0x20, 0x69, 0x6E, 0x66, 0x6F, 0x20, 0x6F, 0x6E, 0x20, 0x6F, 0x6E, 
  0x2D, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 
  0x86, 0x9D, 0x01, 0xDA, 0x86, 0x7D, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 0x86, 0x7F, 0xDA, 0x09, 0xCE, 
  0x22, 0x28, 0x2B, 0x2B, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x49, 0x6E, 0x63, 0x72, 0x65, 0x6D, 0x65, 
  0x6E, 0x74, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x61, 0x72, 0x20, 0x78, 0x20, 0x62, 0x79, 
  0x20, 0x31, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x80, 0x83, 0x01, 0xDA, 0x35, 0xCB, 
  0xDA, 0x86, 0x80, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x86, 0x81, 0xDA, 0x09, 0xCE, 0x80, 0xBB, 0x28, 
  0x61, 0x73, 0x6D, 0x20, 0x61, 0x73, 0x73, 0x65, 0x6D, 0x62, 0x6C, 0x79, 0x29, 0x0A, 0x0A, 0x52, 
  0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x61, 0x20, 0x6E, 0x65, 0x77, 0x20, 0x66, 0x75, 0x6E, 
  0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 
  0x65, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x64, 0x20, 0x72, 0x65, 0x73, 0x75, 0x6C, 
  0x74, 0x20, 0x6F, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x73, 0x73, 0x65, 0x6D, 0x62, 0x6C, 
  0x79, 0x2E, 0x0A, 0x54, 0x68, 0x65, 0x20, 0x73, 0x79, 0x6E, 0x74, 0x61, 0x78, 0x20, 0x66, 0x6F, 
  0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x73, 0x73, 0x65, 0x6D, 0x62, 0x6C, 0x79, 0x20, 0x63, 
  0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x66, 0x6F, 0x75, 0x6E, 0x64, 0x20, 0x6F, 0x6E, 0x20, 0x74, 
  0x68, 0x65, 0x20, 0x4A, 0x61, 0x6E, 0x65, 0x74, 0x20, 0x77, 0x65, 0x62, 0x73, 0x69, 0x74, 0x65, 
  0x2E, 0x20, 0x57, 0x69, 0x6C, 0x6C, 0x20, 0x74, 0x68, 0x72, 0x6F, 0x77, 0x20, 0x61, 0x6E, 0x0A, 
  0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x6F, 0x6E, 0x20, 0x69, 0x6E, 0x76, 0x61, 0x6C, 0x69, 0x64, 
  0x20, 0x61, 0x73, 0x73, 0x65, 0x6D, 0x62, 0x6C, 0x79, 0x2E, 0xDA, 0x86, 0x82, 0xD3, 0x02, 0xDA, 
  0x03, 0xDA, 0x85, 0xA5, 0xDA, 0x09, 0xCE, 0x42, 0x28, 0x25, 0x20, 0x64, 0x69, 0x76, 0x69, 0x64, 
  0x65, 0x6E, 0x64, 0x20, 0x64, 0x69, 0x76, 0x69, 0x73, 0x6F, 0x72, 0x29, 0x0A, 0x0A, 0x52, 0x65, 
  0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x6D, 0x61, 0x69, 0x6E, 
  0x64, 0x65, 0x72, 0x20, 0x6F, 0x66, 0x20, 0x64, 0x69, 0x76, 0x69, 0x64, 0x65, 0x6E, 0x64, 0x20, 
  0x2F, 0x20, 0x64, 0x69, 0x76, 0x69, 0x73, 0x6F, 0x72, 0x2E, 0xDA, 0x86, 0x83, 0xD3, 0x03, 0xDA, 
  0x03, 0xDA, 0x85, 0x0E, 0xDA, 0x09, 0xCE, 0x4A, 0x28, 0x63, 0x6F, 0x6D, 0x70, 0x6C, 0x65, 0x6D, 
  0x65, 0x6E, 0x74, 0x20, 0x66, 0x29, 0x0A, 0x0A, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 
  0x61, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 
  0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6F, 0x6D, 0x70, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 
  0x74, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 
  0x74, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x82, 0x7E, 0x01, 0xDA, 0x86, 0x84, 0xD3, 
  0x02, 0xDA, 0x03, 0xDA, 0x83, 0xC9, 0xDA, 0x09, 0xCE, 0x3B, 0x28, 0x70, 0x72, 0x69, 0x6E, 0x66, 
  0x20, 0x66, 0x6D, 0x74, 0x20, 0x26, 0x20, 0x78, 0x73, 0x29, 0x0A, 0x0A, 0x4C, 0x69, 0x6B, 0x65, 
  0x20, 0x70, 0x72, 0x69, 0x6E, 0x74, 0x66, 0x20, 0x62, 0x75, 0x74, 0x20, 0x77, 0x69, 0x74, 0x68, 
  0x20, 0x6E, 0x6F, 0x20, 0x74, 0x72, 0x61, 0x69, 0x6C, 0x69, 0x6E, 0x67, 0x20, 0x6E, 0x65, 0x77, 
  0x6C, 0x69, 0x6E, 0x65, 0x2E, 0xDA, 0x86, 0x85, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x86, 0x88, 0xDA, 
  0x09, 0xCE, 0x24, 0x28, 0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 
  0x43, 0x68, 0x65, 0x63, 0x6B, 0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 
  0x6E, 0x75, 0x6D, 0x62, 0x65, 0x72, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x58, 0x01, 
  0xDA, 0x86, 0x89, 0xD3, 0x03, 0xDA, 0x03, 0xDA, 0x4E, 0xDA, 0x09, 0xCE, 0x26, 0x28, 0x6B, 0x65, 
  0x79, 0x77, 0x6F, 0x72, 0x64, 0x3F, 0x20, 0x78, 0x29, 0x0A, 0x0A, 0x43, 0x68, 0x65, 0x63, 0x6B, 
  0x20, 0x69, 0x66, 0x20, 0x78, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x6B, 0x65, 0x79, 0x77, 0x6F, 
  0x72, 0x64, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x5C, 0x01, 0xDA, 0x86, 0x8A, 0xD3, 
  0x04, 0xDA, 0x03, 0xDA, 0x86, 0x8C, 0xDA, 0x09, 0xCE, 0x81, 0x38, 0x28, 0x77, 0x69, 0x74, 0x68, 
  0x20, 0x5B, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x63, 0x74, 0x6F, 0x72, 0x20, 0x64, 
  0x74, 0x6F, 0x72, 0x5D, 0x20, 0x26, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x29, 0x0A, 0x0A, 0x45, 0x76, 
  0x61, 0x6C, 0x75, 0x61, 0x74, 0x65, 0x20, 0x62, 0x6F, 0x64, 0x79, 0x20, 0x77, 0x69, 0x74, 0x68, 
  0x20, 0x73, 0x6F, 0x6D, 0x65, 0x20, 0x72, 0x65, 0x73, 0x6F, 0x75, 0x72, 0x63, 0x65, 0x2C, 0x20, 
  0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x62, 0x65, 0x20, 0x61, 0x75, 
  0x74, 0x6F, 0x6D, 0x61, 0x74, 0x69, 0x63, 0x61, 0x6C, 0x6C, 0x79, 0x20, 0x63, 0x6C, 0x65, 0x61, 
  0x6E, 0x65, 0x64, 0x20, 0x75, 0x70, 0x20, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x72, 0x65, 
  0x20, 0x69, 0x73, 0x20, 0x61, 0x6E, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0x20, 0x69, 0x6E, 0x20, 
  0x62, 0x6F, 0x64, 0x79, 0x2E, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x20, 0x69, 0x73, 
  0x20, 0x62, 0x6F, 0x75, 0x6E, 0x64, 0x20, 0x74, 0x6F, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x78, 
  0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x63, 0x74, 0x6F, 0x72, 0x2C, 0x20, 0x61, 
  0x6E, 0x64, 0x20, 0x20, 0x64, 0x74, 0x6F, 0x72, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x66, 0x75, 
  0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x6F, 0x72, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x61, 0x62, 
  0x6C, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x73, 0x20, 0x70, 0x61, 0x73, 0x73, 0x65, 
  0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x69, 0x6E, 0x64, 0x69, 0x6E, 0x67, 0x2E, 0x20, 0x49, 
  0x66, 0x20, 0x6E, 0x6F, 0x20, 0x64, 0x65, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x6F, 0x72, 0x20, 
  0x20, 0x28, 0x64, 0x74, 0x6F, 0x72, 0x29, 0x20, 0x69, 0x73, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6E, 
  0x2C, 0x20, 0x77, 0x69, 0x6C, 0x6C, 0x20, 0x63, 0x61, 0x6C, 0x6C, 0x20, 0x3A, 0x63, 0x6C, 0x6F, 
  0x73, 0x65, 0x20, 0x6F, 0x6E, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x6F, 0x75, 0x72, 
  0x63, 0x65, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x81, 0x64, 0x01, 0xDA, 0x35, 0xCB, 
  0xDA, 0x86, 0x8D, 0xD3, 0x02, 0xDA, 0x03, 0xDA, 0x86, 0x8E, 0xDA, 0x09, 0xCE, 0x80, 0x91, 0x28, 
  0x6E, 0x65, 0x74, 0x2F, 0x63, 0x6F, 0x6E, 0x6E, 0x65, 0x63, 0x74, 0x20, 0x68, 0x6F, 0x73, 0x74, 
  0x20, 0x70, 0x6F, 0x72, 0x74, 0x29, 0x0A, 0x0A, 0x4F, 0x70, 0x65, 0x6E, 0x20, 0x61, 0x20, 0x63, 
  0x6F, 0x6E, 0x6E, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x74, 0x6F, 0x20, 0x63, 0x6F, 0x6D, 
  0x6D, 0x75, 0x6E, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61, 0x20, 
  0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x2E, 0x20, 0x52, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x73, 0x20, 
  0x61, 0x20, 0x64, 0x75, 0x70, 0x6C, 0x65, 0x78, 0x20, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6D, 0x20, 
  0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 0x61, 0x6E, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 
  0x20, 0x74, 0x6F, 0x20, 0x63, 0x6F, 0x6D, 0x6D, 0x75, 0x6E, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 
  0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x2E, 
  0xDA, 0x84, 0x56, 0xD3, 0x04, 0xDA, 0x03, 0xDA, 0x74, 0xDA, 0x09, 0xCE, 0x55, 0x28, 0x64, 0x65, 
  0x66, 0x6E, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x26, 0x20, 0x6D, 0x6F, 0x72, 0x65, 0x29, 0x0A, 
  0x0A, 0x44, 0x65, 0x66, 0x69, 0x6E, 0x65, 0x20, 0x61, 0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 
  0x6F, 0x6E, 0x2E, 0x20, 0x45, 0x71, 0x75, 0x69, 0x76, 0x61, 0x6C, 0x65, 0x6E, 0x74, 0x20, 0x74, 
  0x6F, 0x20, 0x28, 0x64, 0x65, 0x66, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x28, 0x66, 0x6E, 0x20, 
  0x6E, 0x61, 0x6D, 0x65, 0x20, 0x5B, 0x61, 0x72, 0x67, 0x73, 0x5D, 0x20, 0x2E, 0x2E, 0x2E, 0x29, 
  0x29, 0x2E, 0xDA, 0x0B, 0xD2, 0x03, 0x00, 0xDA, 0x05, 0x0A, 0x01, 0xDA, 0x35, 0xCB, 
  0
};

const unsigned char *janet_core_image = janet_core_image_bytes;
size_t janet_core_image_size = sizeof(janet_core_image_bytes);
